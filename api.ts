// tslint:disable
/**
 * HyperOne
 * HyperOne API
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as globalImportUrl from 'url';
import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface Agent
 */
export interface Agent {
    /**
     * 
     * @type {string}
     * @memberof Agent
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Agent
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Agent
     */
    flavour?: string;
    /**
     * 
     * @type {string}
     * @memberof Agent
     */
    modifiedOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Agent
     */
    modifiedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Agent
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Agent
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Agent
     */
    state?: AgentStateEnum;
    /**
     * 
     * @type {string}
     * @memberof Agent
     */
    project?: string;
    /**
     * 
     * @type {string}
     * @memberof Agent
     */
    uri?: string;
    /**
     * 
     * @type {string}
     * @memberof Agent
     */
    type?: string;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof Agent
     */
    tag?: Array<Tag>;
}

/**
    * @export
    * @enum {string}
    */
export enum AgentStateEnum {
    Online = 'Online',
    Suspended = 'Suspended',
    Unknown = 'Unknown',
    Processing = 'Processing',
    NotCreated = 'NotCreated'
}

/**
 * 
 * @export
 * @interface AgentCredential
 */
export interface AgentCredential {
    /**
     * 
     * @type {string}
     * @memberof AgentCredential
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof AgentCredential
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof AgentCredential
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof AgentCredential
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof AgentCredential
     */
    type: AgentCredentialTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof AgentCredential
     */
    value: string;
    /**
     * 
     * @type {string}
     * @memberof AgentCredential
     */
    fingerprint?: string;
    /**
     * 
     * @type {string}
     * @memberof AgentCredential
     */
    token?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum AgentCredentialTypeEnum {
    Ssh = 'ssh'
}

/**
 * 
 * @export
 * @interface Attempt
 */
export interface Attempt {
    /**
     * 
     * @type {string}
     * @memberof Attempt
     */
    id?: string;
    /**
     * 
     * @type {number}
     * @memberof Attempt
     */
    status?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Attempt
     */
    error?: boolean;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof Attempt
     */
    stdout?: { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof Attempt
     */
    stderr?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof Attempt
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Attempt
     */
    agent?: string;
}
/**
 * 
 * @export
 * @interface AuthToken
 */
export interface AuthToken {
    /**
     * 
     * @type {string}
     * @memberof AuthToken
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthToken
     */
    expiry?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthToken
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthToken
     */
    createdOn?: string;
    /**
     * 
     * @type {Array<AuthTokenAccess>}
     * @memberof AuthToken
     */
    access?: Array<AuthTokenAccess>;
    /**
     * 
     * @type {string}
     * @memberof AuthToken
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthToken
     */
    clientIp?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthToken
     */
    userAgent?: string;
}
/**
 * 
 * @export
 * @interface AuthTokenAccess
 */
export interface AuthTokenAccess {
    /**
     * 
     * @type {string}
     * @memberof AuthTokenAccess
     */
    method: AuthTokenAccessMethodEnum;
    /**
     * 
     * @type {string}
     * @memberof AuthTokenAccess
     */
    path: string;
}

/**
    * @export
    * @enum {string}
    */
export enum AuthTokenAccessMethodEnum {
    ALL = 'ALL',
    GET = 'GET',
    POST = 'POST',
    PATCH = 'PATCH',
    DELETE = 'DELETE'
}

/**
 * 
 * @export
 * @interface Backup
 */
export interface Backup {
    /**
     * 
     * @type {string}
     * @memberof Backup
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Backup
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Backup
     */
    flavour?: string;
    /**
     * 
     * @type {string}
     * @memberof Backup
     */
    modifiedOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Backup
     */
    modifiedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Backup
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Backup
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Backup
     */
    state?: BackupStateEnum;
    /**
     * 
     * @type {string}
     * @memberof Backup
     */
    project?: string;
    /**
     * 
     * @type {string}
     * @memberof Backup
     */
    uri?: string;
    /**
     * 
     * @type {number}
     * @memberof Backup
     */
    size?: number;
    /**
     * 
     * @type {string}
     * @memberof Backup
     */
    source?: string;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof Backup
     */
    tag?: Array<Tag>;
}

/**
    * @export
    * @enum {string}
    */
export enum BackupStateEnum {
    Online = 'Online',
    Unknown = 'Unknown',
    Processing = 'Processing',
    NotCreated = 'NotCreated'
}

/**
 * 
 * @export
 * @interface Billing
 */
export interface Billing {
    /**
     * 
     * @type {string}
     * @memberof Billing
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Billing
     */
    period?: string;
    /**
     * 
     * @type {number}
     * @memberof Billing
     */
    price?: number;
    /**
     * 
     * @type {number}
     * @memberof Billing
     */
    quantity?: number;
    /**
     * 
     * @type {string}
     * @memberof Billing
     */
    project?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Billing
     */
    oneTime?: boolean;
    /**
     * 
     * @type {BillingService}
     * @memberof Billing
     */
    service?: BillingService;
    /**
     * 
     * @type {BillingResource}
     * @memberof Billing
     */
    resource?: BillingResource;
    /**
     * 
     * @type {Array<BillingCharges>}
     * @memberof Billing
     */
    charges?: Array<BillingCharges>;
}
/**
 * 
 * @export
 * @interface BillingAddress
 */
export interface BillingAddress {
    /**
     * 
     * @type {string}
     * @memberof BillingAddress
     */
    country?: BillingAddressCountryEnum;
    /**
     * 
     * @type {string}
     * @memberof BillingAddress
     */
    city: string;
    /**
     * 
     * @type {string}
     * @memberof BillingAddress
     */
    street: string;
    /**
     * 
     * @type {string}
     * @memberof BillingAddress
     */
    zipcode: string;
}

/**
    * @export
    * @enum {string}
    */
export enum BillingAddressCountryEnum {
    AD = 'AD',
    BE = 'BE',
    HR = 'HR',
    CY = 'CY',
    CZ = 'CZ',
    DK = 'DK',
    EE = 'EE',
    FI = 'FI',
    FR = 'FR',
    DE = 'DE',
    GR = 'GR',
    HU = 'HU',
    IE = 'IE',
    IT = 'IT',
    LV = 'LV',
    LT = 'LT',
    LU = 'LU',
    MT = 'MT',
    NL = 'NL',
    PL = 'PL',
    PT = 'PT',
    RO = 'RO',
    SK = 'SK',
    SI = 'SI',
    ES = 'ES',
    GB = 'GB'
}

/**
 * 
 * @export
 * @interface BillingAddress1
 */
export interface BillingAddress1 {
    /**
     * 
     * @type {string}
     * @memberof BillingAddress1
     */
    city?: string;
    /**
     * 
     * @type {string}
     * @memberof BillingAddress1
     */
    zipcode?: string;
    /**
     * 
     * @type {string}
     * @memberof BillingAddress1
     */
    street?: string;
}
/**
 * 
 * @export
 * @interface BillingCharges
 */
export interface BillingCharges {
    /**
     * 
     * @type {string}
     * @memberof BillingCharges
     */
    id?: string;
    /**
     * 
     * @type {number}
     * @memberof BillingCharges
     */
    value?: number;
    /**
     * 
     * @type {string}
     * @memberof BillingCharges
     */
    start?: string;
    /**
     * 
     * @type {string}
     * @memberof BillingCharges
     */
    end?: string;
    /**
     * 
     * @type {number}
     * @memberof BillingCharges
     */
    price?: number;
    /**
     * 
     * @type {number}
     * @memberof BillingCharges
     */
    quantity?: number;
    /**
     * 
     * @type {string}
     * @memberof BillingCharges
     */
    paidFrom?: string;
    /**
     * 
     * @type {string}
     * @memberof BillingCharges
     */
    paidOn?: string;
}
/**
 * 
 * @export
 * @interface BillingProjectReservationAssign
 */
export interface BillingProjectReservationAssign {
    /**
     * 
     * @type {string}
     * @memberof BillingProjectReservationAssign
     */
    resource?: string;
}
/**
 * 
 * @export
 * @interface BillingProjectReservationCreate
 */
export interface BillingProjectReservationCreate {
    /**
     * 
     * @type {string}
     * @memberof BillingProjectReservationCreate
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof BillingProjectReservationCreate
     */
    service: string;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof BillingProjectReservationCreate
     */
    tag?: Array<Tag>;
}
/**
 * 
 * @export
 * @interface BillingProjectReservationUpdate
 */
export interface BillingProjectReservationUpdate {
    /**
     * 
     * @type {string}
     * @memberof BillingProjectReservationUpdate
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface BillingResource
 */
export interface BillingResource {
    /**
     * 
     * @type {string}
     * @memberof BillingResource
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof BillingResource
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof BillingResource
     */
    name?: string;
    /**
     * 
     * @type {boolean}
     * @memberof BillingResource
     */
    deleted?: boolean;
}
/**
 * 
 * @export
 * @interface BillingService
 */
export interface BillingService {
    /**
     * 
     * @type {string}
     * @memberof BillingService
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof BillingService
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof BillingService
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface Bucket
 */
export interface Bucket {
    /**
     * 
     * @type {string}
     * @memberof Bucket
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Bucket
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Bucket
     */
    flavour?: string;
    /**
     * 
     * @type {string}
     * @memberof Bucket
     */
    modifiedOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Bucket
     */
    modifiedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Bucket
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Bucket
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Bucket
     */
    state?: string;
    /**
     * 
     * @type {string}
     * @memberof Bucket
     */
    project?: string;
    /**
     * 
     * @type {string}
     * @memberof Bucket
     */
    organisation?: string;
    /**
     * 
     * @type {string}
     * @memberof Bucket
     */
    uri?: string;
    /**
     * 
     * @type {number}
     * @memberof Bucket
     */
    sizeUsed?: number;
}
/**
 * 
 * @export
 * @interface ComputeProjectReplicaCreate
 */
export interface ComputeProjectReplicaCreate {
    /**
     * 
     * @type {string}
     * @memberof ComputeProjectReplicaCreate
     */
    hostname: string;
    /**
     * 
     * @type {string}
     * @memberof ComputeProjectReplicaCreate
     */
    secret: string;
}
/**
 * 
 * @export
 * @interface ComputeProjectVmConnectOpen
 */
export interface ComputeProjectVmConnectOpen {
    /**
     * 
     * @type {string}
     * @memberof ComputeProjectVmConnectOpen
     */
    protocol?: ComputeProjectVmConnectOpenProtocolEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum ComputeProjectVmConnectOpenProtocolEnum {
    Http = 'http',
    Ws = 'ws'
}

/**
 * 
 * @export
 * @interface ComputeProjectVmCreate
 */
export interface ComputeProjectVmCreate {
    /**
     * 
     * @type {string}
     * @memberof ComputeProjectVmCreate
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof ComputeProjectVmCreate
     */
    service: string;
    /**
     * 
     * @type {string}
     * @memberof ComputeProjectVmCreate
     */
    image?: string;
    /**
     * 
     * @type {string}
     * @memberof ComputeProjectVmCreate
     */
    iso?: string;
    /**
     * 
     * @type {string}
     * @memberof ComputeProjectVmCreate
     */
    username?: string;
    /**
     * 
     * @type {string}
     * @memberof ComputeProjectVmCreate
     */
    userMetadata?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ComputeProjectVmCreate
     */
    start?: boolean;
    /**
     * 
     * @type {Array<ComputeProjectVmCreateCredential>}
     * @memberof ComputeProjectVmCreate
     */
    credential?: Array<ComputeProjectVmCreateCredential>;
    /**
     * 
     * @type {Array<ComputeProjectVmCreateDisk>}
     * @memberof ComputeProjectVmCreate
     */
    disk?: Array<ComputeProjectVmCreateDisk>;
    /**
     * 
     * @type {Array<ComputeProjectVmCreateNetadp>}
     * @memberof ComputeProjectVmCreate
     */
    netadp?: Array<ComputeProjectVmCreateNetadp>;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof ComputeProjectVmCreate
     */
    tag?: Array<Tag>;
}
/**
 * 
 * @export
 * @interface ComputeProjectVmCreateCredential
 */
export interface ComputeProjectVmCreateCredential {
    /**
     * 
     * @type {string}
     * @memberof ComputeProjectVmCreateCredential
     */
    type: ComputeProjectVmCreateCredentialTypeEnum;
    /**
     * - user credential (by id or name) - project credential (by id or name) - raw openssh public key (starting with `ssh-rsa/ssh-ed25519`) - defaults to user keys
     * @type {string}
     * @memberof ComputeProjectVmCreateCredential
     */
    value: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ComputeProjectVmCreateCredentialTypeEnum {
    Ssh = 'ssh',
    Plain = 'plain',
    Unix = 'unix'
}

/**
 * 
 * @export
 * @interface ComputeProjectVmCreateDisk
 */
export interface ComputeProjectVmCreateDisk {
    /**
     * 
     * @type {string}
     * @memberof ComputeProjectVmCreateDisk
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof ComputeProjectVmCreateDisk
     */
    service: string;
    /**
     * 
     * @type {number}
     * @memberof ComputeProjectVmCreateDisk
     */
    size: number;
}
/**
 * 
 * @export
 * @interface ComputeProjectVmCreateNetadp
 */
export interface ComputeProjectVmCreateNetadp {
    /**
     * 
     * @type {string}
     * @memberof ComputeProjectVmCreateNetadp
     */
    network: string;
    /**
     * 
     * @type {string}
     * @memberof ComputeProjectVmCreateNetadp
     */
    firewall?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ComputeProjectVmCreateNetadp
     */
    ip?: Array<string>;
}
/**
 * 
 * @export
 * @interface ComputeProjectVmDiskCreate
 */
export interface ComputeProjectVmDiskCreate {
    /**
     * 
     * @type {string}
     * @memberof ComputeProjectVmDiskCreate
     */
    disk: string;
}
/**
 * 
 * @export
 * @interface ComputeProjectVmFlavour
 */
export interface ComputeProjectVmFlavour {
    /**
     * 
     * @type {string}
     * @memberof ComputeProjectVmFlavour
     */
    service: string;
}
/**
 * 
 * @export
 * @interface ComputeProjectVmIsoCreate
 */
export interface ComputeProjectVmIsoCreate {
    /**
     * 
     * @type {string}
     * @memberof ComputeProjectVmIsoCreate
     */
    iso?: string;
}
/**
 * 
 * @export
 * @interface ComputeProjectVmPasswordReset
 */
export interface ComputeProjectVmPasswordReset {
    /**
     * 
     * @type {string}
     * @memberof ComputeProjectVmPasswordReset
     */
    userName: string;
    /**
     * 
     * @type {string}
     * @memberof ComputeProjectVmPasswordReset
     */
    modulus: string;
    /**
     * 
     * @type {string}
     * @memberof ComputeProjectVmPasswordReset
     */
    exponent: string;
}
/**
 * 
 * @export
 * @interface ComputeProjectVmSerialport
 */
export interface ComputeProjectVmSerialport {
    /**
     * 
     * @type {string}
     * @memberof ComputeProjectVmSerialport
     */
    number?: ComputeProjectVmSerialportNumberEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum ComputeProjectVmSerialportNumberEnum {
    _1 = '1',
    _2 = '2'
}

/**
 * 
 * @export
 * @interface ComputeProjectVmUpdate
 */
export interface ComputeProjectVmUpdate {
    /**
     * 
     * @type {string}
     * @memberof ComputeProjectVmUpdate
     */
    userMetadata?: string;
    /**
     * 
     * @type {string}
     * @memberof ComputeProjectVmUpdate
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface Connect
 */
export interface Connect {
    /**
     * 
     * @type {string}
     * @memberof Connect
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof Connect
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Connect
     */
    type: ConnectTypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum ConnectTypeEnum {
    Console = 'console'
}

/**
 * 
 * @export
 * @interface ContainerImage
 */
export interface ContainerImage {
    /**
     * 
     * @type {string}
     * @memberof ContainerImage
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ContainerImage
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof ContainerImage
     */
    digest: string;
    /**
     * 
     * @type {string}
     * @memberof ContainerImage
     */
    createdOn: string;
    /**
     * 
     * @type {string}
     * @memberof ContainerImage
     */
    modifiedOn: string;
}
/**
 * 
 * @export
 * @interface ContainerProjectRegistryCreate
 */
export interface ContainerProjectRegistryCreate {
    /**
     * 
     * @type {string}
     * @memberof ContainerProjectRegistryCreate
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof ContainerProjectRegistryCreate
     */
    service: string;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof ContainerProjectRegistryCreate
     */
    tag?: Array<Tag>;
}
/**
 * 
 * @export
 * @interface ContainerProjectRegistryCredentialPatch
 */
export interface ContainerProjectRegistryCredentialPatch {
    /**
     * 
     * @type {string}
     * @memberof ContainerProjectRegistryCredentialPatch
     */
    name: string;
}
/**
 * 
 * @export
 * @interface ContainerProjectRegistryTransfer
 */
export interface ContainerProjectRegistryTransfer {
    /**
     * 
     * @type {string}
     * @memberof ContainerProjectRegistryTransfer
     */
    project: string;
}
/**
 * 
 * @export
 * @interface ContainerProjectRegistryUpdate
 */
export interface ContainerProjectRegistryUpdate {
    /**
     * 
     * @type {string}
     * @memberof ContainerProjectRegistryUpdate
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface ContainerRepository
 */
export interface ContainerRepository {
    /**
     * 
     * @type {string}
     * @memberof ContainerRepository
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ContainerRepository
     */
    name: string;
}
/**
 * 
 * @export
 * @interface Database
 */
export interface Database {
    /**
     * 
     * @type {string}
     * @memberof Database
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Database
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Database
     */
    flavour?: string;
    /**
     * 
     * @type {string}
     * @memberof Database
     */
    modifiedOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Database
     */
    modifiedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Database
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Database
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Database
     */
    state?: DatabaseStateEnum;
    /**
     * 
     * @type {string}
     * @memberof Database
     */
    project?: string;
    /**
     * 
     * @type {string}
     * @memberof Database
     */
    uri?: string;
    /**
     * 
     * @type {string}
     * @memberof Database
     */
    fqdn?: string;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof Database
     */
    tag?: Array<Tag>;
}

/**
    * @export
    * @enum {string}
    */
export enum DatabaseStateEnum {
    Running = 'Running',
    Off = 'Off',
    Unknown = 'Unknown',
    Processing = 'Processing',
    NotCreated = 'NotCreated'
}

/**
 * 
 * @export
 * @interface DatabaseCredential
 */
export interface DatabaseCredential {
    /**
     * 
     * @type {string}
     * @memberof DatabaseCredential
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof DatabaseCredential
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof DatabaseCredential
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof DatabaseCredential
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof DatabaseCredential
     */
    type: DatabaseCredentialTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof DatabaseCredential
     */
    value: string;
    /**
     * 
     * @type {string}
     * @memberof DatabaseCredential
     */
    fingerprint?: string;
    /**
     * 
     * @type {string}
     * @memberof DatabaseCredential
     */
    token?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum DatabaseCredentialTypeEnum {
    Mysql = 'mysql',
    Plain = 'plain',
    Postgres = 'postgres'
}

/**
 * 
 * @export
 * @interface DatabaseProjectInstanceCreate
 */
export interface DatabaseProjectInstanceCreate {
    /**
     * 
     * @type {string}
     * @memberof DatabaseProjectInstanceCreate
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof DatabaseProjectInstanceCreate
     */
    service: string;
    /**
     * 
     * @type {string}
     * @memberof DatabaseProjectInstanceCreate
     */
    source?: string;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof DatabaseProjectInstanceCreate
     */
    tag?: Array<Tag>;
}
/**
 * 
 * @export
 * @interface DatabaseProjectInstanceCredentialPatch
 */
export interface DatabaseProjectInstanceCredentialPatch {
    /**
     * 
     * @type {string}
     * @memberof DatabaseProjectInstanceCredentialPatch
     */
    name: string;
}
/**
 * 
 * @export
 * @interface DatabaseProjectInstanceTransfer
 */
export interface DatabaseProjectInstanceTransfer {
    /**
     * 
     * @type {string}
     * @memberof DatabaseProjectInstanceTransfer
     */
    project: string;
}
/**
 * 
 * @export
 * @interface DatabaseProjectInstanceUpdate
 */
export interface DatabaseProjectInstanceUpdate {
    /**
     * 
     * @type {string}
     * @memberof DatabaseProjectInstanceUpdate
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface Disk
 */
export interface Disk {
    /**
     * 
     * @type {string}
     * @memberof Disk
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Disk
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Disk
     */
    flavour?: string;
    /**
     * 
     * @type {string}
     * @memberof Disk
     */
    modifiedOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Disk
     */
    modifiedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Disk
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Disk
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Disk
     */
    state?: DiskStateEnum;
    /**
     * 
     * @type {string}
     * @memberof Disk
     */
    project?: string;
    /**
     * 
     * @type {string}
     * @memberof Disk
     */
    uri?: string;
    /**
     * 
     * @type {number}
     * @memberof Disk
     */
    size?: number;
    /**
     * 
     * @type {string}
     * @memberof Disk
     */
    vm?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Disk
     */
    persistent?: boolean;
    /**
     * 
     * @type {DiskMetadata}
     * @memberof Disk
     */
    metadata?: DiskMetadata;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof Disk
     */
    tag?: Array<Tag>;
}

/**
    * @export
    * @enum {string}
    */
export enum DiskStateEnum {
    Uploading = 'Uploading',
    Online = 'Online',
    Attached = 'Attached',
    Detached = 'Detached',
    Unknown = 'Unknown',
    Processing = 'Processing',
    NotCreated = 'NotCreated'
}

/**
 * 
 * @export
 * @interface DiskMetadata
 */
export interface DiskMetadata {
    /**
     * 
     * @type {string}
     * @memberof DiskMetadata
     */
    source?: string;
}
/**
 * 
 * @export
 * @interface DnsProjectZoneCreate
 */
export interface DnsProjectZoneCreate {
    /**
     * 
     * @type {string}
     * @memberof DnsProjectZoneCreate
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof DnsProjectZoneCreate
     */
    service: string;
    /**
     * 
     * @type {string}
     * @memberof DnsProjectZoneCreate
     */
    dnsName: string;
    /**
     * 
     * @type {ZoneSource}
     * @memberof DnsProjectZoneCreate
     */
    source?: ZoneSource;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof DnsProjectZoneCreate
     */
    tag?: Array<Tag>;
}
/**
 * 
 * @export
 * @interface DnsProjectZoneRecordsetPatch
 */
export interface DnsProjectZoneRecordsetPatch {
    /**
     * 
     * @type {number}
     * @memberof DnsProjectZoneRecordsetPatch
     */
    ttl?: number;
}
/**
 * 
 * @export
 * @interface DnsProjectZoneUpdate
 */
export interface DnsProjectZoneUpdate {
    /**
     * 
     * @type {string}
     * @memberof DnsProjectZoneUpdate
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface DnsRecord
 */
export interface DnsRecord {
    /**
     * 
     * @type {string}
     * @memberof DnsRecord
     */
    id?: string;
    /**
     * Template string: - {{REQUEST_IP}} is replaced by the requester ip address.
     * @type {string}
     * @memberof DnsRecord
     */
    content: string;
    /**
     * 
     * @type {boolean}
     * @memberof DnsRecord
     */
    enabled?: boolean;
}
/**
 * 
 * @export
 * @interface DnsRecordset
 */
export interface DnsRecordset {
    /**
     * 
     * @type {string}
     * @memberof DnsRecordset
     */
    id?: string;
    /**
     * use \'@\' to reference the zone origin
     * @type {string}
     * @memberof DnsRecordset
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof DnsRecordset
     */
    type: DnsRecordsetTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof DnsRecordset
     */
    ttl?: number;
    /**
     * 
     * @type {Array<DnsRecord>}
     * @memberof DnsRecordset
     */
    record?: Array<DnsRecord>;
}

/**
    * @export
    * @enum {string}
    */
export enum DnsRecordsetTypeEnum {
    A = 'A',
    AAAA = 'AAAA',
    CAA = 'CAA',
    CNAME = 'CNAME',
    MX = 'MX',
    NS = 'NS',
    PTR = 'PTR',
    SOA = 'SOA',
    SRV = 'SRV',
    TXT = 'TXT'
}

/**
 * 
 * @export
 * @interface Domain
 */
export interface Domain {
    /**
     * 
     * @type {string}
     * @memberof Domain
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Domain
     */
    value: string;
}
/**
 * 
 * @export
 * @interface EnabledService
 */
export interface EnabledService {
    /**
     * 
     * @type {string}
     * @memberof EnabledService
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof EnabledService
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof EnabledService
     */
    service?: string;
}
/**
 * 
 * @export
 * @interface Event
 */
export interface Event {
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    state?: EventStateEnum;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    stage?: string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    resource?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum EventStateEnum {
    Pending = 'pending',
    Processing = 'processing',
    Finished = 'finished',
    Error = 'error'
}

/**
 * 
 * @export
 * @interface Firewall
 */
export interface Firewall {
    /**
     * 
     * @type {string}
     * @memberof Firewall
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Firewall
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Firewall
     */
    flavour?: string;
    /**
     * 
     * @type {string}
     * @memberof Firewall
     */
    modifiedOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Firewall
     */
    modifiedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Firewall
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Firewall
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Firewall
     */
    state?: FirewallStateEnum;
    /**
     * 
     * @type {string}
     * @memberof Firewall
     */
    project?: string;
    /**
     * 
     * @type {string}
     * @memberof Firewall
     */
    uri?: string;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof Firewall
     */
    tag?: Array<Tag>;
}

/**
    * @export
    * @enum {string}
    */
export enum FirewallStateEnum {
    Attached = 'Attached',
    Detached = 'Detached',
    Unknown = 'Unknown',
    Processing = 'Processing',
    NotCreated = 'NotCreated'
}

/**
 * 
 * @export
 * @interface Hdd
 */
export interface Hdd {
    /**
     * 
     * @type {number}
     * @memberof Hdd
     */
    maximumIOPS?: number;
    /**
     * 
     * @type {string}
     * @memberof Hdd
     */
    controllerType?: string;
    /**
     * 
     * @type {string}
     * @memberof Hdd
     */
    controllerNumber?: string;
    /**
     * 
     * @type {number}
     * @memberof Hdd
     */
    controllerLocation?: number;
    /**
     * 
     * @type {string}
     * @memberof Hdd
     */
    disk?: string;
    /**
     * 
     * @type {string}
     * @memberof Hdd
     */
    id?: string;
}
/**
 * 
 * @export
 * @interface IamActor
 */
export interface IamActor {
    /**
     * 
     * @type {string}
     * @memberof IamActor
     */
    id?: string;
    /**
     * one of: * E-mail * User URI * Service Account URI * \'me\' -§ requestor
     * @type {string}
     * @memberof IamActor
     */
    value: string;
}
/**
 * 
 * @export
 * @interface IamOrganisationCreate
 */
export interface IamOrganisationCreate {
    /**
     * 
     * @type {string}
     * @memberof IamOrganisationCreate
     */
    name: string;
    /**
     * 
     * @type {OrganisationBilling}
     * @memberof IamOrganisationCreate
     */
    billing?: OrganisationBilling;
}
/**
 * 
 * @export
 * @interface IamOrganisationInvitationAccept
 */
export interface IamOrganisationInvitationAccept {
    /**
     * 
     * @type {string}
     * @memberof IamOrganisationInvitationAccept
     */
    token: string;
}
/**
 * 
 * @export
 * @interface IamOrganisationOwnershipCreate
 */
export interface IamOrganisationOwnershipCreate {
    /**
     * 
     * @type {string}
     * @memberof IamOrganisationOwnershipCreate
     */
    email: string;
}
/**
 * 
 * @export
 * @interface IamOrganisationPaymentAllocate
 */
export interface IamOrganisationPaymentAllocate {
    /**
     * 
     * @type {string}
     * @memberof IamOrganisationPaymentAllocate
     */
    project: string;
}
/**
 * 
 * @export
 * @interface IamOrganisationProformaCreate
 */
export interface IamOrganisationProformaCreate {
    /**
     * 
     * @type {number}
     * @memberof IamOrganisationProformaCreate
     */
    amount: number;
    /**
     * 
     * @type {string}
     * @memberof IamOrganisationProformaCreate
     */
    project: string;
}
/**
 * 
 * @export
 * @interface IamOrganisationTransferAccept
 */
export interface IamOrganisationTransferAccept {
    /**
     * 
     * @type {string}
     * @memberof IamOrganisationTransferAccept
     */
    payment: string;
}
/**
 * 
 * @export
 * @interface IamOrganisationUpdate
 */
export interface IamOrganisationUpdate {
    /**
     * 
     * @type {string}
     * @memberof IamOrganisationUpdate
     */
    name?: string;
    /**
     * 
     * @type {OrganisationBilling1}
     * @memberof IamOrganisationUpdate
     */
    billing?: OrganisationBilling1;
}
/**
 * 
 * @export
 * @interface IamPermission
 */
export interface IamPermission {
    /**
     * 
     * @type {string}
     * @memberof IamPermission
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof IamPermission
     */
    value: string;
}
/**
 * 
 * @export
 * @interface IamProjectCreate
 */
export interface IamProjectCreate {
    /**
     * 
     * @type {string}
     * @memberof IamProjectCreate
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof IamProjectCreate
     */
    organisation: string;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof IamProjectCreate
     */
    tag?: Array<Tag>;
}
/**
 * 
 * @export
 * @interface IamProjectCredentialStorePatch
 */
export interface IamProjectCredentialStorePatch {
    /**
     * 
     * @type {string}
     * @memberof IamProjectCredentialStorePatch
     */
    name: string;
}
/**
 * 
 * @export
 * @interface IamProjectInvitationAccept
 */
export interface IamProjectInvitationAccept {
    /**
     * 
     * @type {string}
     * @memberof IamProjectInvitationAccept
     */
    token: string;
}
/**
 * 
 * @export
 * @interface IamProjectOwnershipCreate
 */
export interface IamProjectOwnershipCreate {
    /**
     * 
     * @type {string}
     * @memberof IamProjectOwnershipCreate
     */
    email: string;
}
/**
 * 
 * @export
 * @interface IamProjectPolicyCreate
 */
export interface IamProjectPolicyCreate {
    /**
     * 
     * @type {string}
     * @memberof IamProjectPolicyCreate
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof IamProjectPolicyCreate
     */
    role: string;
    /**
     * 
     * @type {string}
     * @memberof IamProjectPolicyCreate
     */
    resource: string;
    /**
     * 
     * @type {Array<IamProjectPolicyCreateActor>}
     * @memberof IamProjectPolicyCreate
     */
    actor?: Array<IamProjectPolicyCreateActor>;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof IamProjectPolicyCreate
     */
    tag?: Array<Tag>;
}
/**
 * 
 * @export
 * @interface IamProjectPolicyCreateActor
 */
export interface IamProjectPolicyCreateActor {
    /**
     * 
     * @type {string}
     * @memberof IamProjectPolicyCreateActor
     */
    value?: string;
}
/**
 * 
 * @export
 * @interface IamProjectPolicyUpdate
 */
export interface IamProjectPolicyUpdate {
    /**
     * 
     * @type {string}
     * @memberof IamProjectPolicyUpdate
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface IamProjectQuotaLimitPatch
 */
export interface IamProjectQuotaLimitPatch {
    /**
     * 
     * @type {number}
     * @memberof IamProjectQuotaLimitPatch
     */
    user?: number;
}
/**
 * 
 * @export
 * @interface IamProjectRoleCreate
 */
export interface IamProjectRoleCreate {
    /**
     * 
     * @type {string}
     * @memberof IamProjectRoleCreate
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof IamProjectRoleCreate
     */
    service?: string;
    /**
     * 
     * @type {string}
     * @memberof IamProjectRoleCreate
     */
    description?: string;
    /**
     * 
     * @type {Array<IamPermission>}
     * @memberof IamProjectRoleCreate
     */
    permission?: Array<IamPermission>;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof IamProjectRoleCreate
     */
    tag?: Array<Tag>;
}
/**
 * 
 * @export
 * @interface IamProjectRoleUpdate
 */
export interface IamProjectRoleUpdate {
    /**
     * 
     * @type {string}
     * @memberof IamProjectRoleUpdate
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof IamProjectRoleUpdate
     */
    description?: string;
}
/**
 * 
 * @export
 * @interface IamProjectSaCreate
 */
export interface IamProjectSaCreate {
    /**
     * 
     * @type {string}
     * @memberof IamProjectSaCreate
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof IamProjectSaCreate
     */
    service?: string;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof IamProjectSaCreate
     */
    tag?: Array<Tag>;
}
/**
 * 
 * @export
 * @interface IamProjectSaCredentialPatch
 */
export interface IamProjectSaCredentialPatch {
    /**
     * 
     * @type {string}
     * @memberof IamProjectSaCredentialPatch
     */
    name: string;
}
/**
 * 
 * @export
 * @interface IamProjectSaUpdate
 */
export interface IamProjectSaUpdate {
    /**
     * 
     * @type {string}
     * @memberof IamProjectSaUpdate
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface IamProjectThresholdCreate
 */
export interface IamProjectThresholdCreate {
    /**
     * 
     * @type {string}
     * @memberof IamProjectThresholdCreate
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof IamProjectThresholdCreate
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof IamProjectThresholdCreate
     */
    type?: string;
    /**
     * 
     * @type {number}
     * @memberof IamProjectThresholdCreate
     */
    value?: number;
    /**
     * 
     * @type {string}
     * @memberof IamProjectThresholdCreate
     */
    uri?: string;
}
/**
 * 
 * @export
 * @interface IamProjectTransfer
 */
export interface IamProjectTransfer {
    /**
     * 
     * @type {string}
     * @memberof IamProjectTransfer
     */
    organisation: string;
}
/**
 * 
 * @export
 * @interface IamProjectUpdate
 */
export interface IamProjectUpdate {
    /**
     * 
     * @type {string}
     * @memberof IamProjectUpdate
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface IamUserCredentialPatch
 */
export interface IamUserCredentialPatch {
    /**
     * 
     * @type {string}
     * @memberof IamUserCredentialPatch
     */
    name: string;
}
/**
 * 
 * @export
 * @interface IamUserUpdate
 */
export interface IamUserUpdate {
    /**
     * 
     * @type {string}
     * @memberof IamUserUpdate
     */
    phone?: string;
    /**
     * 
     * @type {string}
     * @memberof IamUserUpdate
     */
    firstName?: string;
    /**
     * 
     * @type {string}
     * @memberof IamUserUpdate
     */
    familyName?: string;
    /**
     * 
     * @type {string}
     * @memberof IamUserUpdate
     */
    lang?: IamUserUpdateLangEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum IamUserUpdateLangEnum {
    En = 'en',
    Pl = 'pl'
}

/**
 * 
 * @export
 * @interface Image
 */
export interface Image {
    /**
     * 
     * @type {string}
     * @memberof Image
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Image
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Image
     */
    flavour?: string;
    /**
     * 
     * @type {string}
     * @memberof Image
     */
    modifiedOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Image
     */
    modifiedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Image
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Image
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Image
     */
    state?: ImageStateEnum;
    /**
     * 
     * @type {string}
     * @memberof Image
     */
    project?: string;
    /**
     * 
     * @type {string}
     * @memberof Image
     */
    uri?: string;
    /**
     * 
     * @type {string}
     * @memberof Image
     */
    description?: string;
    /**
     * 
     * @type {number}
     * @memberof Image
     */
    disks?: number;
    /**
     * 
     * @type {number}
     * @memberof Image
     */
    fileSize?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof Image
     */
    license?: Array<string>;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof Image
     */
    tag?: Array<Tag>;
}

/**
    * @export
    * @enum {string}
    */
export enum ImageStateEnum {
    Online = 'Online',
    Unknown = 'Unknown',
    Processing = 'Processing',
    NotCreated = 'NotCreated'
}

/**
 * 
 * @export
 * @interface InlineResponse400
 */
export interface InlineResponse400 {
    /**
     * error description
     * @type {string}
     * @memberof InlineResponse400
     */
    message?: string;
}
/**
 * 
 * @export
 * @interface InsightProjectJournalCreate
 */
export interface InsightProjectJournalCreate {
    /**
     * 
     * @type {string}
     * @memberof InsightProjectJournalCreate
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof InsightProjectJournalCreate
     */
    service?: string;
    /**
     * 
     * @type {number}
     * @memberof InsightProjectJournalCreate
     */
    retention?: number;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof InsightProjectJournalCreate
     */
    tag?: Array<Tag>;
}
/**
 * 
 * @export
 * @interface InsightProjectJournalCredentialPatch
 */
export interface InsightProjectJournalCredentialPatch {
    /**
     * 
     * @type {string}
     * @memberof InsightProjectJournalCredentialPatch
     */
    name: string;
}
/**
 * 
 * @export
 * @interface InsightProjectJournalTransfer
 */
export interface InsightProjectJournalTransfer {
    /**
     * 
     * @type {string}
     * @memberof InsightProjectJournalTransfer
     */
    project: string;
}
/**
 * 
 * @export
 * @interface InsightProjectJournalUpdate
 */
export interface InsightProjectJournalUpdate {
    /**
     * 
     * @type {string}
     * @memberof InsightProjectJournalUpdate
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof InsightProjectJournalUpdate
     */
    retention?: number;
}
/**
 * 
 * @export
 * @interface Invitation
 */
export interface Invitation {
    /**
     * 
     * @type {string}
     * @memberof Invitation
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof Invitation
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof Invitation
     */
    resource: string;
}
/**
 * 
 * @export
 * @interface Invoice
 */
export interface Invoice {
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    additionalInfo?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Invoice
     */
    corrections?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    invoiceInfo?: string;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    invoiceNo?: string;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    issueDate?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Invoice
     */
    payments?: Array<string>;
    /**
     * 
     * @type {InvoiceSeller}
     * @memberof Invoice
     */
    seller?: InvoiceSeller;
    /**
     * 
     * @type {Array<InvoiceItems>}
     * @memberof Invoice
     */
    items?: Array<InvoiceItems>;
    /**
     * 
     * @type {InvoiceBuyer}
     * @memberof Invoice
     */
    buyer?: InvoiceBuyer;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    type?: InvoiceTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    summary?: string;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    project?: string;
    /**
     * 
     * @type {InvoiceDuplicate}
     * @memberof Invoice
     */
    duplicate?: InvoiceDuplicate;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    uri?: string;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    __array__?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum InvoiceTypeEnum {
    Vat = 'vat',
    Correction = 'correction'
}

/**
 * 
 * @export
 * @interface InvoiceBuyer
 */
export interface InvoiceBuyer {
    /**
     * 
     * @type {string}
     * @memberof InvoiceBuyer
     */
    company: string;
    /**
     * 
     * @type {InvoiceBuyerAddress}
     * @memberof InvoiceBuyer
     */
    address?: InvoiceBuyerAddress;
    /**
     * 
     * @type {string}
     * @memberof InvoiceBuyer
     */
    nip?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceBuyer
     */
    email?: string;
}
/**
 * 
 * @export
 * @interface InvoiceBuyerAddress
 */
export interface InvoiceBuyerAddress {
    /**
     * 
     * @type {string}
     * @memberof InvoiceBuyerAddress
     */
    street: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceBuyerAddress
     */
    zipcode?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceBuyerAddress
     */
    city: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceBuyerAddress
     */
    country: string;
}
/**
 * 
 * @export
 * @interface InvoiceDuplicate
 */
export interface InvoiceDuplicate {
    /**
     * 
     * @type {string}
     * @memberof InvoiceDuplicate
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceDuplicate
     */
    id?: string;
}
/**
 * 
 * @export
 * @interface InvoiceItems
 */
export interface InvoiceItems {
    /**
     * 
     * @type {string}
     * @memberof InvoiceItems
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceItems
     */
    price: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceItems
     */
    netto: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceItems
     */
    brutto: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceItems
     */
    vatAmount: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceItems
     */
    vatRate: string;
    /**
     * 
     * @type {number}
     * @memberof InvoiceItems
     */
    quantity: number;
}
/**
 * 
 * @export
 * @interface InvoiceSeller
 */
export interface InvoiceSeller {
    /**
     * 
     * @type {string}
     * @memberof InvoiceSeller
     */
    company: string;
    /**
     * 
     * @type {InvoiceSellerAddress}
     * @memberof InvoiceSeller
     */
    address?: InvoiceSellerAddress;
    /**
     * 
     * @type {string}
     * @memberof InvoiceSeller
     */
    nip: string;
}
/**
 * 
 * @export
 * @interface InvoiceSellerAddress
 */
export interface InvoiceSellerAddress {
    /**
     * 
     * @type {string}
     * @memberof InvoiceSellerAddress
     */
    street: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceSellerAddress
     */
    zipcode: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceSellerAddress
     */
    city: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceSellerAddress
     */
    country: string;
}
/**
 * 
 * @export
 * @interface Ip
 */
export interface Ip {
    /**
     * 
     * @type {string}
     * @memberof Ip
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Ip
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Ip
     */
    flavour?: string;
    /**
     * 
     * @type {string}
     * @memberof Ip
     */
    modifiedOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Ip
     */
    modifiedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Ip
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Ip
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Ip
     */
    state?: IpStateEnum;
    /**
     * 
     * @type {string}
     * @memberof Ip
     */
    project?: string;
    /**
     * 
     * @type {string}
     * @memberof Ip
     */
    uri?: string;
    /**
     * 
     * @type {string}
     * @memberof Ip
     */
    address?: string;
    /**
     * 
     * @type {string}
     * @memberof Ip
     */
    fqdn?: string;
    /**
     * 
     * @type {string}
     * @memberof Ip
     */
    network?: string;
    /**
     * 
     * @type {string}
     * @memberof Ip
     */
    ptrRecord?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Ip
     */
    persistent?: boolean;
    /**
     * 
     * @type {IpAssociated}
     * @memberof Ip
     */
    associated?: IpAssociated;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof Ip
     */
    tag?: Array<Tag>;
}

/**
    * @export
    * @enum {string}
    */
export enum IpStateEnum {
    Associated = 'Associated',
    Allocated = 'Allocated',
    Unallocated = 'Unallocated'
}

/**
 * 
 * @export
 * @interface IpAssociated
 */
export interface IpAssociated {
    /**
     * 
     * @type {string}
     * @memberof IpAssociated
     */
    ip?: string;
    /**
     * 
     * @type {string}
     * @memberof IpAssociated
     */
    fip?: string;
    /**
     * 
     * @type {string}
     * @memberof IpAssociated
     */
    netadp?: string;
}
/**
 * 
 * @export
 * @interface Iso
 */
export interface Iso {
    /**
     * 
     * @type {string}
     * @memberof Iso
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Iso
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Iso
     */
    flavour?: string;
    /**
     * 
     * @type {string}
     * @memberof Iso
     */
    modifiedOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Iso
     */
    modifiedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Iso
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Iso
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Iso
     */
    state?: IsoStateEnum;
    /**
     * 
     * @type {string}
     * @memberof Iso
     */
    project?: string;
    /**
     * 
     * @type {string}
     * @memberof Iso
     */
    uri?: string;
    /**
     * 
     * @type {number}
     * @memberof Iso
     */
    size?: number;
    /**
     * 
     * @type {IsoMetadata}
     * @memberof Iso
     */
    metadata?: IsoMetadata;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof Iso
     */
    tag?: Array<Tag>;
}

/**
    * @export
    * @enum {string}
    */
export enum IsoStateEnum {
    Uploading = 'Uploading',
    Online = 'Online',
    Unknown = 'Unknown',
    Processing = 'Processing',
    NotCreated = 'NotCreated'
}

/**
 * 
 * @export
 * @interface IsoMetadata
 */
export interface IsoMetadata {
    /**
     * 
     * @type {IsoMetadataSource}
     * @memberof IsoMetadata
     */
    source?: IsoMetadataSource;
}
/**
 * 
 * @export
 * @interface IsoMetadataSource
 */
export interface IsoMetadataSource {
    /**
     * 
     * @type {string}
     * @memberof IsoMetadataSource
     */
    filename?: string;
    /**
     * 
     * @type {number}
     * @memberof IsoMetadataSource
     */
    size?: number;
}
/**
 * 
 * @export
 * @interface Journal
 */
export interface Journal {
    /**
     * 
     * @type {string}
     * @memberof Journal
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Journal
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Journal
     */
    flavour?: string;
    /**
     * 
     * @type {string}
     * @memberof Journal
     */
    modifiedOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Journal
     */
    modifiedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Journal
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Journal
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Journal
     */
    state?: JournalStateEnum;
    /**
     * 
     * @type {string}
     * @memberof Journal
     */
    project?: string;
    /**
     * 
     * @type {string}
     * @memberof Journal
     */
    uri?: string;
    /**
     * 
     * @type {number}
     * @memberof Journal
     */
    sizeUsed?: number;
    /**
     * 
     * @type {number}
     * @memberof Journal
     */
    retention?: number;
    /**
     * 
     * @type {string}
     * @memberof Journal
     */
    fqdn?: string;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof Journal
     */
    tag?: Array<Tag>;
}

/**
    * @export
    * @enum {string}
    */
export enum JournalStateEnum {
    Online = 'Online',
    Unknown = 'Unknown',
    Processing = 'Processing',
    NotCreated = 'NotCreated'
}

/**
 * 
 * @export
 * @interface JournalCredential
 */
export interface JournalCredential {
    /**
     * 
     * @type {string}
     * @memberof JournalCredential
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof JournalCredential
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof JournalCredential
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof JournalCredential
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof JournalCredential
     */
    type: JournalCredentialTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof JournalCredential
     */
    value: string;
    /**
     * 
     * @type {string}
     * @memberof JournalCredential
     */
    fingerprint?: string;
    /**
     * 
     * @type {string}
     * @memberof JournalCredential
     */
    token?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum JournalCredentialTypeEnum {
    Sha512 = 'sha512',
    Plain = 'plain'
}

/**
 * 
 * @export
 * @interface Log
 */
export interface Log {
    /**
     * 
     * @type {string}
     * @memberof Log
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof Log
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Log
     */
    type: LogTypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum LogTypeEnum {
    Console = 'console'
}

/**
 * 
 * @export
 * @interface MessageData
 */
export interface MessageData {
    /**
     * 
     * @type {string}
     * @memberof MessageData
     */
    mime: MessageDataMimeEnum;
    /**
     * 
     * @type {string}
     * @memberof MessageData
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof MessageData
     */
    body?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum MessageDataMimeEnum {
    TextPlain = 'text/plain',
    ImagePng = 'image/png',
    ImageJpeg = 'image/jpeg'
}

/**
 * 
 * @export
 * @interface Metric
 */
export interface Metric {
    /**
     * 
     * @type {string}
     * @memberof Metric
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof Metric
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Metric
     */
    unit: string;
    /**
     * 
     * @type {Array<MetricDimension>}
     * @memberof Metric
     */
    dimension?: Array<MetricDimension>;
}
/**
 * 
 * @export
 * @interface MetricDimension
 */
export interface MetricDimension {
    /**
     * 
     * @type {string}
     * @memberof MetricDimension
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof MetricDimension
     */
    description: string;
}
/**
 * 
 * @export
 * @interface Netadp
 */
export interface Netadp {
    /**
     * 
     * @type {string}
     * @memberof Netadp
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Netadp
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Netadp
     */
    flavour?: string;
    /**
     * 
     * @type {string}
     * @memberof Netadp
     */
    modifiedOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Netadp
     */
    modifiedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Netadp
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Netadp
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Netadp
     */
    state?: NetadpStateEnum;
    /**
     * 
     * @type {string}
     * @memberof Netadp
     */
    project?: string;
    /**
     * 
     * @type {string}
     * @memberof Netadp
     */
    uri?: string;
    /**
     * 
     * @type {string}
     * @memberof Netadp
     */
    macaddress?: string;
    /**
     * 
     * @type {number}
     * @memberof Netadp
     */
    speed?: number;
    /**
     * 
     * @type {string}
     * @memberof Netadp
     */
    fqdn?: string;
    /**
     * 
     * @type {string}
     * @memberof Netadp
     */
    network?: string;
    /**
     * 
     * @type {string}
     * @memberof Netadp
     */
    firewall?: string;
    /**
     * 
     * @type {string}
     * @memberof Netadp
     */
    assigned?: string;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof Netadp
     */
    tag?: Array<Tag>;
}

/**
    * @export
    * @enum {string}
    */
export enum NetadpStateEnum {
    Online = 'Online',
    Deallocated = 'Deallocated',
    Unknown = 'Unknown',
    Processing = 'Processing',
    NotCreated = 'NotCreated'
}

/**
 * 
 * @export
 * @interface Netgw
 */
export interface Netgw {
    /**
     * 
     * @type {string}
     * @memberof Netgw
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Netgw
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Netgw
     */
    flavour?: string;
    /**
     * 
     * @type {string}
     * @memberof Netgw
     */
    modifiedOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Netgw
     */
    modifiedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Netgw
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Netgw
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Netgw
     */
    state?: NetgwStateEnum;
    /**
     * 
     * @type {string}
     * @memberof Netgw
     */
    project?: string;
    /**
     * 
     * @type {string}
     * @memberof Netgw
     */
    uri?: string;
    /**
     * 
     * @type {string}
     * @memberof Netgw
     */
    primaryIP?: string;
    /**
     * 
     * @type {string}
     * @memberof Netgw
     */
    network?: string;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof Netgw
     */
    tag?: Array<Tag>;
}

/**
    * @export
    * @enum {string}
    */
export enum NetgwStateEnum {
    Attached = 'Attached',
    Detached = 'Detached',
    Unknown = 'Unknown',
    Processing = 'Processing',
    NotCreated = 'NotCreated'
}

/**
 * 
 * @export
 * @interface NetgwPrivate
 */
export interface NetgwPrivate {
    /**
     * 
     * @type {string}
     * @memberof NetgwPrivate
     */
    network: string;
}
/**
 * 
 * @export
 * @interface NetgwPublic
 */
export interface NetgwPublic {
    /**
     * 
     * @type {string}
     * @memberof NetgwPublic
     */
    ip: string;
}
/**
 * 
 * @export
 * @interface Network
 */
export interface Network {
    /**
     * 
     * @type {string}
     * @memberof Network
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Network
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Network
     */
    flavour?: string;
    /**
     * 
     * @type {string}
     * @memberof Network
     */
    modifiedOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Network
     */
    modifiedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Network
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Network
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Network
     */
    state?: NetworkStateEnum;
    /**
     * 
     * @type {string}
     * @memberof Network
     */
    project?: string;
    /**
     * 
     * @type {string}
     * @memberof Network
     */
    uri?: string;
    /**
     * 
     * @type {string}
     * @memberof Network
     */
    address?: string;
    /**
     * 
     * @type {string}
     * @memberof Network
     */
    gateway?: string;
    /**
     * 
     * @type {string}
     * @memberof Network
     */
    type?: NetworkTypeEnum;
    /**
     * 
     * @type {NetworkDns}
     * @memberof Network
     */
    dns?: NetworkDns;
    /**
     * 
     * @type {string}
     * @memberof Network
     */
    netgw?: string;
    /**
     * 
     * @type {string}
     * @memberof Network
     */
    firewall?: string;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof Network
     */
    tag?: Array<Tag>;
}

/**
    * @export
    * @enum {string}
    */
export enum NetworkStateEnum {
    Online = 'Online',
    Unknown = 'Unknown',
    Processing = 'Processing',
    NotCreated = 'NotCreated'
}
/**
    * @export
    * @enum {string}
    */
export enum NetworkTypeEnum {
    Public = 'public',
    Private = 'private'
}

/**
 * 
 * @export
 * @interface NetworkDns
 */
export interface NetworkDns {
    /**
     * 
     * @type {Array<string>}
     * @memberof NetworkDns
     */
    nameservers?: Array<string>;
}
/**
 * 
 * @export
 * @interface NetworkingProjectFirewallCreate
 */
export interface NetworkingProjectFirewallCreate {
    /**
     * 
     * @type {string}
     * @memberof NetworkingProjectFirewallCreate
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof NetworkingProjectFirewallCreate
     */
    service?: string;
    /**
     * 
     * @type {Array<NetworkingRule>}
     * @memberof NetworkingProjectFirewallCreate
     */
    ingress?: Array<NetworkingRule>;
    /**
     * 
     * @type {Array<NetworkingRule>}
     * @memberof NetworkingProjectFirewallCreate
     */
    egress?: Array<NetworkingRule>;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof NetworkingProjectFirewallCreate
     */
    tag?: Array<Tag>;
}
/**
 * 
 * @export
 * @interface NetworkingProjectFirewallTransfer
 */
export interface NetworkingProjectFirewallTransfer {
    /**
     * 
     * @type {string}
     * @memberof NetworkingProjectFirewallTransfer
     */
    project: string;
}
/**
 * 
 * @export
 * @interface NetworkingProjectFirewallUpdate
 */
export interface NetworkingProjectFirewallUpdate {
    /**
     * 
     * @type {string}
     * @memberof NetworkingProjectFirewallUpdate
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface NetworkingProjectIpAssociate
 */
export interface NetworkingProjectIpAssociate {
    /**
     * 
     * @type {string}
     * @memberof NetworkingProjectIpAssociate
     */
    ip: string;
}
/**
 * 
 * @export
 * @interface NetworkingProjectIpCreate
 */
export interface NetworkingProjectIpCreate {
    /**
     * 
     * @type {string}
     * @memberof NetworkingProjectIpCreate
     */
    network?: string;
    /**
     * 
     * @type {string}
     * @memberof NetworkingProjectIpCreate
     */
    ptrRecord?: string;
    /**
     * 
     * @type {string}
     * @memberof NetworkingProjectIpCreate
     */
    address?: string;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof NetworkingProjectIpCreate
     */
    tag?: Array<Tag>;
}
/**
 * 
 * @export
 * @interface NetworkingProjectIpTransfer
 */
export interface NetworkingProjectIpTransfer {
    /**
     * 
     * @type {string}
     * @memberof NetworkingProjectIpTransfer
     */
    project: string;
}
/**
 * 
 * @export
 * @interface NetworkingProjectIpUpdate
 */
export interface NetworkingProjectIpUpdate {
    /**
     * 
     * @type {string}
     * @memberof NetworkingProjectIpUpdate
     */
    ptrRecord?: string;
}
/**
 * 
 * @export
 * @interface NetworkingProjectNetadpCreate
 */
export interface NetworkingProjectNetadpCreate {
    /**
     * 
     * @type {string}
     * @memberof NetworkingProjectNetadpCreate
     */
    vm: string;
    /**
     * 
     * @type {string}
     * @memberof NetworkingProjectNetadpCreate
     */
    network: string;
    /**
     * 
     * @type {string}
     * @memberof NetworkingProjectNetadpCreate
     */
    firewall?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof NetworkingProjectNetadpCreate
     */
    ip?: Array<string>;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof NetworkingProjectNetadpCreate
     */
    tag?: Array<Tag>;
}
/**
 * 
 * @export
 * @interface NetworkingProjectNetadpUpdate
 */
export interface NetworkingProjectNetadpUpdate {
    /**
     * 
     * @type {string}
     * @memberof NetworkingProjectNetadpUpdate
     */
    firewall?: string;
}
/**
 * 
 * @export
 * @interface NetworkingProjectNetgwAttach
 */
export interface NetworkingProjectNetgwAttach {
    /**
     * 
     * @type {NetgwPrivate}
     * @memberof NetworkingProjectNetgwAttach
     */
    _private?: NetgwPrivate;
}
/**
 * 
 * @export
 * @interface NetworkingProjectNetgwCreate
 */
export interface NetworkingProjectNetgwCreate {
    /**
     * 
     * @type {string}
     * @memberof NetworkingProjectNetgwCreate
     */
    name?: string;
    /**
     * 
     * @type {NetgwPublic}
     * @memberof NetworkingProjectNetgwCreate
     */
    _public?: NetgwPublic;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof NetworkingProjectNetgwCreate
     */
    tag?: Array<Tag>;
}
/**
 * 
 * @export
 * @interface NetworkingProjectNetgwUpdate
 */
export interface NetworkingProjectNetgwUpdate {
    /**
     * 
     * @type {string}
     * @memberof NetworkingProjectNetgwUpdate
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface NetworkingProjectNetworkCreate
 */
export interface NetworkingProjectNetworkCreate {
    /**
     * 
     * @type {string}
     * @memberof NetworkingProjectNetworkCreate
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof NetworkingProjectNetworkCreate
     */
    address?: string;
    /**
     * 
     * @type {string}
     * @memberof NetworkingProjectNetworkCreate
     */
    gateway?: string;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof NetworkingProjectNetworkCreate
     */
    tag?: Array<Tag>;
}
/**
 * 
 * @export
 * @interface NetworkingProjectNetworkUpdate
 */
export interface NetworkingProjectNetworkUpdate {
    /**
     * 
     * @type {string}
     * @memberof NetworkingProjectNetworkUpdate
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof NetworkingProjectNetworkUpdate
     */
    gateway?: string;
    /**
     * 
     * @type {string}
     * @memberof NetworkingProjectNetworkUpdate
     */
    firewall?: string;
}
/**
 * 
 * @export
 * @interface NetworkingRule
 */
export interface NetworkingRule {
    /**
     * 
     * @type {string}
     * @memberof NetworkingRule
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof NetworkingRule
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof NetworkingRule
     */
    action: NetworkingRuleActionEnum;
    /**
     * 
     * @type {number}
     * @memberof NetworkingRule
     */
    priority: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof NetworkingRule
     */
    filter: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof NetworkingRule
     */
    external?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof NetworkingRule
     */
    internal?: Array<string>;
}

/**
    * @export
    * @enum {string}
    */
export enum NetworkingRuleActionEnum {
    Allow = 'allow',
    Deny = 'deny'
}

/**
 * 
 * @export
 * @interface Organisation
 */
export interface Organisation {
    /**
     * 
     * @type {string}
     * @memberof Organisation
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Organisation
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Organisation
     */
    flavour?: string;
    /**
     * 
     * @type {string}
     * @memberof Organisation
     */
    modifiedOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Organisation
     */
    modifiedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Organisation
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Organisation
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Organisation
     */
    state?: OrganisationStateEnum;
    /**
     * 
     * @type {string}
     * @memberof Organisation
     */
    uri?: string;
    /**
     * 
     * @type {OrganisationBilling}
     * @memberof Organisation
     */
    billing?: OrganisationBilling;
    /**
     * 
     * @type {string}
     * @memberof Organisation
     */
    bankAccount?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum OrganisationStateEnum {
    Active = 'Active',
    Inactive = 'Inactive',
    Processing = 'Processing',
    NotCreated = 'NotCreated'
}

/**
 * 
 * @export
 * @interface OrganisationBilling
 */
export interface OrganisationBilling {
    /**
     * 
     * @type {string}
     * @memberof OrganisationBilling
     */
    currency?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganisationBilling
     */
    company?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganisationBilling
     */
    email?: string;
    /**
     * 
     * @type {InvoiceSellerAddress}
     * @memberof OrganisationBilling
     */
    address?: InvoiceSellerAddress;
    /**
     * 
     * @type {string}
     * @memberof OrganisationBilling
     */
    nip?: string;
}
/**
 * 
 * @export
 * @interface OrganisationBilling1
 */
export interface OrganisationBilling1 {
    /**
     * 
     * @type {string}
     * @memberof OrganisationBilling1
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganisationBilling1
     */
    company?: string;
    /**
     * 
     * @type {BillingAddress1}
     * @memberof OrganisationBilling1
     */
    address?: BillingAddress1;
}
/**
 * 
 * @export
 * @interface Ownership
 */
export interface Ownership {
    /**
     * 
     * @type {string}
     * @memberof Ownership
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof Ownership
     */
    user: string;
}
/**
 * 
 * @export
 * @interface Payment
 */
export interface Payment {
    /**
     * 
     * @type {string}
     * @memberof Payment
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Payment
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Payment
     */
    modifiedOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Payment
     */
    modifiedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Payment
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Payment
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Payment
     */
    state?: PaymentStateEnum;
    /**
     * 
     * @type {string}
     * @memberof Payment
     */
    project?: string;
    /**
     * 
     * @type {string}
     * @memberof Payment
     */
    uri?: string;
    /**
     * 
     * @type {number}
     * @memberof Payment
     */
    creditsFree?: number;
    /**
     * 
     * @type {number}
     * @memberof Payment
     */
    credits?: number;
    /**
     * 
     * @type {string}
     * @memberof Payment
     */
    channel?: PaymentChannelEnum;
    /**
     * 
     * @type {number}
     * @memberof Payment
     */
    amount?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum PaymentStateEnum {
    Unallocated = 'Unallocated',
    Allocated = 'Allocated',
    Expired = 'Expired'
}
/**
    * @export
    * @enum {string}
    */
export enum PaymentChannelEnum {
    Bank = 'bank',
    Dotpay = 'dotpay',
    Promo = 'promo',
    Paypal = 'paypal',
    Ecard = 'ecard',
    Przelewy24 = 'przelewy24'
}

/**
 * 
 * @export
 * @interface Point
 */
export interface Point {
    /**
     * 
     * @type {string}
     * @memberof Point
     */
    time: string;
    /**
     * 
     * @type {number}
     * @memberof Point
     */
    value: number;
}
/**
 * 
 * @export
 * @interface Policy
 */
export interface Policy {
    /**
     * 
     * @type {string}
     * @memberof Policy
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Policy
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Policy
     */
    flavour?: string;
    /**
     * 
     * @type {string}
     * @memberof Policy
     */
    modifiedOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Policy
     */
    modifiedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Policy
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Policy
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Policy
     */
    state?: PolicyStateEnum;
    /**
     * 
     * @type {string}
     * @memberof Policy
     */
    project?: string;
    /**
     * 
     * @type {string}
     * @memberof Policy
     */
    organisation?: string;
    /**
     * 
     * @type {string}
     * @memberof Policy
     */
    uri?: string;
    /**
     * 
     * @type {string}
     * @memberof Policy
     */
    role?: string;
    /**
     * 
     * @type {string}
     * @memberof Policy
     */
    resource?: string;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof Policy
     */
    tag?: Array<Tag>;
}

/**
    * @export
    * @enum {string}
    */
export enum PolicyStateEnum {
    Online = 'Online',
    Processing = 'Processing',
    NotCreated = 'NotCreated'
}

/**
 * 
 * @export
 * @interface Proforma
 */
export interface Proforma {
    /**
     * 
     * @type {string}
     * @memberof Proforma
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Proforma
     */
    invoiceNo?: string;
    /**
     * 
     * @type {ProformaSeller}
     * @memberof Proforma
     */
    seller?: ProformaSeller;
    /**
     * 
     * @type {InvoiceBuyer}
     * @memberof Proforma
     */
    buyer?: InvoiceBuyer;
    /**
     * 
     * @type {string}
     * @memberof Proforma
     */
    issueDate?: string;
    /**
     * 
     * @type {Array<InvoiceItems>}
     * @memberof Proforma
     */
    items?: Array<InvoiceItems>;
    /**
     * 
     * @type {string}
     * @memberof Proforma
     */
    summary?: string;
    /**
     * 
     * @type {string}
     * @memberof Proforma
     */
    project?: string;
    /**
     * 
     * @type {string}
     * @memberof Proforma
     */
    uri?: string;
    /**
     * 
     * @type {ProformaArray}
     * @memberof Proforma
     */
    __array__?: ProformaArray;
}
/**
 * 
 * @export
 * @interface ProformaArray
 */
export interface ProformaArray {
    /**
     * 
     * @type {string}
     * @memberof ProformaArray
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ProformaArray
     */
    invoiceNo?: string;
    /**
     * 
     * @type {string}
     * @memberof ProformaArray
     */
    issueDate?: string;
    /**
     * 
     * @type {string}
     * @memberof ProformaArray
     */
    summary?: string;
    /**
     * 
     * @type {string}
     * @memberof ProformaArray
     */
    project?: string;
    /**
     * 
     * @type {string}
     * @memberof ProformaArray
     */
    uri?: string;
}
/**
 * 
 * @export
 * @interface ProformaSeller
 */
export interface ProformaSeller {
    /**
     * 
     * @type {string}
     * @memberof ProformaSeller
     */
    company: string;
    /**
     * 
     * @type {InvoiceSellerAddress}
     * @memberof ProformaSeller
     */
    address?: InvoiceSellerAddress;
    /**
     * 
     * @type {string}
     * @memberof ProformaSeller
     */
    nip: string;
    /**
     * 
     * @type {string}
     * @memberof ProformaSeller
     */
    iban: string;
}
/**
 * 
 * @export
 * @interface Project
 */
export interface Project {
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    flavour?: string;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    modifiedOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    modifiedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    state?: ProjectStateEnum;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    organisation?: string;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    uri?: string;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    bankAccount?: string;
    /**
     * 
     * @type {ProjectBilling}
     * @memberof Project
     */
    billing?: ProjectBilling;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof Project
     */
    tag?: Array<Tag>;
}

/**
    * @export
    * @enum {string}
    */
export enum ProjectStateEnum {
    Active = 'Active',
    Inactive = 'Inactive',
    Limited = 'Limited',
    Transferring = 'Transferring',
    Processing = 'Processing',
    NotCreated = 'NotCreated'
}

/**
 * 
 * @export
 * @interface ProjectBilling
 */
export interface ProjectBilling {
    /**
     * 
     * @type {number}
     * @memberof ProjectBilling
     */
    credits?: number;
    /**
     * 
     * @type {number}
     * @memberof ProjectBilling
     */
    creditsBonus?: number;
    /**
     * 
     * @type {number}
     * @memberof ProjectBilling
     */
    creditLimit?: number;
}
/**
 * 
 * @export
 * @interface ProjectCredential
 */
export interface ProjectCredential {
    /**
     * 
     * @type {string}
     * @memberof ProjectCredential
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectCredential
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectCredential
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectCredential
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectCredential
     */
    type: ProjectCredentialTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ProjectCredential
     */
    value: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectCredential
     */
    fingerprint?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectCredential
     */
    token?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ProjectCredentialTypeEnum {
    Ssh = 'ssh'
}

/**
 * 
 * @export
 * @interface ProjectFeature
 */
export interface ProjectFeature {
    /**
     * 
     * @type {boolean}
     * @memberof ProjectFeature
     */
    earlyAdopter?: boolean;
}
/**
 * 
 * @export
 * @interface ProjectThreshold
 */
export interface ProjectThreshold {
    /**
     * 
     * @type {string}
     * @memberof ProjectThreshold
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectThreshold
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectThreshold
     */
    type?: string;
    /**
     * 
     * @type {number}
     * @memberof ProjectThreshold
     */
    value?: number;
    /**
     * 
     * @type {string}
     * @memberof ProjectThreshold
     */
    uri?: string;
}
/**
 * 
 * @export
 * @interface ProviderAgentResource
 */
export interface ProviderAgentResource {
    /**
     * 
     * @type {string}
     * @memberof ProviderAgentResource
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ProviderAgentResource
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ProviderAgentResource
     */
    state?: string;
    /**
     * 
     * @type {string}
     * @memberof ProviderAgentResource
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof ProviderAgentResource
     */
    project?: string;
    /**
     * 
     * @type {string}
     * @memberof ProviderAgentResource
     */
    resource?: string;
}
/**
 * 
 * @export
 * @interface ProviderAgentResourceEvent
 */
export interface ProviderAgentResourceEvent {
    /**
     * 
     * @type {string}
     * @memberof ProviderAgentResourceEvent
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ProviderAgentResourceEvent
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ProviderAgentResourceEvent
     */
    state?: ProviderAgentResourceEventStateEnum;
    /**
     * 
     * @type {string}
     * @memberof ProviderAgentResourceEvent
     */
    createdOn?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ProviderAgentResourceEventStateEnum {
    Pending = 'pending',
    Processing = 'processing',
    Finished = 'finished',
    Error = 'error'
}

/**
 * 
 * @export
 * @interface ProviderProjectAgentCreate
 */
export interface ProviderProjectAgentCreate {
    /**
     * 
     * @type {string}
     * @memberof ProviderProjectAgentCreate
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof ProviderProjectAgentCreate
     */
    service: string;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof ProviderProjectAgentCreate
     */
    tag?: Array<Tag>;
}
/**
 * 
 * @export
 * @interface ProviderProjectAgentCredentialPatch
 */
export interface ProviderProjectAgentCredentialPatch {
    /**
     * 
     * @type {string}
     * @memberof ProviderProjectAgentCredentialPatch
     */
    name: string;
}
/**
 * 
 * @export
 * @interface ProviderProjectAgentTransfer
 */
export interface ProviderProjectAgentTransfer {
    /**
     * 
     * @type {string}
     * @memberof ProviderProjectAgentTransfer
     */
    project: string;
}
/**
 * 
 * @export
 * @interface ProviderProjectAgentUpdate
 */
export interface ProviderProjectAgentUpdate {
    /**
     * 
     * @type {string}
     * @memberof ProviderProjectAgentUpdate
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface Quota
 */
export interface Quota {
    /**
     * 
     * @type {string}
     * @memberof Quota
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Quota
     */
    name?: string;
    /**
     * 
     * @type {QuotaMetric}
     * @memberof Quota
     */
    metric?: QuotaMetric;
    /**
     * 
     * @type {number}
     * @memberof Quota
     */
    usage?: number;
    /**
     * 
     * @type {QuotaLimit}
     * @memberof Quota
     */
    limit?: QuotaLimit;
}
/**
 * 
 * @export
 * @interface QuotaLimit
 */
export interface QuotaLimit {
    /**
     * 
     * @type {number}
     * @memberof QuotaLimit
     */
    platform?: number;
    /**
     * 
     * @type {number}
     * @memberof QuotaLimit
     */
    user?: number;
    /**
     * 
     * @type {number}
     * @memberof QuotaLimit
     */
    effective?: number;
}
/**
 * 
 * @export
 * @interface QuotaMetric
 */
export interface QuotaMetric {
    /**
     * 
     * @type {string}
     * @memberof QuotaMetric
     */
    key?: string;
    /**
     * 
     * @type {string}
     * @memberof QuotaMetric
     */
    unit?: string;
}
/**
 * 
 * @export
 * @interface RecoveryProjectBackupCreate
 */
export interface RecoveryProjectBackupCreate {
    /**
     * 
     * @type {string}
     * @memberof RecoveryProjectBackupCreate
     */
    name: string;
    /**
     * 
     * @type {any}
     * @memberof RecoveryProjectBackupCreate
     */
    source: any;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof RecoveryProjectBackupCreate
     */
    tag?: Array<Tag>;
}
/**
 * 
 * @export
 * @interface RecoveryProjectBackupExport
 */
export interface RecoveryProjectBackupExport {
    /**
     * 
     * @type {string}
     * @memberof RecoveryProjectBackupExport
     */
    bucket: string;
}
/**
 * 
 * @export
 * @interface RecoveryProjectBackupUpdate
 */
export interface RecoveryProjectBackupUpdate {
    /**
     * 
     * @type {string}
     * @memberof RecoveryProjectBackupUpdate
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface Registry
 */
export interface Registry {
    /**
     * 
     * @type {string}
     * @memberof Registry
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Registry
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Registry
     */
    flavour?: string;
    /**
     * 
     * @type {string}
     * @memberof Registry
     */
    modifiedOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Registry
     */
    modifiedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Registry
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Registry
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Registry
     */
    state?: RegistryStateEnum;
    /**
     * 
     * @type {string}
     * @memberof Registry
     */
    project?: string;
    /**
     * 
     * @type {string}
     * @memberof Registry
     */
    uri?: string;
    /**
     * 
     * @type {number}
     * @memberof Registry
     */
    sizeUsed?: number;
    /**
     * 
     * @type {string}
     * @memberof Registry
     */
    fqdn?: string;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof Registry
     */
    tag?: Array<Tag>;
}

/**
    * @export
    * @enum {string}
    */
export enum RegistryStateEnum {
    Running = 'Running',
    Off = 'Off',
    Unknown = 'Unknown',
    Processing = 'Processing',
    NotCreated = 'NotCreated'
}

/**
 * 
 * @export
 * @interface RegistryCredential
 */
export interface RegistryCredential {
    /**
     * 
     * @type {string}
     * @memberof RegistryCredential
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof RegistryCredential
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof RegistryCredential
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof RegistryCredential
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof RegistryCredential
     */
    type: RegistryCredentialTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof RegistryCredential
     */
    value: string;
    /**
     * 
     * @type {string}
     * @memberof RegistryCredential
     */
    fingerprint?: string;
    /**
     * 
     * @type {string}
     * @memberof RegistryCredential
     */
    token?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum RegistryCredentialTypeEnum {
    Sha512 = 'sha512',
    Plain = 'plain'
}

/**
 * 
 * @export
 * @interface Replica
 */
export interface Replica {
    /**
     * 
     * @type {string}
     * @memberof Replica
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Replica
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Replica
     */
    flavour?: string;
    /**
     * 
     * @type {string}
     * @memberof Replica
     */
    modifiedOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Replica
     */
    modifiedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Replica
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Replica
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Replica
     */
    state?: ReplicaStateEnum;
    /**
     * 
     * @type {string}
     * @memberof Replica
     */
    project?: string;
    /**
     * 
     * @type {string}
     * @memberof Replica
     */
    uri?: string;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof Replica
     */
    tag?: Array<Tag>;
}

/**
    * @export
    * @enum {string}
    */
export enum ReplicaStateEnum {
    Error = 'Error',
    FailOverWaitingCompletion = 'FailOverWaitingCompletion',
    FailedOver = 'FailedOver',
    NotApplicable = 'NotApplicable',
    ReadyForInitialReplication = 'ReadyForInitialReplication',
    Replicating = 'Replicating',
    Resynchronizing = 'Resynchronizing',
    ResynchronizeSuspended = 'ResynchronizeSuspended',
    Suspended = 'Suspended',
    SyncedReplicationComplete = 'SyncedReplicationComplete',
    WaitingForInitialReplication = 'WaitingForInitialReplication',
    WaitingForStartResynchronize = 'WaitingForStartResynchronize',
    Unknown = 'Unknown',
    Processing = 'Processing',
    NotCreated = 'NotCreated'
}

/**
 * 
 * @export
 * @interface Reservation
 */
export interface Reservation {
    /**
     * 
     * @type {string}
     * @memberof Reservation
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Reservation
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Reservation
     */
    flavour?: string;
    /**
     * 
     * @type {string}
     * @memberof Reservation
     */
    modifiedOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Reservation
     */
    modifiedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Reservation
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Reservation
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Reservation
     */
    state?: ReservationStateEnum;
    /**
     * 
     * @type {string}
     * @memberof Reservation
     */
    project?: string;
    /**
     * 
     * @type {string}
     * @memberof Reservation
     */
    uri?: string;
    /**
     * 
     * @type {string}
     * @memberof Reservation
     */
    kind?: string;
    /**
     * 
     * @type {string}
     * @memberof Reservation
     */
    assigned?: string;
    /**
     * 
     * @type {string}
     * @memberof Reservation
     */
    sourceService?: string;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof Reservation
     */
    tag?: Array<Tag>;
}

/**
    * @export
    * @enum {string}
    */
export enum ReservationStateEnum {
    Detached = 'Detached',
    Attached = 'Attached',
    Expired = 'Expired',
    Billing = 'Billing',
    Unknown = 'Unknown'
}

/**
 * 
 * @export
 * @interface ResourceConnect
 */
export interface ResourceConnect {
    /**
     * 
     * @type {string}
     * @memberof ResourceConnect
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ResourceConnect
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ResourceConnect
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof ResourceConnect
     */
    username?: string;
    /**
     * 
     * @type {string}
     * @memberof ResourceConnect
     */
    host?: string;
    /**
     * 
     * @type {string}
     * @memberof ResourceConnect
     */
    example?: string;
}
/**
 * 
 * @export
 * @interface ResourceService
 */
export interface ResourceService {
    /**
     * 
     * @type {string}
     * @memberof ResourceService
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ResourceService
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ResourceService
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof ResourceService
     */
    sourceService?: string;
    /**
     * 
     * @type {string}
     * @memberof ResourceService
     */
    billing?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ResourceService
     */
    data?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface Role
 */
export interface Role {
    /**
     * 
     * @type {string}
     * @memberof Role
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Role
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Role
     */
    flavour?: string;
    /**
     * 
     * @type {string}
     * @memberof Role
     */
    modifiedOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Role
     */
    modifiedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Role
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Role
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Role
     */
    state?: RoleStateEnum;
    /**
     * 
     * @type {string}
     * @memberof Role
     */
    project?: string;
    /**
     * 
     * @type {string}
     * @memberof Role
     */
    organisation?: string;
    /**
     * 
     * @type {string}
     * @memberof Role
     */
    uri?: string;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof Role
     */
    tag?: Array<Tag>;
}

/**
    * @export
    * @enum {string}
    */
export enum RoleStateEnum {
    Online = 'Online',
    Processing = 'Processing',
    NotCreated = 'NotCreated'
}

/**
 * 
 * @export
 * @interface Sa
 */
export interface Sa {
    /**
     * 
     * @type {string}
     * @memberof Sa
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Sa
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Sa
     */
    flavour?: string;
    /**
     * 
     * @type {string}
     * @memberof Sa
     */
    modifiedOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Sa
     */
    modifiedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Sa
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Sa
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Sa
     */
    state?: SaStateEnum;
    /**
     * 
     * @type {string}
     * @memberof Sa
     */
    project?: string;
    /**
     * 
     * @type {string}
     * @memberof Sa
     */
    uri?: string;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof Sa
     */
    tag?: Array<Tag>;
}

/**
    * @export
    * @enum {string}
    */
export enum SaStateEnum {
    Online = 'Online',
    Processing = 'Processing',
    NotCreated = 'NotCreated'
}

/**
 * 
 * @export
 * @interface SaCredential
 */
export interface SaCredential {
    /**
     * 
     * @type {string}
     * @memberof SaCredential
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof SaCredential
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof SaCredential
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof SaCredential
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof SaCredential
     */
    type: SaCredentialTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof SaCredential
     */
    value: string;
    /**
     * 
     * @type {string}
     * @memberof SaCredential
     */
    fingerprint?: string;
    /**
     * 
     * @type {string}
     * @memberof SaCredential
     */
    token?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum SaCredentialTypeEnum {
    Ssh = 'ssh'
}

/**
 * 
 * @export
 * @interface Service
 */
export interface Service {
    /**
     * 
     * @type {string}
     * @memberof Service
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Service
     */
    resource?: string;
    /**
     * 
     * @type {string}
     * @memberof Service
     */
    type?: string;
    /**
     * 
     * @type {ServiceBilling}
     * @memberof Service
     */
    billing?: ServiceBilling;
    /**
     * 
     * @type {ServiceDisplay}
     * @memberof Service
     */
    display?: ServiceDisplay;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof Service
     */
    data?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof Service
     */
    name?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Service
     */
    availableServices?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Service
     */
    uri?: string;
}
/**
 * 
 * @export
 * @interface ServiceBilling
 */
export interface ServiceBilling {
    /**
     * 
     * @type {ServiceBillingPrice}
     * @memberof ServiceBilling
     */
    price?: ServiceBillingPrice;
    /**
     * 
     * @type {string}
     * @memberof ServiceBilling
     */
    period?: string;
    /**
     * 
     * @type {number}
     * @memberof ServiceBilling
     */
    quantity?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ServiceBilling
     */
    oneTime?: boolean;
    /**
     * 
     * @type {ServiceBillingReservations}
     * @memberof ServiceBilling
     */
    reservations?: ServiceBillingReservations;
}
/**
 * 
 * @export
 * @interface ServiceBillingPrice
 */
export interface ServiceBillingPrice {
    /**
     * 
     * @type {number}
     * @memberof ServiceBillingPrice
     */
    PLN?: number;
    /**
     * 
     * @type {number}
     * @memberof ServiceBillingPrice
     */
    EUR?: number;
    /**
     * 
     * @type {number}
     * @memberof ServiceBillingPrice
     */
    USD?: number;
    /**
     * 
     * @type {number}
     * @memberof ServiceBillingPrice
     */
    GBP?: number;
}
/**
 * 
 * @export
 * @interface ServiceBillingReservations
 */
export interface ServiceBillingReservations {
    /**
     * 
     * @type {string}
     * @memberof ServiceBillingReservations
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceBillingReservations
     */
    period?: string;
    /**
     * 
     * @type {ServiceBillingPrice}
     * @memberof ServiceBillingReservations
     */
    price?: ServiceBillingPrice;
    /**
     * 
     * @type {ServiceBillingPrice}
     * @memberof ServiceBillingReservations
     */
    resourcePrice?: ServiceBillingPrice;
}
/**
 * 
 * @export
 * @interface ServiceDisplay
 */
export interface ServiceDisplay {
    /**
     * 
     * @type {ServiceDisplayUnit}
     * @memberof ServiceDisplay
     */
    unit?: ServiceDisplayUnit;
}
/**
 * 
 * @export
 * @interface ServiceDisplayUnit
 */
export interface ServiceDisplayUnit {
    /**
     * 
     * @type {string}
     * @memberof ServiceDisplayUnit
     */
    usage?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceDisplayUnit
     */
    billing?: string;
}
/**
 * 
 * @export
 * @interface StorageObject
 */
export interface StorageObject {
    /**
     * 
     * @type {string}
     * @memberof StorageObject
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof StorageObject
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof StorageObject
     */
    size?: number;
    /**
     * 
     * @type {string}
     * @memberof StorageObject
     */
    createdOn?: string;
}
/**
 * 
 * @export
 * @interface StorageProjectBucketUpload
 */
export interface StorageProjectBucketUpload {
    /**
     * 
     * @type {string}
     * @memberof StorageProjectBucketUpload
     */
    name: string;
}
/**
 * 
 * @export
 * @interface StorageProjectDiskCreate
 */
export interface StorageProjectDiskCreate {
    /**
     * 
     * @type {string}
     * @memberof StorageProjectDiskCreate
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof StorageProjectDiskCreate
     */
    service: string;
    /**
     * 
     * @type {number}
     * @memberof StorageProjectDiskCreate
     */
    size: number;
    /**
     * 
     * @type {any}
     * @memberof StorageProjectDiskCreate
     */
    source?: any;
    /**
     * 
     * @type {string}
     * @memberof StorageProjectDiskCreate
     */
    vm?: string;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof StorageProjectDiskCreate
     */
    tag?: Array<Tag>;
}
/**
 * 
 * @export
 * @interface StorageProjectDiskResize
 */
export interface StorageProjectDiskResize {
    /**
     * 
     * @type {number}
     * @memberof StorageProjectDiskResize
     */
    size: number;
}
/**
 * 
 * @export
 * @interface StorageProjectDiskTransfer
 */
export interface StorageProjectDiskTransfer {
    /**
     * 
     * @type {string}
     * @memberof StorageProjectDiskTransfer
     */
    project: string;
}
/**
 * 
 * @export
 * @interface StorageProjectDiskUpdate
 */
export interface StorageProjectDiskUpdate {
    /**
     * 
     * @type {string}
     * @memberof StorageProjectDiskUpdate
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface StorageProjectImageCreate
 */
export interface StorageProjectImageCreate {
    /**
     * 
     * @type {string}
     * @memberof StorageProjectImageCreate
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof StorageProjectImageCreate
     */
    service?: string;
    /**
     * 
     * @type {string}
     * @memberof StorageProjectImageCreate
     */
    vm?: string;
    /**
     * 
     * @type {string}
     * @memberof StorageProjectImageCreate
     */
    replica?: string;
    /**
     * 
     * @type {string}
     * @memberof StorageProjectImageCreate
     */
    description?: string;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof StorageProjectImageCreate
     */
    tag?: Array<Tag>;
}
/**
 * 
 * @export
 * @interface StorageProjectImageTransfer
 */
export interface StorageProjectImageTransfer {
    /**
     * 
     * @type {string}
     * @memberof StorageProjectImageTransfer
     */
    project: string;
}
/**
 * 
 * @export
 * @interface StorageProjectImageUpdate
 */
export interface StorageProjectImageUpdate {
    /**
     * 
     * @type {string}
     * @memberof StorageProjectImageUpdate
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof StorageProjectImageUpdate
     */
    description?: string;
}
/**
 * 
 * @export
 * @interface StorageProjectIsoCreate
 */
export interface StorageProjectIsoCreate {
    /**
     * 
     * @type {string}
     * @memberof StorageProjectIsoCreate
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof StorageProjectIsoCreate
     */
    source: string;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof StorageProjectIsoCreate
     */
    tag?: Array<Tag>;
}
/**
 * 
 * @export
 * @interface StorageProjectIsoDetach
 */
export interface StorageProjectIsoDetach {
    /**
     * 
     * @type {string}
     * @memberof StorageProjectIsoDetach
     */
    vm: string;
}
/**
 * 
 * @export
 * @interface StorageProjectIsoTransfer
 */
export interface StorageProjectIsoTransfer {
    /**
     * 
     * @type {string}
     * @memberof StorageProjectIsoTransfer
     */
    project: string;
}
/**
 * 
 * @export
 * @interface StorageProjectIsoUpdate
 */
export interface StorageProjectIsoUpdate {
    /**
     * 
     * @type {string}
     * @memberof StorageProjectIsoUpdate
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface StorageProjectVaultCreate
 */
export interface StorageProjectVaultCreate {
    /**
     * 
     * @type {string}
     * @memberof StorageProjectVaultCreate
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof StorageProjectVaultCreate
     */
    service?: string;
    /**
     * 
     * @type {number}
     * @memberof StorageProjectVaultCreate
     */
    size: number;
    /**
     * 
     * @type {string}
     * @memberof StorageProjectVaultCreate
     */
    source?: string;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof StorageProjectVaultCreate
     */
    tag?: Array<Tag>;
}
/**
 * 
 * @export
 * @interface StorageProjectVaultCredentialPatch
 */
export interface StorageProjectVaultCredentialPatch {
    /**
     * 
     * @type {string}
     * @memberof StorageProjectVaultCredentialPatch
     */
    name: string;
}
/**
 * 
 * @export
 * @interface StorageProjectVaultDelete
 */
export interface StorageProjectVaultDelete {
    /**
     * 
     * @type {boolean}
     * @memberof StorageProjectVaultDelete
     */
    removeAllSnapshots?: boolean;
}
/**
 * 
 * @export
 * @interface StorageProjectVaultResize
 */
export interface StorageProjectVaultResize {
    /**
     * 
     * @type {number}
     * @memberof StorageProjectVaultResize
     */
    size: number;
}
/**
 * 
 * @export
 * @interface StorageProjectVaultSnapshotCreate
 */
export interface StorageProjectVaultSnapshotCreate {
    /**
     * 
     * @type {string}
     * @memberof StorageProjectVaultSnapshotCreate
     */
    name: string;
}
/**
 * 
 * @export
 * @interface StorageProjectVaultUpdate
 */
export interface StorageProjectVaultUpdate {
    /**
     * 
     * @type {string}
     * @memberof StorageProjectVaultUpdate
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface StorageS3credential
 */
export interface StorageS3credential {
    /**
     * 
     * @type {string}
     * @memberof StorageS3credential
     */
    accessKeyId?: string;
    /**
     * 
     * @type {string}
     * @memberof StorageS3credential
     */
    sessionToken?: string;
    /**
     * 
     * @type {string}
     * @memberof StorageS3credential
     */
    secretAccessKey?: string;
    /**
     * 
     * @type {string}
     * @memberof StorageS3credential
     */
    endpoint?: string;
    /**
     * 
     * @type {string}
     * @memberof StorageS3credential
     */
    region?: string;
    /**
     * 
     * @type {string}
     * @memberof StorageS3credential
     */
    location?: string;
    /**
     * 
     * @type {string}
     * @memberof StorageS3credential
     */
    bucket?: string;
    /**
     * 
     * @type {string}
     * @memberof StorageS3credential
     */
    key?: string;
}
/**
 * 
 * @export
 * @interface StorageSnapshot
 */
export interface StorageSnapshot {
    /**
     * 
     * @type {string}
     * @memberof StorageSnapshot
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof StorageSnapshot
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof StorageSnapshot
     */
    flavour?: string;
    /**
     * 
     * @type {string}
     * @memberof StorageSnapshot
     */
    modifiedOn?: string;
    /**
     * 
     * @type {string}
     * @memberof StorageSnapshot
     */
    modifiedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof StorageSnapshot
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof StorageSnapshot
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof StorageSnapshot
     */
    state?: string;
    /**
     * 
     * @type {string}
     * @memberof StorageSnapshot
     */
    project?: string;
    /**
     * 
     * @type {string}
     * @memberof StorageSnapshot
     */
    organisation?: string;
    /**
     * 
     * @type {string}
     * @memberof StorageSnapshot
     */
    uri?: string;
    /**
     * 
     * @type {number}
     * @memberof StorageSnapshot
     */
    sizeUsed?: number;
}
/**
 * 
 * @export
 * @interface SupportMessage
 */
export interface SupportMessage {
    /**
     * 
     * @type {string}
     * @memberof SupportMessage
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof SupportMessage
     */
    type: SupportMessageTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof SupportMessage
     */
    user?: string;
    /**
     * 
     * @type {MessageData}
     * @memberof SupportMessage
     */
    data?: MessageData;
    /**
     * 
     * @type {string}
     * @memberof SupportMessage
     */
    origin?: string;
    /**
     * 
     * @type {string}
     * @memberof SupportMessage
     */
    date?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum SupportMessageTypeEnum {
    Text = 'text',
    Attachment = 'attachment'
}

/**
 * 
 * @export
 * @interface SupportProjectTicketCreate
 */
export interface SupportProjectTicketCreate {
    /**
     * 
     * @type {string}
     * @memberof SupportProjectTicketCreate
     */
    type: SupportProjectTicketCreateTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof SupportProjectTicketCreate
     */
    subject: string;
    /**
     * 
     * @type {string}
     * @memberof SupportProjectTicketCreate
     */
    message: string;
}

/**
    * @export
    * @enum {string}
    */
export enum SupportProjectTicketCreateTypeEnum {
    Sales = 'sales',
    Billing = 'billing',
    ServiceSupport = 'service support'
}

/**
 * 
 * @export
 * @interface Tag
 */
export interface Tag {
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    key: string;
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    value: string;
}
/**
 * 
 * @export
 * @interface Ticket
 */
export interface Ticket {
    /**
     * 
     * @type {string}
     * @memberof Ticket
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Ticket
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof Ticket
     */
    state?: TicketStateEnum;
    /**
     * 
     * @type {string}
     * @memberof Ticket
     */
    subject?: string;
    /**
     * 
     * @type {string}
     * @memberof Ticket
     */
    project?: string;
    /**
     * 
     * @type {string}
     * @memberof Ticket
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Ticket
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Ticket
     */
    modifiedOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Ticket
     */
    modifiedBy?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum TicketStateEnum {
    Open = 'open',
    Closed = 'closed'
}

/**
 * 
 * @export
 * @interface Transfer
 */
export interface Transfer {
    /**
     * 
     * @type {string}
     * @memberof Transfer
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Transfer
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Transfer
     */
    state?: string;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    firstName?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    familyName?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    modifiedOn?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    lang?: UserLangEnum;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    phone?: string;
    /**
     * 
     * @type {UserLimit}
     * @memberof User
     */
    limit?: UserLimit;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    uri?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum UserLangEnum {
    En = 'en',
    Pl = 'pl'
}

/**
 * 
 * @export
 * @interface UserCredential
 */
export interface UserCredential {
    /**
     * 
     * @type {string}
     * @memberof UserCredential
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof UserCredential
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof UserCredential
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof UserCredential
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof UserCredential
     */
    type: UserCredentialTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof UserCredential
     */
    value: string;
    /**
     * 
     * @type {string}
     * @memberof UserCredential
     */
    fingerprint?: string;
    /**
     * 
     * @type {string}
     * @memberof UserCredential
     */
    token?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum UserCredentialTypeEnum {
    Ssh = 'ssh',
    Sha512 = 'sha512',
    Totp = 'totp',
    Otac = 'otac',
    Plain = 'plain'
}

/**
 * 
 * @export
 * @interface UserLimit
 */
export interface UserLimit {
    /**
     * 
     * @type {UserLimitOrganisation}
     * @memberof UserLimit
     */
    organisation?: UserLimitOrganisation;
}
/**
 * 
 * @export
 * @interface UserLimitOrganisation
 */
export interface UserLimitOrganisation {
    /**
     * 
     * @type {number}
     * @memberof UserLimitOrganisation
     */
    count: number;
}
/**
 * 
 * @export
 * @interface Vault
 */
export interface Vault {
    /**
     * 
     * @type {string}
     * @memberof Vault
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Vault
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Vault
     */
    flavour?: string;
    /**
     * 
     * @type {string}
     * @memberof Vault
     */
    modifiedOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Vault
     */
    modifiedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Vault
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Vault
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Vault
     */
    state?: VaultStateEnum;
    /**
     * 
     * @type {string}
     * @memberof Vault
     */
    project?: string;
    /**
     * 
     * @type {string}
     * @memberof Vault
     */
    uri?: string;
    /**
     * 
     * @type {number}
     * @memberof Vault
     */
    sizeUsed?: number;
    /**
     * 
     * @type {number}
     * @memberof Vault
     */
    size?: number;
    /**
     * 
     * @type {string}
     * @memberof Vault
     */
    fqdn?: string;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof Vault
     */
    tag?: Array<Tag>;
}

/**
    * @export
    * @enum {string}
    */
export enum VaultStateEnum {
    Online = 'Online',
    Off = 'Off',
    Unknown = 'Unknown',
    Processing = 'Processing',
    NotCreated = 'NotCreated'
}

/**
 * 
 * @export
 * @interface VaultCredential
 */
export interface VaultCredential {
    /**
     * 
     * @type {string}
     * @memberof VaultCredential
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof VaultCredential
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof VaultCredential
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof VaultCredential
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof VaultCredential
     */
    type: VaultCredentialTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof VaultCredential
     */
    value: string;
    /**
     * 
     * @type {string}
     * @memberof VaultCredential
     */
    fingerprint?: string;
    /**
     * 
     * @type {string}
     * @memberof VaultCredential
     */
    token?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum VaultCredentialTypeEnum {
    Ssh = 'ssh',
    Sha512 = 'sha512',
    Plain = 'plain'
}

/**
 * 
 * @export
 * @interface Vm
 */
export interface Vm {
    /**
     * 
     * @type {string}
     * @memberof Vm
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Vm
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Vm
     */
    flavour?: string;
    /**
     * 
     * @type {string}
     * @memberof Vm
     */
    modifiedOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Vm
     */
    modifiedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Vm
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Vm
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Vm
     */
    state?: VmStateEnum;
    /**
     * 
     * @type {string}
     * @memberof Vm
     */
    project?: string;
    /**
     * 
     * @type {string}
     * @memberof Vm
     */
    uri?: string;
    /**
     * 
     * @type {string}
     * @memberof Vm
     */
    userMetadata?: string;
    /**
     * 
     * @type {number}
     * @memberof Vm
     */
    cpu?: number;
    /**
     * 
     * @type {number}
     * @memberof Vm
     */
    memory?: number;
    /**
     * 
     * @type {string}
     * @memberof Vm
     */
    fqdn?: string;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof Vm
     */
    tag?: Array<Tag>;
}

/**
    * @export
    * @enum {string}
    */
export enum VmStateEnum {
    Other = 'Other',
    Running = 'Running',
    Off = 'Off',
    Stopping = 'Stopping',
    Saved = 'Saved',
    Paused = 'Paused',
    Starting = 'Starting',
    Reset = 'Reset',
    Saving = 'Saving',
    Pausing = 'Pausing',
    Resuming = 'Resuming',
    FastSaved = 'FastSaved',
    FastSaving = 'FastSaving',
    RunningCritical = 'RunningCritical',
    OffCritical = 'OffCritical',
    StoppingCritical = 'StoppingCritical',
    SavedCritical = 'SavedCritical',
    PausedCritical = 'PausedCritical',
    StartingCritical = 'StartingCritical',
    ResetCritical = 'ResetCritical',
    SavingCritical = 'SavingCritical',
    PausingCritical = 'PausingCritical',
    ResumingCritical = 'ResumingCritical',
    FastSavedCritical = 'FastSavedCritical',
    FastSavingCritical = 'FastSavingCritical',
    Unknown = 'Unknown',
    Processing = 'Processing',
    NotCreated = 'NotCreated'
}

/**
 * 
 * @export
 * @interface Vmhost
 */
export interface Vmhost {
    /**
     * 
     * @type {string}
     * @memberof Vmhost
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Vmhost
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Vmhost
     */
    flavour?: string;
    /**
     * 
     * @type {string}
     * @memberof Vmhost
     */
    modifiedOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Vmhost
     */
    modifiedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Vmhost
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Vmhost
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Vmhost
     */
    state?: VmhostStateEnum;
    /**
     * 
     * @type {string}
     * @memberof Vmhost
     */
    project?: string;
    /**
     * 
     * @type {string}
     * @memberof Vmhost
     */
    uri?: string;
    /**
     * 
     * @type {string}
     * @memberof Vmhost
     */
    type?: VmhostTypeEnum;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof Vmhost
     */
    tag?: Array<Tag>;
}

/**
    * @export
    * @enum {string}
    */
export enum VmhostStateEnum {
    Running = 'Running',
    Unknown = 'Unknown',
    Processing = 'Processing',
    NotCreated = 'NotCreated'
}
/**
    * @export
    * @enum {string}
    */
export enum VmhostTypeEnum {
    Compute = 'compute',
    Network = 'network',
    Vault = 'vault',
    Container = 'container'
}

/**
 * 
 * @export
 * @interface Website
 */
export interface Website {
    /**
     * 
     * @type {string}
     * @memberof Website
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Website
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Website
     */
    flavour?: string;
    /**
     * 
     * @type {string}
     * @memberof Website
     */
    modifiedOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Website
     */
    modifiedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Website
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Website
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Website
     */
    state?: WebsiteStateEnum;
    /**
     * 
     * @type {string}
     * @memberof Website
     */
    project?: string;
    /**
     * 
     * @type {string}
     * @memberof Website
     */
    uri?: string;
    /**
     * 
     * @type {string}
     * @memberof Website
     */
    image?: string;
    /**
     * 
     * @type {string}
     * @memberof Website
     */
    fqdn?: string;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof Website
     */
    tag?: Array<Tag>;
}

/**
    * @export
    * @enum {string}
    */
export enum WebsiteStateEnum {
    Running = 'Running',
    Restarting = 'Restarting',
    Off = 'Off',
    Unknown = 'Unknown',
    Processing = 'Processing',
    NotCreated = 'NotCreated'
}

/**
 * 
 * @export
 * @interface WebsiteCredential
 */
export interface WebsiteCredential {
    /**
     * 
     * @type {string}
     * @memberof WebsiteCredential
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof WebsiteCredential
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof WebsiteCredential
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof WebsiteCredential
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof WebsiteCredential
     */
    type: WebsiteCredentialTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof WebsiteCredential
     */
    value: string;
    /**
     * 
     * @type {string}
     * @memberof WebsiteCredential
     */
    fingerprint?: string;
    /**
     * 
     * @type {string}
     * @memberof WebsiteCredential
     */
    token?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum WebsiteCredentialTypeEnum {
    Ssh = 'ssh',
    Sha512 = 'sha512',
    Plain = 'plain'
}

/**
 * 
 * @export
 * @interface WebsiteEnv
 */
export interface WebsiteEnv {
    /**
     * 
     * @type {string}
     * @memberof WebsiteEnv
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof WebsiteEnv
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof WebsiteEnv
     */
    value: string;
}
/**
 * 
 * @export
 * @interface WebsiteLink
 */
export interface WebsiteLink {
    /**
     * 
     * @type {string}
     * @memberof WebsiteLink
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof WebsiteLink
     */
    actor: string;
    /**
     * 
     * @type {string}
     * @memberof WebsiteLink
     */
    purpose: WebsiteLinkPurposeEnum;
    /**
     * 
     * @type {string}
     * @memberof WebsiteLink
     */
    resource: string;
}

/**
    * @export
    * @enum {string}
    */
export enum WebsiteLinkPurposeEnum {
    Logs = 'logs'
}

/**
 * 
 * @export
 * @interface WebsiteProjectInstanceCreate
 */
export interface WebsiteProjectInstanceCreate {
    /**
     * 
     * @type {string}
     * @memberof WebsiteProjectInstanceCreate
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof WebsiteProjectInstanceCreate
     */
    service: string;
    /**
     * 
     * @type {string}
     * @memberof WebsiteProjectInstanceCreate
     */
    image: string;
    /**
     * 
     * @type {any}
     * @memberof WebsiteProjectInstanceCreate
     */
    source?: any;
    /**
     * 
     * @type {Array<WebsiteEnv>}
     * @memberof WebsiteProjectInstanceCreate
     */
    env?: Array<WebsiteEnv>;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof WebsiteProjectInstanceCreate
     */
    tag?: Array<Tag>;
}
/**
 * 
 * @export
 * @interface WebsiteProjectInstanceCredentialPatch
 */
export interface WebsiteProjectInstanceCredentialPatch {
    /**
     * 
     * @type {string}
     * @memberof WebsiteProjectInstanceCredentialPatch
     */
    name: string;
}
/**
 * 
 * @export
 * @interface WebsiteProjectInstanceSnapshotDownload
 */
export interface WebsiteProjectInstanceSnapshotDownload {
    /**
     * 
     * @type {string}
     * @memberof WebsiteProjectInstanceSnapshotDownload
     */
    incremental?: string;
}
/**
 * 
 * @export
 * @interface WebsiteProjectInstanceTransfer
 */
export interface WebsiteProjectInstanceTransfer {
    /**
     * 
     * @type {string}
     * @memberof WebsiteProjectInstanceTransfer
     */
    project: string;
}
/**
 * 
 * @export
 * @interface WebsiteProjectInstanceUpdate
 */
export interface WebsiteProjectInstanceUpdate {
    /**
     * 
     * @type {string}
     * @memberof WebsiteProjectInstanceUpdate
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof WebsiteProjectInstanceUpdate
     */
    image?: string;
}
/**
 * 
 * @export
 * @interface WebsiteSideapp
 */
export interface WebsiteSideapp {
    /**
     * 
     * @type {string}
     * @memberof WebsiteSideapp
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof WebsiteSideapp
     */
    flavour: string;
    /**
     * Only available on the creation response
     * @type {string}
     * @memberof WebsiteSideapp
     */
    url?: string;
}
/**
 * 
 * @export
 * @interface WebsiteSnapshot
 */
export interface WebsiteSnapshot {
    /**
     * 
     * @type {string}
     * @memberof WebsiteSnapshot
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof WebsiteSnapshot
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof WebsiteSnapshot
     */
    creation?: string;
    /**
     * 
     * @type {number}
     * @memberof WebsiteSnapshot
     */
    used?: number;
}
/**
 * 
 * @export
 * @interface Zone
 */
export interface Zone {
    /**
     * 
     * @type {string}
     * @memberof Zone
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Zone
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Zone
     */
    flavour?: string;
    /**
     * 
     * @type {string}
     * @memberof Zone
     */
    modifiedOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Zone
     */
    modifiedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Zone
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Zone
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Zone
     */
    state?: ZoneStateEnum;
    /**
     * 
     * @type {string}
     * @memberof Zone
     */
    project?: string;
    /**
     * 
     * @type {string}
     * @memberof Zone
     */
    uri?: string;
    /**
     * 
     * @type {Array<ZoneRrsets>}
     * @memberof Zone
     */
    rrsets?: Array<ZoneRrsets>;
    /**
     * 
     * @type {string}
     * @memberof Zone
     */
    dnsName?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Zone
     */
    nameserver?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Zone
     */
    fqdn?: string;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof Zone
     */
    tag?: Array<Tag>;
}

/**
    * @export
    * @enum {string}
    */
export enum ZoneStateEnum {
    Online = 'Online',
    Offline = 'Offline',
    Unknown = 'Unknown',
    Processing = 'Processing',
    NotCreated = 'NotCreated'
}

/**
 * 
 * @export
 * @interface ZoneRrsets
 */
export interface ZoneRrsets {
    /**
     * 
     * @type {string}
     * @memberof ZoneRrsets
     */
    records?: string;
    /**
     * 
     * @type {string}
     * @memberof ZoneRrsets
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ZoneRrsets
     */
    type?: string;
    /**
     * 
     * @type {number}
     * @memberof ZoneRrsets
     */
    ttl?: number;
}
/**
 * 
 * @export
 * @interface ZoneSource
 */
export interface ZoneSource {
    /**
     * 
     * @type {boolean}
     * @memberof ZoneSource
     */
    dnsProbing?: boolean;
}

/**
 * BillingProjectReservationApi - axios parameter creator
 * @export
 */
export const BillingProjectReservationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * action assign
         * @summary Assign billing/reservation
         * @param {string} projectId Project Id
         * @param {string} reservationId Reservation Id
         * @param {BillingProjectReservationAssign} billingProjectReservationAssign 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingProjectReservationAssign: async (projectId: string, reservationId: string, billingProjectReservationAssign: BillingProjectReservationAssign, xIdempotencyKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling billingProjectReservationAssign.');
            }
            // verify required parameter 'reservationId' is not null or undefined
            if (reservationId === null || reservationId === undefined) {
                throw new RequiredError('reservationId','Required parameter reservationId was null or undefined when calling billingProjectReservationAssign.');
            }
            // verify required parameter 'billingProjectReservationAssign' is not null or undefined
            if (billingProjectReservationAssign === null || billingProjectReservationAssign === undefined) {
                throw new RequiredError('billingProjectReservationAssign','Required parameter billingProjectReservationAssign was null or undefined when calling billingProjectReservationAssign.');
            }
            const localVarPath = `/billing/project/{projectId}/reservation/{reservationId}/actions/assign`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"reservationId"}}`, encodeURIComponent(String(reservationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof billingProjectReservationAssign !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(billingProjectReservationAssign !== undefined ? billingProjectReservationAssign : {}) : (billingProjectReservationAssign || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create reservation
         * @summary Create billing/reservation
         * @param {string} projectId Project Id
         * @param {BillingProjectReservationCreate} billingProjectReservationCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingProjectReservationCreate: async (projectId: string, billingProjectReservationCreate: BillingProjectReservationCreate, xIdempotencyKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling billingProjectReservationCreate.');
            }
            // verify required parameter 'billingProjectReservationCreate' is not null or undefined
            if (billingProjectReservationCreate === null || billingProjectReservationCreate === undefined) {
                throw new RequiredError('billingProjectReservationCreate','Required parameter billingProjectReservationCreate was null or undefined when calling billingProjectReservationCreate.');
            }
            const localVarPath = `/billing/project/{projectId}/reservation`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof billingProjectReservationCreate !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(billingProjectReservationCreate !== undefined ? billingProjectReservationCreate : {}) : (billingProjectReservationCreate || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete reservation
         * @summary Delete billing/reservation
         * @param {string} projectId Project Id
         * @param {string} reservationId Reservation Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingProjectReservationDelete: async (projectId: string, reservationId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling billingProjectReservationDelete.');
            }
            // verify required parameter 'reservationId' is not null or undefined
            if (reservationId === null || reservationId === undefined) {
                throw new RequiredError('reservationId','Required parameter reservationId was null or undefined when calling billingProjectReservationDelete.');
            }
            const localVarPath = `/billing/project/{projectId}/reservation/{reservationId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"reservationId"}}`, encodeURIComponent(String(reservationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get billing/reservation.event
         * @summary Get billing/reservation.event
         * @param {string} projectId Project Id
         * @param {string} reservationId Reservation Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingProjectReservationEventGet: async (projectId: string, reservationId: string, eventId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling billingProjectReservationEventGet.');
            }
            // verify required parameter 'reservationId' is not null or undefined
            if (reservationId === null || reservationId === undefined) {
                throw new RequiredError('reservationId','Required parameter reservationId was null or undefined when calling billingProjectReservationEventGet.');
            }
            // verify required parameter 'eventId' is not null or undefined
            if (eventId === null || eventId === undefined) {
                throw new RequiredError('eventId','Required parameter eventId was null or undefined when calling billingProjectReservationEventGet.');
            }
            const localVarPath = `/billing/project/{projectId}/reservation/{reservationId}/event/{eventId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"reservationId"}}`, encodeURIComponent(String(reservationId)))
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List billing/reservation.event
         * @summary List billing/reservation.event
         * @param {string} projectId Project Id
         * @param {string} reservationId Reservation Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingProjectReservationEventList: async (projectId: string, reservationId: string, $limit?: number, $skip?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling billingProjectReservationEventList.');
            }
            // verify required parameter 'reservationId' is not null or undefined
            if (reservationId === null || reservationId === undefined) {
                throw new RequiredError('reservationId','Required parameter reservationId was null or undefined when calling billingProjectReservationEventList.');
            }
            const localVarPath = `/billing/project/{projectId}/reservation/{reservationId}/event`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"reservationId"}}`, encodeURIComponent(String(reservationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if ($limit !== undefined) {
                localVarQueryParameter['$limit'] = $limit;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * action extend
         * @summary Extend billing/reservation
         * @param {string} projectId Project Id
         * @param {string} reservationId Reservation Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingProjectReservationExtend: async (projectId: string, reservationId: string, xIdempotencyKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling billingProjectReservationExtend.');
            }
            // verify required parameter 'reservationId' is not null or undefined
            if (reservationId === null || reservationId === undefined) {
                throw new RequiredError('reservationId','Required parameter reservationId was null or undefined when calling billingProjectReservationExtend.');
            }
            const localVarPath = `/billing/project/{projectId}/reservation/{reservationId}/actions/extend`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"reservationId"}}`, encodeURIComponent(String(reservationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single reservation
         * @summary Get billing/reservation
         * @param {string} projectId Project Id
         * @param {string} reservationId Reservation Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingProjectReservationGet: async (projectId: string, reservationId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling billingProjectReservationGet.');
            }
            // verify required parameter 'reservationId' is not null or undefined
            if (reservationId === null || reservationId === undefined) {
                throw new RequiredError('reservationId','Required parameter reservationId was null or undefined when calling billingProjectReservationGet.');
            }
            const localVarPath = `/billing/project/{projectId}/reservation/{reservationId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"reservationId"}}`, encodeURIComponent(String(reservationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List reservation
         * @summary List billing/reservation
         * @param {string} projectId Project Id
         * @param {string} [name] Filter by name
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingProjectReservationList: async (projectId: string, name?: string, tagValue?: string, tagKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling billingProjectReservationList.');
            }
            const localVarPath = `/billing/project/{projectId}/reservation`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (tagValue !== undefined) {
                localVarQueryParameter['tag.value'] = tagValue;
            }

            if (tagKey !== undefined) {
                localVarQueryParameter['tag.key'] = tagKey;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get billing/reservation.service
         * @summary Get billing/reservation.service
         * @param {string} projectId Project Id
         * @param {string} reservationId Reservation Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingProjectReservationServiceGet: async (projectId: string, reservationId: string, serviceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling billingProjectReservationServiceGet.');
            }
            // verify required parameter 'reservationId' is not null or undefined
            if (reservationId === null || reservationId === undefined) {
                throw new RequiredError('reservationId','Required parameter reservationId was null or undefined when calling billingProjectReservationServiceGet.');
            }
            // verify required parameter 'serviceId' is not null or undefined
            if (serviceId === null || serviceId === undefined) {
                throw new RequiredError('serviceId','Required parameter serviceId was null or undefined when calling billingProjectReservationServiceGet.');
            }
            const localVarPath = `/billing/project/{projectId}/reservation/{reservationId}/service/{serviceId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"reservationId"}}`, encodeURIComponent(String(reservationId)))
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List billing/reservation.service
         * @summary List billing/reservation.service
         * @param {string} projectId Project Id
         * @param {string} reservationId Reservation Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingProjectReservationServiceList: async (projectId: string, reservationId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling billingProjectReservationServiceList.');
            }
            // verify required parameter 'reservationId' is not null or undefined
            if (reservationId === null || reservationId === undefined) {
                throw new RequiredError('reservationId','Required parameter reservationId was null or undefined when calling billingProjectReservationServiceList.');
            }
            const localVarPath = `/billing/project/{projectId}/reservation/{reservationId}/service`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"reservationId"}}`, encodeURIComponent(String(reservationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create billing/reservation.tag
         * @summary Create billing/reservation.tag
         * @param {string} projectId Project Id
         * @param {string} reservationId Reservation Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingProjectReservationTagCreate: async (projectId: string, reservationId: string, tag: Tag, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling billingProjectReservationTagCreate.');
            }
            // verify required parameter 'reservationId' is not null or undefined
            if (reservationId === null || reservationId === undefined) {
                throw new RequiredError('reservationId','Required parameter reservationId was null or undefined when calling billingProjectReservationTagCreate.');
            }
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling billingProjectReservationTagCreate.');
            }
            const localVarPath = `/billing/project/{projectId}/reservation/{reservationId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"reservationId"}}`, encodeURIComponent(String(reservationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof tag !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(tag !== undefined ? tag : {}) : (tag || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete billing/reservation.tag
         * @summary Delete billing/reservation.tag
         * @param {string} projectId Project Id
         * @param {string} reservationId Reservation Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingProjectReservationTagDelete: async (projectId: string, reservationId: string, tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling billingProjectReservationTagDelete.');
            }
            // verify required parameter 'reservationId' is not null or undefined
            if (reservationId === null || reservationId === undefined) {
                throw new RequiredError('reservationId','Required parameter reservationId was null or undefined when calling billingProjectReservationTagDelete.');
            }
            // verify required parameter 'tagId' is not null or undefined
            if (tagId === null || tagId === undefined) {
                throw new RequiredError('tagId','Required parameter tagId was null or undefined when calling billingProjectReservationTagDelete.');
            }
            const localVarPath = `/billing/project/{projectId}/reservation/{reservationId}/tag/{tagId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"reservationId"}}`, encodeURIComponent(String(reservationId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get billing/reservation.tag
         * @summary Get billing/reservation.tag
         * @param {string} projectId Project Id
         * @param {string} reservationId Reservation Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingProjectReservationTagGet: async (projectId: string, reservationId: string, tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling billingProjectReservationTagGet.');
            }
            // verify required parameter 'reservationId' is not null or undefined
            if (reservationId === null || reservationId === undefined) {
                throw new RequiredError('reservationId','Required parameter reservationId was null or undefined when calling billingProjectReservationTagGet.');
            }
            // verify required parameter 'tagId' is not null or undefined
            if (tagId === null || tagId === undefined) {
                throw new RequiredError('tagId','Required parameter tagId was null or undefined when calling billingProjectReservationTagGet.');
            }
            const localVarPath = `/billing/project/{projectId}/reservation/{reservationId}/tag/{tagId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"reservationId"}}`, encodeURIComponent(String(reservationId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List billing/reservation.tag
         * @summary List billing/reservation.tag
         * @param {string} projectId Project Id
         * @param {string} reservationId Reservation Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingProjectReservationTagList: async (projectId: string, reservationId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling billingProjectReservationTagList.');
            }
            // verify required parameter 'reservationId' is not null or undefined
            if (reservationId === null || reservationId === undefined) {
                throw new RequiredError('reservationId','Required parameter reservationId was null or undefined when calling billingProjectReservationTagList.');
            }
            const localVarPath = `/billing/project/{projectId}/reservation/{reservationId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"reservationId"}}`, encodeURIComponent(String(reservationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replace billing/reservation.tag
         * @summary Replace billing/reservation.tag
         * @param {string} projectId Project Id
         * @param {string} reservationId Reservation Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingProjectReservationTagPut: async (projectId: string, reservationId: string, tag: Array<Tag>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling billingProjectReservationTagPut.');
            }
            // verify required parameter 'reservationId' is not null or undefined
            if (reservationId === null || reservationId === undefined) {
                throw new RequiredError('reservationId','Required parameter reservationId was null or undefined when calling billingProjectReservationTagPut.');
            }
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling billingProjectReservationTagPut.');
            }
            const localVarPath = `/billing/project/{projectId}/reservation/{reservationId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"reservationId"}}`, encodeURIComponent(String(reservationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof tag !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(tag !== undefined ? tag : {}) : (tag || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns modified reservation
         * @summary Update billing/reservation
         * @param {string} projectId Project Id
         * @param {string} reservationId Reservation Id
         * @param {BillingProjectReservationUpdate} billingProjectReservationUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingProjectReservationUpdate: async (projectId: string, reservationId: string, billingProjectReservationUpdate: BillingProjectReservationUpdate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling billingProjectReservationUpdate.');
            }
            // verify required parameter 'reservationId' is not null or undefined
            if (reservationId === null || reservationId === undefined) {
                throw new RequiredError('reservationId','Required parameter reservationId was null or undefined when calling billingProjectReservationUpdate.');
            }
            // verify required parameter 'billingProjectReservationUpdate' is not null or undefined
            if (billingProjectReservationUpdate === null || billingProjectReservationUpdate === undefined) {
                throw new RequiredError('billingProjectReservationUpdate','Required parameter billingProjectReservationUpdate was null or undefined when calling billingProjectReservationUpdate.');
            }
            const localVarPath = `/billing/project/{projectId}/reservation/{reservationId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"reservationId"}}`, encodeURIComponent(String(reservationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof billingProjectReservationUpdate !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(billingProjectReservationUpdate !== undefined ? billingProjectReservationUpdate : {}) : (billingProjectReservationUpdate || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BillingProjectReservationApi - functional programming interface
 * @export
 */
export const BillingProjectReservationApiFp = function(configuration?: Configuration) {
    return {
        /**
         * action assign
         * @summary Assign billing/reservation
         * @param {string} projectId Project Id
         * @param {string} reservationId Reservation Id
         * @param {BillingProjectReservationAssign} billingProjectReservationAssign 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async billingProjectReservationAssign(projectId: string, reservationId: string, billingProjectReservationAssign: BillingProjectReservationAssign, xIdempotencyKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Reservation>> {
            const localVarAxiosArgs = await BillingProjectReservationApiAxiosParamCreator(configuration).billingProjectReservationAssign(projectId, reservationId, billingProjectReservationAssign, xIdempotencyKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create reservation
         * @summary Create billing/reservation
         * @param {string} projectId Project Id
         * @param {BillingProjectReservationCreate} billingProjectReservationCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async billingProjectReservationCreate(projectId: string, billingProjectReservationCreate: BillingProjectReservationCreate, xIdempotencyKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Reservation>> {
            const localVarAxiosArgs = await BillingProjectReservationApiAxiosParamCreator(configuration).billingProjectReservationCreate(projectId, billingProjectReservationCreate, xIdempotencyKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete reservation
         * @summary Delete billing/reservation
         * @param {string} projectId Project Id
         * @param {string} reservationId Reservation Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async billingProjectReservationDelete(projectId: string, reservationId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await BillingProjectReservationApiAxiosParamCreator(configuration).billingProjectReservationDelete(projectId, reservationId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get billing/reservation.event
         * @summary Get billing/reservation.event
         * @param {string} projectId Project Id
         * @param {string} reservationId Reservation Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async billingProjectReservationEventGet(projectId: string, reservationId: string, eventId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>> {
            const localVarAxiosArgs = await BillingProjectReservationApiAxiosParamCreator(configuration).billingProjectReservationEventGet(projectId, reservationId, eventId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List billing/reservation.event
         * @summary List billing/reservation.event
         * @param {string} projectId Project Id
         * @param {string} reservationId Reservation Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async billingProjectReservationEventList(projectId: string, reservationId: string, $limit?: number, $skip?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Event>>> {
            const localVarAxiosArgs = await BillingProjectReservationApiAxiosParamCreator(configuration).billingProjectReservationEventList(projectId, reservationId, $limit, $skip, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * action extend
         * @summary Extend billing/reservation
         * @param {string} projectId Project Id
         * @param {string} reservationId Reservation Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async billingProjectReservationExtend(projectId: string, reservationId: string, xIdempotencyKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Reservation>> {
            const localVarAxiosArgs = await BillingProjectReservationApiAxiosParamCreator(configuration).billingProjectReservationExtend(projectId, reservationId, xIdempotencyKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a single reservation
         * @summary Get billing/reservation
         * @param {string} projectId Project Id
         * @param {string} reservationId Reservation Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async billingProjectReservationGet(projectId: string, reservationId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Reservation>> {
            const localVarAxiosArgs = await BillingProjectReservationApiAxiosParamCreator(configuration).billingProjectReservationGet(projectId, reservationId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List reservation
         * @summary List billing/reservation
         * @param {string} projectId Project Id
         * @param {string} [name] Filter by name
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async billingProjectReservationList(projectId: string, name?: string, tagValue?: string, tagKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Reservation>>> {
            const localVarAxiosArgs = await BillingProjectReservationApiAxiosParamCreator(configuration).billingProjectReservationList(projectId, name, tagValue, tagKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get billing/reservation.service
         * @summary Get billing/reservation.service
         * @param {string} projectId Project Id
         * @param {string} reservationId Reservation Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async billingProjectReservationServiceGet(projectId: string, reservationId: string, serviceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceService>> {
            const localVarAxiosArgs = await BillingProjectReservationApiAxiosParamCreator(configuration).billingProjectReservationServiceGet(projectId, reservationId, serviceId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List billing/reservation.service
         * @summary List billing/reservation.service
         * @param {string} projectId Project Id
         * @param {string} reservationId Reservation Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async billingProjectReservationServiceList(projectId: string, reservationId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResourceService>>> {
            const localVarAxiosArgs = await BillingProjectReservationApiAxiosParamCreator(configuration).billingProjectReservationServiceList(projectId, reservationId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create billing/reservation.tag
         * @summary Create billing/reservation.tag
         * @param {string} projectId Project Id
         * @param {string} reservationId Reservation Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async billingProjectReservationTagCreate(projectId: string, reservationId: string, tag: Tag, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await BillingProjectReservationApiAxiosParamCreator(configuration).billingProjectReservationTagCreate(projectId, reservationId, tag, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete billing/reservation.tag
         * @summary Delete billing/reservation.tag
         * @param {string} projectId Project Id
         * @param {string} reservationId Reservation Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async billingProjectReservationTagDelete(projectId: string, reservationId: string, tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await BillingProjectReservationApiAxiosParamCreator(configuration).billingProjectReservationTagDelete(projectId, reservationId, tagId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get billing/reservation.tag
         * @summary Get billing/reservation.tag
         * @param {string} projectId Project Id
         * @param {string} reservationId Reservation Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async billingProjectReservationTagGet(projectId: string, reservationId: string, tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await BillingProjectReservationApiAxiosParamCreator(configuration).billingProjectReservationTagGet(projectId, reservationId, tagId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List billing/reservation.tag
         * @summary List billing/reservation.tag
         * @param {string} projectId Project Id
         * @param {string} reservationId Reservation Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async billingProjectReservationTagList(projectId: string, reservationId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await BillingProjectReservationApiAxiosParamCreator(configuration).billingProjectReservationTagList(projectId, reservationId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Replace billing/reservation.tag
         * @summary Replace billing/reservation.tag
         * @param {string} projectId Project Id
         * @param {string} reservationId Reservation Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async billingProjectReservationTagPut(projectId: string, reservationId: string, tag: Array<Tag>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await BillingProjectReservationApiAxiosParamCreator(configuration).billingProjectReservationTagPut(projectId, reservationId, tag, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns modified reservation
         * @summary Update billing/reservation
         * @param {string} projectId Project Id
         * @param {string} reservationId Reservation Id
         * @param {BillingProjectReservationUpdate} billingProjectReservationUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async billingProjectReservationUpdate(projectId: string, reservationId: string, billingProjectReservationUpdate: BillingProjectReservationUpdate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Reservation>> {
            const localVarAxiosArgs = await BillingProjectReservationApiAxiosParamCreator(configuration).billingProjectReservationUpdate(projectId, reservationId, billingProjectReservationUpdate, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * BillingProjectReservationApi - factory interface
 * @export
 */
export const BillingProjectReservationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * action assign
         * @summary Assign billing/reservation
         * @param {string} projectId Project Id
         * @param {string} reservationId Reservation Id
         * @param {BillingProjectReservationAssign} billingProjectReservationAssign 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingProjectReservationAssign(projectId: string, reservationId: string, billingProjectReservationAssign: BillingProjectReservationAssign, xIdempotencyKey?: string, options?: any): AxiosPromise<Reservation> {
            return BillingProjectReservationApiFp(configuration).billingProjectReservationAssign(projectId, reservationId, billingProjectReservationAssign, xIdempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Create reservation
         * @summary Create billing/reservation
         * @param {string} projectId Project Id
         * @param {BillingProjectReservationCreate} billingProjectReservationCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingProjectReservationCreate(projectId: string, billingProjectReservationCreate: BillingProjectReservationCreate, xIdempotencyKey?: string, options?: any): AxiosPromise<Reservation> {
            return BillingProjectReservationApiFp(configuration).billingProjectReservationCreate(projectId, billingProjectReservationCreate, xIdempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete reservation
         * @summary Delete billing/reservation
         * @param {string} projectId Project Id
         * @param {string} reservationId Reservation Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingProjectReservationDelete(projectId: string, reservationId: string, options?: any): AxiosPromise<void> {
            return BillingProjectReservationApiFp(configuration).billingProjectReservationDelete(projectId, reservationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get billing/reservation.event
         * @summary Get billing/reservation.event
         * @param {string} projectId Project Id
         * @param {string} reservationId Reservation Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingProjectReservationEventGet(projectId: string, reservationId: string, eventId: string, options?: any): AxiosPromise<Event> {
            return BillingProjectReservationApiFp(configuration).billingProjectReservationEventGet(projectId, reservationId, eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * List billing/reservation.event
         * @summary List billing/reservation.event
         * @param {string} projectId Project Id
         * @param {string} reservationId Reservation Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingProjectReservationEventList(projectId: string, reservationId: string, $limit?: number, $skip?: number, options?: any): AxiosPromise<Array<Event>> {
            return BillingProjectReservationApiFp(configuration).billingProjectReservationEventList(projectId, reservationId, $limit, $skip, options).then((request) => request(axios, basePath));
        },
        /**
         * action extend
         * @summary Extend billing/reservation
         * @param {string} projectId Project Id
         * @param {string} reservationId Reservation Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingProjectReservationExtend(projectId: string, reservationId: string, xIdempotencyKey?: string, options?: any): AxiosPromise<Reservation> {
            return BillingProjectReservationApiFp(configuration).billingProjectReservationExtend(projectId, reservationId, xIdempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single reservation
         * @summary Get billing/reservation
         * @param {string} projectId Project Id
         * @param {string} reservationId Reservation Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingProjectReservationGet(projectId: string, reservationId: string, options?: any): AxiosPromise<Reservation> {
            return BillingProjectReservationApiFp(configuration).billingProjectReservationGet(projectId, reservationId, options).then((request) => request(axios, basePath));
        },
        /**
         * List reservation
         * @summary List billing/reservation
         * @param {string} projectId Project Id
         * @param {string} [name] Filter by name
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingProjectReservationList(projectId: string, name?: string, tagValue?: string, tagKey?: string, options?: any): AxiosPromise<Array<Reservation>> {
            return BillingProjectReservationApiFp(configuration).billingProjectReservationList(projectId, name, tagValue, tagKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get billing/reservation.service
         * @summary Get billing/reservation.service
         * @param {string} projectId Project Id
         * @param {string} reservationId Reservation Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingProjectReservationServiceGet(projectId: string, reservationId: string, serviceId: string, options?: any): AxiosPromise<ResourceService> {
            return BillingProjectReservationApiFp(configuration).billingProjectReservationServiceGet(projectId, reservationId, serviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * List billing/reservation.service
         * @summary List billing/reservation.service
         * @param {string} projectId Project Id
         * @param {string} reservationId Reservation Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingProjectReservationServiceList(projectId: string, reservationId: string, options?: any): AxiosPromise<Array<ResourceService>> {
            return BillingProjectReservationApiFp(configuration).billingProjectReservationServiceList(projectId, reservationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create billing/reservation.tag
         * @summary Create billing/reservation.tag
         * @param {string} projectId Project Id
         * @param {string} reservationId Reservation Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingProjectReservationTagCreate(projectId: string, reservationId: string, tag: Tag, options?: any): AxiosPromise<Tag> {
            return BillingProjectReservationApiFp(configuration).billingProjectReservationTagCreate(projectId, reservationId, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete billing/reservation.tag
         * @summary Delete billing/reservation.tag
         * @param {string} projectId Project Id
         * @param {string} reservationId Reservation Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingProjectReservationTagDelete(projectId: string, reservationId: string, tagId: string, options?: any): AxiosPromise<void> {
            return BillingProjectReservationApiFp(configuration).billingProjectReservationTagDelete(projectId, reservationId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get billing/reservation.tag
         * @summary Get billing/reservation.tag
         * @param {string} projectId Project Id
         * @param {string} reservationId Reservation Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingProjectReservationTagGet(projectId: string, reservationId: string, tagId: string, options?: any): AxiosPromise<Tag> {
            return BillingProjectReservationApiFp(configuration).billingProjectReservationTagGet(projectId, reservationId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * List billing/reservation.tag
         * @summary List billing/reservation.tag
         * @param {string} projectId Project Id
         * @param {string} reservationId Reservation Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingProjectReservationTagList(projectId: string, reservationId: string, options?: any): AxiosPromise<Array<Tag>> {
            return BillingProjectReservationApiFp(configuration).billingProjectReservationTagList(projectId, reservationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Replace billing/reservation.tag
         * @summary Replace billing/reservation.tag
         * @param {string} projectId Project Id
         * @param {string} reservationId Reservation Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingProjectReservationTagPut(projectId: string, reservationId: string, tag: Array<Tag>, options?: any): AxiosPromise<Array<Tag>> {
            return BillingProjectReservationApiFp(configuration).billingProjectReservationTagPut(projectId, reservationId, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns modified reservation
         * @summary Update billing/reservation
         * @param {string} projectId Project Id
         * @param {string} reservationId Reservation Id
         * @param {BillingProjectReservationUpdate} billingProjectReservationUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingProjectReservationUpdate(projectId: string, reservationId: string, billingProjectReservationUpdate: BillingProjectReservationUpdate, options?: any): AxiosPromise<Reservation> {
            return BillingProjectReservationApiFp(configuration).billingProjectReservationUpdate(projectId, reservationId, billingProjectReservationUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BillingProjectReservationApi - object-oriented interface
 * @export
 * @class BillingProjectReservationApi
 * @extends {BaseAPI}
 */
export class BillingProjectReservationApi extends BaseAPI {
    /**
     * action assign
     * @summary Assign billing/reservation
     * @param {string} projectId Project Id
     * @param {string} reservationId Reservation Id
     * @param {BillingProjectReservationAssign} billingProjectReservationAssign 
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingProjectReservationApi
     */
    public billingProjectReservationAssign(projectId: string, reservationId: string, billingProjectReservationAssign: BillingProjectReservationAssign, xIdempotencyKey?: string, options?: any) {
        return BillingProjectReservationApiFp(this.configuration).billingProjectReservationAssign(projectId, reservationId, billingProjectReservationAssign, xIdempotencyKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create reservation
     * @summary Create billing/reservation
     * @param {string} projectId Project Id
     * @param {BillingProjectReservationCreate} billingProjectReservationCreate 
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingProjectReservationApi
     */
    public billingProjectReservationCreate(projectId: string, billingProjectReservationCreate: BillingProjectReservationCreate, xIdempotencyKey?: string, options?: any) {
        return BillingProjectReservationApiFp(this.configuration).billingProjectReservationCreate(projectId, billingProjectReservationCreate, xIdempotencyKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete reservation
     * @summary Delete billing/reservation
     * @param {string} projectId Project Id
     * @param {string} reservationId Reservation Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingProjectReservationApi
     */
    public billingProjectReservationDelete(projectId: string, reservationId: string, options?: any) {
        return BillingProjectReservationApiFp(this.configuration).billingProjectReservationDelete(projectId, reservationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get billing/reservation.event
     * @summary Get billing/reservation.event
     * @param {string} projectId Project Id
     * @param {string} reservationId Reservation Id
     * @param {string} eventId eventId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingProjectReservationApi
     */
    public billingProjectReservationEventGet(projectId: string, reservationId: string, eventId: string, options?: any) {
        return BillingProjectReservationApiFp(this.configuration).billingProjectReservationEventGet(projectId, reservationId, eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List billing/reservation.event
     * @summary List billing/reservation.event
     * @param {string} projectId Project Id
     * @param {string} reservationId Reservation Id
     * @param {number} [$limit] $limit
     * @param {number} [$skip] $skip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingProjectReservationApi
     */
    public billingProjectReservationEventList(projectId: string, reservationId: string, $limit?: number, $skip?: number, options?: any) {
        return BillingProjectReservationApiFp(this.configuration).billingProjectReservationEventList(projectId, reservationId, $limit, $skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * action extend
     * @summary Extend billing/reservation
     * @param {string} projectId Project Id
     * @param {string} reservationId Reservation Id
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingProjectReservationApi
     */
    public billingProjectReservationExtend(projectId: string, reservationId: string, xIdempotencyKey?: string, options?: any) {
        return BillingProjectReservationApiFp(this.configuration).billingProjectReservationExtend(projectId, reservationId, xIdempotencyKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single reservation
     * @summary Get billing/reservation
     * @param {string} projectId Project Id
     * @param {string} reservationId Reservation Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingProjectReservationApi
     */
    public billingProjectReservationGet(projectId: string, reservationId: string, options?: any) {
        return BillingProjectReservationApiFp(this.configuration).billingProjectReservationGet(projectId, reservationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List reservation
     * @summary List billing/reservation
     * @param {string} projectId Project Id
     * @param {string} [name] Filter by name
     * @param {string} [tagValue] Filter by tag.value
     * @param {string} [tagKey] Filter by tag.key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingProjectReservationApi
     */
    public billingProjectReservationList(projectId: string, name?: string, tagValue?: string, tagKey?: string, options?: any) {
        return BillingProjectReservationApiFp(this.configuration).billingProjectReservationList(projectId, name, tagValue, tagKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get billing/reservation.service
     * @summary Get billing/reservation.service
     * @param {string} projectId Project Id
     * @param {string} reservationId Reservation Id
     * @param {string} serviceId serviceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingProjectReservationApi
     */
    public billingProjectReservationServiceGet(projectId: string, reservationId: string, serviceId: string, options?: any) {
        return BillingProjectReservationApiFp(this.configuration).billingProjectReservationServiceGet(projectId, reservationId, serviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List billing/reservation.service
     * @summary List billing/reservation.service
     * @param {string} projectId Project Id
     * @param {string} reservationId Reservation Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingProjectReservationApi
     */
    public billingProjectReservationServiceList(projectId: string, reservationId: string, options?: any) {
        return BillingProjectReservationApiFp(this.configuration).billingProjectReservationServiceList(projectId, reservationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create billing/reservation.tag
     * @summary Create billing/reservation.tag
     * @param {string} projectId Project Id
     * @param {string} reservationId Reservation Id
     * @param {Tag} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingProjectReservationApi
     */
    public billingProjectReservationTagCreate(projectId: string, reservationId: string, tag: Tag, options?: any) {
        return BillingProjectReservationApiFp(this.configuration).billingProjectReservationTagCreate(projectId, reservationId, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete billing/reservation.tag
     * @summary Delete billing/reservation.tag
     * @param {string} projectId Project Id
     * @param {string} reservationId Reservation Id
     * @param {string} tagId tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingProjectReservationApi
     */
    public billingProjectReservationTagDelete(projectId: string, reservationId: string, tagId: string, options?: any) {
        return BillingProjectReservationApiFp(this.configuration).billingProjectReservationTagDelete(projectId, reservationId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get billing/reservation.tag
     * @summary Get billing/reservation.tag
     * @param {string} projectId Project Id
     * @param {string} reservationId Reservation Id
     * @param {string} tagId tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingProjectReservationApi
     */
    public billingProjectReservationTagGet(projectId: string, reservationId: string, tagId: string, options?: any) {
        return BillingProjectReservationApiFp(this.configuration).billingProjectReservationTagGet(projectId, reservationId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List billing/reservation.tag
     * @summary List billing/reservation.tag
     * @param {string} projectId Project Id
     * @param {string} reservationId Reservation Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingProjectReservationApi
     */
    public billingProjectReservationTagList(projectId: string, reservationId: string, options?: any) {
        return BillingProjectReservationApiFp(this.configuration).billingProjectReservationTagList(projectId, reservationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replace billing/reservation.tag
     * @summary Replace billing/reservation.tag
     * @param {string} projectId Project Id
     * @param {string} reservationId Reservation Id
     * @param {Array<Tag>} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingProjectReservationApi
     */
    public billingProjectReservationTagPut(projectId: string, reservationId: string, tag: Array<Tag>, options?: any) {
        return BillingProjectReservationApiFp(this.configuration).billingProjectReservationTagPut(projectId, reservationId, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns modified reservation
     * @summary Update billing/reservation
     * @param {string} projectId Project Id
     * @param {string} reservationId Reservation Id
     * @param {BillingProjectReservationUpdate} billingProjectReservationUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingProjectReservationApi
     */
    public billingProjectReservationUpdate(projectId: string, reservationId: string, billingProjectReservationUpdate: BillingProjectReservationUpdate, options?: any) {
        return BillingProjectReservationApiFp(this.configuration).billingProjectReservationUpdate(projectId, reservationId, billingProjectReservationUpdate, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * BillingProjectServiceApi - axios parameter creator
 * @export
 */
export const BillingProjectServiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a single service
         * @summary Get billing/service
         * @param {string} projectId Project Id
         * @param {string} serviceId Service Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingProjectServiceGet: async (projectId: string, serviceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling billingProjectServiceGet.');
            }
            // verify required parameter 'serviceId' is not null or undefined
            if (serviceId === null || serviceId === undefined) {
                throw new RequiredError('serviceId','Required parameter serviceId was null or undefined when calling billingProjectServiceGet.');
            }
            const localVarPath = `/billing/project/{projectId}/service/{serviceId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List service
         * @summary List billing/service
         * @param {string} projectId Project Id
         * @param {string} [kind] Filter by kind
         * @param {string} [name] Filter by name
         * @param {string} [type] Filter by type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingProjectServiceList: async (projectId: string, kind?: string, name?: string, type?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling billingProjectServiceList.');
            }
            const localVarPath = `/billing/project/{projectId}/service`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (kind !== undefined) {
                localVarQueryParameter['kind'] = kind;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BillingProjectServiceApi - functional programming interface
 * @export
 */
export const BillingProjectServiceApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns a single service
         * @summary Get billing/service
         * @param {string} projectId Project Id
         * @param {string} serviceId Service Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async billingProjectServiceGet(projectId: string, serviceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Service>> {
            const localVarAxiosArgs = await BillingProjectServiceApiAxiosParamCreator(configuration).billingProjectServiceGet(projectId, serviceId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List service
         * @summary List billing/service
         * @param {string} projectId Project Id
         * @param {string} [kind] Filter by kind
         * @param {string} [name] Filter by name
         * @param {string} [type] Filter by type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async billingProjectServiceList(projectId: string, kind?: string, name?: string, type?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Service>>> {
            const localVarAxiosArgs = await BillingProjectServiceApiAxiosParamCreator(configuration).billingProjectServiceList(projectId, kind, name, type, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * BillingProjectServiceApi - factory interface
 * @export
 */
export const BillingProjectServiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Returns a single service
         * @summary Get billing/service
         * @param {string} projectId Project Id
         * @param {string} serviceId Service Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingProjectServiceGet(projectId: string, serviceId: string, options?: any): AxiosPromise<Service> {
            return BillingProjectServiceApiFp(configuration).billingProjectServiceGet(projectId, serviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * List service
         * @summary List billing/service
         * @param {string} projectId Project Id
         * @param {string} [kind] Filter by kind
         * @param {string} [name] Filter by name
         * @param {string} [type] Filter by type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingProjectServiceList(projectId: string, kind?: string, name?: string, type?: string, options?: any): AxiosPromise<Array<Service>> {
            return BillingProjectServiceApiFp(configuration).billingProjectServiceList(projectId, kind, name, type, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BillingProjectServiceApi - object-oriented interface
 * @export
 * @class BillingProjectServiceApi
 * @extends {BaseAPI}
 */
export class BillingProjectServiceApi extends BaseAPI {
    /**
     * Returns a single service
     * @summary Get billing/service
     * @param {string} projectId Project Id
     * @param {string} serviceId Service Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingProjectServiceApi
     */
    public billingProjectServiceGet(projectId: string, serviceId: string, options?: any) {
        return BillingProjectServiceApiFp(this.configuration).billingProjectServiceGet(projectId, serviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List service
     * @summary List billing/service
     * @param {string} projectId Project Id
     * @param {string} [kind] Filter by kind
     * @param {string} [name] Filter by name
     * @param {string} [type] Filter by type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingProjectServiceApi
     */
    public billingProjectServiceList(projectId: string, kind?: string, name?: string, type?: string, options?: any) {
        return BillingProjectServiceApiFp(this.configuration).billingProjectServiceList(projectId, kind, name, type, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * ComputeProjectReplicaApi - axios parameter creator
 * @export
 */
export const ComputeProjectReplicaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create replica
         * @summary Create compute/replica
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {ComputeProjectReplicaCreate} computeProjectReplicaCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectReplicaCreate: async (projectId: string, locationId: string, computeProjectReplicaCreate: ComputeProjectReplicaCreate, xIdempotencyKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling computeProjectReplicaCreate.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling computeProjectReplicaCreate.');
            }
            // verify required parameter 'computeProjectReplicaCreate' is not null or undefined
            if (computeProjectReplicaCreate === null || computeProjectReplicaCreate === undefined) {
                throw new RequiredError('computeProjectReplicaCreate','Required parameter computeProjectReplicaCreate was null or undefined when calling computeProjectReplicaCreate.');
            }
            const localVarPath = `/compute/{locationId}/project/{projectId}/replica`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof computeProjectReplicaCreate !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(computeProjectReplicaCreate !== undefined ? computeProjectReplicaCreate : {}) : (computeProjectReplicaCreate || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete replica
         * @summary Delete compute/replica
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} replicaId Replica Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectReplicaDelete: async (projectId: string, locationId: string, replicaId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling computeProjectReplicaDelete.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling computeProjectReplicaDelete.');
            }
            // verify required parameter 'replicaId' is not null or undefined
            if (replicaId === null || replicaId === undefined) {
                throw new RequiredError('replicaId','Required parameter replicaId was null or undefined when calling computeProjectReplicaDelete.');
            }
            const localVarPath = `/compute/{locationId}/project/{projectId}/replica/{replicaId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"replicaId"}}`, encodeURIComponent(String(replicaId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get compute/replica.event
         * @summary Get compute/replica.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} replicaId Replica Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectReplicaEventGet: async (projectId: string, locationId: string, replicaId: string, eventId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling computeProjectReplicaEventGet.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling computeProjectReplicaEventGet.');
            }
            // verify required parameter 'replicaId' is not null or undefined
            if (replicaId === null || replicaId === undefined) {
                throw new RequiredError('replicaId','Required parameter replicaId was null or undefined when calling computeProjectReplicaEventGet.');
            }
            // verify required parameter 'eventId' is not null or undefined
            if (eventId === null || eventId === undefined) {
                throw new RequiredError('eventId','Required parameter eventId was null or undefined when calling computeProjectReplicaEventGet.');
            }
            const localVarPath = `/compute/{locationId}/project/{projectId}/replica/{replicaId}/event/{eventId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"replicaId"}}`, encodeURIComponent(String(replicaId)))
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List compute/replica.event
         * @summary List compute/replica.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} replicaId Replica Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectReplicaEventList: async (projectId: string, locationId: string, replicaId: string, $limit?: number, $skip?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling computeProjectReplicaEventList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling computeProjectReplicaEventList.');
            }
            // verify required parameter 'replicaId' is not null or undefined
            if (replicaId === null || replicaId === undefined) {
                throw new RequiredError('replicaId','Required parameter replicaId was null or undefined when calling computeProjectReplicaEventList.');
            }
            const localVarPath = `/compute/{locationId}/project/{projectId}/replica/{replicaId}/event`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"replicaId"}}`, encodeURIComponent(String(replicaId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if ($limit !== undefined) {
                localVarQueryParameter['$limit'] = $limit;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single replica
         * @summary Get compute/replica
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} replicaId Replica Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectReplicaGet: async (projectId: string, locationId: string, replicaId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling computeProjectReplicaGet.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling computeProjectReplicaGet.');
            }
            // verify required parameter 'replicaId' is not null or undefined
            if (replicaId === null || replicaId === undefined) {
                throw new RequiredError('replicaId','Required parameter replicaId was null or undefined when calling computeProjectReplicaGet.');
            }
            const localVarPath = `/compute/{locationId}/project/{projectId}/replica/{replicaId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"replicaId"}}`, encodeURIComponent(String(replicaId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List replica
         * @summary List compute/replica
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [name] Filter by name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectReplicaList: async (projectId: string, locationId: string, name?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling computeProjectReplicaList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling computeProjectReplicaList.');
            }
            const localVarPath = `/compute/{locationId}/project/{projectId}/replica`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get compute/replica.service
         * @summary Get compute/replica.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} replicaId Replica Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectReplicaServiceGet: async (projectId: string, locationId: string, replicaId: string, serviceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling computeProjectReplicaServiceGet.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling computeProjectReplicaServiceGet.');
            }
            // verify required parameter 'replicaId' is not null or undefined
            if (replicaId === null || replicaId === undefined) {
                throw new RequiredError('replicaId','Required parameter replicaId was null or undefined when calling computeProjectReplicaServiceGet.');
            }
            // verify required parameter 'serviceId' is not null or undefined
            if (serviceId === null || serviceId === undefined) {
                throw new RequiredError('serviceId','Required parameter serviceId was null or undefined when calling computeProjectReplicaServiceGet.');
            }
            const localVarPath = `/compute/{locationId}/project/{projectId}/replica/{replicaId}/service/{serviceId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"replicaId"}}`, encodeURIComponent(String(replicaId)))
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List compute/replica.service
         * @summary List compute/replica.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} replicaId Replica Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectReplicaServiceList: async (projectId: string, locationId: string, replicaId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling computeProjectReplicaServiceList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling computeProjectReplicaServiceList.');
            }
            // verify required parameter 'replicaId' is not null or undefined
            if (replicaId === null || replicaId === undefined) {
                throw new RequiredError('replicaId','Required parameter replicaId was null or undefined when calling computeProjectReplicaServiceList.');
            }
            const localVarPath = `/compute/{locationId}/project/{projectId}/replica/{replicaId}/service`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"replicaId"}}`, encodeURIComponent(String(replicaId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create compute/replica.tag
         * @summary Create compute/replica.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} replicaId Replica Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectReplicaTagCreate: async (projectId: string, locationId: string, replicaId: string, tag: Tag, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling computeProjectReplicaTagCreate.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling computeProjectReplicaTagCreate.');
            }
            // verify required parameter 'replicaId' is not null or undefined
            if (replicaId === null || replicaId === undefined) {
                throw new RequiredError('replicaId','Required parameter replicaId was null or undefined when calling computeProjectReplicaTagCreate.');
            }
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling computeProjectReplicaTagCreate.');
            }
            const localVarPath = `/compute/{locationId}/project/{projectId}/replica/{replicaId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"replicaId"}}`, encodeURIComponent(String(replicaId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof tag !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(tag !== undefined ? tag : {}) : (tag || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete compute/replica.tag
         * @summary Delete compute/replica.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} replicaId Replica Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectReplicaTagDelete: async (projectId: string, locationId: string, replicaId: string, tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling computeProjectReplicaTagDelete.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling computeProjectReplicaTagDelete.');
            }
            // verify required parameter 'replicaId' is not null or undefined
            if (replicaId === null || replicaId === undefined) {
                throw new RequiredError('replicaId','Required parameter replicaId was null or undefined when calling computeProjectReplicaTagDelete.');
            }
            // verify required parameter 'tagId' is not null or undefined
            if (tagId === null || tagId === undefined) {
                throw new RequiredError('tagId','Required parameter tagId was null or undefined when calling computeProjectReplicaTagDelete.');
            }
            const localVarPath = `/compute/{locationId}/project/{projectId}/replica/{replicaId}/tag/{tagId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"replicaId"}}`, encodeURIComponent(String(replicaId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get compute/replica.tag
         * @summary Get compute/replica.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} replicaId Replica Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectReplicaTagGet: async (projectId: string, locationId: string, replicaId: string, tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling computeProjectReplicaTagGet.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling computeProjectReplicaTagGet.');
            }
            // verify required parameter 'replicaId' is not null or undefined
            if (replicaId === null || replicaId === undefined) {
                throw new RequiredError('replicaId','Required parameter replicaId was null or undefined when calling computeProjectReplicaTagGet.');
            }
            // verify required parameter 'tagId' is not null or undefined
            if (tagId === null || tagId === undefined) {
                throw new RequiredError('tagId','Required parameter tagId was null or undefined when calling computeProjectReplicaTagGet.');
            }
            const localVarPath = `/compute/{locationId}/project/{projectId}/replica/{replicaId}/tag/{tagId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"replicaId"}}`, encodeURIComponent(String(replicaId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List compute/replica.tag
         * @summary List compute/replica.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} replicaId Replica Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectReplicaTagList: async (projectId: string, locationId: string, replicaId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling computeProjectReplicaTagList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling computeProjectReplicaTagList.');
            }
            // verify required parameter 'replicaId' is not null or undefined
            if (replicaId === null || replicaId === undefined) {
                throw new RequiredError('replicaId','Required parameter replicaId was null or undefined when calling computeProjectReplicaTagList.');
            }
            const localVarPath = `/compute/{locationId}/project/{projectId}/replica/{replicaId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"replicaId"}}`, encodeURIComponent(String(replicaId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replace compute/replica.tag
         * @summary Replace compute/replica.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} replicaId Replica Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectReplicaTagPut: async (projectId: string, locationId: string, replicaId: string, tag: Array<Tag>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling computeProjectReplicaTagPut.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling computeProjectReplicaTagPut.');
            }
            // verify required parameter 'replicaId' is not null or undefined
            if (replicaId === null || replicaId === undefined) {
                throw new RequiredError('replicaId','Required parameter replicaId was null or undefined when calling computeProjectReplicaTagPut.');
            }
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling computeProjectReplicaTagPut.');
            }
            const localVarPath = `/compute/{locationId}/project/{projectId}/replica/{replicaId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"replicaId"}}`, encodeURIComponent(String(replicaId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof tag !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(tag !== undefined ? tag : {}) : (tag || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ComputeProjectReplicaApi - functional programming interface
 * @export
 */
export const ComputeProjectReplicaApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create replica
         * @summary Create compute/replica
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {ComputeProjectReplicaCreate} computeProjectReplicaCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeProjectReplicaCreate(projectId: string, locationId: string, computeProjectReplicaCreate: ComputeProjectReplicaCreate, xIdempotencyKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Replica>> {
            const localVarAxiosArgs = await ComputeProjectReplicaApiAxiosParamCreator(configuration).computeProjectReplicaCreate(projectId, locationId, computeProjectReplicaCreate, xIdempotencyKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete replica
         * @summary Delete compute/replica
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} replicaId Replica Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeProjectReplicaDelete(projectId: string, locationId: string, replicaId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ComputeProjectReplicaApiAxiosParamCreator(configuration).computeProjectReplicaDelete(projectId, locationId, replicaId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get compute/replica.event
         * @summary Get compute/replica.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} replicaId Replica Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeProjectReplicaEventGet(projectId: string, locationId: string, replicaId: string, eventId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>> {
            const localVarAxiosArgs = await ComputeProjectReplicaApiAxiosParamCreator(configuration).computeProjectReplicaEventGet(projectId, locationId, replicaId, eventId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List compute/replica.event
         * @summary List compute/replica.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} replicaId Replica Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeProjectReplicaEventList(projectId: string, locationId: string, replicaId: string, $limit?: number, $skip?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Event>>> {
            const localVarAxiosArgs = await ComputeProjectReplicaApiAxiosParamCreator(configuration).computeProjectReplicaEventList(projectId, locationId, replicaId, $limit, $skip, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a single replica
         * @summary Get compute/replica
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} replicaId Replica Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeProjectReplicaGet(projectId: string, locationId: string, replicaId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Replica>> {
            const localVarAxiosArgs = await ComputeProjectReplicaApiAxiosParamCreator(configuration).computeProjectReplicaGet(projectId, locationId, replicaId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List replica
         * @summary List compute/replica
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [name] Filter by name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeProjectReplicaList(projectId: string, locationId: string, name?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Replica>>> {
            const localVarAxiosArgs = await ComputeProjectReplicaApiAxiosParamCreator(configuration).computeProjectReplicaList(projectId, locationId, name, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get compute/replica.service
         * @summary Get compute/replica.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} replicaId Replica Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeProjectReplicaServiceGet(projectId: string, locationId: string, replicaId: string, serviceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceService>> {
            const localVarAxiosArgs = await ComputeProjectReplicaApiAxiosParamCreator(configuration).computeProjectReplicaServiceGet(projectId, locationId, replicaId, serviceId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List compute/replica.service
         * @summary List compute/replica.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} replicaId Replica Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeProjectReplicaServiceList(projectId: string, locationId: string, replicaId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResourceService>>> {
            const localVarAxiosArgs = await ComputeProjectReplicaApiAxiosParamCreator(configuration).computeProjectReplicaServiceList(projectId, locationId, replicaId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create compute/replica.tag
         * @summary Create compute/replica.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} replicaId Replica Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeProjectReplicaTagCreate(projectId: string, locationId: string, replicaId: string, tag: Tag, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await ComputeProjectReplicaApiAxiosParamCreator(configuration).computeProjectReplicaTagCreate(projectId, locationId, replicaId, tag, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete compute/replica.tag
         * @summary Delete compute/replica.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} replicaId Replica Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeProjectReplicaTagDelete(projectId: string, locationId: string, replicaId: string, tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ComputeProjectReplicaApiAxiosParamCreator(configuration).computeProjectReplicaTagDelete(projectId, locationId, replicaId, tagId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get compute/replica.tag
         * @summary Get compute/replica.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} replicaId Replica Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeProjectReplicaTagGet(projectId: string, locationId: string, replicaId: string, tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await ComputeProjectReplicaApiAxiosParamCreator(configuration).computeProjectReplicaTagGet(projectId, locationId, replicaId, tagId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List compute/replica.tag
         * @summary List compute/replica.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} replicaId Replica Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeProjectReplicaTagList(projectId: string, locationId: string, replicaId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await ComputeProjectReplicaApiAxiosParamCreator(configuration).computeProjectReplicaTagList(projectId, locationId, replicaId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Replace compute/replica.tag
         * @summary Replace compute/replica.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} replicaId Replica Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeProjectReplicaTagPut(projectId: string, locationId: string, replicaId: string, tag: Array<Tag>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await ComputeProjectReplicaApiAxiosParamCreator(configuration).computeProjectReplicaTagPut(projectId, locationId, replicaId, tag, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ComputeProjectReplicaApi - factory interface
 * @export
 */
export const ComputeProjectReplicaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Create replica
         * @summary Create compute/replica
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {ComputeProjectReplicaCreate} computeProjectReplicaCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectReplicaCreate(projectId: string, locationId: string, computeProjectReplicaCreate: ComputeProjectReplicaCreate, xIdempotencyKey?: string, options?: any): AxiosPromise<Replica> {
            return ComputeProjectReplicaApiFp(configuration).computeProjectReplicaCreate(projectId, locationId, computeProjectReplicaCreate, xIdempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete replica
         * @summary Delete compute/replica
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} replicaId Replica Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectReplicaDelete(projectId: string, locationId: string, replicaId: string, options?: any): AxiosPromise<void> {
            return ComputeProjectReplicaApiFp(configuration).computeProjectReplicaDelete(projectId, locationId, replicaId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get compute/replica.event
         * @summary Get compute/replica.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} replicaId Replica Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectReplicaEventGet(projectId: string, locationId: string, replicaId: string, eventId: string, options?: any): AxiosPromise<Event> {
            return ComputeProjectReplicaApiFp(configuration).computeProjectReplicaEventGet(projectId, locationId, replicaId, eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * List compute/replica.event
         * @summary List compute/replica.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} replicaId Replica Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectReplicaEventList(projectId: string, locationId: string, replicaId: string, $limit?: number, $skip?: number, options?: any): AxiosPromise<Array<Event>> {
            return ComputeProjectReplicaApiFp(configuration).computeProjectReplicaEventList(projectId, locationId, replicaId, $limit, $skip, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single replica
         * @summary Get compute/replica
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} replicaId Replica Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectReplicaGet(projectId: string, locationId: string, replicaId: string, options?: any): AxiosPromise<Replica> {
            return ComputeProjectReplicaApiFp(configuration).computeProjectReplicaGet(projectId, locationId, replicaId, options).then((request) => request(axios, basePath));
        },
        /**
         * List replica
         * @summary List compute/replica
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [name] Filter by name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectReplicaList(projectId: string, locationId: string, name?: string, options?: any): AxiosPromise<Array<Replica>> {
            return ComputeProjectReplicaApiFp(configuration).computeProjectReplicaList(projectId, locationId, name, options).then((request) => request(axios, basePath));
        },
        /**
         * Get compute/replica.service
         * @summary Get compute/replica.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} replicaId Replica Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectReplicaServiceGet(projectId: string, locationId: string, replicaId: string, serviceId: string, options?: any): AxiosPromise<ResourceService> {
            return ComputeProjectReplicaApiFp(configuration).computeProjectReplicaServiceGet(projectId, locationId, replicaId, serviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * List compute/replica.service
         * @summary List compute/replica.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} replicaId Replica Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectReplicaServiceList(projectId: string, locationId: string, replicaId: string, options?: any): AxiosPromise<Array<ResourceService>> {
            return ComputeProjectReplicaApiFp(configuration).computeProjectReplicaServiceList(projectId, locationId, replicaId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create compute/replica.tag
         * @summary Create compute/replica.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} replicaId Replica Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectReplicaTagCreate(projectId: string, locationId: string, replicaId: string, tag: Tag, options?: any): AxiosPromise<Tag> {
            return ComputeProjectReplicaApiFp(configuration).computeProjectReplicaTagCreate(projectId, locationId, replicaId, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete compute/replica.tag
         * @summary Delete compute/replica.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} replicaId Replica Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectReplicaTagDelete(projectId: string, locationId: string, replicaId: string, tagId: string, options?: any): AxiosPromise<void> {
            return ComputeProjectReplicaApiFp(configuration).computeProjectReplicaTagDelete(projectId, locationId, replicaId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get compute/replica.tag
         * @summary Get compute/replica.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} replicaId Replica Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectReplicaTagGet(projectId: string, locationId: string, replicaId: string, tagId: string, options?: any): AxiosPromise<Tag> {
            return ComputeProjectReplicaApiFp(configuration).computeProjectReplicaTagGet(projectId, locationId, replicaId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * List compute/replica.tag
         * @summary List compute/replica.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} replicaId Replica Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectReplicaTagList(projectId: string, locationId: string, replicaId: string, options?: any): AxiosPromise<Array<Tag>> {
            return ComputeProjectReplicaApiFp(configuration).computeProjectReplicaTagList(projectId, locationId, replicaId, options).then((request) => request(axios, basePath));
        },
        /**
         * Replace compute/replica.tag
         * @summary Replace compute/replica.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} replicaId Replica Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectReplicaTagPut(projectId: string, locationId: string, replicaId: string, tag: Array<Tag>, options?: any): AxiosPromise<Array<Tag>> {
            return ComputeProjectReplicaApiFp(configuration).computeProjectReplicaTagPut(projectId, locationId, replicaId, tag, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ComputeProjectReplicaApi - object-oriented interface
 * @export
 * @class ComputeProjectReplicaApi
 * @extends {BaseAPI}
 */
export class ComputeProjectReplicaApi extends BaseAPI {
    /**
     * Create replica
     * @summary Create compute/replica
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {ComputeProjectReplicaCreate} computeProjectReplicaCreate 
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputeProjectReplicaApi
     */
    public computeProjectReplicaCreate(projectId: string, locationId: string, computeProjectReplicaCreate: ComputeProjectReplicaCreate, xIdempotencyKey?: string, options?: any) {
        return ComputeProjectReplicaApiFp(this.configuration).computeProjectReplicaCreate(projectId, locationId, computeProjectReplicaCreate, xIdempotencyKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete replica
     * @summary Delete compute/replica
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} replicaId Replica Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputeProjectReplicaApi
     */
    public computeProjectReplicaDelete(projectId: string, locationId: string, replicaId: string, options?: any) {
        return ComputeProjectReplicaApiFp(this.configuration).computeProjectReplicaDelete(projectId, locationId, replicaId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get compute/replica.event
     * @summary Get compute/replica.event
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} replicaId Replica Id
     * @param {string} eventId eventId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputeProjectReplicaApi
     */
    public computeProjectReplicaEventGet(projectId: string, locationId: string, replicaId: string, eventId: string, options?: any) {
        return ComputeProjectReplicaApiFp(this.configuration).computeProjectReplicaEventGet(projectId, locationId, replicaId, eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List compute/replica.event
     * @summary List compute/replica.event
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} replicaId Replica Id
     * @param {number} [$limit] $limit
     * @param {number} [$skip] $skip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputeProjectReplicaApi
     */
    public computeProjectReplicaEventList(projectId: string, locationId: string, replicaId: string, $limit?: number, $skip?: number, options?: any) {
        return ComputeProjectReplicaApiFp(this.configuration).computeProjectReplicaEventList(projectId, locationId, replicaId, $limit, $skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single replica
     * @summary Get compute/replica
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} replicaId Replica Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputeProjectReplicaApi
     */
    public computeProjectReplicaGet(projectId: string, locationId: string, replicaId: string, options?: any) {
        return ComputeProjectReplicaApiFp(this.configuration).computeProjectReplicaGet(projectId, locationId, replicaId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List replica
     * @summary List compute/replica
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} [name] Filter by name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputeProjectReplicaApi
     */
    public computeProjectReplicaList(projectId: string, locationId: string, name?: string, options?: any) {
        return ComputeProjectReplicaApiFp(this.configuration).computeProjectReplicaList(projectId, locationId, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get compute/replica.service
     * @summary Get compute/replica.service
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} replicaId Replica Id
     * @param {string} serviceId serviceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputeProjectReplicaApi
     */
    public computeProjectReplicaServiceGet(projectId: string, locationId: string, replicaId: string, serviceId: string, options?: any) {
        return ComputeProjectReplicaApiFp(this.configuration).computeProjectReplicaServiceGet(projectId, locationId, replicaId, serviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List compute/replica.service
     * @summary List compute/replica.service
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} replicaId Replica Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputeProjectReplicaApi
     */
    public computeProjectReplicaServiceList(projectId: string, locationId: string, replicaId: string, options?: any) {
        return ComputeProjectReplicaApiFp(this.configuration).computeProjectReplicaServiceList(projectId, locationId, replicaId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create compute/replica.tag
     * @summary Create compute/replica.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} replicaId Replica Id
     * @param {Tag} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputeProjectReplicaApi
     */
    public computeProjectReplicaTagCreate(projectId: string, locationId: string, replicaId: string, tag: Tag, options?: any) {
        return ComputeProjectReplicaApiFp(this.configuration).computeProjectReplicaTagCreate(projectId, locationId, replicaId, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete compute/replica.tag
     * @summary Delete compute/replica.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} replicaId Replica Id
     * @param {string} tagId tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputeProjectReplicaApi
     */
    public computeProjectReplicaTagDelete(projectId: string, locationId: string, replicaId: string, tagId: string, options?: any) {
        return ComputeProjectReplicaApiFp(this.configuration).computeProjectReplicaTagDelete(projectId, locationId, replicaId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get compute/replica.tag
     * @summary Get compute/replica.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} replicaId Replica Id
     * @param {string} tagId tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputeProjectReplicaApi
     */
    public computeProjectReplicaTagGet(projectId: string, locationId: string, replicaId: string, tagId: string, options?: any) {
        return ComputeProjectReplicaApiFp(this.configuration).computeProjectReplicaTagGet(projectId, locationId, replicaId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List compute/replica.tag
     * @summary List compute/replica.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} replicaId Replica Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputeProjectReplicaApi
     */
    public computeProjectReplicaTagList(projectId: string, locationId: string, replicaId: string, options?: any) {
        return ComputeProjectReplicaApiFp(this.configuration).computeProjectReplicaTagList(projectId, locationId, replicaId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replace compute/replica.tag
     * @summary Replace compute/replica.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} replicaId Replica Id
     * @param {Array<Tag>} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputeProjectReplicaApi
     */
    public computeProjectReplicaTagPut(projectId: string, locationId: string, replicaId: string, tag: Array<Tag>, options?: any) {
        return ComputeProjectReplicaApiFp(this.configuration).computeProjectReplicaTagPut(projectId, locationId, replicaId, tag, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * ComputeProjectVmApi - axios parameter creator
 * @export
 */
export const ComputeProjectVmApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get compute/vm.connect
         * @summary Get compute/vm.connect
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {string} connectId connectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmConnectGet: async (projectId: string, locationId: string, vmId: string, connectId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling computeProjectVmConnectGet.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling computeProjectVmConnectGet.');
            }
            // verify required parameter 'vmId' is not null or undefined
            if (vmId === null || vmId === undefined) {
                throw new RequiredError('vmId','Required parameter vmId was null or undefined when calling computeProjectVmConnectGet.');
            }
            // verify required parameter 'connectId' is not null or undefined
            if (connectId === null || connectId === undefined) {
                throw new RequiredError('connectId','Required parameter connectId was null or undefined when calling computeProjectVmConnectGet.');
            }
            const localVarPath = `/compute/{locationId}/project/{projectId}/vm/{vmId}/connect/{connectId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"vmId"}}`, encodeURIComponent(String(vmId)))
                .replace(`{${"connectId"}}`, encodeURIComponent(String(connectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List compute/vm.connect
         * @summary List compute/vm.connect
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmConnectList: async (projectId: string, locationId: string, vmId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling computeProjectVmConnectList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling computeProjectVmConnectList.');
            }
            // verify required parameter 'vmId' is not null or undefined
            if (vmId === null || vmId === undefined) {
                throw new RequiredError('vmId','Required parameter vmId was null or undefined when calling computeProjectVmConnectList.');
            }
            const localVarPath = `/compute/{locationId}/project/{projectId}/vm/{vmId}/connect`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"vmId"}}`, encodeURIComponent(String(vmId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * action open
         * @summary Open compute/vm.connect
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {string} connectId connectId
         * @param {ComputeProjectVmConnectOpen} computeProjectVmConnectOpen 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmConnectOpen: async (projectId: string, locationId: string, vmId: string, connectId: string, computeProjectVmConnectOpen: ComputeProjectVmConnectOpen, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling computeProjectVmConnectOpen.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling computeProjectVmConnectOpen.');
            }
            // verify required parameter 'vmId' is not null or undefined
            if (vmId === null || vmId === undefined) {
                throw new RequiredError('vmId','Required parameter vmId was null or undefined when calling computeProjectVmConnectOpen.');
            }
            // verify required parameter 'connectId' is not null or undefined
            if (connectId === null || connectId === undefined) {
                throw new RequiredError('connectId','Required parameter connectId was null or undefined when calling computeProjectVmConnectOpen.');
            }
            // verify required parameter 'computeProjectVmConnectOpen' is not null or undefined
            if (computeProjectVmConnectOpen === null || computeProjectVmConnectOpen === undefined) {
                throw new RequiredError('computeProjectVmConnectOpen','Required parameter computeProjectVmConnectOpen was null or undefined when calling computeProjectVmConnectOpen.');
            }
            const localVarPath = `/compute/{locationId}/project/{projectId}/vm/{vmId}/connect/{connectId}/actions/open`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"vmId"}}`, encodeURIComponent(String(vmId)))
                .replace(`{${"connectId"}}`, encodeURIComponent(String(connectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof computeProjectVmConnectOpen !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(computeProjectVmConnectOpen !== undefined ? computeProjectVmConnectOpen : {}) : (computeProjectVmConnectOpen || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create vm
         * @summary Create compute/vm
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {ComputeProjectVmCreate} computeProjectVmCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmCreate: async (projectId: string, locationId: string, computeProjectVmCreate: ComputeProjectVmCreate, xIdempotencyKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling computeProjectVmCreate.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling computeProjectVmCreate.');
            }
            // verify required parameter 'computeProjectVmCreate' is not null or undefined
            if (computeProjectVmCreate === null || computeProjectVmCreate === undefined) {
                throw new RequiredError('computeProjectVmCreate','Required parameter computeProjectVmCreate was null or undefined when calling computeProjectVmCreate.');
            }
            const localVarPath = `/compute/{locationId}/project/{projectId}/vm`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof computeProjectVmCreate !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(computeProjectVmCreate !== undefined ? computeProjectVmCreate : {}) : (computeProjectVmCreate || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete vm
         * @summary Delete compute/vm
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmDelete: async (projectId: string, locationId: string, vmId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling computeProjectVmDelete.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling computeProjectVmDelete.');
            }
            // verify required parameter 'vmId' is not null or undefined
            if (vmId === null || vmId === undefined) {
                throw new RequiredError('vmId','Required parameter vmId was null or undefined when calling computeProjectVmDelete.');
            }
            const localVarPath = `/compute/{locationId}/project/{projectId}/vm/{vmId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"vmId"}}`, encodeURIComponent(String(vmId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create compute/vm.disk
         * @summary Create compute/vm.disk
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {ComputeProjectVmDiskCreate} computeProjectVmDiskCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmDiskCreate: async (projectId: string, locationId: string, vmId: string, computeProjectVmDiskCreate: ComputeProjectVmDiskCreate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling computeProjectVmDiskCreate.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling computeProjectVmDiskCreate.');
            }
            // verify required parameter 'vmId' is not null or undefined
            if (vmId === null || vmId === undefined) {
                throw new RequiredError('vmId','Required parameter vmId was null or undefined when calling computeProjectVmDiskCreate.');
            }
            // verify required parameter 'computeProjectVmDiskCreate' is not null or undefined
            if (computeProjectVmDiskCreate === null || computeProjectVmDiskCreate === undefined) {
                throw new RequiredError('computeProjectVmDiskCreate','Required parameter computeProjectVmDiskCreate was null or undefined when calling computeProjectVmDiskCreate.');
            }
            const localVarPath = `/compute/{locationId}/project/{projectId}/vm/{vmId}/disk`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"vmId"}}`, encodeURIComponent(String(vmId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof computeProjectVmDiskCreate !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(computeProjectVmDiskCreate !== undefined ? computeProjectVmDiskCreate : {}) : (computeProjectVmDiskCreate || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List compute/vm.disk
         * @summary List compute/vm.disk
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmDiskList: async (projectId: string, locationId: string, vmId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling computeProjectVmDiskList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling computeProjectVmDiskList.');
            }
            // verify required parameter 'vmId' is not null or undefined
            if (vmId === null || vmId === undefined) {
                throw new RequiredError('vmId','Required parameter vmId was null or undefined when calling computeProjectVmDiskList.');
            }
            const localVarPath = `/compute/{locationId}/project/{projectId}/vm/{vmId}/disk`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"vmId"}}`, encodeURIComponent(String(vmId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get compute/vm.event
         * @summary Get compute/vm.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmEventGet: async (projectId: string, locationId: string, vmId: string, eventId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling computeProjectVmEventGet.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling computeProjectVmEventGet.');
            }
            // verify required parameter 'vmId' is not null or undefined
            if (vmId === null || vmId === undefined) {
                throw new RequiredError('vmId','Required parameter vmId was null or undefined when calling computeProjectVmEventGet.');
            }
            // verify required parameter 'eventId' is not null or undefined
            if (eventId === null || eventId === undefined) {
                throw new RequiredError('eventId','Required parameter eventId was null or undefined when calling computeProjectVmEventGet.');
            }
            const localVarPath = `/compute/{locationId}/project/{projectId}/vm/{vmId}/event/{eventId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"vmId"}}`, encodeURIComponent(String(vmId)))
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List compute/vm.event
         * @summary List compute/vm.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmEventList: async (projectId: string, locationId: string, vmId: string, $limit?: number, $skip?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling computeProjectVmEventList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling computeProjectVmEventList.');
            }
            // verify required parameter 'vmId' is not null or undefined
            if (vmId === null || vmId === undefined) {
                throw new RequiredError('vmId','Required parameter vmId was null or undefined when calling computeProjectVmEventList.');
            }
            const localVarPath = `/compute/{locationId}/project/{projectId}/vm/{vmId}/event`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"vmId"}}`, encodeURIComponent(String(vmId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if ($limit !== undefined) {
                localVarQueryParameter['$limit'] = $limit;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * action flavour
         * @summary Flavour compute/vm
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {ComputeProjectVmFlavour} computeProjectVmFlavour 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmFlavour: async (projectId: string, locationId: string, vmId: string, computeProjectVmFlavour: ComputeProjectVmFlavour, xIdempotencyKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling computeProjectVmFlavour.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling computeProjectVmFlavour.');
            }
            // verify required parameter 'vmId' is not null or undefined
            if (vmId === null || vmId === undefined) {
                throw new RequiredError('vmId','Required parameter vmId was null or undefined when calling computeProjectVmFlavour.');
            }
            // verify required parameter 'computeProjectVmFlavour' is not null or undefined
            if (computeProjectVmFlavour === null || computeProjectVmFlavour === undefined) {
                throw new RequiredError('computeProjectVmFlavour','Required parameter computeProjectVmFlavour was null or undefined when calling computeProjectVmFlavour.');
            }
            const localVarPath = `/compute/{locationId}/project/{projectId}/vm/{vmId}/actions/flavour`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"vmId"}}`, encodeURIComponent(String(vmId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof computeProjectVmFlavour !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(computeProjectVmFlavour !== undefined ? computeProjectVmFlavour : {}) : (computeProjectVmFlavour || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single vm
         * @summary Get compute/vm
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmGet: async (projectId: string, locationId: string, vmId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling computeProjectVmGet.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling computeProjectVmGet.');
            }
            // verify required parameter 'vmId' is not null or undefined
            if (vmId === null || vmId === undefined) {
                throw new RequiredError('vmId','Required parameter vmId was null or undefined when calling computeProjectVmGet.');
            }
            const localVarPath = `/compute/{locationId}/project/{projectId}/vm/{vmId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"vmId"}}`, encodeURIComponent(String(vmId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create compute/vm.iso
         * @summary Create compute/vm.iso
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {ComputeProjectVmIsoCreate} computeProjectVmIsoCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmIsoCreate: async (projectId: string, locationId: string, vmId: string, computeProjectVmIsoCreate: ComputeProjectVmIsoCreate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling computeProjectVmIsoCreate.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling computeProjectVmIsoCreate.');
            }
            // verify required parameter 'vmId' is not null or undefined
            if (vmId === null || vmId === undefined) {
                throw new RequiredError('vmId','Required parameter vmId was null or undefined when calling computeProjectVmIsoCreate.');
            }
            // verify required parameter 'computeProjectVmIsoCreate' is not null or undefined
            if (computeProjectVmIsoCreate === null || computeProjectVmIsoCreate === undefined) {
                throw new RequiredError('computeProjectVmIsoCreate','Required parameter computeProjectVmIsoCreate was null or undefined when calling computeProjectVmIsoCreate.');
            }
            const localVarPath = `/compute/{locationId}/project/{projectId}/vm/{vmId}/iso`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"vmId"}}`, encodeURIComponent(String(vmId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof computeProjectVmIsoCreate !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(computeProjectVmIsoCreate !== undefined ? computeProjectVmIsoCreate : {}) : (computeProjectVmIsoCreate || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List compute/vm.iso
         * @summary List compute/vm.iso
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmIsoList: async (projectId: string, locationId: string, vmId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling computeProjectVmIsoList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling computeProjectVmIsoList.');
            }
            // verify required parameter 'vmId' is not null or undefined
            if (vmId === null || vmId === undefined) {
                throw new RequiredError('vmId','Required parameter vmId was null or undefined when calling computeProjectVmIsoList.');
            }
            const localVarPath = `/compute/{locationId}/project/{projectId}/vm/{vmId}/iso`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"vmId"}}`, encodeURIComponent(String(vmId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List vm
         * @summary List compute/vm
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [name] Filter by name
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmList: async (projectId: string, locationId: string, name?: string, tagValue?: string, tagKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling computeProjectVmList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling computeProjectVmList.');
            }
            const localVarPath = `/compute/{locationId}/project/{projectId}/vm`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (tagValue !== undefined) {
                localVarQueryParameter['tag.value'] = tagValue;
            }

            if (tagKey !== undefined) {
                localVarQueryParameter['tag.key'] = tagKey;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get compute/vm.metric
         * @summary Get compute/vm.metric
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {string} metricId metricId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmMetricGet: async (projectId: string, locationId: string, vmId: string, metricId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling computeProjectVmMetricGet.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling computeProjectVmMetricGet.');
            }
            // verify required parameter 'vmId' is not null or undefined
            if (vmId === null || vmId === undefined) {
                throw new RequiredError('vmId','Required parameter vmId was null or undefined when calling computeProjectVmMetricGet.');
            }
            // verify required parameter 'metricId' is not null or undefined
            if (metricId === null || metricId === undefined) {
                throw new RequiredError('metricId','Required parameter metricId was null or undefined when calling computeProjectVmMetricGet.');
            }
            const localVarPath = `/compute/{locationId}/project/{projectId}/vm/{vmId}/metric/{metricId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"vmId"}}`, encodeURIComponent(String(vmId)))
                .replace(`{${"metricId"}}`, encodeURIComponent(String(metricId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List compute/vm.metric
         * @summary List compute/vm.metric
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmMetricList: async (projectId: string, locationId: string, vmId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling computeProjectVmMetricList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling computeProjectVmMetricList.');
            }
            // verify required parameter 'vmId' is not null or undefined
            if (vmId === null || vmId === undefined) {
                throw new RequiredError('vmId','Required parameter vmId was null or undefined when calling computeProjectVmMetricList.');
            }
            const localVarPath = `/compute/{locationId}/project/{projectId}/vm/{vmId}/metric`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"vmId"}}`, encodeURIComponent(String(vmId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List compute/vm.point
         * @summary List compute/vm.point
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {string} metricId metricId
         * @param {string} [interval] interval
         * @param {string} [timespan] timespan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmMetricPointList: async (projectId: string, locationId: string, vmId: string, metricId: string, interval?: string, timespan?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling computeProjectVmMetricPointList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling computeProjectVmMetricPointList.');
            }
            // verify required parameter 'vmId' is not null or undefined
            if (vmId === null || vmId === undefined) {
                throw new RequiredError('vmId','Required parameter vmId was null or undefined when calling computeProjectVmMetricPointList.');
            }
            // verify required parameter 'metricId' is not null or undefined
            if (metricId === null || metricId === undefined) {
                throw new RequiredError('metricId','Required parameter metricId was null or undefined when calling computeProjectVmMetricPointList.');
            }
            const localVarPath = `/compute/{locationId}/project/{projectId}/vm/{vmId}/metric/{metricId}/point`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"vmId"}}`, encodeURIComponent(String(vmId)))
                .replace(`{${"metricId"}}`, encodeURIComponent(String(metricId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (timespan !== undefined) {
                localVarQueryParameter['timespan'] = timespan;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * action password_reset
         * @summary Password reset compute/vm
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {ComputeProjectVmPasswordReset} computeProjectVmPasswordReset 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmPasswordReset: async (projectId: string, locationId: string, vmId: string, computeProjectVmPasswordReset: ComputeProjectVmPasswordReset, xIdempotencyKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling computeProjectVmPasswordReset.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling computeProjectVmPasswordReset.');
            }
            // verify required parameter 'vmId' is not null or undefined
            if (vmId === null || vmId === undefined) {
                throw new RequiredError('vmId','Required parameter vmId was null or undefined when calling computeProjectVmPasswordReset.');
            }
            // verify required parameter 'computeProjectVmPasswordReset' is not null or undefined
            if (computeProjectVmPasswordReset === null || computeProjectVmPasswordReset === undefined) {
                throw new RequiredError('computeProjectVmPasswordReset','Required parameter computeProjectVmPasswordReset was null or undefined when calling computeProjectVmPasswordReset.');
            }
            const localVarPath = `/compute/{locationId}/project/{projectId}/vm/{vmId}/actions/password_reset`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"vmId"}}`, encodeURIComponent(String(vmId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof computeProjectVmPasswordReset !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(computeProjectVmPasswordReset !== undefined ? computeProjectVmPasswordReset : {}) : (computeProjectVmPasswordReset || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * action restart
         * @summary Restart compute/vm
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmRestart: async (projectId: string, locationId: string, vmId: string, xIdempotencyKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling computeProjectVmRestart.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling computeProjectVmRestart.');
            }
            // verify required parameter 'vmId' is not null or undefined
            if (vmId === null || vmId === undefined) {
                throw new RequiredError('vmId','Required parameter vmId was null or undefined when calling computeProjectVmRestart.');
            }
            const localVarPath = `/compute/{locationId}/project/{projectId}/vm/{vmId}/actions/restart`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"vmId"}}`, encodeURIComponent(String(vmId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * action serialport
         * @summary Serialport compute/vm
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {ComputeProjectVmSerialport} computeProjectVmSerialport 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmSerialport: async (projectId: string, locationId: string, vmId: string, computeProjectVmSerialport: ComputeProjectVmSerialport, xIdempotencyKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling computeProjectVmSerialport.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling computeProjectVmSerialport.');
            }
            // verify required parameter 'vmId' is not null or undefined
            if (vmId === null || vmId === undefined) {
                throw new RequiredError('vmId','Required parameter vmId was null or undefined when calling computeProjectVmSerialport.');
            }
            // verify required parameter 'computeProjectVmSerialport' is not null or undefined
            if (computeProjectVmSerialport === null || computeProjectVmSerialport === undefined) {
                throw new RequiredError('computeProjectVmSerialport','Required parameter computeProjectVmSerialport was null or undefined when calling computeProjectVmSerialport.');
            }
            const localVarPath = `/compute/{locationId}/project/{projectId}/vm/{vmId}/actions/serialport`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"vmId"}}`, encodeURIComponent(String(vmId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof computeProjectVmSerialport !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(computeProjectVmSerialport !== undefined ? computeProjectVmSerialport : {}) : (computeProjectVmSerialport || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get compute/vm.service
         * @summary Get compute/vm.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmServiceGet: async (projectId: string, locationId: string, vmId: string, serviceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling computeProjectVmServiceGet.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling computeProjectVmServiceGet.');
            }
            // verify required parameter 'vmId' is not null or undefined
            if (vmId === null || vmId === undefined) {
                throw new RequiredError('vmId','Required parameter vmId was null or undefined when calling computeProjectVmServiceGet.');
            }
            // verify required parameter 'serviceId' is not null or undefined
            if (serviceId === null || serviceId === undefined) {
                throw new RequiredError('serviceId','Required parameter serviceId was null or undefined when calling computeProjectVmServiceGet.');
            }
            const localVarPath = `/compute/{locationId}/project/{projectId}/vm/{vmId}/service/{serviceId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"vmId"}}`, encodeURIComponent(String(vmId)))
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List compute/vm.service
         * @summary List compute/vm.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmServiceList: async (projectId: string, locationId: string, vmId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling computeProjectVmServiceList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling computeProjectVmServiceList.');
            }
            // verify required parameter 'vmId' is not null or undefined
            if (vmId === null || vmId === undefined) {
                throw new RequiredError('vmId','Required parameter vmId was null or undefined when calling computeProjectVmServiceList.');
            }
            const localVarPath = `/compute/{locationId}/project/{projectId}/vm/{vmId}/service`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"vmId"}}`, encodeURIComponent(String(vmId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * action start
         * @summary Start compute/vm
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmStart: async (projectId: string, locationId: string, vmId: string, xIdempotencyKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling computeProjectVmStart.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling computeProjectVmStart.');
            }
            // verify required parameter 'vmId' is not null or undefined
            if (vmId === null || vmId === undefined) {
                throw new RequiredError('vmId','Required parameter vmId was null or undefined when calling computeProjectVmStart.');
            }
            const localVarPath = `/compute/{locationId}/project/{projectId}/vm/{vmId}/actions/start`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"vmId"}}`, encodeURIComponent(String(vmId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * action stop
         * @summary Stop compute/vm
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmStop: async (projectId: string, locationId: string, vmId: string, xIdempotencyKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling computeProjectVmStop.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling computeProjectVmStop.');
            }
            // verify required parameter 'vmId' is not null or undefined
            if (vmId === null || vmId === undefined) {
                throw new RequiredError('vmId','Required parameter vmId was null or undefined when calling computeProjectVmStop.');
            }
            const localVarPath = `/compute/{locationId}/project/{projectId}/vm/{vmId}/actions/stop`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"vmId"}}`, encodeURIComponent(String(vmId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create compute/vm.tag
         * @summary Create compute/vm.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmTagCreate: async (projectId: string, locationId: string, vmId: string, tag: Tag, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling computeProjectVmTagCreate.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling computeProjectVmTagCreate.');
            }
            // verify required parameter 'vmId' is not null or undefined
            if (vmId === null || vmId === undefined) {
                throw new RequiredError('vmId','Required parameter vmId was null or undefined when calling computeProjectVmTagCreate.');
            }
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling computeProjectVmTagCreate.');
            }
            const localVarPath = `/compute/{locationId}/project/{projectId}/vm/{vmId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"vmId"}}`, encodeURIComponent(String(vmId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof tag !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(tag !== undefined ? tag : {}) : (tag || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete compute/vm.tag
         * @summary Delete compute/vm.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmTagDelete: async (projectId: string, locationId: string, vmId: string, tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling computeProjectVmTagDelete.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling computeProjectVmTagDelete.');
            }
            // verify required parameter 'vmId' is not null or undefined
            if (vmId === null || vmId === undefined) {
                throw new RequiredError('vmId','Required parameter vmId was null or undefined when calling computeProjectVmTagDelete.');
            }
            // verify required parameter 'tagId' is not null or undefined
            if (tagId === null || tagId === undefined) {
                throw new RequiredError('tagId','Required parameter tagId was null or undefined when calling computeProjectVmTagDelete.');
            }
            const localVarPath = `/compute/{locationId}/project/{projectId}/vm/{vmId}/tag/{tagId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"vmId"}}`, encodeURIComponent(String(vmId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get compute/vm.tag
         * @summary Get compute/vm.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmTagGet: async (projectId: string, locationId: string, vmId: string, tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling computeProjectVmTagGet.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling computeProjectVmTagGet.');
            }
            // verify required parameter 'vmId' is not null or undefined
            if (vmId === null || vmId === undefined) {
                throw new RequiredError('vmId','Required parameter vmId was null or undefined when calling computeProjectVmTagGet.');
            }
            // verify required parameter 'tagId' is not null or undefined
            if (tagId === null || tagId === undefined) {
                throw new RequiredError('tagId','Required parameter tagId was null or undefined when calling computeProjectVmTagGet.');
            }
            const localVarPath = `/compute/{locationId}/project/{projectId}/vm/{vmId}/tag/{tagId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"vmId"}}`, encodeURIComponent(String(vmId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List compute/vm.tag
         * @summary List compute/vm.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmTagList: async (projectId: string, locationId: string, vmId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling computeProjectVmTagList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling computeProjectVmTagList.');
            }
            // verify required parameter 'vmId' is not null or undefined
            if (vmId === null || vmId === undefined) {
                throw new RequiredError('vmId','Required parameter vmId was null or undefined when calling computeProjectVmTagList.');
            }
            const localVarPath = `/compute/{locationId}/project/{projectId}/vm/{vmId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"vmId"}}`, encodeURIComponent(String(vmId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replace compute/vm.tag
         * @summary Replace compute/vm.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmTagPut: async (projectId: string, locationId: string, vmId: string, tag: Array<Tag>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling computeProjectVmTagPut.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling computeProjectVmTagPut.');
            }
            // verify required parameter 'vmId' is not null or undefined
            if (vmId === null || vmId === undefined) {
                throw new RequiredError('vmId','Required parameter vmId was null or undefined when calling computeProjectVmTagPut.');
            }
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling computeProjectVmTagPut.');
            }
            const localVarPath = `/compute/{locationId}/project/{projectId}/vm/{vmId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"vmId"}}`, encodeURIComponent(String(vmId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof tag !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(tag !== undefined ? tag : {}) : (tag || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * action turnoff
         * @summary Turnoff compute/vm
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmTurnoff: async (projectId: string, locationId: string, vmId: string, xIdempotencyKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling computeProjectVmTurnoff.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling computeProjectVmTurnoff.');
            }
            // verify required parameter 'vmId' is not null or undefined
            if (vmId === null || vmId === undefined) {
                throw new RequiredError('vmId','Required parameter vmId was null or undefined when calling computeProjectVmTurnoff.');
            }
            const localVarPath = `/compute/{locationId}/project/{projectId}/vm/{vmId}/actions/turnoff`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"vmId"}}`, encodeURIComponent(String(vmId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns modified vm
         * @summary Update compute/vm
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {ComputeProjectVmUpdate} computeProjectVmUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmUpdate: async (projectId: string, locationId: string, vmId: string, computeProjectVmUpdate: ComputeProjectVmUpdate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling computeProjectVmUpdate.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling computeProjectVmUpdate.');
            }
            // verify required parameter 'vmId' is not null or undefined
            if (vmId === null || vmId === undefined) {
                throw new RequiredError('vmId','Required parameter vmId was null or undefined when calling computeProjectVmUpdate.');
            }
            // verify required parameter 'computeProjectVmUpdate' is not null or undefined
            if (computeProjectVmUpdate === null || computeProjectVmUpdate === undefined) {
                throw new RequiredError('computeProjectVmUpdate','Required parameter computeProjectVmUpdate was null or undefined when calling computeProjectVmUpdate.');
            }
            const localVarPath = `/compute/{locationId}/project/{projectId}/vm/{vmId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"vmId"}}`, encodeURIComponent(String(vmId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof computeProjectVmUpdate !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(computeProjectVmUpdate !== undefined ? computeProjectVmUpdate : {}) : (computeProjectVmUpdate || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ComputeProjectVmApi - functional programming interface
 * @export
 */
export const ComputeProjectVmApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get compute/vm.connect
         * @summary Get compute/vm.connect
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {string} connectId connectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeProjectVmConnectGet(projectId: string, locationId: string, vmId: string, connectId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Connect>> {
            const localVarAxiosArgs = await ComputeProjectVmApiAxiosParamCreator(configuration).computeProjectVmConnectGet(projectId, locationId, vmId, connectId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List compute/vm.connect
         * @summary List compute/vm.connect
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeProjectVmConnectList(projectId: string, locationId: string, vmId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Connect>>> {
            const localVarAxiosArgs = await ComputeProjectVmApiAxiosParamCreator(configuration).computeProjectVmConnectList(projectId, locationId, vmId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * action open
         * @summary Open compute/vm.connect
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {string} connectId connectId
         * @param {ComputeProjectVmConnectOpen} computeProjectVmConnectOpen 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeProjectVmConnectOpen(projectId: string, locationId: string, vmId: string, connectId: string, computeProjectVmConnectOpen: ComputeProjectVmConnectOpen, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ComputeProjectVmApiAxiosParamCreator(configuration).computeProjectVmConnectOpen(projectId, locationId, vmId, connectId, computeProjectVmConnectOpen, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create vm
         * @summary Create compute/vm
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {ComputeProjectVmCreate} computeProjectVmCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeProjectVmCreate(projectId: string, locationId: string, computeProjectVmCreate: ComputeProjectVmCreate, xIdempotencyKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Vm>> {
            const localVarAxiosArgs = await ComputeProjectVmApiAxiosParamCreator(configuration).computeProjectVmCreate(projectId, locationId, computeProjectVmCreate, xIdempotencyKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete vm
         * @summary Delete compute/vm
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeProjectVmDelete(projectId: string, locationId: string, vmId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ComputeProjectVmApiAxiosParamCreator(configuration).computeProjectVmDelete(projectId, locationId, vmId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create compute/vm.disk
         * @summary Create compute/vm.disk
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {ComputeProjectVmDiskCreate} computeProjectVmDiskCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeProjectVmDiskCreate(projectId: string, locationId: string, vmId: string, computeProjectVmDiskCreate: ComputeProjectVmDiskCreate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Disk>> {
            const localVarAxiosArgs = await ComputeProjectVmApiAxiosParamCreator(configuration).computeProjectVmDiskCreate(projectId, locationId, vmId, computeProjectVmDiskCreate, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List compute/vm.disk
         * @summary List compute/vm.disk
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeProjectVmDiskList(projectId: string, locationId: string, vmId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Disk>>> {
            const localVarAxiosArgs = await ComputeProjectVmApiAxiosParamCreator(configuration).computeProjectVmDiskList(projectId, locationId, vmId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get compute/vm.event
         * @summary Get compute/vm.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeProjectVmEventGet(projectId: string, locationId: string, vmId: string, eventId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>> {
            const localVarAxiosArgs = await ComputeProjectVmApiAxiosParamCreator(configuration).computeProjectVmEventGet(projectId, locationId, vmId, eventId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List compute/vm.event
         * @summary List compute/vm.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeProjectVmEventList(projectId: string, locationId: string, vmId: string, $limit?: number, $skip?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Event>>> {
            const localVarAxiosArgs = await ComputeProjectVmApiAxiosParamCreator(configuration).computeProjectVmEventList(projectId, locationId, vmId, $limit, $skip, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * action flavour
         * @summary Flavour compute/vm
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {ComputeProjectVmFlavour} computeProjectVmFlavour 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeProjectVmFlavour(projectId: string, locationId: string, vmId: string, computeProjectVmFlavour: ComputeProjectVmFlavour, xIdempotencyKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Vm>> {
            const localVarAxiosArgs = await ComputeProjectVmApiAxiosParamCreator(configuration).computeProjectVmFlavour(projectId, locationId, vmId, computeProjectVmFlavour, xIdempotencyKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a single vm
         * @summary Get compute/vm
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeProjectVmGet(projectId: string, locationId: string, vmId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Vm>> {
            const localVarAxiosArgs = await ComputeProjectVmApiAxiosParamCreator(configuration).computeProjectVmGet(projectId, locationId, vmId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create compute/vm.iso
         * @summary Create compute/vm.iso
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {ComputeProjectVmIsoCreate} computeProjectVmIsoCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeProjectVmIsoCreate(projectId: string, locationId: string, vmId: string, computeProjectVmIsoCreate: ComputeProjectVmIsoCreate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Iso>> {
            const localVarAxiosArgs = await ComputeProjectVmApiAxiosParamCreator(configuration).computeProjectVmIsoCreate(projectId, locationId, vmId, computeProjectVmIsoCreate, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List compute/vm.iso
         * @summary List compute/vm.iso
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeProjectVmIsoList(projectId: string, locationId: string, vmId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Iso>>> {
            const localVarAxiosArgs = await ComputeProjectVmApiAxiosParamCreator(configuration).computeProjectVmIsoList(projectId, locationId, vmId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List vm
         * @summary List compute/vm
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [name] Filter by name
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeProjectVmList(projectId: string, locationId: string, name?: string, tagValue?: string, tagKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Vm>>> {
            const localVarAxiosArgs = await ComputeProjectVmApiAxiosParamCreator(configuration).computeProjectVmList(projectId, locationId, name, tagValue, tagKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get compute/vm.metric
         * @summary Get compute/vm.metric
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {string} metricId metricId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeProjectVmMetricGet(projectId: string, locationId: string, vmId: string, metricId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Metric>> {
            const localVarAxiosArgs = await ComputeProjectVmApiAxiosParamCreator(configuration).computeProjectVmMetricGet(projectId, locationId, vmId, metricId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List compute/vm.metric
         * @summary List compute/vm.metric
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeProjectVmMetricList(projectId: string, locationId: string, vmId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Metric>>> {
            const localVarAxiosArgs = await ComputeProjectVmApiAxiosParamCreator(configuration).computeProjectVmMetricList(projectId, locationId, vmId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List compute/vm.point
         * @summary List compute/vm.point
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {string} metricId metricId
         * @param {string} [interval] interval
         * @param {string} [timespan] timespan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeProjectVmMetricPointList(projectId: string, locationId: string, vmId: string, metricId: string, interval?: string, timespan?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Point>>> {
            const localVarAxiosArgs = await ComputeProjectVmApiAxiosParamCreator(configuration).computeProjectVmMetricPointList(projectId, locationId, vmId, metricId, interval, timespan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * action password_reset
         * @summary Password reset compute/vm
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {ComputeProjectVmPasswordReset} computeProjectVmPasswordReset 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeProjectVmPasswordReset(projectId: string, locationId: string, vmId: string, computeProjectVmPasswordReset: ComputeProjectVmPasswordReset, xIdempotencyKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Vm>> {
            const localVarAxiosArgs = await ComputeProjectVmApiAxiosParamCreator(configuration).computeProjectVmPasswordReset(projectId, locationId, vmId, computeProjectVmPasswordReset, xIdempotencyKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * action restart
         * @summary Restart compute/vm
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeProjectVmRestart(projectId: string, locationId: string, vmId: string, xIdempotencyKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Vm>> {
            const localVarAxiosArgs = await ComputeProjectVmApiAxiosParamCreator(configuration).computeProjectVmRestart(projectId, locationId, vmId, xIdempotencyKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * action serialport
         * @summary Serialport compute/vm
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {ComputeProjectVmSerialport} computeProjectVmSerialport 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeProjectVmSerialport(projectId: string, locationId: string, vmId: string, computeProjectVmSerialport: ComputeProjectVmSerialport, xIdempotencyKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await ComputeProjectVmApiAxiosParamCreator(configuration).computeProjectVmSerialport(projectId, locationId, vmId, computeProjectVmSerialport, xIdempotencyKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get compute/vm.service
         * @summary Get compute/vm.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeProjectVmServiceGet(projectId: string, locationId: string, vmId: string, serviceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceService>> {
            const localVarAxiosArgs = await ComputeProjectVmApiAxiosParamCreator(configuration).computeProjectVmServiceGet(projectId, locationId, vmId, serviceId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List compute/vm.service
         * @summary List compute/vm.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeProjectVmServiceList(projectId: string, locationId: string, vmId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResourceService>>> {
            const localVarAxiosArgs = await ComputeProjectVmApiAxiosParamCreator(configuration).computeProjectVmServiceList(projectId, locationId, vmId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * action start
         * @summary Start compute/vm
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeProjectVmStart(projectId: string, locationId: string, vmId: string, xIdempotencyKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Vm>> {
            const localVarAxiosArgs = await ComputeProjectVmApiAxiosParamCreator(configuration).computeProjectVmStart(projectId, locationId, vmId, xIdempotencyKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * action stop
         * @summary Stop compute/vm
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeProjectVmStop(projectId: string, locationId: string, vmId: string, xIdempotencyKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Vm>> {
            const localVarAxiosArgs = await ComputeProjectVmApiAxiosParamCreator(configuration).computeProjectVmStop(projectId, locationId, vmId, xIdempotencyKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create compute/vm.tag
         * @summary Create compute/vm.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeProjectVmTagCreate(projectId: string, locationId: string, vmId: string, tag: Tag, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await ComputeProjectVmApiAxiosParamCreator(configuration).computeProjectVmTagCreate(projectId, locationId, vmId, tag, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete compute/vm.tag
         * @summary Delete compute/vm.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeProjectVmTagDelete(projectId: string, locationId: string, vmId: string, tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ComputeProjectVmApiAxiosParamCreator(configuration).computeProjectVmTagDelete(projectId, locationId, vmId, tagId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get compute/vm.tag
         * @summary Get compute/vm.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeProjectVmTagGet(projectId: string, locationId: string, vmId: string, tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await ComputeProjectVmApiAxiosParamCreator(configuration).computeProjectVmTagGet(projectId, locationId, vmId, tagId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List compute/vm.tag
         * @summary List compute/vm.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeProjectVmTagList(projectId: string, locationId: string, vmId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await ComputeProjectVmApiAxiosParamCreator(configuration).computeProjectVmTagList(projectId, locationId, vmId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Replace compute/vm.tag
         * @summary Replace compute/vm.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeProjectVmTagPut(projectId: string, locationId: string, vmId: string, tag: Array<Tag>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await ComputeProjectVmApiAxiosParamCreator(configuration).computeProjectVmTagPut(projectId, locationId, vmId, tag, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * action turnoff
         * @summary Turnoff compute/vm
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeProjectVmTurnoff(projectId: string, locationId: string, vmId: string, xIdempotencyKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Vm>> {
            const localVarAxiosArgs = await ComputeProjectVmApiAxiosParamCreator(configuration).computeProjectVmTurnoff(projectId, locationId, vmId, xIdempotencyKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns modified vm
         * @summary Update compute/vm
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {ComputeProjectVmUpdate} computeProjectVmUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeProjectVmUpdate(projectId: string, locationId: string, vmId: string, computeProjectVmUpdate: ComputeProjectVmUpdate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Vm>> {
            const localVarAxiosArgs = await ComputeProjectVmApiAxiosParamCreator(configuration).computeProjectVmUpdate(projectId, locationId, vmId, computeProjectVmUpdate, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ComputeProjectVmApi - factory interface
 * @export
 */
export const ComputeProjectVmApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Get compute/vm.connect
         * @summary Get compute/vm.connect
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {string} connectId connectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmConnectGet(projectId: string, locationId: string, vmId: string, connectId: string, options?: any): AxiosPromise<Connect> {
            return ComputeProjectVmApiFp(configuration).computeProjectVmConnectGet(projectId, locationId, vmId, connectId, options).then((request) => request(axios, basePath));
        },
        /**
         * List compute/vm.connect
         * @summary List compute/vm.connect
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmConnectList(projectId: string, locationId: string, vmId: string, options?: any): AxiosPromise<Array<Connect>> {
            return ComputeProjectVmApiFp(configuration).computeProjectVmConnectList(projectId, locationId, vmId, options).then((request) => request(axios, basePath));
        },
        /**
         * action open
         * @summary Open compute/vm.connect
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {string} connectId connectId
         * @param {ComputeProjectVmConnectOpen} computeProjectVmConnectOpen 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmConnectOpen(projectId: string, locationId: string, vmId: string, connectId: string, computeProjectVmConnectOpen: ComputeProjectVmConnectOpen, options?: any): AxiosPromise<void> {
            return ComputeProjectVmApiFp(configuration).computeProjectVmConnectOpen(projectId, locationId, vmId, connectId, computeProjectVmConnectOpen, options).then((request) => request(axios, basePath));
        },
        /**
         * Create vm
         * @summary Create compute/vm
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {ComputeProjectVmCreate} computeProjectVmCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmCreate(projectId: string, locationId: string, computeProjectVmCreate: ComputeProjectVmCreate, xIdempotencyKey?: string, options?: any): AxiosPromise<Vm> {
            return ComputeProjectVmApiFp(configuration).computeProjectVmCreate(projectId, locationId, computeProjectVmCreate, xIdempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete vm
         * @summary Delete compute/vm
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmDelete(projectId: string, locationId: string, vmId: string, options?: any): AxiosPromise<void> {
            return ComputeProjectVmApiFp(configuration).computeProjectVmDelete(projectId, locationId, vmId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create compute/vm.disk
         * @summary Create compute/vm.disk
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {ComputeProjectVmDiskCreate} computeProjectVmDiskCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmDiskCreate(projectId: string, locationId: string, vmId: string, computeProjectVmDiskCreate: ComputeProjectVmDiskCreate, options?: any): AxiosPromise<Disk> {
            return ComputeProjectVmApiFp(configuration).computeProjectVmDiskCreate(projectId, locationId, vmId, computeProjectVmDiskCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * List compute/vm.disk
         * @summary List compute/vm.disk
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmDiskList(projectId: string, locationId: string, vmId: string, options?: any): AxiosPromise<Array<Disk>> {
            return ComputeProjectVmApiFp(configuration).computeProjectVmDiskList(projectId, locationId, vmId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get compute/vm.event
         * @summary Get compute/vm.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmEventGet(projectId: string, locationId: string, vmId: string, eventId: string, options?: any): AxiosPromise<Event> {
            return ComputeProjectVmApiFp(configuration).computeProjectVmEventGet(projectId, locationId, vmId, eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * List compute/vm.event
         * @summary List compute/vm.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmEventList(projectId: string, locationId: string, vmId: string, $limit?: number, $skip?: number, options?: any): AxiosPromise<Array<Event>> {
            return ComputeProjectVmApiFp(configuration).computeProjectVmEventList(projectId, locationId, vmId, $limit, $skip, options).then((request) => request(axios, basePath));
        },
        /**
         * action flavour
         * @summary Flavour compute/vm
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {ComputeProjectVmFlavour} computeProjectVmFlavour 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmFlavour(projectId: string, locationId: string, vmId: string, computeProjectVmFlavour: ComputeProjectVmFlavour, xIdempotencyKey?: string, options?: any): AxiosPromise<Vm> {
            return ComputeProjectVmApiFp(configuration).computeProjectVmFlavour(projectId, locationId, vmId, computeProjectVmFlavour, xIdempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single vm
         * @summary Get compute/vm
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmGet(projectId: string, locationId: string, vmId: string, options?: any): AxiosPromise<Vm> {
            return ComputeProjectVmApiFp(configuration).computeProjectVmGet(projectId, locationId, vmId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create compute/vm.iso
         * @summary Create compute/vm.iso
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {ComputeProjectVmIsoCreate} computeProjectVmIsoCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmIsoCreate(projectId: string, locationId: string, vmId: string, computeProjectVmIsoCreate: ComputeProjectVmIsoCreate, options?: any): AxiosPromise<Iso> {
            return ComputeProjectVmApiFp(configuration).computeProjectVmIsoCreate(projectId, locationId, vmId, computeProjectVmIsoCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * List compute/vm.iso
         * @summary List compute/vm.iso
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmIsoList(projectId: string, locationId: string, vmId: string, options?: any): AxiosPromise<Array<Iso>> {
            return ComputeProjectVmApiFp(configuration).computeProjectVmIsoList(projectId, locationId, vmId, options).then((request) => request(axios, basePath));
        },
        /**
         * List vm
         * @summary List compute/vm
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [name] Filter by name
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmList(projectId: string, locationId: string, name?: string, tagValue?: string, tagKey?: string, options?: any): AxiosPromise<Array<Vm>> {
            return ComputeProjectVmApiFp(configuration).computeProjectVmList(projectId, locationId, name, tagValue, tagKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get compute/vm.metric
         * @summary Get compute/vm.metric
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {string} metricId metricId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmMetricGet(projectId: string, locationId: string, vmId: string, metricId: string, options?: any): AxiosPromise<Metric> {
            return ComputeProjectVmApiFp(configuration).computeProjectVmMetricGet(projectId, locationId, vmId, metricId, options).then((request) => request(axios, basePath));
        },
        /**
         * List compute/vm.metric
         * @summary List compute/vm.metric
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmMetricList(projectId: string, locationId: string, vmId: string, options?: any): AxiosPromise<Array<Metric>> {
            return ComputeProjectVmApiFp(configuration).computeProjectVmMetricList(projectId, locationId, vmId, options).then((request) => request(axios, basePath));
        },
        /**
         * List compute/vm.point
         * @summary List compute/vm.point
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {string} metricId metricId
         * @param {string} [interval] interval
         * @param {string} [timespan] timespan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmMetricPointList(projectId: string, locationId: string, vmId: string, metricId: string, interval?: string, timespan?: string, options?: any): AxiosPromise<Array<Point>> {
            return ComputeProjectVmApiFp(configuration).computeProjectVmMetricPointList(projectId, locationId, vmId, metricId, interval, timespan, options).then((request) => request(axios, basePath));
        },
        /**
         * action password_reset
         * @summary Password reset compute/vm
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {ComputeProjectVmPasswordReset} computeProjectVmPasswordReset 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmPasswordReset(projectId: string, locationId: string, vmId: string, computeProjectVmPasswordReset: ComputeProjectVmPasswordReset, xIdempotencyKey?: string, options?: any): AxiosPromise<Vm> {
            return ComputeProjectVmApiFp(configuration).computeProjectVmPasswordReset(projectId, locationId, vmId, computeProjectVmPasswordReset, xIdempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * action restart
         * @summary Restart compute/vm
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmRestart(projectId: string, locationId: string, vmId: string, xIdempotencyKey?: string, options?: any): AxiosPromise<Vm> {
            return ComputeProjectVmApiFp(configuration).computeProjectVmRestart(projectId, locationId, vmId, xIdempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * action serialport
         * @summary Serialport compute/vm
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {ComputeProjectVmSerialport} computeProjectVmSerialport 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmSerialport(projectId: string, locationId: string, vmId: string, computeProjectVmSerialport: ComputeProjectVmSerialport, xIdempotencyKey?: string, options?: any): AxiosPromise<any> {
            return ComputeProjectVmApiFp(configuration).computeProjectVmSerialport(projectId, locationId, vmId, computeProjectVmSerialport, xIdempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get compute/vm.service
         * @summary Get compute/vm.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmServiceGet(projectId: string, locationId: string, vmId: string, serviceId: string, options?: any): AxiosPromise<ResourceService> {
            return ComputeProjectVmApiFp(configuration).computeProjectVmServiceGet(projectId, locationId, vmId, serviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * List compute/vm.service
         * @summary List compute/vm.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmServiceList(projectId: string, locationId: string, vmId: string, options?: any): AxiosPromise<Array<ResourceService>> {
            return ComputeProjectVmApiFp(configuration).computeProjectVmServiceList(projectId, locationId, vmId, options).then((request) => request(axios, basePath));
        },
        /**
         * action start
         * @summary Start compute/vm
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmStart(projectId: string, locationId: string, vmId: string, xIdempotencyKey?: string, options?: any): AxiosPromise<Vm> {
            return ComputeProjectVmApiFp(configuration).computeProjectVmStart(projectId, locationId, vmId, xIdempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * action stop
         * @summary Stop compute/vm
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmStop(projectId: string, locationId: string, vmId: string, xIdempotencyKey?: string, options?: any): AxiosPromise<Vm> {
            return ComputeProjectVmApiFp(configuration).computeProjectVmStop(projectId, locationId, vmId, xIdempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Create compute/vm.tag
         * @summary Create compute/vm.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmTagCreate(projectId: string, locationId: string, vmId: string, tag: Tag, options?: any): AxiosPromise<Tag> {
            return ComputeProjectVmApiFp(configuration).computeProjectVmTagCreate(projectId, locationId, vmId, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete compute/vm.tag
         * @summary Delete compute/vm.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmTagDelete(projectId: string, locationId: string, vmId: string, tagId: string, options?: any): AxiosPromise<void> {
            return ComputeProjectVmApiFp(configuration).computeProjectVmTagDelete(projectId, locationId, vmId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get compute/vm.tag
         * @summary Get compute/vm.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmTagGet(projectId: string, locationId: string, vmId: string, tagId: string, options?: any): AxiosPromise<Tag> {
            return ComputeProjectVmApiFp(configuration).computeProjectVmTagGet(projectId, locationId, vmId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * List compute/vm.tag
         * @summary List compute/vm.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmTagList(projectId: string, locationId: string, vmId: string, options?: any): AxiosPromise<Array<Tag>> {
            return ComputeProjectVmApiFp(configuration).computeProjectVmTagList(projectId, locationId, vmId, options).then((request) => request(axios, basePath));
        },
        /**
         * Replace compute/vm.tag
         * @summary Replace compute/vm.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmTagPut(projectId: string, locationId: string, vmId: string, tag: Array<Tag>, options?: any): AxiosPromise<Array<Tag>> {
            return ComputeProjectVmApiFp(configuration).computeProjectVmTagPut(projectId, locationId, vmId, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * action turnoff
         * @summary Turnoff compute/vm
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmTurnoff(projectId: string, locationId: string, vmId: string, xIdempotencyKey?: string, options?: any): AxiosPromise<Vm> {
            return ComputeProjectVmApiFp(configuration).computeProjectVmTurnoff(projectId, locationId, vmId, xIdempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns modified vm
         * @summary Update compute/vm
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {ComputeProjectVmUpdate} computeProjectVmUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmUpdate(projectId: string, locationId: string, vmId: string, computeProjectVmUpdate: ComputeProjectVmUpdate, options?: any): AxiosPromise<Vm> {
            return ComputeProjectVmApiFp(configuration).computeProjectVmUpdate(projectId, locationId, vmId, computeProjectVmUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ComputeProjectVmApi - object-oriented interface
 * @export
 * @class ComputeProjectVmApi
 * @extends {BaseAPI}
 */
export class ComputeProjectVmApi extends BaseAPI {
    /**
     * Get compute/vm.connect
     * @summary Get compute/vm.connect
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} vmId Vm Id
     * @param {string} connectId connectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputeProjectVmApi
     */
    public computeProjectVmConnectGet(projectId: string, locationId: string, vmId: string, connectId: string, options?: any) {
        return ComputeProjectVmApiFp(this.configuration).computeProjectVmConnectGet(projectId, locationId, vmId, connectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List compute/vm.connect
     * @summary List compute/vm.connect
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} vmId Vm Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputeProjectVmApi
     */
    public computeProjectVmConnectList(projectId: string, locationId: string, vmId: string, options?: any) {
        return ComputeProjectVmApiFp(this.configuration).computeProjectVmConnectList(projectId, locationId, vmId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * action open
     * @summary Open compute/vm.connect
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} vmId Vm Id
     * @param {string} connectId connectId
     * @param {ComputeProjectVmConnectOpen} computeProjectVmConnectOpen 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputeProjectVmApi
     */
    public computeProjectVmConnectOpen(projectId: string, locationId: string, vmId: string, connectId: string, computeProjectVmConnectOpen: ComputeProjectVmConnectOpen, options?: any) {
        return ComputeProjectVmApiFp(this.configuration).computeProjectVmConnectOpen(projectId, locationId, vmId, connectId, computeProjectVmConnectOpen, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create vm
     * @summary Create compute/vm
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {ComputeProjectVmCreate} computeProjectVmCreate 
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputeProjectVmApi
     */
    public computeProjectVmCreate(projectId: string, locationId: string, computeProjectVmCreate: ComputeProjectVmCreate, xIdempotencyKey?: string, options?: any) {
        return ComputeProjectVmApiFp(this.configuration).computeProjectVmCreate(projectId, locationId, computeProjectVmCreate, xIdempotencyKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete vm
     * @summary Delete compute/vm
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} vmId Vm Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputeProjectVmApi
     */
    public computeProjectVmDelete(projectId: string, locationId: string, vmId: string, options?: any) {
        return ComputeProjectVmApiFp(this.configuration).computeProjectVmDelete(projectId, locationId, vmId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create compute/vm.disk
     * @summary Create compute/vm.disk
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} vmId Vm Id
     * @param {ComputeProjectVmDiskCreate} computeProjectVmDiskCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputeProjectVmApi
     */
    public computeProjectVmDiskCreate(projectId: string, locationId: string, vmId: string, computeProjectVmDiskCreate: ComputeProjectVmDiskCreate, options?: any) {
        return ComputeProjectVmApiFp(this.configuration).computeProjectVmDiskCreate(projectId, locationId, vmId, computeProjectVmDiskCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List compute/vm.disk
     * @summary List compute/vm.disk
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} vmId Vm Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputeProjectVmApi
     */
    public computeProjectVmDiskList(projectId: string, locationId: string, vmId: string, options?: any) {
        return ComputeProjectVmApiFp(this.configuration).computeProjectVmDiskList(projectId, locationId, vmId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get compute/vm.event
     * @summary Get compute/vm.event
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} vmId Vm Id
     * @param {string} eventId eventId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputeProjectVmApi
     */
    public computeProjectVmEventGet(projectId: string, locationId: string, vmId: string, eventId: string, options?: any) {
        return ComputeProjectVmApiFp(this.configuration).computeProjectVmEventGet(projectId, locationId, vmId, eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List compute/vm.event
     * @summary List compute/vm.event
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} vmId Vm Id
     * @param {number} [$limit] $limit
     * @param {number} [$skip] $skip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputeProjectVmApi
     */
    public computeProjectVmEventList(projectId: string, locationId: string, vmId: string, $limit?: number, $skip?: number, options?: any) {
        return ComputeProjectVmApiFp(this.configuration).computeProjectVmEventList(projectId, locationId, vmId, $limit, $skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * action flavour
     * @summary Flavour compute/vm
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} vmId Vm Id
     * @param {ComputeProjectVmFlavour} computeProjectVmFlavour 
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputeProjectVmApi
     */
    public computeProjectVmFlavour(projectId: string, locationId: string, vmId: string, computeProjectVmFlavour: ComputeProjectVmFlavour, xIdempotencyKey?: string, options?: any) {
        return ComputeProjectVmApiFp(this.configuration).computeProjectVmFlavour(projectId, locationId, vmId, computeProjectVmFlavour, xIdempotencyKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single vm
     * @summary Get compute/vm
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} vmId Vm Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputeProjectVmApi
     */
    public computeProjectVmGet(projectId: string, locationId: string, vmId: string, options?: any) {
        return ComputeProjectVmApiFp(this.configuration).computeProjectVmGet(projectId, locationId, vmId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create compute/vm.iso
     * @summary Create compute/vm.iso
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} vmId Vm Id
     * @param {ComputeProjectVmIsoCreate} computeProjectVmIsoCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputeProjectVmApi
     */
    public computeProjectVmIsoCreate(projectId: string, locationId: string, vmId: string, computeProjectVmIsoCreate: ComputeProjectVmIsoCreate, options?: any) {
        return ComputeProjectVmApiFp(this.configuration).computeProjectVmIsoCreate(projectId, locationId, vmId, computeProjectVmIsoCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List compute/vm.iso
     * @summary List compute/vm.iso
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} vmId Vm Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputeProjectVmApi
     */
    public computeProjectVmIsoList(projectId: string, locationId: string, vmId: string, options?: any) {
        return ComputeProjectVmApiFp(this.configuration).computeProjectVmIsoList(projectId, locationId, vmId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List vm
     * @summary List compute/vm
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} [name] Filter by name
     * @param {string} [tagValue] Filter by tag.value
     * @param {string} [tagKey] Filter by tag.key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputeProjectVmApi
     */
    public computeProjectVmList(projectId: string, locationId: string, name?: string, tagValue?: string, tagKey?: string, options?: any) {
        return ComputeProjectVmApiFp(this.configuration).computeProjectVmList(projectId, locationId, name, tagValue, tagKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get compute/vm.metric
     * @summary Get compute/vm.metric
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} vmId Vm Id
     * @param {string} metricId metricId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputeProjectVmApi
     */
    public computeProjectVmMetricGet(projectId: string, locationId: string, vmId: string, metricId: string, options?: any) {
        return ComputeProjectVmApiFp(this.configuration).computeProjectVmMetricGet(projectId, locationId, vmId, metricId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List compute/vm.metric
     * @summary List compute/vm.metric
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} vmId Vm Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputeProjectVmApi
     */
    public computeProjectVmMetricList(projectId: string, locationId: string, vmId: string, options?: any) {
        return ComputeProjectVmApiFp(this.configuration).computeProjectVmMetricList(projectId, locationId, vmId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List compute/vm.point
     * @summary List compute/vm.point
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} vmId Vm Id
     * @param {string} metricId metricId
     * @param {string} [interval] interval
     * @param {string} [timespan] timespan
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputeProjectVmApi
     */
    public computeProjectVmMetricPointList(projectId: string, locationId: string, vmId: string, metricId: string, interval?: string, timespan?: string, options?: any) {
        return ComputeProjectVmApiFp(this.configuration).computeProjectVmMetricPointList(projectId, locationId, vmId, metricId, interval, timespan, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * action password_reset
     * @summary Password reset compute/vm
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} vmId Vm Id
     * @param {ComputeProjectVmPasswordReset} computeProjectVmPasswordReset 
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputeProjectVmApi
     */
    public computeProjectVmPasswordReset(projectId: string, locationId: string, vmId: string, computeProjectVmPasswordReset: ComputeProjectVmPasswordReset, xIdempotencyKey?: string, options?: any) {
        return ComputeProjectVmApiFp(this.configuration).computeProjectVmPasswordReset(projectId, locationId, vmId, computeProjectVmPasswordReset, xIdempotencyKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * action restart
     * @summary Restart compute/vm
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} vmId Vm Id
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputeProjectVmApi
     */
    public computeProjectVmRestart(projectId: string, locationId: string, vmId: string, xIdempotencyKey?: string, options?: any) {
        return ComputeProjectVmApiFp(this.configuration).computeProjectVmRestart(projectId, locationId, vmId, xIdempotencyKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * action serialport
     * @summary Serialport compute/vm
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} vmId Vm Id
     * @param {ComputeProjectVmSerialport} computeProjectVmSerialport 
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputeProjectVmApi
     */
    public computeProjectVmSerialport(projectId: string, locationId: string, vmId: string, computeProjectVmSerialport: ComputeProjectVmSerialport, xIdempotencyKey?: string, options?: any) {
        return ComputeProjectVmApiFp(this.configuration).computeProjectVmSerialport(projectId, locationId, vmId, computeProjectVmSerialport, xIdempotencyKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get compute/vm.service
     * @summary Get compute/vm.service
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} vmId Vm Id
     * @param {string} serviceId serviceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputeProjectVmApi
     */
    public computeProjectVmServiceGet(projectId: string, locationId: string, vmId: string, serviceId: string, options?: any) {
        return ComputeProjectVmApiFp(this.configuration).computeProjectVmServiceGet(projectId, locationId, vmId, serviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List compute/vm.service
     * @summary List compute/vm.service
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} vmId Vm Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputeProjectVmApi
     */
    public computeProjectVmServiceList(projectId: string, locationId: string, vmId: string, options?: any) {
        return ComputeProjectVmApiFp(this.configuration).computeProjectVmServiceList(projectId, locationId, vmId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * action start
     * @summary Start compute/vm
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} vmId Vm Id
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputeProjectVmApi
     */
    public computeProjectVmStart(projectId: string, locationId: string, vmId: string, xIdempotencyKey?: string, options?: any) {
        return ComputeProjectVmApiFp(this.configuration).computeProjectVmStart(projectId, locationId, vmId, xIdempotencyKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * action stop
     * @summary Stop compute/vm
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} vmId Vm Id
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputeProjectVmApi
     */
    public computeProjectVmStop(projectId: string, locationId: string, vmId: string, xIdempotencyKey?: string, options?: any) {
        return ComputeProjectVmApiFp(this.configuration).computeProjectVmStop(projectId, locationId, vmId, xIdempotencyKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create compute/vm.tag
     * @summary Create compute/vm.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} vmId Vm Id
     * @param {Tag} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputeProjectVmApi
     */
    public computeProjectVmTagCreate(projectId: string, locationId: string, vmId: string, tag: Tag, options?: any) {
        return ComputeProjectVmApiFp(this.configuration).computeProjectVmTagCreate(projectId, locationId, vmId, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete compute/vm.tag
     * @summary Delete compute/vm.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} vmId Vm Id
     * @param {string} tagId tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputeProjectVmApi
     */
    public computeProjectVmTagDelete(projectId: string, locationId: string, vmId: string, tagId: string, options?: any) {
        return ComputeProjectVmApiFp(this.configuration).computeProjectVmTagDelete(projectId, locationId, vmId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get compute/vm.tag
     * @summary Get compute/vm.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} vmId Vm Id
     * @param {string} tagId tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputeProjectVmApi
     */
    public computeProjectVmTagGet(projectId: string, locationId: string, vmId: string, tagId: string, options?: any) {
        return ComputeProjectVmApiFp(this.configuration).computeProjectVmTagGet(projectId, locationId, vmId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List compute/vm.tag
     * @summary List compute/vm.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} vmId Vm Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputeProjectVmApi
     */
    public computeProjectVmTagList(projectId: string, locationId: string, vmId: string, options?: any) {
        return ComputeProjectVmApiFp(this.configuration).computeProjectVmTagList(projectId, locationId, vmId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replace compute/vm.tag
     * @summary Replace compute/vm.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} vmId Vm Id
     * @param {Array<Tag>} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputeProjectVmApi
     */
    public computeProjectVmTagPut(projectId: string, locationId: string, vmId: string, tag: Array<Tag>, options?: any) {
        return ComputeProjectVmApiFp(this.configuration).computeProjectVmTagPut(projectId, locationId, vmId, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * action turnoff
     * @summary Turnoff compute/vm
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} vmId Vm Id
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputeProjectVmApi
     */
    public computeProjectVmTurnoff(projectId: string, locationId: string, vmId: string, xIdempotencyKey?: string, options?: any) {
        return ComputeProjectVmApiFp(this.configuration).computeProjectVmTurnoff(projectId, locationId, vmId, xIdempotencyKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns modified vm
     * @summary Update compute/vm
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} vmId Vm Id
     * @param {ComputeProjectVmUpdate} computeProjectVmUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputeProjectVmApi
     */
    public computeProjectVmUpdate(projectId: string, locationId: string, vmId: string, computeProjectVmUpdate: ComputeProjectVmUpdate, options?: any) {
        return ComputeProjectVmApiFp(this.configuration).computeProjectVmUpdate(projectId, locationId, vmId, computeProjectVmUpdate, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * ContainerProjectRegistryApi - axios parameter creator
 * @export
 */
export const ContainerProjectRegistryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create registry
         * @summary Create container/registry
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {ContainerProjectRegistryCreate} containerProjectRegistryCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryCreate: async (projectId: string, locationId: string, containerProjectRegistryCreate: ContainerProjectRegistryCreate, xIdempotencyKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling containerProjectRegistryCreate.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling containerProjectRegistryCreate.');
            }
            // verify required parameter 'containerProjectRegistryCreate' is not null or undefined
            if (containerProjectRegistryCreate === null || containerProjectRegistryCreate === undefined) {
                throw new RequiredError('containerProjectRegistryCreate','Required parameter containerProjectRegistryCreate was null or undefined when calling containerProjectRegistryCreate.');
            }
            const localVarPath = `/container/{locationId}/project/{projectId}/registry`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof containerProjectRegistryCreate !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(containerProjectRegistryCreate !== undefined ? containerProjectRegistryCreate : {}) : (containerProjectRegistryCreate || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create container/registry.credential
         * @summary Create container/registry.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {RegistryCredential} registryCredential 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryCredentialCreate: async (projectId: string, locationId: string, registryId: string, registryCredential: RegistryCredential, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling containerProjectRegistryCredentialCreate.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling containerProjectRegistryCredentialCreate.');
            }
            // verify required parameter 'registryId' is not null or undefined
            if (registryId === null || registryId === undefined) {
                throw new RequiredError('registryId','Required parameter registryId was null or undefined when calling containerProjectRegistryCredentialCreate.');
            }
            // verify required parameter 'registryCredential' is not null or undefined
            if (registryCredential === null || registryCredential === undefined) {
                throw new RequiredError('registryCredential','Required parameter registryCredential was null or undefined when calling containerProjectRegistryCredentialCreate.');
            }
            const localVarPath = `/container/{locationId}/project/{projectId}/registry/{registryId}/credential`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"registryId"}}`, encodeURIComponent(String(registryId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof registryCredential !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(registryCredential !== undefined ? registryCredential : {}) : (registryCredential || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete container/registry.credential
         * @summary Delete container/registry.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {string} credentialId credentialId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryCredentialDelete: async (projectId: string, locationId: string, registryId: string, credentialId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling containerProjectRegistryCredentialDelete.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling containerProjectRegistryCredentialDelete.');
            }
            // verify required parameter 'registryId' is not null or undefined
            if (registryId === null || registryId === undefined) {
                throw new RequiredError('registryId','Required parameter registryId was null or undefined when calling containerProjectRegistryCredentialDelete.');
            }
            // verify required parameter 'credentialId' is not null or undefined
            if (credentialId === null || credentialId === undefined) {
                throw new RequiredError('credentialId','Required parameter credentialId was null or undefined when calling containerProjectRegistryCredentialDelete.');
            }
            const localVarPath = `/container/{locationId}/project/{projectId}/registry/{registryId}/credential/{credentialId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"registryId"}}`, encodeURIComponent(String(registryId)))
                .replace(`{${"credentialId"}}`, encodeURIComponent(String(credentialId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get container/registry.credential
         * @summary Get container/registry.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {string} credentialId credentialId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryCredentialGet: async (projectId: string, locationId: string, registryId: string, credentialId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling containerProjectRegistryCredentialGet.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling containerProjectRegistryCredentialGet.');
            }
            // verify required parameter 'registryId' is not null or undefined
            if (registryId === null || registryId === undefined) {
                throw new RequiredError('registryId','Required parameter registryId was null or undefined when calling containerProjectRegistryCredentialGet.');
            }
            // verify required parameter 'credentialId' is not null or undefined
            if (credentialId === null || credentialId === undefined) {
                throw new RequiredError('credentialId','Required parameter credentialId was null or undefined when calling containerProjectRegistryCredentialGet.');
            }
            const localVarPath = `/container/{locationId}/project/{projectId}/registry/{registryId}/credential/{credentialId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"registryId"}}`, encodeURIComponent(String(registryId)))
                .replace(`{${"credentialId"}}`, encodeURIComponent(String(credentialId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List container/registry.credential
         * @summary List container/registry.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryCredentialList: async (projectId: string, locationId: string, registryId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling containerProjectRegistryCredentialList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling containerProjectRegistryCredentialList.');
            }
            // verify required parameter 'registryId' is not null or undefined
            if (registryId === null || registryId === undefined) {
                throw new RequiredError('registryId','Required parameter registryId was null or undefined when calling containerProjectRegistryCredentialList.');
            }
            const localVarPath = `/container/{locationId}/project/{projectId}/registry/{registryId}/credential`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"registryId"}}`, encodeURIComponent(String(registryId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update container/registry.credential
         * @summary Update container/registry.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {string} credentialId credentialId
         * @param {ContainerProjectRegistryCredentialPatch} containerProjectRegistryCredentialPatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryCredentialPatch: async (projectId: string, locationId: string, registryId: string, credentialId: string, containerProjectRegistryCredentialPatch: ContainerProjectRegistryCredentialPatch, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling containerProjectRegistryCredentialPatch.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling containerProjectRegistryCredentialPatch.');
            }
            // verify required parameter 'registryId' is not null or undefined
            if (registryId === null || registryId === undefined) {
                throw new RequiredError('registryId','Required parameter registryId was null or undefined when calling containerProjectRegistryCredentialPatch.');
            }
            // verify required parameter 'credentialId' is not null or undefined
            if (credentialId === null || credentialId === undefined) {
                throw new RequiredError('credentialId','Required parameter credentialId was null or undefined when calling containerProjectRegistryCredentialPatch.');
            }
            // verify required parameter 'containerProjectRegistryCredentialPatch' is not null or undefined
            if (containerProjectRegistryCredentialPatch === null || containerProjectRegistryCredentialPatch === undefined) {
                throw new RequiredError('containerProjectRegistryCredentialPatch','Required parameter containerProjectRegistryCredentialPatch was null or undefined when calling containerProjectRegistryCredentialPatch.');
            }
            const localVarPath = `/container/{locationId}/project/{projectId}/registry/{registryId}/credential/{credentialId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"registryId"}}`, encodeURIComponent(String(registryId)))
                .replace(`{${"credentialId"}}`, encodeURIComponent(String(credentialId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof containerProjectRegistryCredentialPatch !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(containerProjectRegistryCredentialPatch !== undefined ? containerProjectRegistryCredentialPatch : {}) : (containerProjectRegistryCredentialPatch || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete registry
         * @summary Delete container/registry
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryDelete: async (projectId: string, locationId: string, registryId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling containerProjectRegistryDelete.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling containerProjectRegistryDelete.');
            }
            // verify required parameter 'registryId' is not null or undefined
            if (registryId === null || registryId === undefined) {
                throw new RequiredError('registryId','Required parameter registryId was null or undefined when calling containerProjectRegistryDelete.');
            }
            const localVarPath = `/container/{locationId}/project/{projectId}/registry/{registryId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"registryId"}}`, encodeURIComponent(String(registryId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create container/registry.domain
         * @summary Create container/registry.domain
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {Domain} domain 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryDomainCreate: async (projectId: string, locationId: string, registryId: string, domain: Domain, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling containerProjectRegistryDomainCreate.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling containerProjectRegistryDomainCreate.');
            }
            // verify required parameter 'registryId' is not null or undefined
            if (registryId === null || registryId === undefined) {
                throw new RequiredError('registryId','Required parameter registryId was null or undefined when calling containerProjectRegistryDomainCreate.');
            }
            // verify required parameter 'domain' is not null or undefined
            if (domain === null || domain === undefined) {
                throw new RequiredError('domain','Required parameter domain was null or undefined when calling containerProjectRegistryDomainCreate.');
            }
            const localVarPath = `/container/{locationId}/project/{projectId}/registry/{registryId}/domain`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"registryId"}}`, encodeURIComponent(String(registryId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof domain !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(domain !== undefined ? domain : {}) : (domain || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete container/registry.domain
         * @summary Delete container/registry.domain
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {string} domainId domainId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryDomainDelete: async (projectId: string, locationId: string, registryId: string, domainId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling containerProjectRegistryDomainDelete.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling containerProjectRegistryDomainDelete.');
            }
            // verify required parameter 'registryId' is not null or undefined
            if (registryId === null || registryId === undefined) {
                throw new RequiredError('registryId','Required parameter registryId was null or undefined when calling containerProjectRegistryDomainDelete.');
            }
            // verify required parameter 'domainId' is not null or undefined
            if (domainId === null || domainId === undefined) {
                throw new RequiredError('domainId','Required parameter domainId was null or undefined when calling containerProjectRegistryDomainDelete.');
            }
            const localVarPath = `/container/{locationId}/project/{projectId}/registry/{registryId}/domain/{domainId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"registryId"}}`, encodeURIComponent(String(registryId)))
                .replace(`{${"domainId"}}`, encodeURIComponent(String(domainId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get container/registry.domain
         * @summary Get container/registry.domain
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {string} domainId domainId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryDomainGet: async (projectId: string, locationId: string, registryId: string, domainId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling containerProjectRegistryDomainGet.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling containerProjectRegistryDomainGet.');
            }
            // verify required parameter 'registryId' is not null or undefined
            if (registryId === null || registryId === undefined) {
                throw new RequiredError('registryId','Required parameter registryId was null or undefined when calling containerProjectRegistryDomainGet.');
            }
            // verify required parameter 'domainId' is not null or undefined
            if (domainId === null || domainId === undefined) {
                throw new RequiredError('domainId','Required parameter domainId was null or undefined when calling containerProjectRegistryDomainGet.');
            }
            const localVarPath = `/container/{locationId}/project/{projectId}/registry/{registryId}/domain/{domainId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"registryId"}}`, encodeURIComponent(String(registryId)))
                .replace(`{${"domainId"}}`, encodeURIComponent(String(domainId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List container/registry.domain
         * @summary List container/registry.domain
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryDomainList: async (projectId: string, locationId: string, registryId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling containerProjectRegistryDomainList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling containerProjectRegistryDomainList.');
            }
            // verify required parameter 'registryId' is not null or undefined
            if (registryId === null || registryId === undefined) {
                throw new RequiredError('registryId','Required parameter registryId was null or undefined when calling containerProjectRegistryDomainList.');
            }
            const localVarPath = `/container/{locationId}/project/{projectId}/registry/{registryId}/domain`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"registryId"}}`, encodeURIComponent(String(registryId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get container/registry.event
         * @summary Get container/registry.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryEventGet: async (projectId: string, locationId: string, registryId: string, eventId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling containerProjectRegistryEventGet.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling containerProjectRegistryEventGet.');
            }
            // verify required parameter 'registryId' is not null or undefined
            if (registryId === null || registryId === undefined) {
                throw new RequiredError('registryId','Required parameter registryId was null or undefined when calling containerProjectRegistryEventGet.');
            }
            // verify required parameter 'eventId' is not null or undefined
            if (eventId === null || eventId === undefined) {
                throw new RequiredError('eventId','Required parameter eventId was null or undefined when calling containerProjectRegistryEventGet.');
            }
            const localVarPath = `/container/{locationId}/project/{projectId}/registry/{registryId}/event/{eventId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"registryId"}}`, encodeURIComponent(String(registryId)))
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List container/registry.event
         * @summary List container/registry.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryEventList: async (projectId: string, locationId: string, registryId: string, $limit?: number, $skip?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling containerProjectRegistryEventList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling containerProjectRegistryEventList.');
            }
            // verify required parameter 'registryId' is not null or undefined
            if (registryId === null || registryId === undefined) {
                throw new RequiredError('registryId','Required parameter registryId was null or undefined when calling containerProjectRegistryEventList.');
            }
            const localVarPath = `/container/{locationId}/project/{projectId}/registry/{registryId}/event`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"registryId"}}`, encodeURIComponent(String(registryId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if ($limit !== undefined) {
                localVarQueryParameter['$limit'] = $limit;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single registry
         * @summary Get container/registry
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryGet: async (projectId: string, locationId: string, registryId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling containerProjectRegistryGet.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling containerProjectRegistryGet.');
            }
            // verify required parameter 'registryId' is not null or undefined
            if (registryId === null || registryId === undefined) {
                throw new RequiredError('registryId','Required parameter registryId was null or undefined when calling containerProjectRegistryGet.');
            }
            const localVarPath = `/container/{locationId}/project/{projectId}/registry/{registryId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"registryId"}}`, encodeURIComponent(String(registryId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List registry
         * @summary List container/registry
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [name] Filter by name
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryList: async (projectId: string, locationId: string, name?: string, tagValue?: string, tagKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling containerProjectRegistryList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling containerProjectRegistryList.');
            }
            const localVarPath = `/container/{locationId}/project/{projectId}/registry`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (tagValue !== undefined) {
                localVarQueryParameter['tag.value'] = tagValue;
            }

            if (tagKey !== undefined) {
                localVarQueryParameter['tag.key'] = tagKey;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get container/registry.repository
         * @summary Get container/registry.repository
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {string} repositoryId repositoryId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryRepositoryGet: async (projectId: string, locationId: string, registryId: string, repositoryId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling containerProjectRegistryRepositoryGet.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling containerProjectRegistryRepositoryGet.');
            }
            // verify required parameter 'registryId' is not null or undefined
            if (registryId === null || registryId === undefined) {
                throw new RequiredError('registryId','Required parameter registryId was null or undefined when calling containerProjectRegistryRepositoryGet.');
            }
            // verify required parameter 'repositoryId' is not null or undefined
            if (repositoryId === null || repositoryId === undefined) {
                throw new RequiredError('repositoryId','Required parameter repositoryId was null or undefined when calling containerProjectRegistryRepositoryGet.');
            }
            const localVarPath = `/container/{locationId}/project/{projectId}/registry/{registryId}/repository/{repositoryId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"registryId"}}`, encodeURIComponent(String(registryId)))
                .replace(`{${"repositoryId"}}`, encodeURIComponent(String(repositoryId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete container/registry.image
         * @summary Delete container/registry.image
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {string} repositoryId repositoryId
         * @param {string} imageId imageId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryRepositoryImageDelete: async (projectId: string, locationId: string, registryId: string, repositoryId: string, imageId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling containerProjectRegistryRepositoryImageDelete.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling containerProjectRegistryRepositoryImageDelete.');
            }
            // verify required parameter 'registryId' is not null or undefined
            if (registryId === null || registryId === undefined) {
                throw new RequiredError('registryId','Required parameter registryId was null or undefined when calling containerProjectRegistryRepositoryImageDelete.');
            }
            // verify required parameter 'repositoryId' is not null or undefined
            if (repositoryId === null || repositoryId === undefined) {
                throw new RequiredError('repositoryId','Required parameter repositoryId was null or undefined when calling containerProjectRegistryRepositoryImageDelete.');
            }
            // verify required parameter 'imageId' is not null or undefined
            if (imageId === null || imageId === undefined) {
                throw new RequiredError('imageId','Required parameter imageId was null or undefined when calling containerProjectRegistryRepositoryImageDelete.');
            }
            const localVarPath = `/container/{locationId}/project/{projectId}/registry/{registryId}/repository/{repositoryId}/image/{imageId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"registryId"}}`, encodeURIComponent(String(registryId)))
                .replace(`{${"repositoryId"}}`, encodeURIComponent(String(repositoryId)))
                .replace(`{${"imageId"}}`, encodeURIComponent(String(imageId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get container/registry.image
         * @summary Get container/registry.image
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {string} repositoryId repositoryId
         * @param {string} imageId imageId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryRepositoryImageGet: async (projectId: string, locationId: string, registryId: string, repositoryId: string, imageId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling containerProjectRegistryRepositoryImageGet.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling containerProjectRegistryRepositoryImageGet.');
            }
            // verify required parameter 'registryId' is not null or undefined
            if (registryId === null || registryId === undefined) {
                throw new RequiredError('registryId','Required parameter registryId was null or undefined when calling containerProjectRegistryRepositoryImageGet.');
            }
            // verify required parameter 'repositoryId' is not null or undefined
            if (repositoryId === null || repositoryId === undefined) {
                throw new RequiredError('repositoryId','Required parameter repositoryId was null or undefined when calling containerProjectRegistryRepositoryImageGet.');
            }
            // verify required parameter 'imageId' is not null or undefined
            if (imageId === null || imageId === undefined) {
                throw new RequiredError('imageId','Required parameter imageId was null or undefined when calling containerProjectRegistryRepositoryImageGet.');
            }
            const localVarPath = `/container/{locationId}/project/{projectId}/registry/{registryId}/repository/{repositoryId}/image/{imageId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"registryId"}}`, encodeURIComponent(String(registryId)))
                .replace(`{${"repositoryId"}}`, encodeURIComponent(String(repositoryId)))
                .replace(`{${"imageId"}}`, encodeURIComponent(String(imageId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List container/registry.image
         * @summary List container/registry.image
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {string} repositoryId repositoryId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryRepositoryImageList: async (projectId: string, locationId: string, registryId: string, repositoryId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling containerProjectRegistryRepositoryImageList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling containerProjectRegistryRepositoryImageList.');
            }
            // verify required parameter 'registryId' is not null or undefined
            if (registryId === null || registryId === undefined) {
                throw new RequiredError('registryId','Required parameter registryId was null or undefined when calling containerProjectRegistryRepositoryImageList.');
            }
            // verify required parameter 'repositoryId' is not null or undefined
            if (repositoryId === null || repositoryId === undefined) {
                throw new RequiredError('repositoryId','Required parameter repositoryId was null or undefined when calling containerProjectRegistryRepositoryImageList.');
            }
            const localVarPath = `/container/{locationId}/project/{projectId}/registry/{registryId}/repository/{repositoryId}/image`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"registryId"}}`, encodeURIComponent(String(registryId)))
                .replace(`{${"repositoryId"}}`, encodeURIComponent(String(repositoryId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List container/registry.repository
         * @summary List container/registry.repository
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryRepositoryList: async (projectId: string, locationId: string, registryId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling containerProjectRegistryRepositoryList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling containerProjectRegistryRepositoryList.');
            }
            // verify required parameter 'registryId' is not null or undefined
            if (registryId === null || registryId === undefined) {
                throw new RequiredError('registryId','Required parameter registryId was null or undefined when calling containerProjectRegistryRepositoryList.');
            }
            const localVarPath = `/container/{locationId}/project/{projectId}/registry/{registryId}/repository`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"registryId"}}`, encodeURIComponent(String(registryId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get container/registry.service
         * @summary Get container/registry.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryServiceGet: async (projectId: string, locationId: string, registryId: string, serviceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling containerProjectRegistryServiceGet.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling containerProjectRegistryServiceGet.');
            }
            // verify required parameter 'registryId' is not null or undefined
            if (registryId === null || registryId === undefined) {
                throw new RequiredError('registryId','Required parameter registryId was null or undefined when calling containerProjectRegistryServiceGet.');
            }
            // verify required parameter 'serviceId' is not null or undefined
            if (serviceId === null || serviceId === undefined) {
                throw new RequiredError('serviceId','Required parameter serviceId was null or undefined when calling containerProjectRegistryServiceGet.');
            }
            const localVarPath = `/container/{locationId}/project/{projectId}/registry/{registryId}/service/{serviceId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"registryId"}}`, encodeURIComponent(String(registryId)))
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List container/registry.service
         * @summary List container/registry.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryServiceList: async (projectId: string, locationId: string, registryId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling containerProjectRegistryServiceList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling containerProjectRegistryServiceList.');
            }
            // verify required parameter 'registryId' is not null or undefined
            if (registryId === null || registryId === undefined) {
                throw new RequiredError('registryId','Required parameter registryId was null or undefined when calling containerProjectRegistryServiceList.');
            }
            const localVarPath = `/container/{locationId}/project/{projectId}/registry/{registryId}/service`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"registryId"}}`, encodeURIComponent(String(registryId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * action start
         * @summary Start container/registry
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryStart: async (projectId: string, locationId: string, registryId: string, xIdempotencyKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling containerProjectRegistryStart.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling containerProjectRegistryStart.');
            }
            // verify required parameter 'registryId' is not null or undefined
            if (registryId === null || registryId === undefined) {
                throw new RequiredError('registryId','Required parameter registryId was null or undefined when calling containerProjectRegistryStart.');
            }
            const localVarPath = `/container/{locationId}/project/{projectId}/registry/{registryId}/actions/start`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"registryId"}}`, encodeURIComponent(String(registryId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * action stop
         * @summary Stop container/registry
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryStop: async (projectId: string, locationId: string, registryId: string, xIdempotencyKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling containerProjectRegistryStop.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling containerProjectRegistryStop.');
            }
            // verify required parameter 'registryId' is not null or undefined
            if (registryId === null || registryId === undefined) {
                throw new RequiredError('registryId','Required parameter registryId was null or undefined when calling containerProjectRegistryStop.');
            }
            const localVarPath = `/container/{locationId}/project/{projectId}/registry/{registryId}/actions/stop`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"registryId"}}`, encodeURIComponent(String(registryId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create container/registry.tag
         * @summary Create container/registry.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryTagCreate: async (projectId: string, locationId: string, registryId: string, tag: Tag, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling containerProjectRegistryTagCreate.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling containerProjectRegistryTagCreate.');
            }
            // verify required parameter 'registryId' is not null or undefined
            if (registryId === null || registryId === undefined) {
                throw new RequiredError('registryId','Required parameter registryId was null or undefined when calling containerProjectRegistryTagCreate.');
            }
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling containerProjectRegistryTagCreate.');
            }
            const localVarPath = `/container/{locationId}/project/{projectId}/registry/{registryId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"registryId"}}`, encodeURIComponent(String(registryId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof tag !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(tag !== undefined ? tag : {}) : (tag || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete container/registry.tag
         * @summary Delete container/registry.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryTagDelete: async (projectId: string, locationId: string, registryId: string, tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling containerProjectRegistryTagDelete.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling containerProjectRegistryTagDelete.');
            }
            // verify required parameter 'registryId' is not null or undefined
            if (registryId === null || registryId === undefined) {
                throw new RequiredError('registryId','Required parameter registryId was null or undefined when calling containerProjectRegistryTagDelete.');
            }
            // verify required parameter 'tagId' is not null or undefined
            if (tagId === null || tagId === undefined) {
                throw new RequiredError('tagId','Required parameter tagId was null or undefined when calling containerProjectRegistryTagDelete.');
            }
            const localVarPath = `/container/{locationId}/project/{projectId}/registry/{registryId}/tag/{tagId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"registryId"}}`, encodeURIComponent(String(registryId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get container/registry.tag
         * @summary Get container/registry.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryTagGet: async (projectId: string, locationId: string, registryId: string, tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling containerProjectRegistryTagGet.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling containerProjectRegistryTagGet.');
            }
            // verify required parameter 'registryId' is not null or undefined
            if (registryId === null || registryId === undefined) {
                throw new RequiredError('registryId','Required parameter registryId was null or undefined when calling containerProjectRegistryTagGet.');
            }
            // verify required parameter 'tagId' is not null or undefined
            if (tagId === null || tagId === undefined) {
                throw new RequiredError('tagId','Required parameter tagId was null or undefined when calling containerProjectRegistryTagGet.');
            }
            const localVarPath = `/container/{locationId}/project/{projectId}/registry/{registryId}/tag/{tagId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"registryId"}}`, encodeURIComponent(String(registryId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List container/registry.tag
         * @summary List container/registry.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryTagList: async (projectId: string, locationId: string, registryId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling containerProjectRegistryTagList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling containerProjectRegistryTagList.');
            }
            // verify required parameter 'registryId' is not null or undefined
            if (registryId === null || registryId === undefined) {
                throw new RequiredError('registryId','Required parameter registryId was null or undefined when calling containerProjectRegistryTagList.');
            }
            const localVarPath = `/container/{locationId}/project/{projectId}/registry/{registryId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"registryId"}}`, encodeURIComponent(String(registryId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replace container/registry.tag
         * @summary Replace container/registry.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryTagPut: async (projectId: string, locationId: string, registryId: string, tag: Array<Tag>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling containerProjectRegistryTagPut.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling containerProjectRegistryTagPut.');
            }
            // verify required parameter 'registryId' is not null or undefined
            if (registryId === null || registryId === undefined) {
                throw new RequiredError('registryId','Required parameter registryId was null or undefined when calling containerProjectRegistryTagPut.');
            }
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling containerProjectRegistryTagPut.');
            }
            const localVarPath = `/container/{locationId}/project/{projectId}/registry/{registryId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"registryId"}}`, encodeURIComponent(String(registryId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof tag !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(tag !== undefined ? tag : {}) : (tag || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * action transfer
         * @summary Transfer container/registry
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {ContainerProjectRegistryTransfer} containerProjectRegistryTransfer 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryTransfer: async (projectId: string, locationId: string, registryId: string, containerProjectRegistryTransfer: ContainerProjectRegistryTransfer, xIdempotencyKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling containerProjectRegistryTransfer.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling containerProjectRegistryTransfer.');
            }
            // verify required parameter 'registryId' is not null or undefined
            if (registryId === null || registryId === undefined) {
                throw new RequiredError('registryId','Required parameter registryId was null or undefined when calling containerProjectRegistryTransfer.');
            }
            // verify required parameter 'containerProjectRegistryTransfer' is not null or undefined
            if (containerProjectRegistryTransfer === null || containerProjectRegistryTransfer === undefined) {
                throw new RequiredError('containerProjectRegistryTransfer','Required parameter containerProjectRegistryTransfer was null or undefined when calling containerProjectRegistryTransfer.');
            }
            const localVarPath = `/container/{locationId}/project/{projectId}/registry/{registryId}/actions/transfer`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"registryId"}}`, encodeURIComponent(String(registryId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof containerProjectRegistryTransfer !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(containerProjectRegistryTransfer !== undefined ? containerProjectRegistryTransfer : {}) : (containerProjectRegistryTransfer || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns modified registry
         * @summary Update container/registry
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {ContainerProjectRegistryUpdate} containerProjectRegistryUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryUpdate: async (projectId: string, locationId: string, registryId: string, containerProjectRegistryUpdate: ContainerProjectRegistryUpdate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling containerProjectRegistryUpdate.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling containerProjectRegistryUpdate.');
            }
            // verify required parameter 'registryId' is not null or undefined
            if (registryId === null || registryId === undefined) {
                throw new RequiredError('registryId','Required parameter registryId was null or undefined when calling containerProjectRegistryUpdate.');
            }
            // verify required parameter 'containerProjectRegistryUpdate' is not null or undefined
            if (containerProjectRegistryUpdate === null || containerProjectRegistryUpdate === undefined) {
                throw new RequiredError('containerProjectRegistryUpdate','Required parameter containerProjectRegistryUpdate was null or undefined when calling containerProjectRegistryUpdate.');
            }
            const localVarPath = `/container/{locationId}/project/{projectId}/registry/{registryId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"registryId"}}`, encodeURIComponent(String(registryId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof containerProjectRegistryUpdate !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(containerProjectRegistryUpdate !== undefined ? containerProjectRegistryUpdate : {}) : (containerProjectRegistryUpdate || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContainerProjectRegistryApi - functional programming interface
 * @export
 */
export const ContainerProjectRegistryApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create registry
         * @summary Create container/registry
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {ContainerProjectRegistryCreate} containerProjectRegistryCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async containerProjectRegistryCreate(projectId: string, locationId: string, containerProjectRegistryCreate: ContainerProjectRegistryCreate, xIdempotencyKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Registry>> {
            const localVarAxiosArgs = await ContainerProjectRegistryApiAxiosParamCreator(configuration).containerProjectRegistryCreate(projectId, locationId, containerProjectRegistryCreate, xIdempotencyKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create container/registry.credential
         * @summary Create container/registry.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {RegistryCredential} registryCredential 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async containerProjectRegistryCredentialCreate(projectId: string, locationId: string, registryId: string, registryCredential: RegistryCredential, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegistryCredential>> {
            const localVarAxiosArgs = await ContainerProjectRegistryApiAxiosParamCreator(configuration).containerProjectRegistryCredentialCreate(projectId, locationId, registryId, registryCredential, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete container/registry.credential
         * @summary Delete container/registry.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {string} credentialId credentialId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async containerProjectRegistryCredentialDelete(projectId: string, locationId: string, registryId: string, credentialId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Registry>> {
            const localVarAxiosArgs = await ContainerProjectRegistryApiAxiosParamCreator(configuration).containerProjectRegistryCredentialDelete(projectId, locationId, registryId, credentialId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get container/registry.credential
         * @summary Get container/registry.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {string} credentialId credentialId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async containerProjectRegistryCredentialGet(projectId: string, locationId: string, registryId: string, credentialId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegistryCredential>> {
            const localVarAxiosArgs = await ContainerProjectRegistryApiAxiosParamCreator(configuration).containerProjectRegistryCredentialGet(projectId, locationId, registryId, credentialId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List container/registry.credential
         * @summary List container/registry.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async containerProjectRegistryCredentialList(projectId: string, locationId: string, registryId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RegistryCredential>>> {
            const localVarAxiosArgs = await ContainerProjectRegistryApiAxiosParamCreator(configuration).containerProjectRegistryCredentialList(projectId, locationId, registryId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update container/registry.credential
         * @summary Update container/registry.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {string} credentialId credentialId
         * @param {ContainerProjectRegistryCredentialPatch} containerProjectRegistryCredentialPatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async containerProjectRegistryCredentialPatch(projectId: string, locationId: string, registryId: string, credentialId: string, containerProjectRegistryCredentialPatch: ContainerProjectRegistryCredentialPatch, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegistryCredential>> {
            const localVarAxiosArgs = await ContainerProjectRegistryApiAxiosParamCreator(configuration).containerProjectRegistryCredentialPatch(projectId, locationId, registryId, credentialId, containerProjectRegistryCredentialPatch, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete registry
         * @summary Delete container/registry
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async containerProjectRegistryDelete(projectId: string, locationId: string, registryId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ContainerProjectRegistryApiAxiosParamCreator(configuration).containerProjectRegistryDelete(projectId, locationId, registryId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create container/registry.domain
         * @summary Create container/registry.domain
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {Domain} domain 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async containerProjectRegistryDomainCreate(projectId: string, locationId: string, registryId: string, domain: Domain, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Domain>> {
            const localVarAxiosArgs = await ContainerProjectRegistryApiAxiosParamCreator(configuration).containerProjectRegistryDomainCreate(projectId, locationId, registryId, domain, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete container/registry.domain
         * @summary Delete container/registry.domain
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {string} domainId domainId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async containerProjectRegistryDomainDelete(projectId: string, locationId: string, registryId: string, domainId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ContainerProjectRegistryApiAxiosParamCreator(configuration).containerProjectRegistryDomainDelete(projectId, locationId, registryId, domainId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get container/registry.domain
         * @summary Get container/registry.domain
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {string} domainId domainId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async containerProjectRegistryDomainGet(projectId: string, locationId: string, registryId: string, domainId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Domain>> {
            const localVarAxiosArgs = await ContainerProjectRegistryApiAxiosParamCreator(configuration).containerProjectRegistryDomainGet(projectId, locationId, registryId, domainId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List container/registry.domain
         * @summary List container/registry.domain
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async containerProjectRegistryDomainList(projectId: string, locationId: string, registryId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Domain>>> {
            const localVarAxiosArgs = await ContainerProjectRegistryApiAxiosParamCreator(configuration).containerProjectRegistryDomainList(projectId, locationId, registryId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get container/registry.event
         * @summary Get container/registry.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async containerProjectRegistryEventGet(projectId: string, locationId: string, registryId: string, eventId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>> {
            const localVarAxiosArgs = await ContainerProjectRegistryApiAxiosParamCreator(configuration).containerProjectRegistryEventGet(projectId, locationId, registryId, eventId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List container/registry.event
         * @summary List container/registry.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async containerProjectRegistryEventList(projectId: string, locationId: string, registryId: string, $limit?: number, $skip?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Event>>> {
            const localVarAxiosArgs = await ContainerProjectRegistryApiAxiosParamCreator(configuration).containerProjectRegistryEventList(projectId, locationId, registryId, $limit, $skip, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a single registry
         * @summary Get container/registry
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async containerProjectRegistryGet(projectId: string, locationId: string, registryId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Registry>> {
            const localVarAxiosArgs = await ContainerProjectRegistryApiAxiosParamCreator(configuration).containerProjectRegistryGet(projectId, locationId, registryId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List registry
         * @summary List container/registry
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [name] Filter by name
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async containerProjectRegistryList(projectId: string, locationId: string, name?: string, tagValue?: string, tagKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Registry>>> {
            const localVarAxiosArgs = await ContainerProjectRegistryApiAxiosParamCreator(configuration).containerProjectRegistryList(projectId, locationId, name, tagValue, tagKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get container/registry.repository
         * @summary Get container/registry.repository
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {string} repositoryId repositoryId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async containerProjectRegistryRepositoryGet(projectId: string, locationId: string, registryId: string, repositoryId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerRepository>> {
            const localVarAxiosArgs = await ContainerProjectRegistryApiAxiosParamCreator(configuration).containerProjectRegistryRepositoryGet(projectId, locationId, registryId, repositoryId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete container/registry.image
         * @summary Delete container/registry.image
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {string} repositoryId repositoryId
         * @param {string} imageId imageId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async containerProjectRegistryRepositoryImageDelete(projectId: string, locationId: string, registryId: string, repositoryId: string, imageId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ContainerProjectRegistryApiAxiosParamCreator(configuration).containerProjectRegistryRepositoryImageDelete(projectId, locationId, registryId, repositoryId, imageId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get container/registry.image
         * @summary Get container/registry.image
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {string} repositoryId repositoryId
         * @param {string} imageId imageId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async containerProjectRegistryRepositoryImageGet(projectId: string, locationId: string, registryId: string, repositoryId: string, imageId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerImage>> {
            const localVarAxiosArgs = await ContainerProjectRegistryApiAxiosParamCreator(configuration).containerProjectRegistryRepositoryImageGet(projectId, locationId, registryId, repositoryId, imageId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List container/registry.image
         * @summary List container/registry.image
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {string} repositoryId repositoryId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async containerProjectRegistryRepositoryImageList(projectId: string, locationId: string, registryId: string, repositoryId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ContainerImage>>> {
            const localVarAxiosArgs = await ContainerProjectRegistryApiAxiosParamCreator(configuration).containerProjectRegistryRepositoryImageList(projectId, locationId, registryId, repositoryId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List container/registry.repository
         * @summary List container/registry.repository
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async containerProjectRegistryRepositoryList(projectId: string, locationId: string, registryId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ContainerRepository>>> {
            const localVarAxiosArgs = await ContainerProjectRegistryApiAxiosParamCreator(configuration).containerProjectRegistryRepositoryList(projectId, locationId, registryId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get container/registry.service
         * @summary Get container/registry.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async containerProjectRegistryServiceGet(projectId: string, locationId: string, registryId: string, serviceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceService>> {
            const localVarAxiosArgs = await ContainerProjectRegistryApiAxiosParamCreator(configuration).containerProjectRegistryServiceGet(projectId, locationId, registryId, serviceId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List container/registry.service
         * @summary List container/registry.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async containerProjectRegistryServiceList(projectId: string, locationId: string, registryId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResourceService>>> {
            const localVarAxiosArgs = await ContainerProjectRegistryApiAxiosParamCreator(configuration).containerProjectRegistryServiceList(projectId, locationId, registryId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * action start
         * @summary Start container/registry
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async containerProjectRegistryStart(projectId: string, locationId: string, registryId: string, xIdempotencyKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Registry>> {
            const localVarAxiosArgs = await ContainerProjectRegistryApiAxiosParamCreator(configuration).containerProjectRegistryStart(projectId, locationId, registryId, xIdempotencyKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * action stop
         * @summary Stop container/registry
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async containerProjectRegistryStop(projectId: string, locationId: string, registryId: string, xIdempotencyKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Registry>> {
            const localVarAxiosArgs = await ContainerProjectRegistryApiAxiosParamCreator(configuration).containerProjectRegistryStop(projectId, locationId, registryId, xIdempotencyKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create container/registry.tag
         * @summary Create container/registry.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async containerProjectRegistryTagCreate(projectId: string, locationId: string, registryId: string, tag: Tag, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await ContainerProjectRegistryApiAxiosParamCreator(configuration).containerProjectRegistryTagCreate(projectId, locationId, registryId, tag, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete container/registry.tag
         * @summary Delete container/registry.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async containerProjectRegistryTagDelete(projectId: string, locationId: string, registryId: string, tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ContainerProjectRegistryApiAxiosParamCreator(configuration).containerProjectRegistryTagDelete(projectId, locationId, registryId, tagId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get container/registry.tag
         * @summary Get container/registry.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async containerProjectRegistryTagGet(projectId: string, locationId: string, registryId: string, tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await ContainerProjectRegistryApiAxiosParamCreator(configuration).containerProjectRegistryTagGet(projectId, locationId, registryId, tagId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List container/registry.tag
         * @summary List container/registry.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async containerProjectRegistryTagList(projectId: string, locationId: string, registryId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await ContainerProjectRegistryApiAxiosParamCreator(configuration).containerProjectRegistryTagList(projectId, locationId, registryId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Replace container/registry.tag
         * @summary Replace container/registry.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async containerProjectRegistryTagPut(projectId: string, locationId: string, registryId: string, tag: Array<Tag>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await ContainerProjectRegistryApiAxiosParamCreator(configuration).containerProjectRegistryTagPut(projectId, locationId, registryId, tag, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * action transfer
         * @summary Transfer container/registry
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {ContainerProjectRegistryTransfer} containerProjectRegistryTransfer 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async containerProjectRegistryTransfer(projectId: string, locationId: string, registryId: string, containerProjectRegistryTransfer: ContainerProjectRegistryTransfer, xIdempotencyKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Registry>> {
            const localVarAxiosArgs = await ContainerProjectRegistryApiAxiosParamCreator(configuration).containerProjectRegistryTransfer(projectId, locationId, registryId, containerProjectRegistryTransfer, xIdempotencyKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns modified registry
         * @summary Update container/registry
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {ContainerProjectRegistryUpdate} containerProjectRegistryUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async containerProjectRegistryUpdate(projectId: string, locationId: string, registryId: string, containerProjectRegistryUpdate: ContainerProjectRegistryUpdate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Registry>> {
            const localVarAxiosArgs = await ContainerProjectRegistryApiAxiosParamCreator(configuration).containerProjectRegistryUpdate(projectId, locationId, registryId, containerProjectRegistryUpdate, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ContainerProjectRegistryApi - factory interface
 * @export
 */
export const ContainerProjectRegistryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Create registry
         * @summary Create container/registry
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {ContainerProjectRegistryCreate} containerProjectRegistryCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryCreate(projectId: string, locationId: string, containerProjectRegistryCreate: ContainerProjectRegistryCreate, xIdempotencyKey?: string, options?: any): AxiosPromise<Registry> {
            return ContainerProjectRegistryApiFp(configuration).containerProjectRegistryCreate(projectId, locationId, containerProjectRegistryCreate, xIdempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Create container/registry.credential
         * @summary Create container/registry.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {RegistryCredential} registryCredential 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryCredentialCreate(projectId: string, locationId: string, registryId: string, registryCredential: RegistryCredential, options?: any): AxiosPromise<RegistryCredential> {
            return ContainerProjectRegistryApiFp(configuration).containerProjectRegistryCredentialCreate(projectId, locationId, registryId, registryCredential, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete container/registry.credential
         * @summary Delete container/registry.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {string} credentialId credentialId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryCredentialDelete(projectId: string, locationId: string, registryId: string, credentialId: string, options?: any): AxiosPromise<Registry> {
            return ContainerProjectRegistryApiFp(configuration).containerProjectRegistryCredentialDelete(projectId, locationId, registryId, credentialId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get container/registry.credential
         * @summary Get container/registry.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {string} credentialId credentialId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryCredentialGet(projectId: string, locationId: string, registryId: string, credentialId: string, options?: any): AxiosPromise<RegistryCredential> {
            return ContainerProjectRegistryApiFp(configuration).containerProjectRegistryCredentialGet(projectId, locationId, registryId, credentialId, options).then((request) => request(axios, basePath));
        },
        /**
         * List container/registry.credential
         * @summary List container/registry.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryCredentialList(projectId: string, locationId: string, registryId: string, options?: any): AxiosPromise<Array<RegistryCredential>> {
            return ContainerProjectRegistryApiFp(configuration).containerProjectRegistryCredentialList(projectId, locationId, registryId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update container/registry.credential
         * @summary Update container/registry.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {string} credentialId credentialId
         * @param {ContainerProjectRegistryCredentialPatch} containerProjectRegistryCredentialPatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryCredentialPatch(projectId: string, locationId: string, registryId: string, credentialId: string, containerProjectRegistryCredentialPatch: ContainerProjectRegistryCredentialPatch, options?: any): AxiosPromise<RegistryCredential> {
            return ContainerProjectRegistryApiFp(configuration).containerProjectRegistryCredentialPatch(projectId, locationId, registryId, credentialId, containerProjectRegistryCredentialPatch, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete registry
         * @summary Delete container/registry
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryDelete(projectId: string, locationId: string, registryId: string, options?: any): AxiosPromise<void> {
            return ContainerProjectRegistryApiFp(configuration).containerProjectRegistryDelete(projectId, locationId, registryId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create container/registry.domain
         * @summary Create container/registry.domain
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {Domain} domain 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryDomainCreate(projectId: string, locationId: string, registryId: string, domain: Domain, options?: any): AxiosPromise<Domain> {
            return ContainerProjectRegistryApiFp(configuration).containerProjectRegistryDomainCreate(projectId, locationId, registryId, domain, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete container/registry.domain
         * @summary Delete container/registry.domain
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {string} domainId domainId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryDomainDelete(projectId: string, locationId: string, registryId: string, domainId: string, options?: any): AxiosPromise<void> {
            return ContainerProjectRegistryApiFp(configuration).containerProjectRegistryDomainDelete(projectId, locationId, registryId, domainId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get container/registry.domain
         * @summary Get container/registry.domain
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {string} domainId domainId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryDomainGet(projectId: string, locationId: string, registryId: string, domainId: string, options?: any): AxiosPromise<Domain> {
            return ContainerProjectRegistryApiFp(configuration).containerProjectRegistryDomainGet(projectId, locationId, registryId, domainId, options).then((request) => request(axios, basePath));
        },
        /**
         * List container/registry.domain
         * @summary List container/registry.domain
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryDomainList(projectId: string, locationId: string, registryId: string, options?: any): AxiosPromise<Array<Domain>> {
            return ContainerProjectRegistryApiFp(configuration).containerProjectRegistryDomainList(projectId, locationId, registryId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get container/registry.event
         * @summary Get container/registry.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryEventGet(projectId: string, locationId: string, registryId: string, eventId: string, options?: any): AxiosPromise<Event> {
            return ContainerProjectRegistryApiFp(configuration).containerProjectRegistryEventGet(projectId, locationId, registryId, eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * List container/registry.event
         * @summary List container/registry.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryEventList(projectId: string, locationId: string, registryId: string, $limit?: number, $skip?: number, options?: any): AxiosPromise<Array<Event>> {
            return ContainerProjectRegistryApiFp(configuration).containerProjectRegistryEventList(projectId, locationId, registryId, $limit, $skip, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single registry
         * @summary Get container/registry
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryGet(projectId: string, locationId: string, registryId: string, options?: any): AxiosPromise<Registry> {
            return ContainerProjectRegistryApiFp(configuration).containerProjectRegistryGet(projectId, locationId, registryId, options).then((request) => request(axios, basePath));
        },
        /**
         * List registry
         * @summary List container/registry
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [name] Filter by name
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryList(projectId: string, locationId: string, name?: string, tagValue?: string, tagKey?: string, options?: any): AxiosPromise<Array<Registry>> {
            return ContainerProjectRegistryApiFp(configuration).containerProjectRegistryList(projectId, locationId, name, tagValue, tagKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get container/registry.repository
         * @summary Get container/registry.repository
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {string} repositoryId repositoryId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryRepositoryGet(projectId: string, locationId: string, registryId: string, repositoryId: string, options?: any): AxiosPromise<ContainerRepository> {
            return ContainerProjectRegistryApiFp(configuration).containerProjectRegistryRepositoryGet(projectId, locationId, registryId, repositoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete container/registry.image
         * @summary Delete container/registry.image
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {string} repositoryId repositoryId
         * @param {string} imageId imageId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryRepositoryImageDelete(projectId: string, locationId: string, registryId: string, repositoryId: string, imageId: string, options?: any): AxiosPromise<void> {
            return ContainerProjectRegistryApiFp(configuration).containerProjectRegistryRepositoryImageDelete(projectId, locationId, registryId, repositoryId, imageId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get container/registry.image
         * @summary Get container/registry.image
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {string} repositoryId repositoryId
         * @param {string} imageId imageId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryRepositoryImageGet(projectId: string, locationId: string, registryId: string, repositoryId: string, imageId: string, options?: any): AxiosPromise<ContainerImage> {
            return ContainerProjectRegistryApiFp(configuration).containerProjectRegistryRepositoryImageGet(projectId, locationId, registryId, repositoryId, imageId, options).then((request) => request(axios, basePath));
        },
        /**
         * List container/registry.image
         * @summary List container/registry.image
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {string} repositoryId repositoryId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryRepositoryImageList(projectId: string, locationId: string, registryId: string, repositoryId: string, options?: any): AxiosPromise<Array<ContainerImage>> {
            return ContainerProjectRegistryApiFp(configuration).containerProjectRegistryRepositoryImageList(projectId, locationId, registryId, repositoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * List container/registry.repository
         * @summary List container/registry.repository
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryRepositoryList(projectId: string, locationId: string, registryId: string, options?: any): AxiosPromise<Array<ContainerRepository>> {
            return ContainerProjectRegistryApiFp(configuration).containerProjectRegistryRepositoryList(projectId, locationId, registryId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get container/registry.service
         * @summary Get container/registry.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryServiceGet(projectId: string, locationId: string, registryId: string, serviceId: string, options?: any): AxiosPromise<ResourceService> {
            return ContainerProjectRegistryApiFp(configuration).containerProjectRegistryServiceGet(projectId, locationId, registryId, serviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * List container/registry.service
         * @summary List container/registry.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryServiceList(projectId: string, locationId: string, registryId: string, options?: any): AxiosPromise<Array<ResourceService>> {
            return ContainerProjectRegistryApiFp(configuration).containerProjectRegistryServiceList(projectId, locationId, registryId, options).then((request) => request(axios, basePath));
        },
        /**
         * action start
         * @summary Start container/registry
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryStart(projectId: string, locationId: string, registryId: string, xIdempotencyKey?: string, options?: any): AxiosPromise<Registry> {
            return ContainerProjectRegistryApiFp(configuration).containerProjectRegistryStart(projectId, locationId, registryId, xIdempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * action stop
         * @summary Stop container/registry
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryStop(projectId: string, locationId: string, registryId: string, xIdempotencyKey?: string, options?: any): AxiosPromise<Registry> {
            return ContainerProjectRegistryApiFp(configuration).containerProjectRegistryStop(projectId, locationId, registryId, xIdempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Create container/registry.tag
         * @summary Create container/registry.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryTagCreate(projectId: string, locationId: string, registryId: string, tag: Tag, options?: any): AxiosPromise<Tag> {
            return ContainerProjectRegistryApiFp(configuration).containerProjectRegistryTagCreate(projectId, locationId, registryId, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete container/registry.tag
         * @summary Delete container/registry.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryTagDelete(projectId: string, locationId: string, registryId: string, tagId: string, options?: any): AxiosPromise<void> {
            return ContainerProjectRegistryApiFp(configuration).containerProjectRegistryTagDelete(projectId, locationId, registryId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get container/registry.tag
         * @summary Get container/registry.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryTagGet(projectId: string, locationId: string, registryId: string, tagId: string, options?: any): AxiosPromise<Tag> {
            return ContainerProjectRegistryApiFp(configuration).containerProjectRegistryTagGet(projectId, locationId, registryId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * List container/registry.tag
         * @summary List container/registry.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryTagList(projectId: string, locationId: string, registryId: string, options?: any): AxiosPromise<Array<Tag>> {
            return ContainerProjectRegistryApiFp(configuration).containerProjectRegistryTagList(projectId, locationId, registryId, options).then((request) => request(axios, basePath));
        },
        /**
         * Replace container/registry.tag
         * @summary Replace container/registry.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryTagPut(projectId: string, locationId: string, registryId: string, tag: Array<Tag>, options?: any): AxiosPromise<Array<Tag>> {
            return ContainerProjectRegistryApiFp(configuration).containerProjectRegistryTagPut(projectId, locationId, registryId, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * action transfer
         * @summary Transfer container/registry
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {ContainerProjectRegistryTransfer} containerProjectRegistryTransfer 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryTransfer(projectId: string, locationId: string, registryId: string, containerProjectRegistryTransfer: ContainerProjectRegistryTransfer, xIdempotencyKey?: string, options?: any): AxiosPromise<Registry> {
            return ContainerProjectRegistryApiFp(configuration).containerProjectRegistryTransfer(projectId, locationId, registryId, containerProjectRegistryTransfer, xIdempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns modified registry
         * @summary Update container/registry
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {ContainerProjectRegistryUpdate} containerProjectRegistryUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryUpdate(projectId: string, locationId: string, registryId: string, containerProjectRegistryUpdate: ContainerProjectRegistryUpdate, options?: any): AxiosPromise<Registry> {
            return ContainerProjectRegistryApiFp(configuration).containerProjectRegistryUpdate(projectId, locationId, registryId, containerProjectRegistryUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContainerProjectRegistryApi - object-oriented interface
 * @export
 * @class ContainerProjectRegistryApi
 * @extends {BaseAPI}
 */
export class ContainerProjectRegistryApi extends BaseAPI {
    /**
     * Create registry
     * @summary Create container/registry
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {ContainerProjectRegistryCreate} containerProjectRegistryCreate 
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerProjectRegistryApi
     */
    public containerProjectRegistryCreate(projectId: string, locationId: string, containerProjectRegistryCreate: ContainerProjectRegistryCreate, xIdempotencyKey?: string, options?: any) {
        return ContainerProjectRegistryApiFp(this.configuration).containerProjectRegistryCreate(projectId, locationId, containerProjectRegistryCreate, xIdempotencyKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create container/registry.credential
     * @summary Create container/registry.credential
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} registryId Registry Id
     * @param {RegistryCredential} registryCredential 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerProjectRegistryApi
     */
    public containerProjectRegistryCredentialCreate(projectId: string, locationId: string, registryId: string, registryCredential: RegistryCredential, options?: any) {
        return ContainerProjectRegistryApiFp(this.configuration).containerProjectRegistryCredentialCreate(projectId, locationId, registryId, registryCredential, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete container/registry.credential
     * @summary Delete container/registry.credential
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} registryId Registry Id
     * @param {string} credentialId credentialId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerProjectRegistryApi
     */
    public containerProjectRegistryCredentialDelete(projectId: string, locationId: string, registryId: string, credentialId: string, options?: any) {
        return ContainerProjectRegistryApiFp(this.configuration).containerProjectRegistryCredentialDelete(projectId, locationId, registryId, credentialId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get container/registry.credential
     * @summary Get container/registry.credential
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} registryId Registry Id
     * @param {string} credentialId credentialId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerProjectRegistryApi
     */
    public containerProjectRegistryCredentialGet(projectId: string, locationId: string, registryId: string, credentialId: string, options?: any) {
        return ContainerProjectRegistryApiFp(this.configuration).containerProjectRegistryCredentialGet(projectId, locationId, registryId, credentialId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List container/registry.credential
     * @summary List container/registry.credential
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} registryId Registry Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerProjectRegistryApi
     */
    public containerProjectRegistryCredentialList(projectId: string, locationId: string, registryId: string, options?: any) {
        return ContainerProjectRegistryApiFp(this.configuration).containerProjectRegistryCredentialList(projectId, locationId, registryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update container/registry.credential
     * @summary Update container/registry.credential
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} registryId Registry Id
     * @param {string} credentialId credentialId
     * @param {ContainerProjectRegistryCredentialPatch} containerProjectRegistryCredentialPatch 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerProjectRegistryApi
     */
    public containerProjectRegistryCredentialPatch(projectId: string, locationId: string, registryId: string, credentialId: string, containerProjectRegistryCredentialPatch: ContainerProjectRegistryCredentialPatch, options?: any) {
        return ContainerProjectRegistryApiFp(this.configuration).containerProjectRegistryCredentialPatch(projectId, locationId, registryId, credentialId, containerProjectRegistryCredentialPatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete registry
     * @summary Delete container/registry
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} registryId Registry Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerProjectRegistryApi
     */
    public containerProjectRegistryDelete(projectId: string, locationId: string, registryId: string, options?: any) {
        return ContainerProjectRegistryApiFp(this.configuration).containerProjectRegistryDelete(projectId, locationId, registryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create container/registry.domain
     * @summary Create container/registry.domain
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} registryId Registry Id
     * @param {Domain} domain 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerProjectRegistryApi
     */
    public containerProjectRegistryDomainCreate(projectId: string, locationId: string, registryId: string, domain: Domain, options?: any) {
        return ContainerProjectRegistryApiFp(this.configuration).containerProjectRegistryDomainCreate(projectId, locationId, registryId, domain, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete container/registry.domain
     * @summary Delete container/registry.domain
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} registryId Registry Id
     * @param {string} domainId domainId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerProjectRegistryApi
     */
    public containerProjectRegistryDomainDelete(projectId: string, locationId: string, registryId: string, domainId: string, options?: any) {
        return ContainerProjectRegistryApiFp(this.configuration).containerProjectRegistryDomainDelete(projectId, locationId, registryId, domainId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get container/registry.domain
     * @summary Get container/registry.domain
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} registryId Registry Id
     * @param {string} domainId domainId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerProjectRegistryApi
     */
    public containerProjectRegistryDomainGet(projectId: string, locationId: string, registryId: string, domainId: string, options?: any) {
        return ContainerProjectRegistryApiFp(this.configuration).containerProjectRegistryDomainGet(projectId, locationId, registryId, domainId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List container/registry.domain
     * @summary List container/registry.domain
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} registryId Registry Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerProjectRegistryApi
     */
    public containerProjectRegistryDomainList(projectId: string, locationId: string, registryId: string, options?: any) {
        return ContainerProjectRegistryApiFp(this.configuration).containerProjectRegistryDomainList(projectId, locationId, registryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get container/registry.event
     * @summary Get container/registry.event
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} registryId Registry Id
     * @param {string} eventId eventId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerProjectRegistryApi
     */
    public containerProjectRegistryEventGet(projectId: string, locationId: string, registryId: string, eventId: string, options?: any) {
        return ContainerProjectRegistryApiFp(this.configuration).containerProjectRegistryEventGet(projectId, locationId, registryId, eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List container/registry.event
     * @summary List container/registry.event
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} registryId Registry Id
     * @param {number} [$limit] $limit
     * @param {number} [$skip] $skip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerProjectRegistryApi
     */
    public containerProjectRegistryEventList(projectId: string, locationId: string, registryId: string, $limit?: number, $skip?: number, options?: any) {
        return ContainerProjectRegistryApiFp(this.configuration).containerProjectRegistryEventList(projectId, locationId, registryId, $limit, $skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single registry
     * @summary Get container/registry
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} registryId Registry Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerProjectRegistryApi
     */
    public containerProjectRegistryGet(projectId: string, locationId: string, registryId: string, options?: any) {
        return ContainerProjectRegistryApiFp(this.configuration).containerProjectRegistryGet(projectId, locationId, registryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List registry
     * @summary List container/registry
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} [name] Filter by name
     * @param {string} [tagValue] Filter by tag.value
     * @param {string} [tagKey] Filter by tag.key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerProjectRegistryApi
     */
    public containerProjectRegistryList(projectId: string, locationId: string, name?: string, tagValue?: string, tagKey?: string, options?: any) {
        return ContainerProjectRegistryApiFp(this.configuration).containerProjectRegistryList(projectId, locationId, name, tagValue, tagKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get container/registry.repository
     * @summary Get container/registry.repository
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} registryId Registry Id
     * @param {string} repositoryId repositoryId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerProjectRegistryApi
     */
    public containerProjectRegistryRepositoryGet(projectId: string, locationId: string, registryId: string, repositoryId: string, options?: any) {
        return ContainerProjectRegistryApiFp(this.configuration).containerProjectRegistryRepositoryGet(projectId, locationId, registryId, repositoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete container/registry.image
     * @summary Delete container/registry.image
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} registryId Registry Id
     * @param {string} repositoryId repositoryId
     * @param {string} imageId imageId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerProjectRegistryApi
     */
    public containerProjectRegistryRepositoryImageDelete(projectId: string, locationId: string, registryId: string, repositoryId: string, imageId: string, options?: any) {
        return ContainerProjectRegistryApiFp(this.configuration).containerProjectRegistryRepositoryImageDelete(projectId, locationId, registryId, repositoryId, imageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get container/registry.image
     * @summary Get container/registry.image
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} registryId Registry Id
     * @param {string} repositoryId repositoryId
     * @param {string} imageId imageId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerProjectRegistryApi
     */
    public containerProjectRegistryRepositoryImageGet(projectId: string, locationId: string, registryId: string, repositoryId: string, imageId: string, options?: any) {
        return ContainerProjectRegistryApiFp(this.configuration).containerProjectRegistryRepositoryImageGet(projectId, locationId, registryId, repositoryId, imageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List container/registry.image
     * @summary List container/registry.image
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} registryId Registry Id
     * @param {string} repositoryId repositoryId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerProjectRegistryApi
     */
    public containerProjectRegistryRepositoryImageList(projectId: string, locationId: string, registryId: string, repositoryId: string, options?: any) {
        return ContainerProjectRegistryApiFp(this.configuration).containerProjectRegistryRepositoryImageList(projectId, locationId, registryId, repositoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List container/registry.repository
     * @summary List container/registry.repository
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} registryId Registry Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerProjectRegistryApi
     */
    public containerProjectRegistryRepositoryList(projectId: string, locationId: string, registryId: string, options?: any) {
        return ContainerProjectRegistryApiFp(this.configuration).containerProjectRegistryRepositoryList(projectId, locationId, registryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get container/registry.service
     * @summary Get container/registry.service
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} registryId Registry Id
     * @param {string} serviceId serviceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerProjectRegistryApi
     */
    public containerProjectRegistryServiceGet(projectId: string, locationId: string, registryId: string, serviceId: string, options?: any) {
        return ContainerProjectRegistryApiFp(this.configuration).containerProjectRegistryServiceGet(projectId, locationId, registryId, serviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List container/registry.service
     * @summary List container/registry.service
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} registryId Registry Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerProjectRegistryApi
     */
    public containerProjectRegistryServiceList(projectId: string, locationId: string, registryId: string, options?: any) {
        return ContainerProjectRegistryApiFp(this.configuration).containerProjectRegistryServiceList(projectId, locationId, registryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * action start
     * @summary Start container/registry
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} registryId Registry Id
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerProjectRegistryApi
     */
    public containerProjectRegistryStart(projectId: string, locationId: string, registryId: string, xIdempotencyKey?: string, options?: any) {
        return ContainerProjectRegistryApiFp(this.configuration).containerProjectRegistryStart(projectId, locationId, registryId, xIdempotencyKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * action stop
     * @summary Stop container/registry
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} registryId Registry Id
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerProjectRegistryApi
     */
    public containerProjectRegistryStop(projectId: string, locationId: string, registryId: string, xIdempotencyKey?: string, options?: any) {
        return ContainerProjectRegistryApiFp(this.configuration).containerProjectRegistryStop(projectId, locationId, registryId, xIdempotencyKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create container/registry.tag
     * @summary Create container/registry.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} registryId Registry Id
     * @param {Tag} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerProjectRegistryApi
     */
    public containerProjectRegistryTagCreate(projectId: string, locationId: string, registryId: string, tag: Tag, options?: any) {
        return ContainerProjectRegistryApiFp(this.configuration).containerProjectRegistryTagCreate(projectId, locationId, registryId, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete container/registry.tag
     * @summary Delete container/registry.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} registryId Registry Id
     * @param {string} tagId tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerProjectRegistryApi
     */
    public containerProjectRegistryTagDelete(projectId: string, locationId: string, registryId: string, tagId: string, options?: any) {
        return ContainerProjectRegistryApiFp(this.configuration).containerProjectRegistryTagDelete(projectId, locationId, registryId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get container/registry.tag
     * @summary Get container/registry.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} registryId Registry Id
     * @param {string} tagId tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerProjectRegistryApi
     */
    public containerProjectRegistryTagGet(projectId: string, locationId: string, registryId: string, tagId: string, options?: any) {
        return ContainerProjectRegistryApiFp(this.configuration).containerProjectRegistryTagGet(projectId, locationId, registryId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List container/registry.tag
     * @summary List container/registry.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} registryId Registry Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerProjectRegistryApi
     */
    public containerProjectRegistryTagList(projectId: string, locationId: string, registryId: string, options?: any) {
        return ContainerProjectRegistryApiFp(this.configuration).containerProjectRegistryTagList(projectId, locationId, registryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replace container/registry.tag
     * @summary Replace container/registry.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} registryId Registry Id
     * @param {Array<Tag>} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerProjectRegistryApi
     */
    public containerProjectRegistryTagPut(projectId: string, locationId: string, registryId: string, tag: Array<Tag>, options?: any) {
        return ContainerProjectRegistryApiFp(this.configuration).containerProjectRegistryTagPut(projectId, locationId, registryId, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * action transfer
     * @summary Transfer container/registry
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} registryId Registry Id
     * @param {ContainerProjectRegistryTransfer} containerProjectRegistryTransfer 
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerProjectRegistryApi
     */
    public containerProjectRegistryTransfer(projectId: string, locationId: string, registryId: string, containerProjectRegistryTransfer: ContainerProjectRegistryTransfer, xIdempotencyKey?: string, options?: any) {
        return ContainerProjectRegistryApiFp(this.configuration).containerProjectRegistryTransfer(projectId, locationId, registryId, containerProjectRegistryTransfer, xIdempotencyKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns modified registry
     * @summary Update container/registry
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} registryId Registry Id
     * @param {ContainerProjectRegistryUpdate} containerProjectRegistryUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerProjectRegistryApi
     */
    public containerProjectRegistryUpdate(projectId: string, locationId: string, registryId: string, containerProjectRegistryUpdate: ContainerProjectRegistryUpdate, options?: any) {
        return ContainerProjectRegistryApiFp(this.configuration).containerProjectRegistryUpdate(projectId, locationId, registryId, containerProjectRegistryUpdate, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * DatabaseProjectInstanceApi - axios parameter creator
 * @export
 */
export const DatabaseProjectInstanceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get database/instance.connect
         * @summary Get database/instance.connect
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} connectId connectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseProjectInstanceConnectGet: async (projectId: string, locationId: string, instanceId: string, connectId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling databaseProjectInstanceConnectGet.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling databaseProjectInstanceConnectGet.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling databaseProjectInstanceConnectGet.');
            }
            // verify required parameter 'connectId' is not null or undefined
            if (connectId === null || connectId === undefined) {
                throw new RequiredError('connectId','Required parameter connectId was null or undefined when calling databaseProjectInstanceConnectGet.');
            }
            const localVarPath = `/database/{locationId}/project/{projectId}/instance/{instanceId}/connect/{connectId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"connectId"}}`, encodeURIComponent(String(connectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List database/instance.connect
         * @summary List database/instance.connect
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseProjectInstanceConnectList: async (projectId: string, locationId: string, instanceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling databaseProjectInstanceConnectList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling databaseProjectInstanceConnectList.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling databaseProjectInstanceConnectList.');
            }
            const localVarPath = `/database/{locationId}/project/{projectId}/instance/{instanceId}/connect`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create instance
         * @summary Create database/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {DatabaseProjectInstanceCreate} databaseProjectInstanceCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseProjectInstanceCreate: async (projectId: string, locationId: string, databaseProjectInstanceCreate: DatabaseProjectInstanceCreate, xIdempotencyKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling databaseProjectInstanceCreate.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling databaseProjectInstanceCreate.');
            }
            // verify required parameter 'databaseProjectInstanceCreate' is not null or undefined
            if (databaseProjectInstanceCreate === null || databaseProjectInstanceCreate === undefined) {
                throw new RequiredError('databaseProjectInstanceCreate','Required parameter databaseProjectInstanceCreate was null or undefined when calling databaseProjectInstanceCreate.');
            }
            const localVarPath = `/database/{locationId}/project/{projectId}/instance`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof databaseProjectInstanceCreate !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(databaseProjectInstanceCreate !== undefined ? databaseProjectInstanceCreate : {}) : (databaseProjectInstanceCreate || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create database/instance.credential
         * @summary Create database/instance.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {DatabaseCredential} databaseCredential 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseProjectInstanceCredentialCreate: async (projectId: string, locationId: string, instanceId: string, databaseCredential: DatabaseCredential, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling databaseProjectInstanceCredentialCreate.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling databaseProjectInstanceCredentialCreate.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling databaseProjectInstanceCredentialCreate.');
            }
            // verify required parameter 'databaseCredential' is not null or undefined
            if (databaseCredential === null || databaseCredential === undefined) {
                throw new RequiredError('databaseCredential','Required parameter databaseCredential was null or undefined when calling databaseProjectInstanceCredentialCreate.');
            }
            const localVarPath = `/database/{locationId}/project/{projectId}/instance/{instanceId}/credential`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof databaseCredential !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(databaseCredential !== undefined ? databaseCredential : {}) : (databaseCredential || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete database/instance.credential
         * @summary Delete database/instance.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} credentialId credentialId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseProjectInstanceCredentialDelete: async (projectId: string, locationId: string, instanceId: string, credentialId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling databaseProjectInstanceCredentialDelete.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling databaseProjectInstanceCredentialDelete.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling databaseProjectInstanceCredentialDelete.');
            }
            // verify required parameter 'credentialId' is not null or undefined
            if (credentialId === null || credentialId === undefined) {
                throw new RequiredError('credentialId','Required parameter credentialId was null or undefined when calling databaseProjectInstanceCredentialDelete.');
            }
            const localVarPath = `/database/{locationId}/project/{projectId}/instance/{instanceId}/credential/{credentialId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"credentialId"}}`, encodeURIComponent(String(credentialId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get database/instance.credential
         * @summary Get database/instance.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} credentialId credentialId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseProjectInstanceCredentialGet: async (projectId: string, locationId: string, instanceId: string, credentialId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling databaseProjectInstanceCredentialGet.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling databaseProjectInstanceCredentialGet.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling databaseProjectInstanceCredentialGet.');
            }
            // verify required parameter 'credentialId' is not null or undefined
            if (credentialId === null || credentialId === undefined) {
                throw new RequiredError('credentialId','Required parameter credentialId was null or undefined when calling databaseProjectInstanceCredentialGet.');
            }
            const localVarPath = `/database/{locationId}/project/{projectId}/instance/{instanceId}/credential/{credentialId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"credentialId"}}`, encodeURIComponent(String(credentialId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List database/instance.credential
         * @summary List database/instance.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseProjectInstanceCredentialList: async (projectId: string, locationId: string, instanceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling databaseProjectInstanceCredentialList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling databaseProjectInstanceCredentialList.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling databaseProjectInstanceCredentialList.');
            }
            const localVarPath = `/database/{locationId}/project/{projectId}/instance/{instanceId}/credential`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update database/instance.credential
         * @summary Update database/instance.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} credentialId credentialId
         * @param {DatabaseProjectInstanceCredentialPatch} databaseProjectInstanceCredentialPatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseProjectInstanceCredentialPatch: async (projectId: string, locationId: string, instanceId: string, credentialId: string, databaseProjectInstanceCredentialPatch: DatabaseProjectInstanceCredentialPatch, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling databaseProjectInstanceCredentialPatch.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling databaseProjectInstanceCredentialPatch.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling databaseProjectInstanceCredentialPatch.');
            }
            // verify required parameter 'credentialId' is not null or undefined
            if (credentialId === null || credentialId === undefined) {
                throw new RequiredError('credentialId','Required parameter credentialId was null or undefined when calling databaseProjectInstanceCredentialPatch.');
            }
            // verify required parameter 'databaseProjectInstanceCredentialPatch' is not null or undefined
            if (databaseProjectInstanceCredentialPatch === null || databaseProjectInstanceCredentialPatch === undefined) {
                throw new RequiredError('databaseProjectInstanceCredentialPatch','Required parameter databaseProjectInstanceCredentialPatch was null or undefined when calling databaseProjectInstanceCredentialPatch.');
            }
            const localVarPath = `/database/{locationId}/project/{projectId}/instance/{instanceId}/credential/{credentialId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"credentialId"}}`, encodeURIComponent(String(credentialId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof databaseProjectInstanceCredentialPatch !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(databaseProjectInstanceCredentialPatch !== undefined ? databaseProjectInstanceCredentialPatch : {}) : (databaseProjectInstanceCredentialPatch || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete instance
         * @summary Delete database/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseProjectInstanceDelete: async (projectId: string, locationId: string, instanceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling databaseProjectInstanceDelete.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling databaseProjectInstanceDelete.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling databaseProjectInstanceDelete.');
            }
            const localVarPath = `/database/{locationId}/project/{projectId}/instance/{instanceId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get database/instance.event
         * @summary Get database/instance.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseProjectInstanceEventGet: async (projectId: string, locationId: string, instanceId: string, eventId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling databaseProjectInstanceEventGet.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling databaseProjectInstanceEventGet.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling databaseProjectInstanceEventGet.');
            }
            // verify required parameter 'eventId' is not null or undefined
            if (eventId === null || eventId === undefined) {
                throw new RequiredError('eventId','Required parameter eventId was null or undefined when calling databaseProjectInstanceEventGet.');
            }
            const localVarPath = `/database/{locationId}/project/{projectId}/instance/{instanceId}/event/{eventId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List database/instance.event
         * @summary List database/instance.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseProjectInstanceEventList: async (projectId: string, locationId: string, instanceId: string, $limit?: number, $skip?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling databaseProjectInstanceEventList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling databaseProjectInstanceEventList.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling databaseProjectInstanceEventList.');
            }
            const localVarPath = `/database/{locationId}/project/{projectId}/instance/{instanceId}/event`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if ($limit !== undefined) {
                localVarQueryParameter['$limit'] = $limit;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single instance
         * @summary Get database/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseProjectInstanceGet: async (projectId: string, locationId: string, instanceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling databaseProjectInstanceGet.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling databaseProjectInstanceGet.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling databaseProjectInstanceGet.');
            }
            const localVarPath = `/database/{locationId}/project/{projectId}/instance/{instanceId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List instance
         * @summary List database/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [name] Filter by name
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseProjectInstanceList: async (projectId: string, locationId: string, name?: string, tagValue?: string, tagKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling databaseProjectInstanceList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling databaseProjectInstanceList.');
            }
            const localVarPath = `/database/{locationId}/project/{projectId}/instance`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (tagValue !== undefined) {
                localVarQueryParameter['tag.value'] = tagValue;
            }

            if (tagKey !== undefined) {
                localVarQueryParameter['tag.key'] = tagKey;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get database/instance.service
         * @summary Get database/instance.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseProjectInstanceServiceGet: async (projectId: string, locationId: string, instanceId: string, serviceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling databaseProjectInstanceServiceGet.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling databaseProjectInstanceServiceGet.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling databaseProjectInstanceServiceGet.');
            }
            // verify required parameter 'serviceId' is not null or undefined
            if (serviceId === null || serviceId === undefined) {
                throw new RequiredError('serviceId','Required parameter serviceId was null or undefined when calling databaseProjectInstanceServiceGet.');
            }
            const localVarPath = `/database/{locationId}/project/{projectId}/instance/{instanceId}/service/{serviceId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List database/instance.service
         * @summary List database/instance.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseProjectInstanceServiceList: async (projectId: string, locationId: string, instanceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling databaseProjectInstanceServiceList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling databaseProjectInstanceServiceList.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling databaseProjectInstanceServiceList.');
            }
            const localVarPath = `/database/{locationId}/project/{projectId}/instance/{instanceId}/service`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * action start
         * @summary Start database/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseProjectInstanceStart: async (projectId: string, locationId: string, instanceId: string, xIdempotencyKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling databaseProjectInstanceStart.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling databaseProjectInstanceStart.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling databaseProjectInstanceStart.');
            }
            const localVarPath = `/database/{locationId}/project/{projectId}/instance/{instanceId}/actions/start`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * action stop
         * @summary Stop database/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseProjectInstanceStop: async (projectId: string, locationId: string, instanceId: string, xIdempotencyKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling databaseProjectInstanceStop.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling databaseProjectInstanceStop.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling databaseProjectInstanceStop.');
            }
            const localVarPath = `/database/{locationId}/project/{projectId}/instance/{instanceId}/actions/stop`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create database/instance.tag
         * @summary Create database/instance.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseProjectInstanceTagCreate: async (projectId: string, locationId: string, instanceId: string, tag: Tag, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling databaseProjectInstanceTagCreate.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling databaseProjectInstanceTagCreate.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling databaseProjectInstanceTagCreate.');
            }
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling databaseProjectInstanceTagCreate.');
            }
            const localVarPath = `/database/{locationId}/project/{projectId}/instance/{instanceId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof tag !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(tag !== undefined ? tag : {}) : (tag || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete database/instance.tag
         * @summary Delete database/instance.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseProjectInstanceTagDelete: async (projectId: string, locationId: string, instanceId: string, tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling databaseProjectInstanceTagDelete.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling databaseProjectInstanceTagDelete.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling databaseProjectInstanceTagDelete.');
            }
            // verify required parameter 'tagId' is not null or undefined
            if (tagId === null || tagId === undefined) {
                throw new RequiredError('tagId','Required parameter tagId was null or undefined when calling databaseProjectInstanceTagDelete.');
            }
            const localVarPath = `/database/{locationId}/project/{projectId}/instance/{instanceId}/tag/{tagId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get database/instance.tag
         * @summary Get database/instance.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseProjectInstanceTagGet: async (projectId: string, locationId: string, instanceId: string, tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling databaseProjectInstanceTagGet.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling databaseProjectInstanceTagGet.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling databaseProjectInstanceTagGet.');
            }
            // verify required parameter 'tagId' is not null or undefined
            if (tagId === null || tagId === undefined) {
                throw new RequiredError('tagId','Required parameter tagId was null or undefined when calling databaseProjectInstanceTagGet.');
            }
            const localVarPath = `/database/{locationId}/project/{projectId}/instance/{instanceId}/tag/{tagId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List database/instance.tag
         * @summary List database/instance.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseProjectInstanceTagList: async (projectId: string, locationId: string, instanceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling databaseProjectInstanceTagList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling databaseProjectInstanceTagList.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling databaseProjectInstanceTagList.');
            }
            const localVarPath = `/database/{locationId}/project/{projectId}/instance/{instanceId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replace database/instance.tag
         * @summary Replace database/instance.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseProjectInstanceTagPut: async (projectId: string, locationId: string, instanceId: string, tag: Array<Tag>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling databaseProjectInstanceTagPut.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling databaseProjectInstanceTagPut.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling databaseProjectInstanceTagPut.');
            }
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling databaseProjectInstanceTagPut.');
            }
            const localVarPath = `/database/{locationId}/project/{projectId}/instance/{instanceId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof tag !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(tag !== undefined ? tag : {}) : (tag || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * action transfer
         * @summary Transfer database/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {DatabaseProjectInstanceTransfer} databaseProjectInstanceTransfer 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseProjectInstanceTransfer: async (projectId: string, locationId: string, instanceId: string, databaseProjectInstanceTransfer: DatabaseProjectInstanceTransfer, xIdempotencyKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling databaseProjectInstanceTransfer.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling databaseProjectInstanceTransfer.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling databaseProjectInstanceTransfer.');
            }
            // verify required parameter 'databaseProjectInstanceTransfer' is not null or undefined
            if (databaseProjectInstanceTransfer === null || databaseProjectInstanceTransfer === undefined) {
                throw new RequiredError('databaseProjectInstanceTransfer','Required parameter databaseProjectInstanceTransfer was null or undefined when calling databaseProjectInstanceTransfer.');
            }
            const localVarPath = `/database/{locationId}/project/{projectId}/instance/{instanceId}/actions/transfer`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof databaseProjectInstanceTransfer !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(databaseProjectInstanceTransfer !== undefined ? databaseProjectInstanceTransfer : {}) : (databaseProjectInstanceTransfer || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns modified instance
         * @summary Update database/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {DatabaseProjectInstanceUpdate} databaseProjectInstanceUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseProjectInstanceUpdate: async (projectId: string, locationId: string, instanceId: string, databaseProjectInstanceUpdate: DatabaseProjectInstanceUpdate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling databaseProjectInstanceUpdate.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling databaseProjectInstanceUpdate.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling databaseProjectInstanceUpdate.');
            }
            // verify required parameter 'databaseProjectInstanceUpdate' is not null or undefined
            if (databaseProjectInstanceUpdate === null || databaseProjectInstanceUpdate === undefined) {
                throw new RequiredError('databaseProjectInstanceUpdate','Required parameter databaseProjectInstanceUpdate was null or undefined when calling databaseProjectInstanceUpdate.');
            }
            const localVarPath = `/database/{locationId}/project/{projectId}/instance/{instanceId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof databaseProjectInstanceUpdate !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(databaseProjectInstanceUpdate !== undefined ? databaseProjectInstanceUpdate : {}) : (databaseProjectInstanceUpdate || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DatabaseProjectInstanceApi - functional programming interface
 * @export
 */
export const DatabaseProjectInstanceApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get database/instance.connect
         * @summary Get database/instance.connect
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} connectId connectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async databaseProjectInstanceConnectGet(projectId: string, locationId: string, instanceId: string, connectId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceConnect>> {
            const localVarAxiosArgs = await DatabaseProjectInstanceApiAxiosParamCreator(configuration).databaseProjectInstanceConnectGet(projectId, locationId, instanceId, connectId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List database/instance.connect
         * @summary List database/instance.connect
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async databaseProjectInstanceConnectList(projectId: string, locationId: string, instanceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResourceConnect>>> {
            const localVarAxiosArgs = await DatabaseProjectInstanceApiAxiosParamCreator(configuration).databaseProjectInstanceConnectList(projectId, locationId, instanceId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create instance
         * @summary Create database/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {DatabaseProjectInstanceCreate} databaseProjectInstanceCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async databaseProjectInstanceCreate(projectId: string, locationId: string, databaseProjectInstanceCreate: DatabaseProjectInstanceCreate, xIdempotencyKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Database>> {
            const localVarAxiosArgs = await DatabaseProjectInstanceApiAxiosParamCreator(configuration).databaseProjectInstanceCreate(projectId, locationId, databaseProjectInstanceCreate, xIdempotencyKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create database/instance.credential
         * @summary Create database/instance.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {DatabaseCredential} databaseCredential 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async databaseProjectInstanceCredentialCreate(projectId: string, locationId: string, instanceId: string, databaseCredential: DatabaseCredential, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DatabaseCredential>> {
            const localVarAxiosArgs = await DatabaseProjectInstanceApiAxiosParamCreator(configuration).databaseProjectInstanceCredentialCreate(projectId, locationId, instanceId, databaseCredential, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete database/instance.credential
         * @summary Delete database/instance.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} credentialId credentialId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async databaseProjectInstanceCredentialDelete(projectId: string, locationId: string, instanceId: string, credentialId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Database>> {
            const localVarAxiosArgs = await DatabaseProjectInstanceApiAxiosParamCreator(configuration).databaseProjectInstanceCredentialDelete(projectId, locationId, instanceId, credentialId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get database/instance.credential
         * @summary Get database/instance.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} credentialId credentialId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async databaseProjectInstanceCredentialGet(projectId: string, locationId: string, instanceId: string, credentialId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DatabaseCredential>> {
            const localVarAxiosArgs = await DatabaseProjectInstanceApiAxiosParamCreator(configuration).databaseProjectInstanceCredentialGet(projectId, locationId, instanceId, credentialId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List database/instance.credential
         * @summary List database/instance.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async databaseProjectInstanceCredentialList(projectId: string, locationId: string, instanceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DatabaseCredential>>> {
            const localVarAxiosArgs = await DatabaseProjectInstanceApiAxiosParamCreator(configuration).databaseProjectInstanceCredentialList(projectId, locationId, instanceId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update database/instance.credential
         * @summary Update database/instance.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} credentialId credentialId
         * @param {DatabaseProjectInstanceCredentialPatch} databaseProjectInstanceCredentialPatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async databaseProjectInstanceCredentialPatch(projectId: string, locationId: string, instanceId: string, credentialId: string, databaseProjectInstanceCredentialPatch: DatabaseProjectInstanceCredentialPatch, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DatabaseCredential>> {
            const localVarAxiosArgs = await DatabaseProjectInstanceApiAxiosParamCreator(configuration).databaseProjectInstanceCredentialPatch(projectId, locationId, instanceId, credentialId, databaseProjectInstanceCredentialPatch, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete instance
         * @summary Delete database/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async databaseProjectInstanceDelete(projectId: string, locationId: string, instanceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DatabaseProjectInstanceApiAxiosParamCreator(configuration).databaseProjectInstanceDelete(projectId, locationId, instanceId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get database/instance.event
         * @summary Get database/instance.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async databaseProjectInstanceEventGet(projectId: string, locationId: string, instanceId: string, eventId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>> {
            const localVarAxiosArgs = await DatabaseProjectInstanceApiAxiosParamCreator(configuration).databaseProjectInstanceEventGet(projectId, locationId, instanceId, eventId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List database/instance.event
         * @summary List database/instance.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async databaseProjectInstanceEventList(projectId: string, locationId: string, instanceId: string, $limit?: number, $skip?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Event>>> {
            const localVarAxiosArgs = await DatabaseProjectInstanceApiAxiosParamCreator(configuration).databaseProjectInstanceEventList(projectId, locationId, instanceId, $limit, $skip, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a single instance
         * @summary Get database/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async databaseProjectInstanceGet(projectId: string, locationId: string, instanceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Database>> {
            const localVarAxiosArgs = await DatabaseProjectInstanceApiAxiosParamCreator(configuration).databaseProjectInstanceGet(projectId, locationId, instanceId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List instance
         * @summary List database/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [name] Filter by name
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async databaseProjectInstanceList(projectId: string, locationId: string, name?: string, tagValue?: string, tagKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Database>>> {
            const localVarAxiosArgs = await DatabaseProjectInstanceApiAxiosParamCreator(configuration).databaseProjectInstanceList(projectId, locationId, name, tagValue, tagKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get database/instance.service
         * @summary Get database/instance.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async databaseProjectInstanceServiceGet(projectId: string, locationId: string, instanceId: string, serviceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceService>> {
            const localVarAxiosArgs = await DatabaseProjectInstanceApiAxiosParamCreator(configuration).databaseProjectInstanceServiceGet(projectId, locationId, instanceId, serviceId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List database/instance.service
         * @summary List database/instance.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async databaseProjectInstanceServiceList(projectId: string, locationId: string, instanceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResourceService>>> {
            const localVarAxiosArgs = await DatabaseProjectInstanceApiAxiosParamCreator(configuration).databaseProjectInstanceServiceList(projectId, locationId, instanceId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * action start
         * @summary Start database/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async databaseProjectInstanceStart(projectId: string, locationId: string, instanceId: string, xIdempotencyKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Database>> {
            const localVarAxiosArgs = await DatabaseProjectInstanceApiAxiosParamCreator(configuration).databaseProjectInstanceStart(projectId, locationId, instanceId, xIdempotencyKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * action stop
         * @summary Stop database/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async databaseProjectInstanceStop(projectId: string, locationId: string, instanceId: string, xIdempotencyKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Database>> {
            const localVarAxiosArgs = await DatabaseProjectInstanceApiAxiosParamCreator(configuration).databaseProjectInstanceStop(projectId, locationId, instanceId, xIdempotencyKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create database/instance.tag
         * @summary Create database/instance.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async databaseProjectInstanceTagCreate(projectId: string, locationId: string, instanceId: string, tag: Tag, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await DatabaseProjectInstanceApiAxiosParamCreator(configuration).databaseProjectInstanceTagCreate(projectId, locationId, instanceId, tag, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete database/instance.tag
         * @summary Delete database/instance.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async databaseProjectInstanceTagDelete(projectId: string, locationId: string, instanceId: string, tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DatabaseProjectInstanceApiAxiosParamCreator(configuration).databaseProjectInstanceTagDelete(projectId, locationId, instanceId, tagId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get database/instance.tag
         * @summary Get database/instance.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async databaseProjectInstanceTagGet(projectId: string, locationId: string, instanceId: string, tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await DatabaseProjectInstanceApiAxiosParamCreator(configuration).databaseProjectInstanceTagGet(projectId, locationId, instanceId, tagId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List database/instance.tag
         * @summary List database/instance.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async databaseProjectInstanceTagList(projectId: string, locationId: string, instanceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await DatabaseProjectInstanceApiAxiosParamCreator(configuration).databaseProjectInstanceTagList(projectId, locationId, instanceId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Replace database/instance.tag
         * @summary Replace database/instance.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async databaseProjectInstanceTagPut(projectId: string, locationId: string, instanceId: string, tag: Array<Tag>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await DatabaseProjectInstanceApiAxiosParamCreator(configuration).databaseProjectInstanceTagPut(projectId, locationId, instanceId, tag, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * action transfer
         * @summary Transfer database/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {DatabaseProjectInstanceTransfer} databaseProjectInstanceTransfer 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async databaseProjectInstanceTransfer(projectId: string, locationId: string, instanceId: string, databaseProjectInstanceTransfer: DatabaseProjectInstanceTransfer, xIdempotencyKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Database>> {
            const localVarAxiosArgs = await DatabaseProjectInstanceApiAxiosParamCreator(configuration).databaseProjectInstanceTransfer(projectId, locationId, instanceId, databaseProjectInstanceTransfer, xIdempotencyKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns modified instance
         * @summary Update database/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {DatabaseProjectInstanceUpdate} databaseProjectInstanceUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async databaseProjectInstanceUpdate(projectId: string, locationId: string, instanceId: string, databaseProjectInstanceUpdate: DatabaseProjectInstanceUpdate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Database>> {
            const localVarAxiosArgs = await DatabaseProjectInstanceApiAxiosParamCreator(configuration).databaseProjectInstanceUpdate(projectId, locationId, instanceId, databaseProjectInstanceUpdate, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * DatabaseProjectInstanceApi - factory interface
 * @export
 */
export const DatabaseProjectInstanceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Get database/instance.connect
         * @summary Get database/instance.connect
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} connectId connectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseProjectInstanceConnectGet(projectId: string, locationId: string, instanceId: string, connectId: string, options?: any): AxiosPromise<ResourceConnect> {
            return DatabaseProjectInstanceApiFp(configuration).databaseProjectInstanceConnectGet(projectId, locationId, instanceId, connectId, options).then((request) => request(axios, basePath));
        },
        /**
         * List database/instance.connect
         * @summary List database/instance.connect
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseProjectInstanceConnectList(projectId: string, locationId: string, instanceId: string, options?: any): AxiosPromise<Array<ResourceConnect>> {
            return DatabaseProjectInstanceApiFp(configuration).databaseProjectInstanceConnectList(projectId, locationId, instanceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create instance
         * @summary Create database/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {DatabaseProjectInstanceCreate} databaseProjectInstanceCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseProjectInstanceCreate(projectId: string, locationId: string, databaseProjectInstanceCreate: DatabaseProjectInstanceCreate, xIdempotencyKey?: string, options?: any): AxiosPromise<Database> {
            return DatabaseProjectInstanceApiFp(configuration).databaseProjectInstanceCreate(projectId, locationId, databaseProjectInstanceCreate, xIdempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Create database/instance.credential
         * @summary Create database/instance.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {DatabaseCredential} databaseCredential 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseProjectInstanceCredentialCreate(projectId: string, locationId: string, instanceId: string, databaseCredential: DatabaseCredential, options?: any): AxiosPromise<DatabaseCredential> {
            return DatabaseProjectInstanceApiFp(configuration).databaseProjectInstanceCredentialCreate(projectId, locationId, instanceId, databaseCredential, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete database/instance.credential
         * @summary Delete database/instance.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} credentialId credentialId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseProjectInstanceCredentialDelete(projectId: string, locationId: string, instanceId: string, credentialId: string, options?: any): AxiosPromise<Database> {
            return DatabaseProjectInstanceApiFp(configuration).databaseProjectInstanceCredentialDelete(projectId, locationId, instanceId, credentialId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get database/instance.credential
         * @summary Get database/instance.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} credentialId credentialId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseProjectInstanceCredentialGet(projectId: string, locationId: string, instanceId: string, credentialId: string, options?: any): AxiosPromise<DatabaseCredential> {
            return DatabaseProjectInstanceApiFp(configuration).databaseProjectInstanceCredentialGet(projectId, locationId, instanceId, credentialId, options).then((request) => request(axios, basePath));
        },
        /**
         * List database/instance.credential
         * @summary List database/instance.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseProjectInstanceCredentialList(projectId: string, locationId: string, instanceId: string, options?: any): AxiosPromise<Array<DatabaseCredential>> {
            return DatabaseProjectInstanceApiFp(configuration).databaseProjectInstanceCredentialList(projectId, locationId, instanceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update database/instance.credential
         * @summary Update database/instance.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} credentialId credentialId
         * @param {DatabaseProjectInstanceCredentialPatch} databaseProjectInstanceCredentialPatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseProjectInstanceCredentialPatch(projectId: string, locationId: string, instanceId: string, credentialId: string, databaseProjectInstanceCredentialPatch: DatabaseProjectInstanceCredentialPatch, options?: any): AxiosPromise<DatabaseCredential> {
            return DatabaseProjectInstanceApiFp(configuration).databaseProjectInstanceCredentialPatch(projectId, locationId, instanceId, credentialId, databaseProjectInstanceCredentialPatch, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete instance
         * @summary Delete database/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseProjectInstanceDelete(projectId: string, locationId: string, instanceId: string, options?: any): AxiosPromise<void> {
            return DatabaseProjectInstanceApiFp(configuration).databaseProjectInstanceDelete(projectId, locationId, instanceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get database/instance.event
         * @summary Get database/instance.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseProjectInstanceEventGet(projectId: string, locationId: string, instanceId: string, eventId: string, options?: any): AxiosPromise<Event> {
            return DatabaseProjectInstanceApiFp(configuration).databaseProjectInstanceEventGet(projectId, locationId, instanceId, eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * List database/instance.event
         * @summary List database/instance.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseProjectInstanceEventList(projectId: string, locationId: string, instanceId: string, $limit?: number, $skip?: number, options?: any): AxiosPromise<Array<Event>> {
            return DatabaseProjectInstanceApiFp(configuration).databaseProjectInstanceEventList(projectId, locationId, instanceId, $limit, $skip, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single instance
         * @summary Get database/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseProjectInstanceGet(projectId: string, locationId: string, instanceId: string, options?: any): AxiosPromise<Database> {
            return DatabaseProjectInstanceApiFp(configuration).databaseProjectInstanceGet(projectId, locationId, instanceId, options).then((request) => request(axios, basePath));
        },
        /**
         * List instance
         * @summary List database/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [name] Filter by name
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseProjectInstanceList(projectId: string, locationId: string, name?: string, tagValue?: string, tagKey?: string, options?: any): AxiosPromise<Array<Database>> {
            return DatabaseProjectInstanceApiFp(configuration).databaseProjectInstanceList(projectId, locationId, name, tagValue, tagKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get database/instance.service
         * @summary Get database/instance.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseProjectInstanceServiceGet(projectId: string, locationId: string, instanceId: string, serviceId: string, options?: any): AxiosPromise<ResourceService> {
            return DatabaseProjectInstanceApiFp(configuration).databaseProjectInstanceServiceGet(projectId, locationId, instanceId, serviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * List database/instance.service
         * @summary List database/instance.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseProjectInstanceServiceList(projectId: string, locationId: string, instanceId: string, options?: any): AxiosPromise<Array<ResourceService>> {
            return DatabaseProjectInstanceApiFp(configuration).databaseProjectInstanceServiceList(projectId, locationId, instanceId, options).then((request) => request(axios, basePath));
        },
        /**
         * action start
         * @summary Start database/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseProjectInstanceStart(projectId: string, locationId: string, instanceId: string, xIdempotencyKey?: string, options?: any): AxiosPromise<Database> {
            return DatabaseProjectInstanceApiFp(configuration).databaseProjectInstanceStart(projectId, locationId, instanceId, xIdempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * action stop
         * @summary Stop database/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseProjectInstanceStop(projectId: string, locationId: string, instanceId: string, xIdempotencyKey?: string, options?: any): AxiosPromise<Database> {
            return DatabaseProjectInstanceApiFp(configuration).databaseProjectInstanceStop(projectId, locationId, instanceId, xIdempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Create database/instance.tag
         * @summary Create database/instance.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseProjectInstanceTagCreate(projectId: string, locationId: string, instanceId: string, tag: Tag, options?: any): AxiosPromise<Tag> {
            return DatabaseProjectInstanceApiFp(configuration).databaseProjectInstanceTagCreate(projectId, locationId, instanceId, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete database/instance.tag
         * @summary Delete database/instance.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseProjectInstanceTagDelete(projectId: string, locationId: string, instanceId: string, tagId: string, options?: any): AxiosPromise<void> {
            return DatabaseProjectInstanceApiFp(configuration).databaseProjectInstanceTagDelete(projectId, locationId, instanceId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get database/instance.tag
         * @summary Get database/instance.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseProjectInstanceTagGet(projectId: string, locationId: string, instanceId: string, tagId: string, options?: any): AxiosPromise<Tag> {
            return DatabaseProjectInstanceApiFp(configuration).databaseProjectInstanceTagGet(projectId, locationId, instanceId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * List database/instance.tag
         * @summary List database/instance.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseProjectInstanceTagList(projectId: string, locationId: string, instanceId: string, options?: any): AxiosPromise<Array<Tag>> {
            return DatabaseProjectInstanceApiFp(configuration).databaseProjectInstanceTagList(projectId, locationId, instanceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Replace database/instance.tag
         * @summary Replace database/instance.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseProjectInstanceTagPut(projectId: string, locationId: string, instanceId: string, tag: Array<Tag>, options?: any): AxiosPromise<Array<Tag>> {
            return DatabaseProjectInstanceApiFp(configuration).databaseProjectInstanceTagPut(projectId, locationId, instanceId, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * action transfer
         * @summary Transfer database/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {DatabaseProjectInstanceTransfer} databaseProjectInstanceTransfer 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseProjectInstanceTransfer(projectId: string, locationId: string, instanceId: string, databaseProjectInstanceTransfer: DatabaseProjectInstanceTransfer, xIdempotencyKey?: string, options?: any): AxiosPromise<Database> {
            return DatabaseProjectInstanceApiFp(configuration).databaseProjectInstanceTransfer(projectId, locationId, instanceId, databaseProjectInstanceTransfer, xIdempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns modified instance
         * @summary Update database/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {DatabaseProjectInstanceUpdate} databaseProjectInstanceUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseProjectInstanceUpdate(projectId: string, locationId: string, instanceId: string, databaseProjectInstanceUpdate: DatabaseProjectInstanceUpdate, options?: any): AxiosPromise<Database> {
            return DatabaseProjectInstanceApiFp(configuration).databaseProjectInstanceUpdate(projectId, locationId, instanceId, databaseProjectInstanceUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DatabaseProjectInstanceApi - object-oriented interface
 * @export
 * @class DatabaseProjectInstanceApi
 * @extends {BaseAPI}
 */
export class DatabaseProjectInstanceApi extends BaseAPI {
    /**
     * Get database/instance.connect
     * @summary Get database/instance.connect
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {string} connectId connectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseProjectInstanceApi
     */
    public databaseProjectInstanceConnectGet(projectId: string, locationId: string, instanceId: string, connectId: string, options?: any) {
        return DatabaseProjectInstanceApiFp(this.configuration).databaseProjectInstanceConnectGet(projectId, locationId, instanceId, connectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List database/instance.connect
     * @summary List database/instance.connect
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseProjectInstanceApi
     */
    public databaseProjectInstanceConnectList(projectId: string, locationId: string, instanceId: string, options?: any) {
        return DatabaseProjectInstanceApiFp(this.configuration).databaseProjectInstanceConnectList(projectId, locationId, instanceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create instance
     * @summary Create database/instance
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {DatabaseProjectInstanceCreate} databaseProjectInstanceCreate 
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseProjectInstanceApi
     */
    public databaseProjectInstanceCreate(projectId: string, locationId: string, databaseProjectInstanceCreate: DatabaseProjectInstanceCreate, xIdempotencyKey?: string, options?: any) {
        return DatabaseProjectInstanceApiFp(this.configuration).databaseProjectInstanceCreate(projectId, locationId, databaseProjectInstanceCreate, xIdempotencyKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create database/instance.credential
     * @summary Create database/instance.credential
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {DatabaseCredential} databaseCredential 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseProjectInstanceApi
     */
    public databaseProjectInstanceCredentialCreate(projectId: string, locationId: string, instanceId: string, databaseCredential: DatabaseCredential, options?: any) {
        return DatabaseProjectInstanceApiFp(this.configuration).databaseProjectInstanceCredentialCreate(projectId, locationId, instanceId, databaseCredential, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete database/instance.credential
     * @summary Delete database/instance.credential
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {string} credentialId credentialId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseProjectInstanceApi
     */
    public databaseProjectInstanceCredentialDelete(projectId: string, locationId: string, instanceId: string, credentialId: string, options?: any) {
        return DatabaseProjectInstanceApiFp(this.configuration).databaseProjectInstanceCredentialDelete(projectId, locationId, instanceId, credentialId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get database/instance.credential
     * @summary Get database/instance.credential
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {string} credentialId credentialId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseProjectInstanceApi
     */
    public databaseProjectInstanceCredentialGet(projectId: string, locationId: string, instanceId: string, credentialId: string, options?: any) {
        return DatabaseProjectInstanceApiFp(this.configuration).databaseProjectInstanceCredentialGet(projectId, locationId, instanceId, credentialId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List database/instance.credential
     * @summary List database/instance.credential
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseProjectInstanceApi
     */
    public databaseProjectInstanceCredentialList(projectId: string, locationId: string, instanceId: string, options?: any) {
        return DatabaseProjectInstanceApiFp(this.configuration).databaseProjectInstanceCredentialList(projectId, locationId, instanceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update database/instance.credential
     * @summary Update database/instance.credential
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {string} credentialId credentialId
     * @param {DatabaseProjectInstanceCredentialPatch} databaseProjectInstanceCredentialPatch 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseProjectInstanceApi
     */
    public databaseProjectInstanceCredentialPatch(projectId: string, locationId: string, instanceId: string, credentialId: string, databaseProjectInstanceCredentialPatch: DatabaseProjectInstanceCredentialPatch, options?: any) {
        return DatabaseProjectInstanceApiFp(this.configuration).databaseProjectInstanceCredentialPatch(projectId, locationId, instanceId, credentialId, databaseProjectInstanceCredentialPatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete instance
     * @summary Delete database/instance
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseProjectInstanceApi
     */
    public databaseProjectInstanceDelete(projectId: string, locationId: string, instanceId: string, options?: any) {
        return DatabaseProjectInstanceApiFp(this.configuration).databaseProjectInstanceDelete(projectId, locationId, instanceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get database/instance.event
     * @summary Get database/instance.event
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {string} eventId eventId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseProjectInstanceApi
     */
    public databaseProjectInstanceEventGet(projectId: string, locationId: string, instanceId: string, eventId: string, options?: any) {
        return DatabaseProjectInstanceApiFp(this.configuration).databaseProjectInstanceEventGet(projectId, locationId, instanceId, eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List database/instance.event
     * @summary List database/instance.event
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {number} [$limit] $limit
     * @param {number} [$skip] $skip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseProjectInstanceApi
     */
    public databaseProjectInstanceEventList(projectId: string, locationId: string, instanceId: string, $limit?: number, $skip?: number, options?: any) {
        return DatabaseProjectInstanceApiFp(this.configuration).databaseProjectInstanceEventList(projectId, locationId, instanceId, $limit, $skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single instance
     * @summary Get database/instance
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseProjectInstanceApi
     */
    public databaseProjectInstanceGet(projectId: string, locationId: string, instanceId: string, options?: any) {
        return DatabaseProjectInstanceApiFp(this.configuration).databaseProjectInstanceGet(projectId, locationId, instanceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List instance
     * @summary List database/instance
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} [name] Filter by name
     * @param {string} [tagValue] Filter by tag.value
     * @param {string} [tagKey] Filter by tag.key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseProjectInstanceApi
     */
    public databaseProjectInstanceList(projectId: string, locationId: string, name?: string, tagValue?: string, tagKey?: string, options?: any) {
        return DatabaseProjectInstanceApiFp(this.configuration).databaseProjectInstanceList(projectId, locationId, name, tagValue, tagKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get database/instance.service
     * @summary Get database/instance.service
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {string} serviceId serviceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseProjectInstanceApi
     */
    public databaseProjectInstanceServiceGet(projectId: string, locationId: string, instanceId: string, serviceId: string, options?: any) {
        return DatabaseProjectInstanceApiFp(this.configuration).databaseProjectInstanceServiceGet(projectId, locationId, instanceId, serviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List database/instance.service
     * @summary List database/instance.service
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseProjectInstanceApi
     */
    public databaseProjectInstanceServiceList(projectId: string, locationId: string, instanceId: string, options?: any) {
        return DatabaseProjectInstanceApiFp(this.configuration).databaseProjectInstanceServiceList(projectId, locationId, instanceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * action start
     * @summary Start database/instance
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseProjectInstanceApi
     */
    public databaseProjectInstanceStart(projectId: string, locationId: string, instanceId: string, xIdempotencyKey?: string, options?: any) {
        return DatabaseProjectInstanceApiFp(this.configuration).databaseProjectInstanceStart(projectId, locationId, instanceId, xIdempotencyKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * action stop
     * @summary Stop database/instance
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseProjectInstanceApi
     */
    public databaseProjectInstanceStop(projectId: string, locationId: string, instanceId: string, xIdempotencyKey?: string, options?: any) {
        return DatabaseProjectInstanceApiFp(this.configuration).databaseProjectInstanceStop(projectId, locationId, instanceId, xIdempotencyKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create database/instance.tag
     * @summary Create database/instance.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {Tag} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseProjectInstanceApi
     */
    public databaseProjectInstanceTagCreate(projectId: string, locationId: string, instanceId: string, tag: Tag, options?: any) {
        return DatabaseProjectInstanceApiFp(this.configuration).databaseProjectInstanceTagCreate(projectId, locationId, instanceId, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete database/instance.tag
     * @summary Delete database/instance.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {string} tagId tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseProjectInstanceApi
     */
    public databaseProjectInstanceTagDelete(projectId: string, locationId: string, instanceId: string, tagId: string, options?: any) {
        return DatabaseProjectInstanceApiFp(this.configuration).databaseProjectInstanceTagDelete(projectId, locationId, instanceId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get database/instance.tag
     * @summary Get database/instance.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {string} tagId tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseProjectInstanceApi
     */
    public databaseProjectInstanceTagGet(projectId: string, locationId: string, instanceId: string, tagId: string, options?: any) {
        return DatabaseProjectInstanceApiFp(this.configuration).databaseProjectInstanceTagGet(projectId, locationId, instanceId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List database/instance.tag
     * @summary List database/instance.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseProjectInstanceApi
     */
    public databaseProjectInstanceTagList(projectId: string, locationId: string, instanceId: string, options?: any) {
        return DatabaseProjectInstanceApiFp(this.configuration).databaseProjectInstanceTagList(projectId, locationId, instanceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replace database/instance.tag
     * @summary Replace database/instance.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {Array<Tag>} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseProjectInstanceApi
     */
    public databaseProjectInstanceTagPut(projectId: string, locationId: string, instanceId: string, tag: Array<Tag>, options?: any) {
        return DatabaseProjectInstanceApiFp(this.configuration).databaseProjectInstanceTagPut(projectId, locationId, instanceId, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * action transfer
     * @summary Transfer database/instance
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {DatabaseProjectInstanceTransfer} databaseProjectInstanceTransfer 
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseProjectInstanceApi
     */
    public databaseProjectInstanceTransfer(projectId: string, locationId: string, instanceId: string, databaseProjectInstanceTransfer: DatabaseProjectInstanceTransfer, xIdempotencyKey?: string, options?: any) {
        return DatabaseProjectInstanceApiFp(this.configuration).databaseProjectInstanceTransfer(projectId, locationId, instanceId, databaseProjectInstanceTransfer, xIdempotencyKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns modified instance
     * @summary Update database/instance
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {DatabaseProjectInstanceUpdate} databaseProjectInstanceUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseProjectInstanceApi
     */
    public databaseProjectInstanceUpdate(projectId: string, locationId: string, instanceId: string, databaseProjectInstanceUpdate: DatabaseProjectInstanceUpdate, options?: any) {
        return DatabaseProjectInstanceApiFp(this.configuration).databaseProjectInstanceUpdate(projectId, locationId, instanceId, databaseProjectInstanceUpdate, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * DnsProjectZoneApi - axios parameter creator
 * @export
 */
export const DnsProjectZoneApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create zone
         * @summary Create dns/zone
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {DnsProjectZoneCreate} dnsProjectZoneCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dnsProjectZoneCreate: async (projectId: string, locationId: string, dnsProjectZoneCreate: DnsProjectZoneCreate, xIdempotencyKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling dnsProjectZoneCreate.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling dnsProjectZoneCreate.');
            }
            // verify required parameter 'dnsProjectZoneCreate' is not null or undefined
            if (dnsProjectZoneCreate === null || dnsProjectZoneCreate === undefined) {
                throw new RequiredError('dnsProjectZoneCreate','Required parameter dnsProjectZoneCreate was null or undefined when calling dnsProjectZoneCreate.');
            }
            const localVarPath = `/dns/{locationId}/project/{projectId}/zone`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof dnsProjectZoneCreate !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(dnsProjectZoneCreate !== undefined ? dnsProjectZoneCreate : {}) : (dnsProjectZoneCreate || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete zone
         * @summary Delete dns/zone
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dnsProjectZoneDelete: async (projectId: string, locationId: string, zoneId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling dnsProjectZoneDelete.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling dnsProjectZoneDelete.');
            }
            // verify required parameter 'zoneId' is not null or undefined
            if (zoneId === null || zoneId === undefined) {
                throw new RequiredError('zoneId','Required parameter zoneId was null or undefined when calling dnsProjectZoneDelete.');
            }
            const localVarPath = `/dns/{locationId}/project/{projectId}/zone/{zoneId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"zoneId"}}`, encodeURIComponent(String(zoneId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get dns/zone.event
         * @summary Get dns/zone.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dnsProjectZoneEventGet: async (projectId: string, locationId: string, zoneId: string, eventId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling dnsProjectZoneEventGet.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling dnsProjectZoneEventGet.');
            }
            // verify required parameter 'zoneId' is not null or undefined
            if (zoneId === null || zoneId === undefined) {
                throw new RequiredError('zoneId','Required parameter zoneId was null or undefined when calling dnsProjectZoneEventGet.');
            }
            // verify required parameter 'eventId' is not null or undefined
            if (eventId === null || eventId === undefined) {
                throw new RequiredError('eventId','Required parameter eventId was null or undefined when calling dnsProjectZoneEventGet.');
            }
            const localVarPath = `/dns/{locationId}/project/{projectId}/zone/{zoneId}/event/{eventId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"zoneId"}}`, encodeURIComponent(String(zoneId)))
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List dns/zone.event
         * @summary List dns/zone.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dnsProjectZoneEventList: async (projectId: string, locationId: string, zoneId: string, $limit?: number, $skip?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling dnsProjectZoneEventList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling dnsProjectZoneEventList.');
            }
            // verify required parameter 'zoneId' is not null or undefined
            if (zoneId === null || zoneId === undefined) {
                throw new RequiredError('zoneId','Required parameter zoneId was null or undefined when calling dnsProjectZoneEventList.');
            }
            const localVarPath = `/dns/{locationId}/project/{projectId}/zone/{zoneId}/event`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"zoneId"}}`, encodeURIComponent(String(zoneId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if ($limit !== undefined) {
                localVarQueryParameter['$limit'] = $limit;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single zone
         * @summary Get dns/zone
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dnsProjectZoneGet: async (projectId: string, locationId: string, zoneId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling dnsProjectZoneGet.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling dnsProjectZoneGet.');
            }
            // verify required parameter 'zoneId' is not null or undefined
            if (zoneId === null || zoneId === undefined) {
                throw new RequiredError('zoneId','Required parameter zoneId was null or undefined when calling dnsProjectZoneGet.');
            }
            const localVarPath = `/dns/{locationId}/project/{projectId}/zone/{zoneId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"zoneId"}}`, encodeURIComponent(String(zoneId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List zone
         * @summary List dns/zone
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [name] Filter by name
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dnsProjectZoneList: async (projectId: string, locationId: string, name?: string, tagValue?: string, tagKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling dnsProjectZoneList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling dnsProjectZoneList.');
            }
            const localVarPath = `/dns/{locationId}/project/{projectId}/zone`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (tagValue !== undefined) {
                localVarQueryParameter['tag.value'] = tagValue;
            }

            if (tagKey !== undefined) {
                localVarQueryParameter['tag.key'] = tagKey;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create dns/zone.recordset
         * @summary Create dns/zone.recordset
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {DnsRecordset} dnsRecordset 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dnsProjectZoneRecordsetCreate: async (projectId: string, locationId: string, zoneId: string, dnsRecordset: DnsRecordset, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling dnsProjectZoneRecordsetCreate.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling dnsProjectZoneRecordsetCreate.');
            }
            // verify required parameter 'zoneId' is not null or undefined
            if (zoneId === null || zoneId === undefined) {
                throw new RequiredError('zoneId','Required parameter zoneId was null or undefined when calling dnsProjectZoneRecordsetCreate.');
            }
            // verify required parameter 'dnsRecordset' is not null or undefined
            if (dnsRecordset === null || dnsRecordset === undefined) {
                throw new RequiredError('dnsRecordset','Required parameter dnsRecordset was null or undefined when calling dnsProjectZoneRecordsetCreate.');
            }
            const localVarPath = `/dns/{locationId}/project/{projectId}/zone/{zoneId}/recordset`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"zoneId"}}`, encodeURIComponent(String(zoneId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof dnsRecordset !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(dnsRecordset !== undefined ? dnsRecordset : {}) : (dnsRecordset || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete dns/zone.recordset
         * @summary Delete dns/zone.recordset
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {string} recordsetId recordsetId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dnsProjectZoneRecordsetDelete: async (projectId: string, locationId: string, zoneId: string, recordsetId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling dnsProjectZoneRecordsetDelete.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling dnsProjectZoneRecordsetDelete.');
            }
            // verify required parameter 'zoneId' is not null or undefined
            if (zoneId === null || zoneId === undefined) {
                throw new RequiredError('zoneId','Required parameter zoneId was null or undefined when calling dnsProjectZoneRecordsetDelete.');
            }
            // verify required parameter 'recordsetId' is not null or undefined
            if (recordsetId === null || recordsetId === undefined) {
                throw new RequiredError('recordsetId','Required parameter recordsetId was null or undefined when calling dnsProjectZoneRecordsetDelete.');
            }
            const localVarPath = `/dns/{locationId}/project/{projectId}/zone/{zoneId}/recordset/{recordsetId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"zoneId"}}`, encodeURIComponent(String(zoneId)))
                .replace(`{${"recordsetId"}}`, encodeURIComponent(String(recordsetId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get dns/zone.recordset
         * @summary Get dns/zone.recordset
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {string} recordsetId recordsetId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dnsProjectZoneRecordsetGet: async (projectId: string, locationId: string, zoneId: string, recordsetId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling dnsProjectZoneRecordsetGet.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling dnsProjectZoneRecordsetGet.');
            }
            // verify required parameter 'zoneId' is not null or undefined
            if (zoneId === null || zoneId === undefined) {
                throw new RequiredError('zoneId','Required parameter zoneId was null or undefined when calling dnsProjectZoneRecordsetGet.');
            }
            // verify required parameter 'recordsetId' is not null or undefined
            if (recordsetId === null || recordsetId === undefined) {
                throw new RequiredError('recordsetId','Required parameter recordsetId was null or undefined when calling dnsProjectZoneRecordsetGet.');
            }
            const localVarPath = `/dns/{locationId}/project/{projectId}/zone/{zoneId}/recordset/{recordsetId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"zoneId"}}`, encodeURIComponent(String(zoneId)))
                .replace(`{${"recordsetId"}}`, encodeURIComponent(String(recordsetId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List dns/zone.recordset
         * @summary List dns/zone.recordset
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dnsProjectZoneRecordsetList: async (projectId: string, locationId: string, zoneId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling dnsProjectZoneRecordsetList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling dnsProjectZoneRecordsetList.');
            }
            // verify required parameter 'zoneId' is not null or undefined
            if (zoneId === null || zoneId === undefined) {
                throw new RequiredError('zoneId','Required parameter zoneId was null or undefined when calling dnsProjectZoneRecordsetList.');
            }
            const localVarPath = `/dns/{locationId}/project/{projectId}/zone/{zoneId}/recordset`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"zoneId"}}`, encodeURIComponent(String(zoneId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update dns/zone.recordset
         * @summary Update dns/zone.recordset
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {string} recordsetId recordsetId
         * @param {DnsProjectZoneRecordsetPatch} dnsProjectZoneRecordsetPatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dnsProjectZoneRecordsetPatch: async (projectId: string, locationId: string, zoneId: string, recordsetId: string, dnsProjectZoneRecordsetPatch: DnsProjectZoneRecordsetPatch, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling dnsProjectZoneRecordsetPatch.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling dnsProjectZoneRecordsetPatch.');
            }
            // verify required parameter 'zoneId' is not null or undefined
            if (zoneId === null || zoneId === undefined) {
                throw new RequiredError('zoneId','Required parameter zoneId was null or undefined when calling dnsProjectZoneRecordsetPatch.');
            }
            // verify required parameter 'recordsetId' is not null or undefined
            if (recordsetId === null || recordsetId === undefined) {
                throw new RequiredError('recordsetId','Required parameter recordsetId was null or undefined when calling dnsProjectZoneRecordsetPatch.');
            }
            // verify required parameter 'dnsProjectZoneRecordsetPatch' is not null or undefined
            if (dnsProjectZoneRecordsetPatch === null || dnsProjectZoneRecordsetPatch === undefined) {
                throw new RequiredError('dnsProjectZoneRecordsetPatch','Required parameter dnsProjectZoneRecordsetPatch was null or undefined when calling dnsProjectZoneRecordsetPatch.');
            }
            const localVarPath = `/dns/{locationId}/project/{projectId}/zone/{zoneId}/recordset/{recordsetId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"zoneId"}}`, encodeURIComponent(String(zoneId)))
                .replace(`{${"recordsetId"}}`, encodeURIComponent(String(recordsetId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof dnsProjectZoneRecordsetPatch !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(dnsProjectZoneRecordsetPatch !== undefined ? dnsProjectZoneRecordsetPatch : {}) : (dnsProjectZoneRecordsetPatch || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create dns/zone.record
         * @summary Create dns/zone.record
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {string} recordsetId recordsetId
         * @param {DnsRecord} dnsRecord 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dnsProjectZoneRecordsetRecordCreate: async (projectId: string, locationId: string, zoneId: string, recordsetId: string, dnsRecord: DnsRecord, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling dnsProjectZoneRecordsetRecordCreate.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling dnsProjectZoneRecordsetRecordCreate.');
            }
            // verify required parameter 'zoneId' is not null or undefined
            if (zoneId === null || zoneId === undefined) {
                throw new RequiredError('zoneId','Required parameter zoneId was null or undefined when calling dnsProjectZoneRecordsetRecordCreate.');
            }
            // verify required parameter 'recordsetId' is not null or undefined
            if (recordsetId === null || recordsetId === undefined) {
                throw new RequiredError('recordsetId','Required parameter recordsetId was null or undefined when calling dnsProjectZoneRecordsetRecordCreate.');
            }
            // verify required parameter 'dnsRecord' is not null or undefined
            if (dnsRecord === null || dnsRecord === undefined) {
                throw new RequiredError('dnsRecord','Required parameter dnsRecord was null or undefined when calling dnsProjectZoneRecordsetRecordCreate.');
            }
            const localVarPath = `/dns/{locationId}/project/{projectId}/zone/{zoneId}/recordset/{recordsetId}/record`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"zoneId"}}`, encodeURIComponent(String(zoneId)))
                .replace(`{${"recordsetId"}}`, encodeURIComponent(String(recordsetId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof dnsRecord !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(dnsRecord !== undefined ? dnsRecord : {}) : (dnsRecord || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete dns/zone.record
         * @summary Delete dns/zone.record
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {string} recordsetId recordsetId
         * @param {string} recordId recordId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dnsProjectZoneRecordsetRecordDelete: async (projectId: string, locationId: string, zoneId: string, recordsetId: string, recordId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling dnsProjectZoneRecordsetRecordDelete.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling dnsProjectZoneRecordsetRecordDelete.');
            }
            // verify required parameter 'zoneId' is not null or undefined
            if (zoneId === null || zoneId === undefined) {
                throw new RequiredError('zoneId','Required parameter zoneId was null or undefined when calling dnsProjectZoneRecordsetRecordDelete.');
            }
            // verify required parameter 'recordsetId' is not null or undefined
            if (recordsetId === null || recordsetId === undefined) {
                throw new RequiredError('recordsetId','Required parameter recordsetId was null or undefined when calling dnsProjectZoneRecordsetRecordDelete.');
            }
            // verify required parameter 'recordId' is not null or undefined
            if (recordId === null || recordId === undefined) {
                throw new RequiredError('recordId','Required parameter recordId was null or undefined when calling dnsProjectZoneRecordsetRecordDelete.');
            }
            const localVarPath = `/dns/{locationId}/project/{projectId}/zone/{zoneId}/recordset/{recordsetId}/record/{recordId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"zoneId"}}`, encodeURIComponent(String(zoneId)))
                .replace(`{${"recordsetId"}}`, encodeURIComponent(String(recordsetId)))
                .replace(`{${"recordId"}}`, encodeURIComponent(String(recordId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get dns/zone.record
         * @summary Get dns/zone.record
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {string} recordsetId recordsetId
         * @param {string} recordId recordId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dnsProjectZoneRecordsetRecordGet: async (projectId: string, locationId: string, zoneId: string, recordsetId: string, recordId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling dnsProjectZoneRecordsetRecordGet.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling dnsProjectZoneRecordsetRecordGet.');
            }
            // verify required parameter 'zoneId' is not null or undefined
            if (zoneId === null || zoneId === undefined) {
                throw new RequiredError('zoneId','Required parameter zoneId was null or undefined when calling dnsProjectZoneRecordsetRecordGet.');
            }
            // verify required parameter 'recordsetId' is not null or undefined
            if (recordsetId === null || recordsetId === undefined) {
                throw new RequiredError('recordsetId','Required parameter recordsetId was null or undefined when calling dnsProjectZoneRecordsetRecordGet.');
            }
            // verify required parameter 'recordId' is not null or undefined
            if (recordId === null || recordId === undefined) {
                throw new RequiredError('recordId','Required parameter recordId was null or undefined when calling dnsProjectZoneRecordsetRecordGet.');
            }
            const localVarPath = `/dns/{locationId}/project/{projectId}/zone/{zoneId}/recordset/{recordsetId}/record/{recordId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"zoneId"}}`, encodeURIComponent(String(zoneId)))
                .replace(`{${"recordsetId"}}`, encodeURIComponent(String(recordsetId)))
                .replace(`{${"recordId"}}`, encodeURIComponent(String(recordId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List dns/zone.record
         * @summary List dns/zone.record
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {string} recordsetId recordsetId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dnsProjectZoneRecordsetRecordList: async (projectId: string, locationId: string, zoneId: string, recordsetId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling dnsProjectZoneRecordsetRecordList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling dnsProjectZoneRecordsetRecordList.');
            }
            // verify required parameter 'zoneId' is not null or undefined
            if (zoneId === null || zoneId === undefined) {
                throw new RequiredError('zoneId','Required parameter zoneId was null or undefined when calling dnsProjectZoneRecordsetRecordList.');
            }
            // verify required parameter 'recordsetId' is not null or undefined
            if (recordsetId === null || recordsetId === undefined) {
                throw new RequiredError('recordsetId','Required parameter recordsetId was null or undefined when calling dnsProjectZoneRecordsetRecordList.');
            }
            const localVarPath = `/dns/{locationId}/project/{projectId}/zone/{zoneId}/recordset/{recordsetId}/record`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"zoneId"}}`, encodeURIComponent(String(zoneId)))
                .replace(`{${"recordsetId"}}`, encodeURIComponent(String(recordsetId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replace dns/zone.record
         * @summary Replace dns/zone.record
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {string} recordsetId recordsetId
         * @param {Array<DnsRecord>} dnsRecord 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dnsProjectZoneRecordsetRecordPut: async (projectId: string, locationId: string, zoneId: string, recordsetId: string, dnsRecord: Array<DnsRecord>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling dnsProjectZoneRecordsetRecordPut.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling dnsProjectZoneRecordsetRecordPut.');
            }
            // verify required parameter 'zoneId' is not null or undefined
            if (zoneId === null || zoneId === undefined) {
                throw new RequiredError('zoneId','Required parameter zoneId was null or undefined when calling dnsProjectZoneRecordsetRecordPut.');
            }
            // verify required parameter 'recordsetId' is not null or undefined
            if (recordsetId === null || recordsetId === undefined) {
                throw new RequiredError('recordsetId','Required parameter recordsetId was null or undefined when calling dnsProjectZoneRecordsetRecordPut.');
            }
            // verify required parameter 'dnsRecord' is not null or undefined
            if (dnsRecord === null || dnsRecord === undefined) {
                throw new RequiredError('dnsRecord','Required parameter dnsRecord was null or undefined when calling dnsProjectZoneRecordsetRecordPut.');
            }
            const localVarPath = `/dns/{locationId}/project/{projectId}/zone/{zoneId}/recordset/{recordsetId}/record`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"zoneId"}}`, encodeURIComponent(String(zoneId)))
                .replace(`{${"recordsetId"}}`, encodeURIComponent(String(recordsetId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof dnsRecord !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(dnsRecord !== undefined ? dnsRecord : {}) : (dnsRecord || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get dns/zone.service
         * @summary Get dns/zone.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dnsProjectZoneServiceGet: async (projectId: string, locationId: string, zoneId: string, serviceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling dnsProjectZoneServiceGet.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling dnsProjectZoneServiceGet.');
            }
            // verify required parameter 'zoneId' is not null or undefined
            if (zoneId === null || zoneId === undefined) {
                throw new RequiredError('zoneId','Required parameter zoneId was null or undefined when calling dnsProjectZoneServiceGet.');
            }
            // verify required parameter 'serviceId' is not null or undefined
            if (serviceId === null || serviceId === undefined) {
                throw new RequiredError('serviceId','Required parameter serviceId was null or undefined when calling dnsProjectZoneServiceGet.');
            }
            const localVarPath = `/dns/{locationId}/project/{projectId}/zone/{zoneId}/service/{serviceId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"zoneId"}}`, encodeURIComponent(String(zoneId)))
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List dns/zone.service
         * @summary List dns/zone.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dnsProjectZoneServiceList: async (projectId: string, locationId: string, zoneId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling dnsProjectZoneServiceList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling dnsProjectZoneServiceList.');
            }
            // verify required parameter 'zoneId' is not null or undefined
            if (zoneId === null || zoneId === undefined) {
                throw new RequiredError('zoneId','Required parameter zoneId was null or undefined when calling dnsProjectZoneServiceList.');
            }
            const localVarPath = `/dns/{locationId}/project/{projectId}/zone/{zoneId}/service`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"zoneId"}}`, encodeURIComponent(String(zoneId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create dns/zone.tag
         * @summary Create dns/zone.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dnsProjectZoneTagCreate: async (projectId: string, locationId: string, zoneId: string, tag: Tag, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling dnsProjectZoneTagCreate.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling dnsProjectZoneTagCreate.');
            }
            // verify required parameter 'zoneId' is not null or undefined
            if (zoneId === null || zoneId === undefined) {
                throw new RequiredError('zoneId','Required parameter zoneId was null or undefined when calling dnsProjectZoneTagCreate.');
            }
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling dnsProjectZoneTagCreate.');
            }
            const localVarPath = `/dns/{locationId}/project/{projectId}/zone/{zoneId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"zoneId"}}`, encodeURIComponent(String(zoneId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof tag !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(tag !== undefined ? tag : {}) : (tag || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete dns/zone.tag
         * @summary Delete dns/zone.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dnsProjectZoneTagDelete: async (projectId: string, locationId: string, zoneId: string, tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling dnsProjectZoneTagDelete.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling dnsProjectZoneTagDelete.');
            }
            // verify required parameter 'zoneId' is not null or undefined
            if (zoneId === null || zoneId === undefined) {
                throw new RequiredError('zoneId','Required parameter zoneId was null or undefined when calling dnsProjectZoneTagDelete.');
            }
            // verify required parameter 'tagId' is not null or undefined
            if (tagId === null || tagId === undefined) {
                throw new RequiredError('tagId','Required parameter tagId was null or undefined when calling dnsProjectZoneTagDelete.');
            }
            const localVarPath = `/dns/{locationId}/project/{projectId}/zone/{zoneId}/tag/{tagId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"zoneId"}}`, encodeURIComponent(String(zoneId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get dns/zone.tag
         * @summary Get dns/zone.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dnsProjectZoneTagGet: async (projectId: string, locationId: string, zoneId: string, tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling dnsProjectZoneTagGet.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling dnsProjectZoneTagGet.');
            }
            // verify required parameter 'zoneId' is not null or undefined
            if (zoneId === null || zoneId === undefined) {
                throw new RequiredError('zoneId','Required parameter zoneId was null or undefined when calling dnsProjectZoneTagGet.');
            }
            // verify required parameter 'tagId' is not null or undefined
            if (tagId === null || tagId === undefined) {
                throw new RequiredError('tagId','Required parameter tagId was null or undefined when calling dnsProjectZoneTagGet.');
            }
            const localVarPath = `/dns/{locationId}/project/{projectId}/zone/{zoneId}/tag/{tagId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"zoneId"}}`, encodeURIComponent(String(zoneId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List dns/zone.tag
         * @summary List dns/zone.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dnsProjectZoneTagList: async (projectId: string, locationId: string, zoneId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling dnsProjectZoneTagList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling dnsProjectZoneTagList.');
            }
            // verify required parameter 'zoneId' is not null or undefined
            if (zoneId === null || zoneId === undefined) {
                throw new RequiredError('zoneId','Required parameter zoneId was null or undefined when calling dnsProjectZoneTagList.');
            }
            const localVarPath = `/dns/{locationId}/project/{projectId}/zone/{zoneId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"zoneId"}}`, encodeURIComponent(String(zoneId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replace dns/zone.tag
         * @summary Replace dns/zone.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dnsProjectZoneTagPut: async (projectId: string, locationId: string, zoneId: string, tag: Array<Tag>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling dnsProjectZoneTagPut.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling dnsProjectZoneTagPut.');
            }
            // verify required parameter 'zoneId' is not null or undefined
            if (zoneId === null || zoneId === undefined) {
                throw new RequiredError('zoneId','Required parameter zoneId was null or undefined when calling dnsProjectZoneTagPut.');
            }
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling dnsProjectZoneTagPut.');
            }
            const localVarPath = `/dns/{locationId}/project/{projectId}/zone/{zoneId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"zoneId"}}`, encodeURIComponent(String(zoneId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof tag !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(tag !== undefined ? tag : {}) : (tag || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns modified zone
         * @summary Update dns/zone
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {DnsProjectZoneUpdate} dnsProjectZoneUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dnsProjectZoneUpdate: async (projectId: string, locationId: string, zoneId: string, dnsProjectZoneUpdate: DnsProjectZoneUpdate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling dnsProjectZoneUpdate.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling dnsProjectZoneUpdate.');
            }
            // verify required parameter 'zoneId' is not null or undefined
            if (zoneId === null || zoneId === undefined) {
                throw new RequiredError('zoneId','Required parameter zoneId was null or undefined when calling dnsProjectZoneUpdate.');
            }
            // verify required parameter 'dnsProjectZoneUpdate' is not null or undefined
            if (dnsProjectZoneUpdate === null || dnsProjectZoneUpdate === undefined) {
                throw new RequiredError('dnsProjectZoneUpdate','Required parameter dnsProjectZoneUpdate was null or undefined when calling dnsProjectZoneUpdate.');
            }
            const localVarPath = `/dns/{locationId}/project/{projectId}/zone/{zoneId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"zoneId"}}`, encodeURIComponent(String(zoneId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof dnsProjectZoneUpdate !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(dnsProjectZoneUpdate !== undefined ? dnsProjectZoneUpdate : {}) : (dnsProjectZoneUpdate || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DnsProjectZoneApi - functional programming interface
 * @export
 */
export const DnsProjectZoneApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create zone
         * @summary Create dns/zone
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {DnsProjectZoneCreate} dnsProjectZoneCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dnsProjectZoneCreate(projectId: string, locationId: string, dnsProjectZoneCreate: DnsProjectZoneCreate, xIdempotencyKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Zone>> {
            const localVarAxiosArgs = await DnsProjectZoneApiAxiosParamCreator(configuration).dnsProjectZoneCreate(projectId, locationId, dnsProjectZoneCreate, xIdempotencyKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete zone
         * @summary Delete dns/zone
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dnsProjectZoneDelete(projectId: string, locationId: string, zoneId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DnsProjectZoneApiAxiosParamCreator(configuration).dnsProjectZoneDelete(projectId, locationId, zoneId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get dns/zone.event
         * @summary Get dns/zone.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dnsProjectZoneEventGet(projectId: string, locationId: string, zoneId: string, eventId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>> {
            const localVarAxiosArgs = await DnsProjectZoneApiAxiosParamCreator(configuration).dnsProjectZoneEventGet(projectId, locationId, zoneId, eventId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List dns/zone.event
         * @summary List dns/zone.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dnsProjectZoneEventList(projectId: string, locationId: string, zoneId: string, $limit?: number, $skip?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Event>>> {
            const localVarAxiosArgs = await DnsProjectZoneApiAxiosParamCreator(configuration).dnsProjectZoneEventList(projectId, locationId, zoneId, $limit, $skip, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a single zone
         * @summary Get dns/zone
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dnsProjectZoneGet(projectId: string, locationId: string, zoneId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Zone>> {
            const localVarAxiosArgs = await DnsProjectZoneApiAxiosParamCreator(configuration).dnsProjectZoneGet(projectId, locationId, zoneId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List zone
         * @summary List dns/zone
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [name] Filter by name
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dnsProjectZoneList(projectId: string, locationId: string, name?: string, tagValue?: string, tagKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Zone>>> {
            const localVarAxiosArgs = await DnsProjectZoneApiAxiosParamCreator(configuration).dnsProjectZoneList(projectId, locationId, name, tagValue, tagKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create dns/zone.recordset
         * @summary Create dns/zone.recordset
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {DnsRecordset} dnsRecordset 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dnsProjectZoneRecordsetCreate(projectId: string, locationId: string, zoneId: string, dnsRecordset: DnsRecordset, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DnsRecordset>> {
            const localVarAxiosArgs = await DnsProjectZoneApiAxiosParamCreator(configuration).dnsProjectZoneRecordsetCreate(projectId, locationId, zoneId, dnsRecordset, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete dns/zone.recordset
         * @summary Delete dns/zone.recordset
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {string} recordsetId recordsetId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dnsProjectZoneRecordsetDelete(projectId: string, locationId: string, zoneId: string, recordsetId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Zone>> {
            const localVarAxiosArgs = await DnsProjectZoneApiAxiosParamCreator(configuration).dnsProjectZoneRecordsetDelete(projectId, locationId, zoneId, recordsetId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get dns/zone.recordset
         * @summary Get dns/zone.recordset
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {string} recordsetId recordsetId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dnsProjectZoneRecordsetGet(projectId: string, locationId: string, zoneId: string, recordsetId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DnsRecordset>> {
            const localVarAxiosArgs = await DnsProjectZoneApiAxiosParamCreator(configuration).dnsProjectZoneRecordsetGet(projectId, locationId, zoneId, recordsetId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List dns/zone.recordset
         * @summary List dns/zone.recordset
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dnsProjectZoneRecordsetList(projectId: string, locationId: string, zoneId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DnsRecordset>>> {
            const localVarAxiosArgs = await DnsProjectZoneApiAxiosParamCreator(configuration).dnsProjectZoneRecordsetList(projectId, locationId, zoneId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update dns/zone.recordset
         * @summary Update dns/zone.recordset
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {string} recordsetId recordsetId
         * @param {DnsProjectZoneRecordsetPatch} dnsProjectZoneRecordsetPatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dnsProjectZoneRecordsetPatch(projectId: string, locationId: string, zoneId: string, recordsetId: string, dnsProjectZoneRecordsetPatch: DnsProjectZoneRecordsetPatch, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DnsRecordset>> {
            const localVarAxiosArgs = await DnsProjectZoneApiAxiosParamCreator(configuration).dnsProjectZoneRecordsetPatch(projectId, locationId, zoneId, recordsetId, dnsProjectZoneRecordsetPatch, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create dns/zone.record
         * @summary Create dns/zone.record
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {string} recordsetId recordsetId
         * @param {DnsRecord} dnsRecord 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dnsProjectZoneRecordsetRecordCreate(projectId: string, locationId: string, zoneId: string, recordsetId: string, dnsRecord: DnsRecord, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DnsRecord>> {
            const localVarAxiosArgs = await DnsProjectZoneApiAxiosParamCreator(configuration).dnsProjectZoneRecordsetRecordCreate(projectId, locationId, zoneId, recordsetId, dnsRecord, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete dns/zone.record
         * @summary Delete dns/zone.record
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {string} recordsetId recordsetId
         * @param {string} recordId recordId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dnsProjectZoneRecordsetRecordDelete(projectId: string, locationId: string, zoneId: string, recordsetId: string, recordId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DnsProjectZoneApiAxiosParamCreator(configuration).dnsProjectZoneRecordsetRecordDelete(projectId, locationId, zoneId, recordsetId, recordId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get dns/zone.record
         * @summary Get dns/zone.record
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {string} recordsetId recordsetId
         * @param {string} recordId recordId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dnsProjectZoneRecordsetRecordGet(projectId: string, locationId: string, zoneId: string, recordsetId: string, recordId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DnsRecord>> {
            const localVarAxiosArgs = await DnsProjectZoneApiAxiosParamCreator(configuration).dnsProjectZoneRecordsetRecordGet(projectId, locationId, zoneId, recordsetId, recordId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List dns/zone.record
         * @summary List dns/zone.record
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {string} recordsetId recordsetId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dnsProjectZoneRecordsetRecordList(projectId: string, locationId: string, zoneId: string, recordsetId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DnsRecord>>> {
            const localVarAxiosArgs = await DnsProjectZoneApiAxiosParamCreator(configuration).dnsProjectZoneRecordsetRecordList(projectId, locationId, zoneId, recordsetId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Replace dns/zone.record
         * @summary Replace dns/zone.record
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {string} recordsetId recordsetId
         * @param {Array<DnsRecord>} dnsRecord 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dnsProjectZoneRecordsetRecordPut(projectId: string, locationId: string, zoneId: string, recordsetId: string, dnsRecord: Array<DnsRecord>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DnsRecord>>> {
            const localVarAxiosArgs = await DnsProjectZoneApiAxiosParamCreator(configuration).dnsProjectZoneRecordsetRecordPut(projectId, locationId, zoneId, recordsetId, dnsRecord, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get dns/zone.service
         * @summary Get dns/zone.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dnsProjectZoneServiceGet(projectId: string, locationId: string, zoneId: string, serviceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceService>> {
            const localVarAxiosArgs = await DnsProjectZoneApiAxiosParamCreator(configuration).dnsProjectZoneServiceGet(projectId, locationId, zoneId, serviceId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List dns/zone.service
         * @summary List dns/zone.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dnsProjectZoneServiceList(projectId: string, locationId: string, zoneId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResourceService>>> {
            const localVarAxiosArgs = await DnsProjectZoneApiAxiosParamCreator(configuration).dnsProjectZoneServiceList(projectId, locationId, zoneId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create dns/zone.tag
         * @summary Create dns/zone.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dnsProjectZoneTagCreate(projectId: string, locationId: string, zoneId: string, tag: Tag, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await DnsProjectZoneApiAxiosParamCreator(configuration).dnsProjectZoneTagCreate(projectId, locationId, zoneId, tag, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete dns/zone.tag
         * @summary Delete dns/zone.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dnsProjectZoneTagDelete(projectId: string, locationId: string, zoneId: string, tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await DnsProjectZoneApiAxiosParamCreator(configuration).dnsProjectZoneTagDelete(projectId, locationId, zoneId, tagId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get dns/zone.tag
         * @summary Get dns/zone.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dnsProjectZoneTagGet(projectId: string, locationId: string, zoneId: string, tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await DnsProjectZoneApiAxiosParamCreator(configuration).dnsProjectZoneTagGet(projectId, locationId, zoneId, tagId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List dns/zone.tag
         * @summary List dns/zone.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dnsProjectZoneTagList(projectId: string, locationId: string, zoneId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await DnsProjectZoneApiAxiosParamCreator(configuration).dnsProjectZoneTagList(projectId, locationId, zoneId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Replace dns/zone.tag
         * @summary Replace dns/zone.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dnsProjectZoneTagPut(projectId: string, locationId: string, zoneId: string, tag: Array<Tag>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await DnsProjectZoneApiAxiosParamCreator(configuration).dnsProjectZoneTagPut(projectId, locationId, zoneId, tag, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns modified zone
         * @summary Update dns/zone
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {DnsProjectZoneUpdate} dnsProjectZoneUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dnsProjectZoneUpdate(projectId: string, locationId: string, zoneId: string, dnsProjectZoneUpdate: DnsProjectZoneUpdate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Zone>> {
            const localVarAxiosArgs = await DnsProjectZoneApiAxiosParamCreator(configuration).dnsProjectZoneUpdate(projectId, locationId, zoneId, dnsProjectZoneUpdate, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * DnsProjectZoneApi - factory interface
 * @export
 */
export const DnsProjectZoneApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Create zone
         * @summary Create dns/zone
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {DnsProjectZoneCreate} dnsProjectZoneCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dnsProjectZoneCreate(projectId: string, locationId: string, dnsProjectZoneCreate: DnsProjectZoneCreate, xIdempotencyKey?: string, options?: any): AxiosPromise<Zone> {
            return DnsProjectZoneApiFp(configuration).dnsProjectZoneCreate(projectId, locationId, dnsProjectZoneCreate, xIdempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete zone
         * @summary Delete dns/zone
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dnsProjectZoneDelete(projectId: string, locationId: string, zoneId: string, options?: any): AxiosPromise<void> {
            return DnsProjectZoneApiFp(configuration).dnsProjectZoneDelete(projectId, locationId, zoneId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get dns/zone.event
         * @summary Get dns/zone.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dnsProjectZoneEventGet(projectId: string, locationId: string, zoneId: string, eventId: string, options?: any): AxiosPromise<Event> {
            return DnsProjectZoneApiFp(configuration).dnsProjectZoneEventGet(projectId, locationId, zoneId, eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * List dns/zone.event
         * @summary List dns/zone.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dnsProjectZoneEventList(projectId: string, locationId: string, zoneId: string, $limit?: number, $skip?: number, options?: any): AxiosPromise<Array<Event>> {
            return DnsProjectZoneApiFp(configuration).dnsProjectZoneEventList(projectId, locationId, zoneId, $limit, $skip, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single zone
         * @summary Get dns/zone
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dnsProjectZoneGet(projectId: string, locationId: string, zoneId: string, options?: any): AxiosPromise<Zone> {
            return DnsProjectZoneApiFp(configuration).dnsProjectZoneGet(projectId, locationId, zoneId, options).then((request) => request(axios, basePath));
        },
        /**
         * List zone
         * @summary List dns/zone
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [name] Filter by name
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dnsProjectZoneList(projectId: string, locationId: string, name?: string, tagValue?: string, tagKey?: string, options?: any): AxiosPromise<Array<Zone>> {
            return DnsProjectZoneApiFp(configuration).dnsProjectZoneList(projectId, locationId, name, tagValue, tagKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Create dns/zone.recordset
         * @summary Create dns/zone.recordset
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {DnsRecordset} dnsRecordset 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dnsProjectZoneRecordsetCreate(projectId: string, locationId: string, zoneId: string, dnsRecordset: DnsRecordset, options?: any): AxiosPromise<DnsRecordset> {
            return DnsProjectZoneApiFp(configuration).dnsProjectZoneRecordsetCreate(projectId, locationId, zoneId, dnsRecordset, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete dns/zone.recordset
         * @summary Delete dns/zone.recordset
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {string} recordsetId recordsetId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dnsProjectZoneRecordsetDelete(projectId: string, locationId: string, zoneId: string, recordsetId: string, options?: any): AxiosPromise<Zone> {
            return DnsProjectZoneApiFp(configuration).dnsProjectZoneRecordsetDelete(projectId, locationId, zoneId, recordsetId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get dns/zone.recordset
         * @summary Get dns/zone.recordset
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {string} recordsetId recordsetId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dnsProjectZoneRecordsetGet(projectId: string, locationId: string, zoneId: string, recordsetId: string, options?: any): AxiosPromise<DnsRecordset> {
            return DnsProjectZoneApiFp(configuration).dnsProjectZoneRecordsetGet(projectId, locationId, zoneId, recordsetId, options).then((request) => request(axios, basePath));
        },
        /**
         * List dns/zone.recordset
         * @summary List dns/zone.recordset
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dnsProjectZoneRecordsetList(projectId: string, locationId: string, zoneId: string, options?: any): AxiosPromise<Array<DnsRecordset>> {
            return DnsProjectZoneApiFp(configuration).dnsProjectZoneRecordsetList(projectId, locationId, zoneId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update dns/zone.recordset
         * @summary Update dns/zone.recordset
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {string} recordsetId recordsetId
         * @param {DnsProjectZoneRecordsetPatch} dnsProjectZoneRecordsetPatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dnsProjectZoneRecordsetPatch(projectId: string, locationId: string, zoneId: string, recordsetId: string, dnsProjectZoneRecordsetPatch: DnsProjectZoneRecordsetPatch, options?: any): AxiosPromise<DnsRecordset> {
            return DnsProjectZoneApiFp(configuration).dnsProjectZoneRecordsetPatch(projectId, locationId, zoneId, recordsetId, dnsProjectZoneRecordsetPatch, options).then((request) => request(axios, basePath));
        },
        /**
         * Create dns/zone.record
         * @summary Create dns/zone.record
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {string} recordsetId recordsetId
         * @param {DnsRecord} dnsRecord 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dnsProjectZoneRecordsetRecordCreate(projectId: string, locationId: string, zoneId: string, recordsetId: string, dnsRecord: DnsRecord, options?: any): AxiosPromise<DnsRecord> {
            return DnsProjectZoneApiFp(configuration).dnsProjectZoneRecordsetRecordCreate(projectId, locationId, zoneId, recordsetId, dnsRecord, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete dns/zone.record
         * @summary Delete dns/zone.record
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {string} recordsetId recordsetId
         * @param {string} recordId recordId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dnsProjectZoneRecordsetRecordDelete(projectId: string, locationId: string, zoneId: string, recordsetId: string, recordId: string, options?: any): AxiosPromise<void> {
            return DnsProjectZoneApiFp(configuration).dnsProjectZoneRecordsetRecordDelete(projectId, locationId, zoneId, recordsetId, recordId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get dns/zone.record
         * @summary Get dns/zone.record
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {string} recordsetId recordsetId
         * @param {string} recordId recordId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dnsProjectZoneRecordsetRecordGet(projectId: string, locationId: string, zoneId: string, recordsetId: string, recordId: string, options?: any): AxiosPromise<DnsRecord> {
            return DnsProjectZoneApiFp(configuration).dnsProjectZoneRecordsetRecordGet(projectId, locationId, zoneId, recordsetId, recordId, options).then((request) => request(axios, basePath));
        },
        /**
         * List dns/zone.record
         * @summary List dns/zone.record
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {string} recordsetId recordsetId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dnsProjectZoneRecordsetRecordList(projectId: string, locationId: string, zoneId: string, recordsetId: string, options?: any): AxiosPromise<Array<DnsRecord>> {
            return DnsProjectZoneApiFp(configuration).dnsProjectZoneRecordsetRecordList(projectId, locationId, zoneId, recordsetId, options).then((request) => request(axios, basePath));
        },
        /**
         * Replace dns/zone.record
         * @summary Replace dns/zone.record
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {string} recordsetId recordsetId
         * @param {Array<DnsRecord>} dnsRecord 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dnsProjectZoneRecordsetRecordPut(projectId: string, locationId: string, zoneId: string, recordsetId: string, dnsRecord: Array<DnsRecord>, options?: any): AxiosPromise<Array<DnsRecord>> {
            return DnsProjectZoneApiFp(configuration).dnsProjectZoneRecordsetRecordPut(projectId, locationId, zoneId, recordsetId, dnsRecord, options).then((request) => request(axios, basePath));
        },
        /**
         * Get dns/zone.service
         * @summary Get dns/zone.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dnsProjectZoneServiceGet(projectId: string, locationId: string, zoneId: string, serviceId: string, options?: any): AxiosPromise<ResourceService> {
            return DnsProjectZoneApiFp(configuration).dnsProjectZoneServiceGet(projectId, locationId, zoneId, serviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * List dns/zone.service
         * @summary List dns/zone.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dnsProjectZoneServiceList(projectId: string, locationId: string, zoneId: string, options?: any): AxiosPromise<Array<ResourceService>> {
            return DnsProjectZoneApiFp(configuration).dnsProjectZoneServiceList(projectId, locationId, zoneId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create dns/zone.tag
         * @summary Create dns/zone.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dnsProjectZoneTagCreate(projectId: string, locationId: string, zoneId: string, tag: Tag, options?: any): AxiosPromise<Tag> {
            return DnsProjectZoneApiFp(configuration).dnsProjectZoneTagCreate(projectId, locationId, zoneId, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete dns/zone.tag
         * @summary Delete dns/zone.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dnsProjectZoneTagDelete(projectId: string, locationId: string, zoneId: string, tagId: string, options?: any): AxiosPromise<void> {
            return DnsProjectZoneApiFp(configuration).dnsProjectZoneTagDelete(projectId, locationId, zoneId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get dns/zone.tag
         * @summary Get dns/zone.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dnsProjectZoneTagGet(projectId: string, locationId: string, zoneId: string, tagId: string, options?: any): AxiosPromise<Tag> {
            return DnsProjectZoneApiFp(configuration).dnsProjectZoneTagGet(projectId, locationId, zoneId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * List dns/zone.tag
         * @summary List dns/zone.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dnsProjectZoneTagList(projectId: string, locationId: string, zoneId: string, options?: any): AxiosPromise<Array<Tag>> {
            return DnsProjectZoneApiFp(configuration).dnsProjectZoneTagList(projectId, locationId, zoneId, options).then((request) => request(axios, basePath));
        },
        /**
         * Replace dns/zone.tag
         * @summary Replace dns/zone.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dnsProjectZoneTagPut(projectId: string, locationId: string, zoneId: string, tag: Array<Tag>, options?: any): AxiosPromise<Array<Tag>> {
            return DnsProjectZoneApiFp(configuration).dnsProjectZoneTagPut(projectId, locationId, zoneId, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns modified zone
         * @summary Update dns/zone
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {DnsProjectZoneUpdate} dnsProjectZoneUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dnsProjectZoneUpdate(projectId: string, locationId: string, zoneId: string, dnsProjectZoneUpdate: DnsProjectZoneUpdate, options?: any): AxiosPromise<Zone> {
            return DnsProjectZoneApiFp(configuration).dnsProjectZoneUpdate(projectId, locationId, zoneId, dnsProjectZoneUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DnsProjectZoneApi - object-oriented interface
 * @export
 * @class DnsProjectZoneApi
 * @extends {BaseAPI}
 */
export class DnsProjectZoneApi extends BaseAPI {
    /**
     * Create zone
     * @summary Create dns/zone
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {DnsProjectZoneCreate} dnsProjectZoneCreate 
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DnsProjectZoneApi
     */
    public dnsProjectZoneCreate(projectId: string, locationId: string, dnsProjectZoneCreate: DnsProjectZoneCreate, xIdempotencyKey?: string, options?: any) {
        return DnsProjectZoneApiFp(this.configuration).dnsProjectZoneCreate(projectId, locationId, dnsProjectZoneCreate, xIdempotencyKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete zone
     * @summary Delete dns/zone
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} zoneId Zone Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DnsProjectZoneApi
     */
    public dnsProjectZoneDelete(projectId: string, locationId: string, zoneId: string, options?: any) {
        return DnsProjectZoneApiFp(this.configuration).dnsProjectZoneDelete(projectId, locationId, zoneId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get dns/zone.event
     * @summary Get dns/zone.event
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} zoneId Zone Id
     * @param {string} eventId eventId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DnsProjectZoneApi
     */
    public dnsProjectZoneEventGet(projectId: string, locationId: string, zoneId: string, eventId: string, options?: any) {
        return DnsProjectZoneApiFp(this.configuration).dnsProjectZoneEventGet(projectId, locationId, zoneId, eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List dns/zone.event
     * @summary List dns/zone.event
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} zoneId Zone Id
     * @param {number} [$limit] $limit
     * @param {number} [$skip] $skip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DnsProjectZoneApi
     */
    public dnsProjectZoneEventList(projectId: string, locationId: string, zoneId: string, $limit?: number, $skip?: number, options?: any) {
        return DnsProjectZoneApiFp(this.configuration).dnsProjectZoneEventList(projectId, locationId, zoneId, $limit, $skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single zone
     * @summary Get dns/zone
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} zoneId Zone Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DnsProjectZoneApi
     */
    public dnsProjectZoneGet(projectId: string, locationId: string, zoneId: string, options?: any) {
        return DnsProjectZoneApiFp(this.configuration).dnsProjectZoneGet(projectId, locationId, zoneId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List zone
     * @summary List dns/zone
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} [name] Filter by name
     * @param {string} [tagValue] Filter by tag.value
     * @param {string} [tagKey] Filter by tag.key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DnsProjectZoneApi
     */
    public dnsProjectZoneList(projectId: string, locationId: string, name?: string, tagValue?: string, tagKey?: string, options?: any) {
        return DnsProjectZoneApiFp(this.configuration).dnsProjectZoneList(projectId, locationId, name, tagValue, tagKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create dns/zone.recordset
     * @summary Create dns/zone.recordset
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} zoneId Zone Id
     * @param {DnsRecordset} dnsRecordset 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DnsProjectZoneApi
     */
    public dnsProjectZoneRecordsetCreate(projectId: string, locationId: string, zoneId: string, dnsRecordset: DnsRecordset, options?: any) {
        return DnsProjectZoneApiFp(this.configuration).dnsProjectZoneRecordsetCreate(projectId, locationId, zoneId, dnsRecordset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete dns/zone.recordset
     * @summary Delete dns/zone.recordset
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} zoneId Zone Id
     * @param {string} recordsetId recordsetId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DnsProjectZoneApi
     */
    public dnsProjectZoneRecordsetDelete(projectId: string, locationId: string, zoneId: string, recordsetId: string, options?: any) {
        return DnsProjectZoneApiFp(this.configuration).dnsProjectZoneRecordsetDelete(projectId, locationId, zoneId, recordsetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get dns/zone.recordset
     * @summary Get dns/zone.recordset
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} zoneId Zone Id
     * @param {string} recordsetId recordsetId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DnsProjectZoneApi
     */
    public dnsProjectZoneRecordsetGet(projectId: string, locationId: string, zoneId: string, recordsetId: string, options?: any) {
        return DnsProjectZoneApiFp(this.configuration).dnsProjectZoneRecordsetGet(projectId, locationId, zoneId, recordsetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List dns/zone.recordset
     * @summary List dns/zone.recordset
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} zoneId Zone Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DnsProjectZoneApi
     */
    public dnsProjectZoneRecordsetList(projectId: string, locationId: string, zoneId: string, options?: any) {
        return DnsProjectZoneApiFp(this.configuration).dnsProjectZoneRecordsetList(projectId, locationId, zoneId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update dns/zone.recordset
     * @summary Update dns/zone.recordset
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} zoneId Zone Id
     * @param {string} recordsetId recordsetId
     * @param {DnsProjectZoneRecordsetPatch} dnsProjectZoneRecordsetPatch 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DnsProjectZoneApi
     */
    public dnsProjectZoneRecordsetPatch(projectId: string, locationId: string, zoneId: string, recordsetId: string, dnsProjectZoneRecordsetPatch: DnsProjectZoneRecordsetPatch, options?: any) {
        return DnsProjectZoneApiFp(this.configuration).dnsProjectZoneRecordsetPatch(projectId, locationId, zoneId, recordsetId, dnsProjectZoneRecordsetPatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create dns/zone.record
     * @summary Create dns/zone.record
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} zoneId Zone Id
     * @param {string} recordsetId recordsetId
     * @param {DnsRecord} dnsRecord 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DnsProjectZoneApi
     */
    public dnsProjectZoneRecordsetRecordCreate(projectId: string, locationId: string, zoneId: string, recordsetId: string, dnsRecord: DnsRecord, options?: any) {
        return DnsProjectZoneApiFp(this.configuration).dnsProjectZoneRecordsetRecordCreate(projectId, locationId, zoneId, recordsetId, dnsRecord, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete dns/zone.record
     * @summary Delete dns/zone.record
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} zoneId Zone Id
     * @param {string} recordsetId recordsetId
     * @param {string} recordId recordId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DnsProjectZoneApi
     */
    public dnsProjectZoneRecordsetRecordDelete(projectId: string, locationId: string, zoneId: string, recordsetId: string, recordId: string, options?: any) {
        return DnsProjectZoneApiFp(this.configuration).dnsProjectZoneRecordsetRecordDelete(projectId, locationId, zoneId, recordsetId, recordId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get dns/zone.record
     * @summary Get dns/zone.record
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} zoneId Zone Id
     * @param {string} recordsetId recordsetId
     * @param {string} recordId recordId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DnsProjectZoneApi
     */
    public dnsProjectZoneRecordsetRecordGet(projectId: string, locationId: string, zoneId: string, recordsetId: string, recordId: string, options?: any) {
        return DnsProjectZoneApiFp(this.configuration).dnsProjectZoneRecordsetRecordGet(projectId, locationId, zoneId, recordsetId, recordId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List dns/zone.record
     * @summary List dns/zone.record
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} zoneId Zone Id
     * @param {string} recordsetId recordsetId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DnsProjectZoneApi
     */
    public dnsProjectZoneRecordsetRecordList(projectId: string, locationId: string, zoneId: string, recordsetId: string, options?: any) {
        return DnsProjectZoneApiFp(this.configuration).dnsProjectZoneRecordsetRecordList(projectId, locationId, zoneId, recordsetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replace dns/zone.record
     * @summary Replace dns/zone.record
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} zoneId Zone Id
     * @param {string} recordsetId recordsetId
     * @param {Array<DnsRecord>} dnsRecord 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DnsProjectZoneApi
     */
    public dnsProjectZoneRecordsetRecordPut(projectId: string, locationId: string, zoneId: string, recordsetId: string, dnsRecord: Array<DnsRecord>, options?: any) {
        return DnsProjectZoneApiFp(this.configuration).dnsProjectZoneRecordsetRecordPut(projectId, locationId, zoneId, recordsetId, dnsRecord, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get dns/zone.service
     * @summary Get dns/zone.service
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} zoneId Zone Id
     * @param {string} serviceId serviceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DnsProjectZoneApi
     */
    public dnsProjectZoneServiceGet(projectId: string, locationId: string, zoneId: string, serviceId: string, options?: any) {
        return DnsProjectZoneApiFp(this.configuration).dnsProjectZoneServiceGet(projectId, locationId, zoneId, serviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List dns/zone.service
     * @summary List dns/zone.service
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} zoneId Zone Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DnsProjectZoneApi
     */
    public dnsProjectZoneServiceList(projectId: string, locationId: string, zoneId: string, options?: any) {
        return DnsProjectZoneApiFp(this.configuration).dnsProjectZoneServiceList(projectId, locationId, zoneId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create dns/zone.tag
     * @summary Create dns/zone.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} zoneId Zone Id
     * @param {Tag} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DnsProjectZoneApi
     */
    public dnsProjectZoneTagCreate(projectId: string, locationId: string, zoneId: string, tag: Tag, options?: any) {
        return DnsProjectZoneApiFp(this.configuration).dnsProjectZoneTagCreate(projectId, locationId, zoneId, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete dns/zone.tag
     * @summary Delete dns/zone.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} zoneId Zone Id
     * @param {string} tagId tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DnsProjectZoneApi
     */
    public dnsProjectZoneTagDelete(projectId: string, locationId: string, zoneId: string, tagId: string, options?: any) {
        return DnsProjectZoneApiFp(this.configuration).dnsProjectZoneTagDelete(projectId, locationId, zoneId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get dns/zone.tag
     * @summary Get dns/zone.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} zoneId Zone Id
     * @param {string} tagId tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DnsProjectZoneApi
     */
    public dnsProjectZoneTagGet(projectId: string, locationId: string, zoneId: string, tagId: string, options?: any) {
        return DnsProjectZoneApiFp(this.configuration).dnsProjectZoneTagGet(projectId, locationId, zoneId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List dns/zone.tag
     * @summary List dns/zone.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} zoneId Zone Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DnsProjectZoneApi
     */
    public dnsProjectZoneTagList(projectId: string, locationId: string, zoneId: string, options?: any) {
        return DnsProjectZoneApiFp(this.configuration).dnsProjectZoneTagList(projectId, locationId, zoneId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replace dns/zone.tag
     * @summary Replace dns/zone.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} zoneId Zone Id
     * @param {Array<Tag>} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DnsProjectZoneApi
     */
    public dnsProjectZoneTagPut(projectId: string, locationId: string, zoneId: string, tag: Array<Tag>, options?: any) {
        return DnsProjectZoneApiFp(this.configuration).dnsProjectZoneTagPut(projectId, locationId, zoneId, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns modified zone
     * @summary Update dns/zone
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} zoneId Zone Id
     * @param {DnsProjectZoneUpdate} dnsProjectZoneUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DnsProjectZoneApi
     */
    public dnsProjectZoneUpdate(projectId: string, locationId: string, zoneId: string, dnsProjectZoneUpdate: DnsProjectZoneUpdate, options?: any) {
        return DnsProjectZoneApiFp(this.configuration).dnsProjectZoneUpdate(projectId, locationId, zoneId, dnsProjectZoneUpdate, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * IamOrganisationApi - axios parameter creator
 * @export
 */
export const IamOrganisationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List iam/organisation.billing
         * @summary List iam/organisation.billing
         * @param {string} organisationId Organisation Id
         * @param {string} [start] start
         * @param {string} [end] end
         * @param {string} [resourceType] resource.type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationBillingList: async (organisationId: string, start?: string, end?: string, resourceType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            if (organisationId === null || organisationId === undefined) {
                throw new RequiredError('organisationId','Required parameter organisationId was null or undefined when calling iamOrganisationBillingList.');
            }
            const localVarPath = `/iam/organisation/{organisationId}/billing`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString() :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString() :
                    end;
            }

            if (resourceType !== undefined) {
                localVarQueryParameter['resource.type'] = resourceType;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create organisation
         * @summary Create iam/organisation
         * @param {IamOrganisationCreate} iamOrganisationCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationCreate: async (iamOrganisationCreate: IamOrganisationCreate, xIdempotencyKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'iamOrganisationCreate' is not null or undefined
            if (iamOrganisationCreate === null || iamOrganisationCreate === undefined) {
                throw new RequiredError('iamOrganisationCreate','Required parameter iamOrganisationCreate was null or undefined when calling iamOrganisationCreate.');
            }
            const localVarPath = `/iam/organisation`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof iamOrganisationCreate !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(iamOrganisationCreate !== undefined ? iamOrganisationCreate : {}) : (iamOrganisationCreate || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete organisation
         * @summary Delete iam/organisation
         * @param {string} organisationId Organisation Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationDelete: async (organisationId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            if (organisationId === null || organisationId === undefined) {
                throw new RequiredError('organisationId','Required parameter organisationId was null or undefined when calling iamOrganisationDelete.');
            }
            const localVarPath = `/iam/organisation/{organisationId}`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get iam/organisation.event
         * @summary Get iam/organisation.event
         * @param {string} organisationId Organisation Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationEventGet: async (organisationId: string, eventId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            if (organisationId === null || organisationId === undefined) {
                throw new RequiredError('organisationId','Required parameter organisationId was null or undefined when calling iamOrganisationEventGet.');
            }
            // verify required parameter 'eventId' is not null or undefined
            if (eventId === null || eventId === undefined) {
                throw new RequiredError('eventId','Required parameter eventId was null or undefined when calling iamOrganisationEventGet.');
            }
            const localVarPath = `/iam/organisation/{organisationId}/event/{eventId}`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)))
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List iam/organisation.event
         * @summary List iam/organisation.event
         * @param {string} organisationId Organisation Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationEventList: async (organisationId: string, $limit?: number, $skip?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            if (organisationId === null || organisationId === undefined) {
                throw new RequiredError('organisationId','Required parameter organisationId was null or undefined when calling iamOrganisationEventList.');
            }
            const localVarPath = `/iam/organisation/{organisationId}/event`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if ($limit !== undefined) {
                localVarQueryParameter['$limit'] = $limit;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single organisation
         * @summary Get iam/organisation
         * @param {string} organisationId Organisation Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationGet: async (organisationId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            if (organisationId === null || organisationId === undefined) {
                throw new RequiredError('organisationId','Required parameter organisationId was null or undefined when calling iamOrganisationGet.');
            }
            const localVarPath = `/iam/organisation/{organisationId}`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * action accept
         * @summary Accept iam/organisation.invitation
         * @param {string} organisationId Organisation Id
         * @param {string} invitationId invitationId
         * @param {IamOrganisationInvitationAccept} iamOrganisationInvitationAccept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationInvitationAccept: async (organisationId: string, invitationId: string, iamOrganisationInvitationAccept: IamOrganisationInvitationAccept, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            if (organisationId === null || organisationId === undefined) {
                throw new RequiredError('organisationId','Required parameter organisationId was null or undefined when calling iamOrganisationInvitationAccept.');
            }
            // verify required parameter 'invitationId' is not null or undefined
            if (invitationId === null || invitationId === undefined) {
                throw new RequiredError('invitationId','Required parameter invitationId was null or undefined when calling iamOrganisationInvitationAccept.');
            }
            // verify required parameter 'iamOrganisationInvitationAccept' is not null or undefined
            if (iamOrganisationInvitationAccept === null || iamOrganisationInvitationAccept === undefined) {
                throw new RequiredError('iamOrganisationInvitationAccept','Required parameter iamOrganisationInvitationAccept was null or undefined when calling iamOrganisationInvitationAccept.');
            }
            const localVarPath = `/iam/organisation/{organisationId}/invitation/{invitationId}/actions/accept`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)))
                .replace(`{${"invitationId"}}`, encodeURIComponent(String(invitationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof iamOrganisationInvitationAccept !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(iamOrganisationInvitationAccept !== undefined ? iamOrganisationInvitationAccept : {}) : (iamOrganisationInvitationAccept || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete iam/organisation.invitation
         * @summary Delete iam/organisation.invitation
         * @param {string} organisationId Organisation Id
         * @param {string} invitationId invitationId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationInvitationDelete: async (organisationId: string, invitationId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            if (organisationId === null || organisationId === undefined) {
                throw new RequiredError('organisationId','Required parameter organisationId was null or undefined when calling iamOrganisationInvitationDelete.');
            }
            // verify required parameter 'invitationId' is not null or undefined
            if (invitationId === null || invitationId === undefined) {
                throw new RequiredError('invitationId','Required parameter invitationId was null or undefined when calling iamOrganisationInvitationDelete.');
            }
            const localVarPath = `/iam/organisation/{organisationId}/invitation/{invitationId}`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)))
                .replace(`{${"invitationId"}}`, encodeURIComponent(String(invitationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get iam/organisation.invitation
         * @summary Get iam/organisation.invitation
         * @param {string} organisationId Organisation Id
         * @param {string} invitationId invitationId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationInvitationGet: async (organisationId: string, invitationId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            if (organisationId === null || organisationId === undefined) {
                throw new RequiredError('organisationId','Required parameter organisationId was null or undefined when calling iamOrganisationInvitationGet.');
            }
            // verify required parameter 'invitationId' is not null or undefined
            if (invitationId === null || invitationId === undefined) {
                throw new RequiredError('invitationId','Required parameter invitationId was null or undefined when calling iamOrganisationInvitationGet.');
            }
            const localVarPath = `/iam/organisation/{organisationId}/invitation/{invitationId}`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)))
                .replace(`{${"invitationId"}}`, encodeURIComponent(String(invitationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List iam/organisation.invitation
         * @summary List iam/organisation.invitation
         * @param {string} organisationId Organisation Id
         * @param {string} [resource] resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationInvitationList: async (organisationId: string, resource?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            if (organisationId === null || organisationId === undefined) {
                throw new RequiredError('organisationId','Required parameter organisationId was null or undefined when calling iamOrganisationInvitationList.');
            }
            const localVarPath = `/iam/organisation/{organisationId}/invitation`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (resource !== undefined) {
                localVarQueryParameter['resource'] = resource;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * action download
         * @summary Download iam/organisation.invoice
         * @param {string} organisationId Organisation Id
         * @param {string} invoiceId invoiceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationInvoiceDownload: async (organisationId: string, invoiceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            if (organisationId === null || organisationId === undefined) {
                throw new RequiredError('organisationId','Required parameter organisationId was null or undefined when calling iamOrganisationInvoiceDownload.');
            }
            // verify required parameter 'invoiceId' is not null or undefined
            if (invoiceId === null || invoiceId === undefined) {
                throw new RequiredError('invoiceId','Required parameter invoiceId was null or undefined when calling iamOrganisationInvoiceDownload.');
            }
            const localVarPath = `/iam/organisation/{organisationId}/invoice/{invoiceId}/actions/download`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)))
                .replace(`{${"invoiceId"}}`, encodeURIComponent(String(invoiceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get iam/organisation.invoice
         * @summary Get iam/organisation.invoice
         * @param {string} organisationId Organisation Id
         * @param {string} invoiceId invoiceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationInvoiceGet: async (organisationId: string, invoiceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            if (organisationId === null || organisationId === undefined) {
                throw new RequiredError('organisationId','Required parameter organisationId was null or undefined when calling iamOrganisationInvoiceGet.');
            }
            // verify required parameter 'invoiceId' is not null or undefined
            if (invoiceId === null || invoiceId === undefined) {
                throw new RequiredError('invoiceId','Required parameter invoiceId was null or undefined when calling iamOrganisationInvoiceGet.');
            }
            const localVarPath = `/iam/organisation/{organisationId}/invoice/{invoiceId}`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)))
                .replace(`{${"invoiceId"}}`, encodeURIComponent(String(invoiceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List iam/organisation.invoice
         * @summary List iam/organisation.invoice
         * @param {string} organisationId Organisation Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationInvoiceList: async (organisationId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            if (organisationId === null || organisationId === undefined) {
                throw new RequiredError('organisationId','Required parameter organisationId was null or undefined when calling iamOrganisationInvoiceList.');
            }
            const localVarPath = `/iam/organisation/{organisationId}/invoice`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List organisation
         * @summary List iam/organisation
         * @param {string} [name] Filter by name
         * @param {string} [billingCompany] Filter by billing.company
         * @param {number} [$limit] Filter by $limit
         * @param {boolean} [active] Filter by active
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationList: async (name?: string, billingCompany?: string, $limit?: number, active?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/iam/organisation`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (billingCompany !== undefined) {
                localVarQueryParameter['billing.company'] = billingCompany;
            }

            if ($limit !== undefined) {
                localVarQueryParameter['$limit'] = $limit;
            }

            if (active !== undefined) {
                localVarQueryParameter['active'] = active;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create iam/organisation.ownership
         * @summary Create iam/organisation.ownership
         * @param {string} organisationId Organisation Id
         * @param {IamOrganisationOwnershipCreate} iamOrganisationOwnershipCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationOwnershipCreate: async (organisationId: string, iamOrganisationOwnershipCreate: IamOrganisationOwnershipCreate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            if (organisationId === null || organisationId === undefined) {
                throw new RequiredError('organisationId','Required parameter organisationId was null or undefined when calling iamOrganisationOwnershipCreate.');
            }
            // verify required parameter 'iamOrganisationOwnershipCreate' is not null or undefined
            if (iamOrganisationOwnershipCreate === null || iamOrganisationOwnershipCreate === undefined) {
                throw new RequiredError('iamOrganisationOwnershipCreate','Required parameter iamOrganisationOwnershipCreate was null or undefined when calling iamOrganisationOwnershipCreate.');
            }
            const localVarPath = `/iam/organisation/{organisationId}/ownership`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof iamOrganisationOwnershipCreate !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(iamOrganisationOwnershipCreate !== undefined ? iamOrganisationOwnershipCreate : {}) : (iamOrganisationOwnershipCreate || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete iam/organisation.ownership
         * @summary Delete iam/organisation.ownership
         * @param {string} organisationId Organisation Id
         * @param {string} ownershipId ownershipId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationOwnershipDelete: async (organisationId: string, ownershipId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            if (organisationId === null || organisationId === undefined) {
                throw new RequiredError('organisationId','Required parameter organisationId was null or undefined when calling iamOrganisationOwnershipDelete.');
            }
            // verify required parameter 'ownershipId' is not null or undefined
            if (ownershipId === null || ownershipId === undefined) {
                throw new RequiredError('ownershipId','Required parameter ownershipId was null or undefined when calling iamOrganisationOwnershipDelete.');
            }
            const localVarPath = `/iam/organisation/{organisationId}/ownership/{ownershipId}`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)))
                .replace(`{${"ownershipId"}}`, encodeURIComponent(String(ownershipId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get iam/organisation.ownership
         * @summary Get iam/organisation.ownership
         * @param {string} organisationId Organisation Id
         * @param {string} ownershipId ownershipId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationOwnershipGet: async (organisationId: string, ownershipId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            if (organisationId === null || organisationId === undefined) {
                throw new RequiredError('organisationId','Required parameter organisationId was null or undefined when calling iamOrganisationOwnershipGet.');
            }
            // verify required parameter 'ownershipId' is not null or undefined
            if (ownershipId === null || ownershipId === undefined) {
                throw new RequiredError('ownershipId','Required parameter ownershipId was null or undefined when calling iamOrganisationOwnershipGet.');
            }
            const localVarPath = `/iam/organisation/{organisationId}/ownership/{ownershipId}`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)))
                .replace(`{${"ownershipId"}}`, encodeURIComponent(String(ownershipId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List iam/organisation.ownership
         * @summary List iam/organisation.ownership
         * @param {string} organisationId Organisation Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationOwnershipList: async (organisationId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            if (organisationId === null || organisationId === undefined) {
                throw new RequiredError('organisationId','Required parameter organisationId was null or undefined when calling iamOrganisationOwnershipList.');
            }
            const localVarPath = `/iam/organisation/{organisationId}/ownership`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * action allocate
         * @summary Allocate iam/organisation.payment
         * @param {string} organisationId Organisation Id
         * @param {string} paymentId paymentId
         * @param {IamOrganisationPaymentAllocate} iamOrganisationPaymentAllocate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationPaymentAllocate: async (organisationId: string, paymentId: string, iamOrganisationPaymentAllocate: IamOrganisationPaymentAllocate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            if (organisationId === null || organisationId === undefined) {
                throw new RequiredError('organisationId','Required parameter organisationId was null or undefined when calling iamOrganisationPaymentAllocate.');
            }
            // verify required parameter 'paymentId' is not null or undefined
            if (paymentId === null || paymentId === undefined) {
                throw new RequiredError('paymentId','Required parameter paymentId was null or undefined when calling iamOrganisationPaymentAllocate.');
            }
            // verify required parameter 'iamOrganisationPaymentAllocate' is not null or undefined
            if (iamOrganisationPaymentAllocate === null || iamOrganisationPaymentAllocate === undefined) {
                throw new RequiredError('iamOrganisationPaymentAllocate','Required parameter iamOrganisationPaymentAllocate was null or undefined when calling iamOrganisationPaymentAllocate.');
            }
            const localVarPath = `/iam/organisation/{organisationId}/payment/{paymentId}/actions/allocate`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)))
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof iamOrganisationPaymentAllocate !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(iamOrganisationPaymentAllocate !== undefined ? iamOrganisationPaymentAllocate : {}) : (iamOrganisationPaymentAllocate || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get iam/organisation.payment
         * @summary Get iam/organisation.payment
         * @param {string} organisationId Organisation Id
         * @param {string} paymentId paymentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationPaymentGet: async (organisationId: string, paymentId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            if (organisationId === null || organisationId === undefined) {
                throw new RequiredError('organisationId','Required parameter organisationId was null or undefined when calling iamOrganisationPaymentGet.');
            }
            // verify required parameter 'paymentId' is not null or undefined
            if (paymentId === null || paymentId === undefined) {
                throw new RequiredError('paymentId','Required parameter paymentId was null or undefined when calling iamOrganisationPaymentGet.');
            }
            const localVarPath = `/iam/organisation/{organisationId}/payment/{paymentId}`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)))
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List iam/organisation.payment
         * @summary List iam/organisation.payment
         * @param {string} organisationId Organisation Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationPaymentList: async (organisationId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            if (organisationId === null || organisationId === undefined) {
                throw new RequiredError('organisationId','Required parameter organisationId was null or undefined when calling iamOrganisationPaymentList.');
            }
            const localVarPath = `/iam/organisation/{organisationId}/payment`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create iam/organisation.proforma
         * @summary Create iam/organisation.proforma
         * @param {string} organisationId Organisation Id
         * @param {IamOrganisationProformaCreate} iamOrganisationProformaCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationProformaCreate: async (organisationId: string, iamOrganisationProformaCreate: IamOrganisationProformaCreate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            if (organisationId === null || organisationId === undefined) {
                throw new RequiredError('organisationId','Required parameter organisationId was null or undefined when calling iamOrganisationProformaCreate.');
            }
            // verify required parameter 'iamOrganisationProformaCreate' is not null or undefined
            if (iamOrganisationProformaCreate === null || iamOrganisationProformaCreate === undefined) {
                throw new RequiredError('iamOrganisationProformaCreate','Required parameter iamOrganisationProformaCreate was null or undefined when calling iamOrganisationProformaCreate.');
            }
            const localVarPath = `/iam/organisation/{organisationId}/proforma`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof iamOrganisationProformaCreate !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(iamOrganisationProformaCreate !== undefined ? iamOrganisationProformaCreate : {}) : (iamOrganisationProformaCreate || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * action download
         * @summary Download iam/organisation.proforma
         * @param {string} organisationId Organisation Id
         * @param {string} proformaId proformaId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationProformaDownload: async (organisationId: string, proformaId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            if (organisationId === null || organisationId === undefined) {
                throw new RequiredError('organisationId','Required parameter organisationId was null or undefined when calling iamOrganisationProformaDownload.');
            }
            // verify required parameter 'proformaId' is not null or undefined
            if (proformaId === null || proformaId === undefined) {
                throw new RequiredError('proformaId','Required parameter proformaId was null or undefined when calling iamOrganisationProformaDownload.');
            }
            const localVarPath = `/iam/organisation/{organisationId}/proforma/{proformaId}/actions/download`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)))
                .replace(`{${"proformaId"}}`, encodeURIComponent(String(proformaId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get iam/organisation.proforma
         * @summary Get iam/organisation.proforma
         * @param {string} organisationId Organisation Id
         * @param {string} proformaId proformaId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationProformaGet: async (organisationId: string, proformaId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            if (organisationId === null || organisationId === undefined) {
                throw new RequiredError('organisationId','Required parameter organisationId was null or undefined when calling iamOrganisationProformaGet.');
            }
            // verify required parameter 'proformaId' is not null or undefined
            if (proformaId === null || proformaId === undefined) {
                throw new RequiredError('proformaId','Required parameter proformaId was null or undefined when calling iamOrganisationProformaGet.');
            }
            const localVarPath = `/iam/organisation/{organisationId}/proforma/{proformaId}`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)))
                .replace(`{${"proformaId"}}`, encodeURIComponent(String(proformaId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List iam/organisation.proforma
         * @summary List iam/organisation.proforma
         * @param {string} organisationId Organisation Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationProformaList: async (organisationId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            if (organisationId === null || organisationId === undefined) {
                throw new RequiredError('organisationId','Required parameter organisationId was null or undefined when calling iamOrganisationProformaList.');
            }
            const localVarPath = `/iam/organisation/{organisationId}/proforma`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get iam/organisation.service
         * @summary Get iam/organisation.service
         * @param {string} organisationId Organisation Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationServiceGet: async (organisationId: string, serviceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            if (organisationId === null || organisationId === undefined) {
                throw new RequiredError('organisationId','Required parameter organisationId was null or undefined when calling iamOrganisationServiceGet.');
            }
            // verify required parameter 'serviceId' is not null or undefined
            if (serviceId === null || serviceId === undefined) {
                throw new RequiredError('serviceId','Required parameter serviceId was null or undefined when calling iamOrganisationServiceGet.');
            }
            const localVarPath = `/iam/organisation/{organisationId}/service/{serviceId}`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)))
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List iam/organisation.service
         * @summary List iam/organisation.service
         * @param {string} organisationId Organisation Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationServiceList: async (organisationId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            if (organisationId === null || organisationId === undefined) {
                throw new RequiredError('organisationId','Required parameter organisationId was null or undefined when calling iamOrganisationServiceList.');
            }
            const localVarPath = `/iam/organisation/{organisationId}/service`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * action accept
         * @summary Accept iam/organisation.transfer
         * @param {string} organisationId Organisation Id
         * @param {string} transferId transferId
         * @param {IamOrganisationTransferAccept} iamOrganisationTransferAccept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationTransferAccept: async (organisationId: string, transferId: string, iamOrganisationTransferAccept: IamOrganisationTransferAccept, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            if (organisationId === null || organisationId === undefined) {
                throw new RequiredError('organisationId','Required parameter organisationId was null or undefined when calling iamOrganisationTransferAccept.');
            }
            // verify required parameter 'transferId' is not null or undefined
            if (transferId === null || transferId === undefined) {
                throw new RequiredError('transferId','Required parameter transferId was null or undefined when calling iamOrganisationTransferAccept.');
            }
            // verify required parameter 'iamOrganisationTransferAccept' is not null or undefined
            if (iamOrganisationTransferAccept === null || iamOrganisationTransferAccept === undefined) {
                throw new RequiredError('iamOrganisationTransferAccept','Required parameter iamOrganisationTransferAccept was null or undefined when calling iamOrganisationTransferAccept.');
            }
            const localVarPath = `/iam/organisation/{organisationId}/transfer/{transferId}/actions/accept`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)))
                .replace(`{${"transferId"}}`, encodeURIComponent(String(transferId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof iamOrganisationTransferAccept !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(iamOrganisationTransferAccept !== undefined ? iamOrganisationTransferAccept : {}) : (iamOrganisationTransferAccept || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get iam/organisation.transfer
         * @summary Get iam/organisation.transfer
         * @param {string} organisationId Organisation Id
         * @param {string} transferId transferId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationTransferGet: async (organisationId: string, transferId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            if (organisationId === null || organisationId === undefined) {
                throw new RequiredError('organisationId','Required parameter organisationId was null or undefined when calling iamOrganisationTransferGet.');
            }
            // verify required parameter 'transferId' is not null or undefined
            if (transferId === null || transferId === undefined) {
                throw new RequiredError('transferId','Required parameter transferId was null or undefined when calling iamOrganisationTransferGet.');
            }
            const localVarPath = `/iam/organisation/{organisationId}/transfer/{transferId}`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)))
                .replace(`{${"transferId"}}`, encodeURIComponent(String(transferId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List iam/organisation.transfer
         * @summary List iam/organisation.transfer
         * @param {string} organisationId Organisation Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationTransferList: async (organisationId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            if (organisationId === null || organisationId === undefined) {
                throw new RequiredError('organisationId','Required parameter organisationId was null or undefined when calling iamOrganisationTransferList.');
            }
            const localVarPath = `/iam/organisation/{organisationId}/transfer`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns modified organisation
         * @summary Update iam/organisation
         * @param {string} organisationId Organisation Id
         * @param {IamOrganisationUpdate} iamOrganisationUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationUpdate: async (organisationId: string, iamOrganisationUpdate: IamOrganisationUpdate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            if (organisationId === null || organisationId === undefined) {
                throw new RequiredError('organisationId','Required parameter organisationId was null or undefined when calling iamOrganisationUpdate.');
            }
            // verify required parameter 'iamOrganisationUpdate' is not null or undefined
            if (iamOrganisationUpdate === null || iamOrganisationUpdate === undefined) {
                throw new RequiredError('iamOrganisationUpdate','Required parameter iamOrganisationUpdate was null or undefined when calling iamOrganisationUpdate.');
            }
            const localVarPath = `/iam/organisation/{organisationId}`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof iamOrganisationUpdate !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(iamOrganisationUpdate !== undefined ? iamOrganisationUpdate : {}) : (iamOrganisationUpdate || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IamOrganisationApi - functional programming interface
 * @export
 */
export const IamOrganisationApiFp = function(configuration?: Configuration) {
    return {
        /**
         * List iam/organisation.billing
         * @summary List iam/organisation.billing
         * @param {string} organisationId Organisation Id
         * @param {string} [start] start
         * @param {string} [end] end
         * @param {string} [resourceType] resource.type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationBillingList(organisationId: string, start?: string, end?: string, resourceType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Billing>>> {
            const localVarAxiosArgs = await IamOrganisationApiAxiosParamCreator(configuration).iamOrganisationBillingList(organisationId, start, end, resourceType, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create organisation
         * @summary Create iam/organisation
         * @param {IamOrganisationCreate} iamOrganisationCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationCreate(iamOrganisationCreate: IamOrganisationCreate, xIdempotencyKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Organisation>> {
            const localVarAxiosArgs = await IamOrganisationApiAxiosParamCreator(configuration).iamOrganisationCreate(iamOrganisationCreate, xIdempotencyKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete organisation
         * @summary Delete iam/organisation
         * @param {string} organisationId Organisation Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationDelete(organisationId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await IamOrganisationApiAxiosParamCreator(configuration).iamOrganisationDelete(organisationId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get iam/organisation.event
         * @summary Get iam/organisation.event
         * @param {string} organisationId Organisation Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationEventGet(organisationId: string, eventId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>> {
            const localVarAxiosArgs = await IamOrganisationApiAxiosParamCreator(configuration).iamOrganisationEventGet(organisationId, eventId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List iam/organisation.event
         * @summary List iam/organisation.event
         * @param {string} organisationId Organisation Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationEventList(organisationId: string, $limit?: number, $skip?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Event>>> {
            const localVarAxiosArgs = await IamOrganisationApiAxiosParamCreator(configuration).iamOrganisationEventList(organisationId, $limit, $skip, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a single organisation
         * @summary Get iam/organisation
         * @param {string} organisationId Organisation Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationGet(organisationId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Organisation>> {
            const localVarAxiosArgs = await IamOrganisationApiAxiosParamCreator(configuration).iamOrganisationGet(organisationId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * action accept
         * @summary Accept iam/organisation.invitation
         * @param {string} organisationId Organisation Id
         * @param {string} invitationId invitationId
         * @param {IamOrganisationInvitationAccept} iamOrganisationInvitationAccept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationInvitationAccept(organisationId: string, invitationId: string, iamOrganisationInvitationAccept: IamOrganisationInvitationAccept, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Invitation>> {
            const localVarAxiosArgs = await IamOrganisationApiAxiosParamCreator(configuration).iamOrganisationInvitationAccept(organisationId, invitationId, iamOrganisationInvitationAccept, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete iam/organisation.invitation
         * @summary Delete iam/organisation.invitation
         * @param {string} organisationId Organisation Id
         * @param {string} invitationId invitationId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationInvitationDelete(organisationId: string, invitationId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await IamOrganisationApiAxiosParamCreator(configuration).iamOrganisationInvitationDelete(organisationId, invitationId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get iam/organisation.invitation
         * @summary Get iam/organisation.invitation
         * @param {string} organisationId Organisation Id
         * @param {string} invitationId invitationId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationInvitationGet(organisationId: string, invitationId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Invitation>> {
            const localVarAxiosArgs = await IamOrganisationApiAxiosParamCreator(configuration).iamOrganisationInvitationGet(organisationId, invitationId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List iam/organisation.invitation
         * @summary List iam/organisation.invitation
         * @param {string} organisationId Organisation Id
         * @param {string} [resource] resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationInvitationList(organisationId: string, resource?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Invitation>>> {
            const localVarAxiosArgs = await IamOrganisationApiAxiosParamCreator(configuration).iamOrganisationInvitationList(organisationId, resource, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * action download
         * @summary Download iam/organisation.invoice
         * @param {string} organisationId Organisation Id
         * @param {string} invoiceId invoiceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationInvoiceDownload(organisationId: string, invoiceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await IamOrganisationApiAxiosParamCreator(configuration).iamOrganisationInvoiceDownload(organisationId, invoiceId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get iam/organisation.invoice
         * @summary Get iam/organisation.invoice
         * @param {string} organisationId Organisation Id
         * @param {string} invoiceId invoiceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationInvoiceGet(organisationId: string, invoiceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Invoice>> {
            const localVarAxiosArgs = await IamOrganisationApiAxiosParamCreator(configuration).iamOrganisationInvoiceGet(organisationId, invoiceId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List iam/organisation.invoice
         * @summary List iam/organisation.invoice
         * @param {string} organisationId Organisation Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationInvoiceList(organisationId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Invoice>>> {
            const localVarAxiosArgs = await IamOrganisationApiAxiosParamCreator(configuration).iamOrganisationInvoiceList(organisationId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List organisation
         * @summary List iam/organisation
         * @param {string} [name] Filter by name
         * @param {string} [billingCompany] Filter by billing.company
         * @param {number} [$limit] Filter by $limit
         * @param {boolean} [active] Filter by active
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationList(name?: string, billingCompany?: string, $limit?: number, active?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Organisation>>> {
            const localVarAxiosArgs = await IamOrganisationApiAxiosParamCreator(configuration).iamOrganisationList(name, billingCompany, $limit, active, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create iam/organisation.ownership
         * @summary Create iam/organisation.ownership
         * @param {string} organisationId Organisation Id
         * @param {IamOrganisationOwnershipCreate} iamOrganisationOwnershipCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationOwnershipCreate(organisationId: string, iamOrganisationOwnershipCreate: IamOrganisationOwnershipCreate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Organisation>> {
            const localVarAxiosArgs = await IamOrganisationApiAxiosParamCreator(configuration).iamOrganisationOwnershipCreate(organisationId, iamOrganisationOwnershipCreate, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete iam/organisation.ownership
         * @summary Delete iam/organisation.ownership
         * @param {string} organisationId Organisation Id
         * @param {string} ownershipId ownershipId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationOwnershipDelete(organisationId: string, ownershipId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await IamOrganisationApiAxiosParamCreator(configuration).iamOrganisationOwnershipDelete(organisationId, ownershipId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get iam/organisation.ownership
         * @summary Get iam/organisation.ownership
         * @param {string} organisationId Organisation Id
         * @param {string} ownershipId ownershipId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationOwnershipGet(organisationId: string, ownershipId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Ownership>> {
            const localVarAxiosArgs = await IamOrganisationApiAxiosParamCreator(configuration).iamOrganisationOwnershipGet(organisationId, ownershipId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List iam/organisation.ownership
         * @summary List iam/organisation.ownership
         * @param {string} organisationId Organisation Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationOwnershipList(organisationId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Ownership>>> {
            const localVarAxiosArgs = await IamOrganisationApiAxiosParamCreator(configuration).iamOrganisationOwnershipList(organisationId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * action allocate
         * @summary Allocate iam/organisation.payment
         * @param {string} organisationId Organisation Id
         * @param {string} paymentId paymentId
         * @param {IamOrganisationPaymentAllocate} iamOrganisationPaymentAllocate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationPaymentAllocate(organisationId: string, paymentId: string, iamOrganisationPaymentAllocate: IamOrganisationPaymentAllocate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payment>> {
            const localVarAxiosArgs = await IamOrganisationApiAxiosParamCreator(configuration).iamOrganisationPaymentAllocate(organisationId, paymentId, iamOrganisationPaymentAllocate, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get iam/organisation.payment
         * @summary Get iam/organisation.payment
         * @param {string} organisationId Organisation Id
         * @param {string} paymentId paymentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationPaymentGet(organisationId: string, paymentId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payment>> {
            const localVarAxiosArgs = await IamOrganisationApiAxiosParamCreator(configuration).iamOrganisationPaymentGet(organisationId, paymentId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List iam/organisation.payment
         * @summary List iam/organisation.payment
         * @param {string} organisationId Organisation Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationPaymentList(organisationId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Payment>>> {
            const localVarAxiosArgs = await IamOrganisationApiAxiosParamCreator(configuration).iamOrganisationPaymentList(organisationId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create iam/organisation.proforma
         * @summary Create iam/organisation.proforma
         * @param {string} organisationId Organisation Id
         * @param {IamOrganisationProformaCreate} iamOrganisationProformaCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationProformaCreate(organisationId: string, iamOrganisationProformaCreate: IamOrganisationProformaCreate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Proforma>> {
            const localVarAxiosArgs = await IamOrganisationApiAxiosParamCreator(configuration).iamOrganisationProformaCreate(organisationId, iamOrganisationProformaCreate, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * action download
         * @summary Download iam/organisation.proforma
         * @param {string} organisationId Organisation Id
         * @param {string} proformaId proformaId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationProformaDownload(organisationId: string, proformaId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await IamOrganisationApiAxiosParamCreator(configuration).iamOrganisationProformaDownload(organisationId, proformaId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get iam/organisation.proforma
         * @summary Get iam/organisation.proforma
         * @param {string} organisationId Organisation Id
         * @param {string} proformaId proformaId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationProformaGet(organisationId: string, proformaId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Proforma>> {
            const localVarAxiosArgs = await IamOrganisationApiAxiosParamCreator(configuration).iamOrganisationProformaGet(organisationId, proformaId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List iam/organisation.proforma
         * @summary List iam/organisation.proforma
         * @param {string} organisationId Organisation Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationProformaList(organisationId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Proforma>>> {
            const localVarAxiosArgs = await IamOrganisationApiAxiosParamCreator(configuration).iamOrganisationProformaList(organisationId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get iam/organisation.service
         * @summary Get iam/organisation.service
         * @param {string} organisationId Organisation Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationServiceGet(organisationId: string, serviceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceService>> {
            const localVarAxiosArgs = await IamOrganisationApiAxiosParamCreator(configuration).iamOrganisationServiceGet(organisationId, serviceId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List iam/organisation.service
         * @summary List iam/organisation.service
         * @param {string} organisationId Organisation Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationServiceList(organisationId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResourceService>>> {
            const localVarAxiosArgs = await IamOrganisationApiAxiosParamCreator(configuration).iamOrganisationServiceList(organisationId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * action accept
         * @summary Accept iam/organisation.transfer
         * @param {string} organisationId Organisation Id
         * @param {string} transferId transferId
         * @param {IamOrganisationTransferAccept} iamOrganisationTransferAccept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationTransferAccept(organisationId: string, transferId: string, iamOrganisationTransferAccept: IamOrganisationTransferAccept, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Transfer>> {
            const localVarAxiosArgs = await IamOrganisationApiAxiosParamCreator(configuration).iamOrganisationTransferAccept(organisationId, transferId, iamOrganisationTransferAccept, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get iam/organisation.transfer
         * @summary Get iam/organisation.transfer
         * @param {string} organisationId Organisation Id
         * @param {string} transferId transferId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationTransferGet(organisationId: string, transferId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Transfer>> {
            const localVarAxiosArgs = await IamOrganisationApiAxiosParamCreator(configuration).iamOrganisationTransferGet(organisationId, transferId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List iam/organisation.transfer
         * @summary List iam/organisation.transfer
         * @param {string} organisationId Organisation Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationTransferList(organisationId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Transfer>>> {
            const localVarAxiosArgs = await IamOrganisationApiAxiosParamCreator(configuration).iamOrganisationTransferList(organisationId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns modified organisation
         * @summary Update iam/organisation
         * @param {string} organisationId Organisation Id
         * @param {IamOrganisationUpdate} iamOrganisationUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationUpdate(organisationId: string, iamOrganisationUpdate: IamOrganisationUpdate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Organisation>> {
            const localVarAxiosArgs = await IamOrganisationApiAxiosParamCreator(configuration).iamOrganisationUpdate(organisationId, iamOrganisationUpdate, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * IamOrganisationApi - factory interface
 * @export
 */
export const IamOrganisationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * List iam/organisation.billing
         * @summary List iam/organisation.billing
         * @param {string} organisationId Organisation Id
         * @param {string} [start] start
         * @param {string} [end] end
         * @param {string} [resourceType] resource.type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationBillingList(organisationId: string, start?: string, end?: string, resourceType?: string, options?: any): AxiosPromise<Array<Billing>> {
            return IamOrganisationApiFp(configuration).iamOrganisationBillingList(organisationId, start, end, resourceType, options).then((request) => request(axios, basePath));
        },
        /**
         * Create organisation
         * @summary Create iam/organisation
         * @param {IamOrganisationCreate} iamOrganisationCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationCreate(iamOrganisationCreate: IamOrganisationCreate, xIdempotencyKey?: string, options?: any): AxiosPromise<Organisation> {
            return IamOrganisationApiFp(configuration).iamOrganisationCreate(iamOrganisationCreate, xIdempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete organisation
         * @summary Delete iam/organisation
         * @param {string} organisationId Organisation Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationDelete(organisationId: string, options?: any): AxiosPromise<void> {
            return IamOrganisationApiFp(configuration).iamOrganisationDelete(organisationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get iam/organisation.event
         * @summary Get iam/organisation.event
         * @param {string} organisationId Organisation Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationEventGet(organisationId: string, eventId: string, options?: any): AxiosPromise<Event> {
            return IamOrganisationApiFp(configuration).iamOrganisationEventGet(organisationId, eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * List iam/organisation.event
         * @summary List iam/organisation.event
         * @param {string} organisationId Organisation Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationEventList(organisationId: string, $limit?: number, $skip?: number, options?: any): AxiosPromise<Array<Event>> {
            return IamOrganisationApiFp(configuration).iamOrganisationEventList(organisationId, $limit, $skip, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single organisation
         * @summary Get iam/organisation
         * @param {string} organisationId Organisation Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationGet(organisationId: string, options?: any): AxiosPromise<Organisation> {
            return IamOrganisationApiFp(configuration).iamOrganisationGet(organisationId, options).then((request) => request(axios, basePath));
        },
        /**
         * action accept
         * @summary Accept iam/organisation.invitation
         * @param {string} organisationId Organisation Id
         * @param {string} invitationId invitationId
         * @param {IamOrganisationInvitationAccept} iamOrganisationInvitationAccept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationInvitationAccept(organisationId: string, invitationId: string, iamOrganisationInvitationAccept: IamOrganisationInvitationAccept, options?: any): AxiosPromise<Invitation> {
            return IamOrganisationApiFp(configuration).iamOrganisationInvitationAccept(organisationId, invitationId, iamOrganisationInvitationAccept, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete iam/organisation.invitation
         * @summary Delete iam/organisation.invitation
         * @param {string} organisationId Organisation Id
         * @param {string} invitationId invitationId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationInvitationDelete(organisationId: string, invitationId: string, options?: any): AxiosPromise<void> {
            return IamOrganisationApiFp(configuration).iamOrganisationInvitationDelete(organisationId, invitationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get iam/organisation.invitation
         * @summary Get iam/organisation.invitation
         * @param {string} organisationId Organisation Id
         * @param {string} invitationId invitationId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationInvitationGet(organisationId: string, invitationId: string, options?: any): AxiosPromise<Invitation> {
            return IamOrganisationApiFp(configuration).iamOrganisationInvitationGet(organisationId, invitationId, options).then((request) => request(axios, basePath));
        },
        /**
         * List iam/organisation.invitation
         * @summary List iam/organisation.invitation
         * @param {string} organisationId Organisation Id
         * @param {string} [resource] resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationInvitationList(organisationId: string, resource?: string, options?: any): AxiosPromise<Array<Invitation>> {
            return IamOrganisationApiFp(configuration).iamOrganisationInvitationList(organisationId, resource, options).then((request) => request(axios, basePath));
        },
        /**
         * action download
         * @summary Download iam/organisation.invoice
         * @param {string} organisationId Organisation Id
         * @param {string} invoiceId invoiceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationInvoiceDownload(organisationId: string, invoiceId: string, options?: any): AxiosPromise<any> {
            return IamOrganisationApiFp(configuration).iamOrganisationInvoiceDownload(organisationId, invoiceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get iam/organisation.invoice
         * @summary Get iam/organisation.invoice
         * @param {string} organisationId Organisation Id
         * @param {string} invoiceId invoiceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationInvoiceGet(organisationId: string, invoiceId: string, options?: any): AxiosPromise<Invoice> {
            return IamOrganisationApiFp(configuration).iamOrganisationInvoiceGet(organisationId, invoiceId, options).then((request) => request(axios, basePath));
        },
        /**
         * List iam/organisation.invoice
         * @summary List iam/organisation.invoice
         * @param {string} organisationId Organisation Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationInvoiceList(organisationId: string, options?: any): AxiosPromise<Array<Invoice>> {
            return IamOrganisationApiFp(configuration).iamOrganisationInvoiceList(organisationId, options).then((request) => request(axios, basePath));
        },
        /**
         * List organisation
         * @summary List iam/organisation
         * @param {string} [name] Filter by name
         * @param {string} [billingCompany] Filter by billing.company
         * @param {number} [$limit] Filter by $limit
         * @param {boolean} [active] Filter by active
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationList(name?: string, billingCompany?: string, $limit?: number, active?: boolean, options?: any): AxiosPromise<Array<Organisation>> {
            return IamOrganisationApiFp(configuration).iamOrganisationList(name, billingCompany, $limit, active, options).then((request) => request(axios, basePath));
        },
        /**
         * Create iam/organisation.ownership
         * @summary Create iam/organisation.ownership
         * @param {string} organisationId Organisation Id
         * @param {IamOrganisationOwnershipCreate} iamOrganisationOwnershipCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationOwnershipCreate(organisationId: string, iamOrganisationOwnershipCreate: IamOrganisationOwnershipCreate, options?: any): AxiosPromise<Organisation> {
            return IamOrganisationApiFp(configuration).iamOrganisationOwnershipCreate(organisationId, iamOrganisationOwnershipCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete iam/organisation.ownership
         * @summary Delete iam/organisation.ownership
         * @param {string} organisationId Organisation Id
         * @param {string} ownershipId ownershipId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationOwnershipDelete(organisationId: string, ownershipId: string, options?: any): AxiosPromise<void> {
            return IamOrganisationApiFp(configuration).iamOrganisationOwnershipDelete(organisationId, ownershipId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get iam/organisation.ownership
         * @summary Get iam/organisation.ownership
         * @param {string} organisationId Organisation Id
         * @param {string} ownershipId ownershipId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationOwnershipGet(organisationId: string, ownershipId: string, options?: any): AxiosPromise<Ownership> {
            return IamOrganisationApiFp(configuration).iamOrganisationOwnershipGet(organisationId, ownershipId, options).then((request) => request(axios, basePath));
        },
        /**
         * List iam/organisation.ownership
         * @summary List iam/organisation.ownership
         * @param {string} organisationId Organisation Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationOwnershipList(organisationId: string, options?: any): AxiosPromise<Array<Ownership>> {
            return IamOrganisationApiFp(configuration).iamOrganisationOwnershipList(organisationId, options).then((request) => request(axios, basePath));
        },
        /**
         * action allocate
         * @summary Allocate iam/organisation.payment
         * @param {string} organisationId Organisation Id
         * @param {string} paymentId paymentId
         * @param {IamOrganisationPaymentAllocate} iamOrganisationPaymentAllocate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationPaymentAllocate(organisationId: string, paymentId: string, iamOrganisationPaymentAllocate: IamOrganisationPaymentAllocate, options?: any): AxiosPromise<Payment> {
            return IamOrganisationApiFp(configuration).iamOrganisationPaymentAllocate(organisationId, paymentId, iamOrganisationPaymentAllocate, options).then((request) => request(axios, basePath));
        },
        /**
         * Get iam/organisation.payment
         * @summary Get iam/organisation.payment
         * @param {string} organisationId Organisation Id
         * @param {string} paymentId paymentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationPaymentGet(organisationId: string, paymentId: string, options?: any): AxiosPromise<Payment> {
            return IamOrganisationApiFp(configuration).iamOrganisationPaymentGet(organisationId, paymentId, options).then((request) => request(axios, basePath));
        },
        /**
         * List iam/organisation.payment
         * @summary List iam/organisation.payment
         * @param {string} organisationId Organisation Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationPaymentList(organisationId: string, options?: any): AxiosPromise<Array<Payment>> {
            return IamOrganisationApiFp(configuration).iamOrganisationPaymentList(organisationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create iam/organisation.proforma
         * @summary Create iam/organisation.proforma
         * @param {string} organisationId Organisation Id
         * @param {IamOrganisationProformaCreate} iamOrganisationProformaCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationProformaCreate(organisationId: string, iamOrganisationProformaCreate: IamOrganisationProformaCreate, options?: any): AxiosPromise<Proforma> {
            return IamOrganisationApiFp(configuration).iamOrganisationProformaCreate(organisationId, iamOrganisationProformaCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * action download
         * @summary Download iam/organisation.proforma
         * @param {string} organisationId Organisation Id
         * @param {string} proformaId proformaId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationProformaDownload(organisationId: string, proformaId: string, options?: any): AxiosPromise<any> {
            return IamOrganisationApiFp(configuration).iamOrganisationProformaDownload(organisationId, proformaId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get iam/organisation.proforma
         * @summary Get iam/organisation.proforma
         * @param {string} organisationId Organisation Id
         * @param {string} proformaId proformaId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationProformaGet(organisationId: string, proformaId: string, options?: any): AxiosPromise<Proforma> {
            return IamOrganisationApiFp(configuration).iamOrganisationProformaGet(organisationId, proformaId, options).then((request) => request(axios, basePath));
        },
        /**
         * List iam/organisation.proforma
         * @summary List iam/organisation.proforma
         * @param {string} organisationId Organisation Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationProformaList(organisationId: string, options?: any): AxiosPromise<Array<Proforma>> {
            return IamOrganisationApiFp(configuration).iamOrganisationProformaList(organisationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get iam/organisation.service
         * @summary Get iam/organisation.service
         * @param {string} organisationId Organisation Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationServiceGet(organisationId: string, serviceId: string, options?: any): AxiosPromise<ResourceService> {
            return IamOrganisationApiFp(configuration).iamOrganisationServiceGet(organisationId, serviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * List iam/organisation.service
         * @summary List iam/organisation.service
         * @param {string} organisationId Organisation Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationServiceList(organisationId: string, options?: any): AxiosPromise<Array<ResourceService>> {
            return IamOrganisationApiFp(configuration).iamOrganisationServiceList(organisationId, options).then((request) => request(axios, basePath));
        },
        /**
         * action accept
         * @summary Accept iam/organisation.transfer
         * @param {string} organisationId Organisation Id
         * @param {string} transferId transferId
         * @param {IamOrganisationTransferAccept} iamOrganisationTransferAccept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationTransferAccept(organisationId: string, transferId: string, iamOrganisationTransferAccept: IamOrganisationTransferAccept, options?: any): AxiosPromise<Transfer> {
            return IamOrganisationApiFp(configuration).iamOrganisationTransferAccept(organisationId, transferId, iamOrganisationTransferAccept, options).then((request) => request(axios, basePath));
        },
        /**
         * Get iam/organisation.transfer
         * @summary Get iam/organisation.transfer
         * @param {string} organisationId Organisation Id
         * @param {string} transferId transferId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationTransferGet(organisationId: string, transferId: string, options?: any): AxiosPromise<Transfer> {
            return IamOrganisationApiFp(configuration).iamOrganisationTransferGet(organisationId, transferId, options).then((request) => request(axios, basePath));
        },
        /**
         * List iam/organisation.transfer
         * @summary List iam/organisation.transfer
         * @param {string} organisationId Organisation Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationTransferList(organisationId: string, options?: any): AxiosPromise<Array<Transfer>> {
            return IamOrganisationApiFp(configuration).iamOrganisationTransferList(organisationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns modified organisation
         * @summary Update iam/organisation
         * @param {string} organisationId Organisation Id
         * @param {IamOrganisationUpdate} iamOrganisationUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationUpdate(organisationId: string, iamOrganisationUpdate: IamOrganisationUpdate, options?: any): AxiosPromise<Organisation> {
            return IamOrganisationApiFp(configuration).iamOrganisationUpdate(organisationId, iamOrganisationUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IamOrganisationApi - object-oriented interface
 * @export
 * @class IamOrganisationApi
 * @extends {BaseAPI}
 */
export class IamOrganisationApi extends BaseAPI {
    /**
     * List iam/organisation.billing
     * @summary List iam/organisation.billing
     * @param {string} organisationId Organisation Id
     * @param {string} [start] start
     * @param {string} [end] end
     * @param {string} [resourceType] resource.type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationApi
     */
    public iamOrganisationBillingList(organisationId: string, start?: string, end?: string, resourceType?: string, options?: any) {
        return IamOrganisationApiFp(this.configuration).iamOrganisationBillingList(organisationId, start, end, resourceType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create organisation
     * @summary Create iam/organisation
     * @param {IamOrganisationCreate} iamOrganisationCreate 
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationApi
     */
    public iamOrganisationCreate(iamOrganisationCreate: IamOrganisationCreate, xIdempotencyKey?: string, options?: any) {
        return IamOrganisationApiFp(this.configuration).iamOrganisationCreate(iamOrganisationCreate, xIdempotencyKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete organisation
     * @summary Delete iam/organisation
     * @param {string} organisationId Organisation Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationApi
     */
    public iamOrganisationDelete(organisationId: string, options?: any) {
        return IamOrganisationApiFp(this.configuration).iamOrganisationDelete(organisationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get iam/organisation.event
     * @summary Get iam/organisation.event
     * @param {string} organisationId Organisation Id
     * @param {string} eventId eventId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationApi
     */
    public iamOrganisationEventGet(organisationId: string, eventId: string, options?: any) {
        return IamOrganisationApiFp(this.configuration).iamOrganisationEventGet(organisationId, eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List iam/organisation.event
     * @summary List iam/organisation.event
     * @param {string} organisationId Organisation Id
     * @param {number} [$limit] $limit
     * @param {number} [$skip] $skip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationApi
     */
    public iamOrganisationEventList(organisationId: string, $limit?: number, $skip?: number, options?: any) {
        return IamOrganisationApiFp(this.configuration).iamOrganisationEventList(organisationId, $limit, $skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single organisation
     * @summary Get iam/organisation
     * @param {string} organisationId Organisation Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationApi
     */
    public iamOrganisationGet(organisationId: string, options?: any) {
        return IamOrganisationApiFp(this.configuration).iamOrganisationGet(organisationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * action accept
     * @summary Accept iam/organisation.invitation
     * @param {string} organisationId Organisation Id
     * @param {string} invitationId invitationId
     * @param {IamOrganisationInvitationAccept} iamOrganisationInvitationAccept 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationApi
     */
    public iamOrganisationInvitationAccept(organisationId: string, invitationId: string, iamOrganisationInvitationAccept: IamOrganisationInvitationAccept, options?: any) {
        return IamOrganisationApiFp(this.configuration).iamOrganisationInvitationAccept(organisationId, invitationId, iamOrganisationInvitationAccept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete iam/organisation.invitation
     * @summary Delete iam/organisation.invitation
     * @param {string} organisationId Organisation Id
     * @param {string} invitationId invitationId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationApi
     */
    public iamOrganisationInvitationDelete(organisationId: string, invitationId: string, options?: any) {
        return IamOrganisationApiFp(this.configuration).iamOrganisationInvitationDelete(organisationId, invitationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get iam/organisation.invitation
     * @summary Get iam/organisation.invitation
     * @param {string} organisationId Organisation Id
     * @param {string} invitationId invitationId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationApi
     */
    public iamOrganisationInvitationGet(organisationId: string, invitationId: string, options?: any) {
        return IamOrganisationApiFp(this.configuration).iamOrganisationInvitationGet(organisationId, invitationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List iam/organisation.invitation
     * @summary List iam/organisation.invitation
     * @param {string} organisationId Organisation Id
     * @param {string} [resource] resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationApi
     */
    public iamOrganisationInvitationList(organisationId: string, resource?: string, options?: any) {
        return IamOrganisationApiFp(this.configuration).iamOrganisationInvitationList(organisationId, resource, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * action download
     * @summary Download iam/organisation.invoice
     * @param {string} organisationId Organisation Id
     * @param {string} invoiceId invoiceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationApi
     */
    public iamOrganisationInvoiceDownload(organisationId: string, invoiceId: string, options?: any) {
        return IamOrganisationApiFp(this.configuration).iamOrganisationInvoiceDownload(organisationId, invoiceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get iam/organisation.invoice
     * @summary Get iam/organisation.invoice
     * @param {string} organisationId Organisation Id
     * @param {string} invoiceId invoiceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationApi
     */
    public iamOrganisationInvoiceGet(organisationId: string, invoiceId: string, options?: any) {
        return IamOrganisationApiFp(this.configuration).iamOrganisationInvoiceGet(organisationId, invoiceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List iam/organisation.invoice
     * @summary List iam/organisation.invoice
     * @param {string} organisationId Organisation Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationApi
     */
    public iamOrganisationInvoiceList(organisationId: string, options?: any) {
        return IamOrganisationApiFp(this.configuration).iamOrganisationInvoiceList(organisationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List organisation
     * @summary List iam/organisation
     * @param {string} [name] Filter by name
     * @param {string} [billingCompany] Filter by billing.company
     * @param {number} [$limit] Filter by $limit
     * @param {boolean} [active] Filter by active
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationApi
     */
    public iamOrganisationList(name?: string, billingCompany?: string, $limit?: number, active?: boolean, options?: any) {
        return IamOrganisationApiFp(this.configuration).iamOrganisationList(name, billingCompany, $limit, active, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create iam/organisation.ownership
     * @summary Create iam/organisation.ownership
     * @param {string} organisationId Organisation Id
     * @param {IamOrganisationOwnershipCreate} iamOrganisationOwnershipCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationApi
     */
    public iamOrganisationOwnershipCreate(organisationId: string, iamOrganisationOwnershipCreate: IamOrganisationOwnershipCreate, options?: any) {
        return IamOrganisationApiFp(this.configuration).iamOrganisationOwnershipCreate(organisationId, iamOrganisationOwnershipCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete iam/organisation.ownership
     * @summary Delete iam/organisation.ownership
     * @param {string} organisationId Organisation Id
     * @param {string} ownershipId ownershipId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationApi
     */
    public iamOrganisationOwnershipDelete(organisationId: string, ownershipId: string, options?: any) {
        return IamOrganisationApiFp(this.configuration).iamOrganisationOwnershipDelete(organisationId, ownershipId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get iam/organisation.ownership
     * @summary Get iam/organisation.ownership
     * @param {string} organisationId Organisation Id
     * @param {string} ownershipId ownershipId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationApi
     */
    public iamOrganisationOwnershipGet(organisationId: string, ownershipId: string, options?: any) {
        return IamOrganisationApiFp(this.configuration).iamOrganisationOwnershipGet(organisationId, ownershipId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List iam/organisation.ownership
     * @summary List iam/organisation.ownership
     * @param {string} organisationId Organisation Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationApi
     */
    public iamOrganisationOwnershipList(organisationId: string, options?: any) {
        return IamOrganisationApiFp(this.configuration).iamOrganisationOwnershipList(organisationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * action allocate
     * @summary Allocate iam/organisation.payment
     * @param {string} organisationId Organisation Id
     * @param {string} paymentId paymentId
     * @param {IamOrganisationPaymentAllocate} iamOrganisationPaymentAllocate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationApi
     */
    public iamOrganisationPaymentAllocate(organisationId: string, paymentId: string, iamOrganisationPaymentAllocate: IamOrganisationPaymentAllocate, options?: any) {
        return IamOrganisationApiFp(this.configuration).iamOrganisationPaymentAllocate(organisationId, paymentId, iamOrganisationPaymentAllocate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get iam/organisation.payment
     * @summary Get iam/organisation.payment
     * @param {string} organisationId Organisation Id
     * @param {string} paymentId paymentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationApi
     */
    public iamOrganisationPaymentGet(organisationId: string, paymentId: string, options?: any) {
        return IamOrganisationApiFp(this.configuration).iamOrganisationPaymentGet(organisationId, paymentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List iam/organisation.payment
     * @summary List iam/organisation.payment
     * @param {string} organisationId Organisation Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationApi
     */
    public iamOrganisationPaymentList(organisationId: string, options?: any) {
        return IamOrganisationApiFp(this.configuration).iamOrganisationPaymentList(organisationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create iam/organisation.proforma
     * @summary Create iam/organisation.proforma
     * @param {string} organisationId Organisation Id
     * @param {IamOrganisationProformaCreate} iamOrganisationProformaCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationApi
     */
    public iamOrganisationProformaCreate(organisationId: string, iamOrganisationProformaCreate: IamOrganisationProformaCreate, options?: any) {
        return IamOrganisationApiFp(this.configuration).iamOrganisationProformaCreate(organisationId, iamOrganisationProformaCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * action download
     * @summary Download iam/organisation.proforma
     * @param {string} organisationId Organisation Id
     * @param {string} proformaId proformaId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationApi
     */
    public iamOrganisationProformaDownload(organisationId: string, proformaId: string, options?: any) {
        return IamOrganisationApiFp(this.configuration).iamOrganisationProformaDownload(organisationId, proformaId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get iam/organisation.proforma
     * @summary Get iam/organisation.proforma
     * @param {string} organisationId Organisation Id
     * @param {string} proformaId proformaId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationApi
     */
    public iamOrganisationProformaGet(organisationId: string, proformaId: string, options?: any) {
        return IamOrganisationApiFp(this.configuration).iamOrganisationProformaGet(organisationId, proformaId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List iam/organisation.proforma
     * @summary List iam/organisation.proforma
     * @param {string} organisationId Organisation Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationApi
     */
    public iamOrganisationProformaList(organisationId: string, options?: any) {
        return IamOrganisationApiFp(this.configuration).iamOrganisationProformaList(organisationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get iam/organisation.service
     * @summary Get iam/organisation.service
     * @param {string} organisationId Organisation Id
     * @param {string} serviceId serviceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationApi
     */
    public iamOrganisationServiceGet(organisationId: string, serviceId: string, options?: any) {
        return IamOrganisationApiFp(this.configuration).iamOrganisationServiceGet(organisationId, serviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List iam/organisation.service
     * @summary List iam/organisation.service
     * @param {string} organisationId Organisation Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationApi
     */
    public iamOrganisationServiceList(organisationId: string, options?: any) {
        return IamOrganisationApiFp(this.configuration).iamOrganisationServiceList(organisationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * action accept
     * @summary Accept iam/organisation.transfer
     * @param {string} organisationId Organisation Id
     * @param {string} transferId transferId
     * @param {IamOrganisationTransferAccept} iamOrganisationTransferAccept 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationApi
     */
    public iamOrganisationTransferAccept(organisationId: string, transferId: string, iamOrganisationTransferAccept: IamOrganisationTransferAccept, options?: any) {
        return IamOrganisationApiFp(this.configuration).iamOrganisationTransferAccept(organisationId, transferId, iamOrganisationTransferAccept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get iam/organisation.transfer
     * @summary Get iam/organisation.transfer
     * @param {string} organisationId Organisation Id
     * @param {string} transferId transferId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationApi
     */
    public iamOrganisationTransferGet(organisationId: string, transferId: string, options?: any) {
        return IamOrganisationApiFp(this.configuration).iamOrganisationTransferGet(organisationId, transferId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List iam/organisation.transfer
     * @summary List iam/organisation.transfer
     * @param {string} organisationId Organisation Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationApi
     */
    public iamOrganisationTransferList(organisationId: string, options?: any) {
        return IamOrganisationApiFp(this.configuration).iamOrganisationTransferList(organisationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns modified organisation
     * @summary Update iam/organisation
     * @param {string} organisationId Organisation Id
     * @param {IamOrganisationUpdate} iamOrganisationUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationApi
     */
    public iamOrganisationUpdate(organisationId: string, iamOrganisationUpdate: IamOrganisationUpdate, options?: any) {
        return IamOrganisationApiFp(this.configuration).iamOrganisationUpdate(organisationId, iamOrganisationUpdate, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * IamOrganisationPolicyApi - axios parameter creator
 * @export
 */
export const IamOrganisationPolicyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create iam/policy.actor
         * @summary Create iam/policy.actor
         * @param {string} organisationId Organisation Id
         * @param {string} policyId Policy Id
         * @param {IamActor} iamActor 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationPolicyActorCreate: async (organisationId: string, policyId: string, iamActor: IamActor, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            if (organisationId === null || organisationId === undefined) {
                throw new RequiredError('organisationId','Required parameter organisationId was null or undefined when calling iamOrganisationPolicyActorCreate.');
            }
            // verify required parameter 'policyId' is not null or undefined
            if (policyId === null || policyId === undefined) {
                throw new RequiredError('policyId','Required parameter policyId was null or undefined when calling iamOrganisationPolicyActorCreate.');
            }
            // verify required parameter 'iamActor' is not null or undefined
            if (iamActor === null || iamActor === undefined) {
                throw new RequiredError('iamActor','Required parameter iamActor was null or undefined when calling iamOrganisationPolicyActorCreate.');
            }
            const localVarPath = `/iam/organisation/{organisationId}/policy/{policyId}/actor`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)))
                .replace(`{${"policyId"}}`, encodeURIComponent(String(policyId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof iamActor !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(iamActor !== undefined ? iamActor : {}) : (iamActor || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete iam/policy.actor
         * @summary Delete iam/policy.actor
         * @param {string} organisationId Organisation Id
         * @param {string} policyId Policy Id
         * @param {string} actorId actorId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationPolicyActorDelete: async (organisationId: string, policyId: string, actorId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            if (organisationId === null || organisationId === undefined) {
                throw new RequiredError('organisationId','Required parameter organisationId was null or undefined when calling iamOrganisationPolicyActorDelete.');
            }
            // verify required parameter 'policyId' is not null or undefined
            if (policyId === null || policyId === undefined) {
                throw new RequiredError('policyId','Required parameter policyId was null or undefined when calling iamOrganisationPolicyActorDelete.');
            }
            // verify required parameter 'actorId' is not null or undefined
            if (actorId === null || actorId === undefined) {
                throw new RequiredError('actorId','Required parameter actorId was null or undefined when calling iamOrganisationPolicyActorDelete.');
            }
            const localVarPath = `/iam/organisation/{organisationId}/policy/{policyId}/actor/{actorId}`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)))
                .replace(`{${"policyId"}}`, encodeURIComponent(String(policyId)))
                .replace(`{${"actorId"}}`, encodeURIComponent(String(actorId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get iam/policy.actor
         * @summary Get iam/policy.actor
         * @param {string} organisationId Organisation Id
         * @param {string} policyId Policy Id
         * @param {string} actorId actorId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationPolicyActorGet: async (organisationId: string, policyId: string, actorId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            if (organisationId === null || organisationId === undefined) {
                throw new RequiredError('organisationId','Required parameter organisationId was null or undefined when calling iamOrganisationPolicyActorGet.');
            }
            // verify required parameter 'policyId' is not null or undefined
            if (policyId === null || policyId === undefined) {
                throw new RequiredError('policyId','Required parameter policyId was null or undefined when calling iamOrganisationPolicyActorGet.');
            }
            // verify required parameter 'actorId' is not null or undefined
            if (actorId === null || actorId === undefined) {
                throw new RequiredError('actorId','Required parameter actorId was null or undefined when calling iamOrganisationPolicyActorGet.');
            }
            const localVarPath = `/iam/organisation/{organisationId}/policy/{policyId}/actor/{actorId}`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)))
                .replace(`{${"policyId"}}`, encodeURIComponent(String(policyId)))
                .replace(`{${"actorId"}}`, encodeURIComponent(String(actorId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List iam/policy.actor
         * @summary List iam/policy.actor
         * @param {string} organisationId Organisation Id
         * @param {string} policyId Policy Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationPolicyActorList: async (organisationId: string, policyId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            if (organisationId === null || organisationId === undefined) {
                throw new RequiredError('organisationId','Required parameter organisationId was null or undefined when calling iamOrganisationPolicyActorList.');
            }
            // verify required parameter 'policyId' is not null or undefined
            if (policyId === null || policyId === undefined) {
                throw new RequiredError('policyId','Required parameter policyId was null or undefined when calling iamOrganisationPolicyActorList.');
            }
            const localVarPath = `/iam/organisation/{organisationId}/policy/{policyId}/actor`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)))
                .replace(`{${"policyId"}}`, encodeURIComponent(String(policyId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create policy
         * @summary Create iam/policy
         * @param {string} organisationId Organisation Id
         * @param {IamProjectPolicyCreate} iamProjectPolicyCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationPolicyCreate: async (organisationId: string, iamProjectPolicyCreate: IamProjectPolicyCreate, xIdempotencyKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            if (organisationId === null || organisationId === undefined) {
                throw new RequiredError('organisationId','Required parameter organisationId was null or undefined when calling iamOrganisationPolicyCreate.');
            }
            // verify required parameter 'iamProjectPolicyCreate' is not null or undefined
            if (iamProjectPolicyCreate === null || iamProjectPolicyCreate === undefined) {
                throw new RequiredError('iamProjectPolicyCreate','Required parameter iamProjectPolicyCreate was null or undefined when calling iamOrganisationPolicyCreate.');
            }
            const localVarPath = `/iam/organisation/{organisationId}/policy`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof iamProjectPolicyCreate !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(iamProjectPolicyCreate !== undefined ? iamProjectPolicyCreate : {}) : (iamProjectPolicyCreate || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete policy
         * @summary Delete iam/policy
         * @param {string} organisationId Organisation Id
         * @param {string} policyId Policy Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationPolicyDelete: async (organisationId: string, policyId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            if (organisationId === null || organisationId === undefined) {
                throw new RequiredError('organisationId','Required parameter organisationId was null or undefined when calling iamOrganisationPolicyDelete.');
            }
            // verify required parameter 'policyId' is not null or undefined
            if (policyId === null || policyId === undefined) {
                throw new RequiredError('policyId','Required parameter policyId was null or undefined when calling iamOrganisationPolicyDelete.');
            }
            const localVarPath = `/iam/organisation/{organisationId}/policy/{policyId}`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)))
                .replace(`{${"policyId"}}`, encodeURIComponent(String(policyId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get iam/policy.event
         * @summary Get iam/policy.event
         * @param {string} organisationId Organisation Id
         * @param {string} policyId Policy Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationPolicyEventGet: async (organisationId: string, policyId: string, eventId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            if (organisationId === null || organisationId === undefined) {
                throw new RequiredError('organisationId','Required parameter organisationId was null or undefined when calling iamOrganisationPolicyEventGet.');
            }
            // verify required parameter 'policyId' is not null or undefined
            if (policyId === null || policyId === undefined) {
                throw new RequiredError('policyId','Required parameter policyId was null or undefined when calling iamOrganisationPolicyEventGet.');
            }
            // verify required parameter 'eventId' is not null or undefined
            if (eventId === null || eventId === undefined) {
                throw new RequiredError('eventId','Required parameter eventId was null or undefined when calling iamOrganisationPolicyEventGet.');
            }
            const localVarPath = `/iam/organisation/{organisationId}/policy/{policyId}/event/{eventId}`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)))
                .replace(`{${"policyId"}}`, encodeURIComponent(String(policyId)))
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List iam/policy.event
         * @summary List iam/policy.event
         * @param {string} organisationId Organisation Id
         * @param {string} policyId Policy Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationPolicyEventList: async (organisationId: string, policyId: string, $limit?: number, $skip?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            if (organisationId === null || organisationId === undefined) {
                throw new RequiredError('organisationId','Required parameter organisationId was null or undefined when calling iamOrganisationPolicyEventList.');
            }
            // verify required parameter 'policyId' is not null or undefined
            if (policyId === null || policyId === undefined) {
                throw new RequiredError('policyId','Required parameter policyId was null or undefined when calling iamOrganisationPolicyEventList.');
            }
            const localVarPath = `/iam/organisation/{organisationId}/policy/{policyId}/event`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)))
                .replace(`{${"policyId"}}`, encodeURIComponent(String(policyId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if ($limit !== undefined) {
                localVarQueryParameter['$limit'] = $limit;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single policy
         * @summary Get iam/policy
         * @param {string} organisationId Organisation Id
         * @param {string} policyId Policy Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationPolicyGet: async (organisationId: string, policyId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            if (organisationId === null || organisationId === undefined) {
                throw new RequiredError('organisationId','Required parameter organisationId was null or undefined when calling iamOrganisationPolicyGet.');
            }
            // verify required parameter 'policyId' is not null or undefined
            if (policyId === null || policyId === undefined) {
                throw new RequiredError('policyId','Required parameter policyId was null or undefined when calling iamOrganisationPolicyGet.');
            }
            const localVarPath = `/iam/organisation/{organisationId}/policy/{policyId}`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)))
                .replace(`{${"policyId"}}`, encodeURIComponent(String(policyId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List policy
         * @summary List iam/policy
         * @param {string} organisationId Organisation Id
         * @param {string} [name] Filter by name
         * @param {string} [resource] Filter by resource
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationPolicyList: async (organisationId: string, name?: string, resource?: string, tagValue?: string, tagKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            if (organisationId === null || organisationId === undefined) {
                throw new RequiredError('organisationId','Required parameter organisationId was null or undefined when calling iamOrganisationPolicyList.');
            }
            const localVarPath = `/iam/organisation/{organisationId}/policy`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (resource !== undefined) {
                localVarQueryParameter['resource'] = resource;
            }

            if (tagValue !== undefined) {
                localVarQueryParameter['tag.value'] = tagValue;
            }

            if (tagKey !== undefined) {
                localVarQueryParameter['tag.key'] = tagKey;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get iam/policy.service
         * @summary Get iam/policy.service
         * @param {string} organisationId Organisation Id
         * @param {string} policyId Policy Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationPolicyServiceGet: async (organisationId: string, policyId: string, serviceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            if (organisationId === null || organisationId === undefined) {
                throw new RequiredError('organisationId','Required parameter organisationId was null or undefined when calling iamOrganisationPolicyServiceGet.');
            }
            // verify required parameter 'policyId' is not null or undefined
            if (policyId === null || policyId === undefined) {
                throw new RequiredError('policyId','Required parameter policyId was null or undefined when calling iamOrganisationPolicyServiceGet.');
            }
            // verify required parameter 'serviceId' is not null or undefined
            if (serviceId === null || serviceId === undefined) {
                throw new RequiredError('serviceId','Required parameter serviceId was null or undefined when calling iamOrganisationPolicyServiceGet.');
            }
            const localVarPath = `/iam/organisation/{organisationId}/policy/{policyId}/service/{serviceId}`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)))
                .replace(`{${"policyId"}}`, encodeURIComponent(String(policyId)))
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List iam/policy.service
         * @summary List iam/policy.service
         * @param {string} organisationId Organisation Id
         * @param {string} policyId Policy Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationPolicyServiceList: async (organisationId: string, policyId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            if (organisationId === null || organisationId === undefined) {
                throw new RequiredError('organisationId','Required parameter organisationId was null or undefined when calling iamOrganisationPolicyServiceList.');
            }
            // verify required parameter 'policyId' is not null or undefined
            if (policyId === null || policyId === undefined) {
                throw new RequiredError('policyId','Required parameter policyId was null or undefined when calling iamOrganisationPolicyServiceList.');
            }
            const localVarPath = `/iam/organisation/{organisationId}/policy/{policyId}/service`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)))
                .replace(`{${"policyId"}}`, encodeURIComponent(String(policyId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create iam/policy.tag
         * @summary Create iam/policy.tag
         * @param {string} organisationId Organisation Id
         * @param {string} policyId Policy Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationPolicyTagCreate: async (organisationId: string, policyId: string, tag: Tag, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            if (organisationId === null || organisationId === undefined) {
                throw new RequiredError('organisationId','Required parameter organisationId was null or undefined when calling iamOrganisationPolicyTagCreate.');
            }
            // verify required parameter 'policyId' is not null or undefined
            if (policyId === null || policyId === undefined) {
                throw new RequiredError('policyId','Required parameter policyId was null or undefined when calling iamOrganisationPolicyTagCreate.');
            }
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling iamOrganisationPolicyTagCreate.');
            }
            const localVarPath = `/iam/organisation/{organisationId}/policy/{policyId}/tag`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)))
                .replace(`{${"policyId"}}`, encodeURIComponent(String(policyId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof tag !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(tag !== undefined ? tag : {}) : (tag || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete iam/policy.tag
         * @summary Delete iam/policy.tag
         * @param {string} organisationId Organisation Id
         * @param {string} policyId Policy Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationPolicyTagDelete: async (organisationId: string, policyId: string, tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            if (organisationId === null || organisationId === undefined) {
                throw new RequiredError('organisationId','Required parameter organisationId was null or undefined when calling iamOrganisationPolicyTagDelete.');
            }
            // verify required parameter 'policyId' is not null or undefined
            if (policyId === null || policyId === undefined) {
                throw new RequiredError('policyId','Required parameter policyId was null or undefined when calling iamOrganisationPolicyTagDelete.');
            }
            // verify required parameter 'tagId' is not null or undefined
            if (tagId === null || tagId === undefined) {
                throw new RequiredError('tagId','Required parameter tagId was null or undefined when calling iamOrganisationPolicyTagDelete.');
            }
            const localVarPath = `/iam/organisation/{organisationId}/policy/{policyId}/tag/{tagId}`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)))
                .replace(`{${"policyId"}}`, encodeURIComponent(String(policyId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get iam/policy.tag
         * @summary Get iam/policy.tag
         * @param {string} organisationId Organisation Id
         * @param {string} policyId Policy Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationPolicyTagGet: async (organisationId: string, policyId: string, tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            if (organisationId === null || organisationId === undefined) {
                throw new RequiredError('organisationId','Required parameter organisationId was null or undefined when calling iamOrganisationPolicyTagGet.');
            }
            // verify required parameter 'policyId' is not null or undefined
            if (policyId === null || policyId === undefined) {
                throw new RequiredError('policyId','Required parameter policyId was null or undefined when calling iamOrganisationPolicyTagGet.');
            }
            // verify required parameter 'tagId' is not null or undefined
            if (tagId === null || tagId === undefined) {
                throw new RequiredError('tagId','Required parameter tagId was null or undefined when calling iamOrganisationPolicyTagGet.');
            }
            const localVarPath = `/iam/organisation/{organisationId}/policy/{policyId}/tag/{tagId}`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)))
                .replace(`{${"policyId"}}`, encodeURIComponent(String(policyId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List iam/policy.tag
         * @summary List iam/policy.tag
         * @param {string} organisationId Organisation Id
         * @param {string} policyId Policy Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationPolicyTagList: async (organisationId: string, policyId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            if (organisationId === null || organisationId === undefined) {
                throw new RequiredError('organisationId','Required parameter organisationId was null or undefined when calling iamOrganisationPolicyTagList.');
            }
            // verify required parameter 'policyId' is not null or undefined
            if (policyId === null || policyId === undefined) {
                throw new RequiredError('policyId','Required parameter policyId was null or undefined when calling iamOrganisationPolicyTagList.');
            }
            const localVarPath = `/iam/organisation/{organisationId}/policy/{policyId}/tag`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)))
                .replace(`{${"policyId"}}`, encodeURIComponent(String(policyId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replace iam/policy.tag
         * @summary Replace iam/policy.tag
         * @param {string} organisationId Organisation Id
         * @param {string} policyId Policy Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationPolicyTagPut: async (organisationId: string, policyId: string, tag: Array<Tag>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            if (organisationId === null || organisationId === undefined) {
                throw new RequiredError('organisationId','Required parameter organisationId was null or undefined when calling iamOrganisationPolicyTagPut.');
            }
            // verify required parameter 'policyId' is not null or undefined
            if (policyId === null || policyId === undefined) {
                throw new RequiredError('policyId','Required parameter policyId was null or undefined when calling iamOrganisationPolicyTagPut.');
            }
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling iamOrganisationPolicyTagPut.');
            }
            const localVarPath = `/iam/organisation/{organisationId}/policy/{policyId}/tag`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)))
                .replace(`{${"policyId"}}`, encodeURIComponent(String(policyId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof tag !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(tag !== undefined ? tag : {}) : (tag || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns modified policy
         * @summary Update iam/policy
         * @param {string} organisationId Organisation Id
         * @param {string} policyId Policy Id
         * @param {IamProjectPolicyUpdate} iamProjectPolicyUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationPolicyUpdate: async (organisationId: string, policyId: string, iamProjectPolicyUpdate: IamProjectPolicyUpdate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            if (organisationId === null || organisationId === undefined) {
                throw new RequiredError('organisationId','Required parameter organisationId was null or undefined when calling iamOrganisationPolicyUpdate.');
            }
            // verify required parameter 'policyId' is not null or undefined
            if (policyId === null || policyId === undefined) {
                throw new RequiredError('policyId','Required parameter policyId was null or undefined when calling iamOrganisationPolicyUpdate.');
            }
            // verify required parameter 'iamProjectPolicyUpdate' is not null or undefined
            if (iamProjectPolicyUpdate === null || iamProjectPolicyUpdate === undefined) {
                throw new RequiredError('iamProjectPolicyUpdate','Required parameter iamProjectPolicyUpdate was null or undefined when calling iamOrganisationPolicyUpdate.');
            }
            const localVarPath = `/iam/organisation/{organisationId}/policy/{policyId}`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)))
                .replace(`{${"policyId"}}`, encodeURIComponent(String(policyId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof iamProjectPolicyUpdate !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(iamProjectPolicyUpdate !== undefined ? iamProjectPolicyUpdate : {}) : (iamProjectPolicyUpdate || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IamOrganisationPolicyApi - functional programming interface
 * @export
 */
export const IamOrganisationPolicyApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create iam/policy.actor
         * @summary Create iam/policy.actor
         * @param {string} organisationId Organisation Id
         * @param {string} policyId Policy Id
         * @param {IamActor} iamActor 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationPolicyActorCreate(organisationId: string, policyId: string, iamActor: IamActor, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IamActor>> {
            const localVarAxiosArgs = await IamOrganisationPolicyApiAxiosParamCreator(configuration).iamOrganisationPolicyActorCreate(organisationId, policyId, iamActor, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete iam/policy.actor
         * @summary Delete iam/policy.actor
         * @param {string} organisationId Organisation Id
         * @param {string} policyId Policy Id
         * @param {string} actorId actorId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationPolicyActorDelete(organisationId: string, policyId: string, actorId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IamActor>> {
            const localVarAxiosArgs = await IamOrganisationPolicyApiAxiosParamCreator(configuration).iamOrganisationPolicyActorDelete(organisationId, policyId, actorId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get iam/policy.actor
         * @summary Get iam/policy.actor
         * @param {string} organisationId Organisation Id
         * @param {string} policyId Policy Id
         * @param {string} actorId actorId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationPolicyActorGet(organisationId: string, policyId: string, actorId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IamActor>> {
            const localVarAxiosArgs = await IamOrganisationPolicyApiAxiosParamCreator(configuration).iamOrganisationPolicyActorGet(organisationId, policyId, actorId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List iam/policy.actor
         * @summary List iam/policy.actor
         * @param {string} organisationId Organisation Id
         * @param {string} policyId Policy Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationPolicyActorList(organisationId: string, policyId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<IamActor>>> {
            const localVarAxiosArgs = await IamOrganisationPolicyApiAxiosParamCreator(configuration).iamOrganisationPolicyActorList(organisationId, policyId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create policy
         * @summary Create iam/policy
         * @param {string} organisationId Organisation Id
         * @param {IamProjectPolicyCreate} iamProjectPolicyCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationPolicyCreate(organisationId: string, iamProjectPolicyCreate: IamProjectPolicyCreate, xIdempotencyKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Policy>> {
            const localVarAxiosArgs = await IamOrganisationPolicyApiAxiosParamCreator(configuration).iamOrganisationPolicyCreate(organisationId, iamProjectPolicyCreate, xIdempotencyKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete policy
         * @summary Delete iam/policy
         * @param {string} organisationId Organisation Id
         * @param {string} policyId Policy Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationPolicyDelete(organisationId: string, policyId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await IamOrganisationPolicyApiAxiosParamCreator(configuration).iamOrganisationPolicyDelete(organisationId, policyId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get iam/policy.event
         * @summary Get iam/policy.event
         * @param {string} organisationId Organisation Id
         * @param {string} policyId Policy Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationPolicyEventGet(organisationId: string, policyId: string, eventId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>> {
            const localVarAxiosArgs = await IamOrganisationPolicyApiAxiosParamCreator(configuration).iamOrganisationPolicyEventGet(organisationId, policyId, eventId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List iam/policy.event
         * @summary List iam/policy.event
         * @param {string} organisationId Organisation Id
         * @param {string} policyId Policy Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationPolicyEventList(organisationId: string, policyId: string, $limit?: number, $skip?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Event>>> {
            const localVarAxiosArgs = await IamOrganisationPolicyApiAxiosParamCreator(configuration).iamOrganisationPolicyEventList(organisationId, policyId, $limit, $skip, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a single policy
         * @summary Get iam/policy
         * @param {string} organisationId Organisation Id
         * @param {string} policyId Policy Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationPolicyGet(organisationId: string, policyId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Policy>> {
            const localVarAxiosArgs = await IamOrganisationPolicyApiAxiosParamCreator(configuration).iamOrganisationPolicyGet(organisationId, policyId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List policy
         * @summary List iam/policy
         * @param {string} organisationId Organisation Id
         * @param {string} [name] Filter by name
         * @param {string} [resource] Filter by resource
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationPolicyList(organisationId: string, name?: string, resource?: string, tagValue?: string, tagKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Policy>>> {
            const localVarAxiosArgs = await IamOrganisationPolicyApiAxiosParamCreator(configuration).iamOrganisationPolicyList(organisationId, name, resource, tagValue, tagKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get iam/policy.service
         * @summary Get iam/policy.service
         * @param {string} organisationId Organisation Id
         * @param {string} policyId Policy Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationPolicyServiceGet(organisationId: string, policyId: string, serviceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceService>> {
            const localVarAxiosArgs = await IamOrganisationPolicyApiAxiosParamCreator(configuration).iamOrganisationPolicyServiceGet(organisationId, policyId, serviceId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List iam/policy.service
         * @summary List iam/policy.service
         * @param {string} organisationId Organisation Id
         * @param {string} policyId Policy Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationPolicyServiceList(organisationId: string, policyId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResourceService>>> {
            const localVarAxiosArgs = await IamOrganisationPolicyApiAxiosParamCreator(configuration).iamOrganisationPolicyServiceList(organisationId, policyId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create iam/policy.tag
         * @summary Create iam/policy.tag
         * @param {string} organisationId Organisation Id
         * @param {string} policyId Policy Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationPolicyTagCreate(organisationId: string, policyId: string, tag: Tag, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await IamOrganisationPolicyApiAxiosParamCreator(configuration).iamOrganisationPolicyTagCreate(organisationId, policyId, tag, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete iam/policy.tag
         * @summary Delete iam/policy.tag
         * @param {string} organisationId Organisation Id
         * @param {string} policyId Policy Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationPolicyTagDelete(organisationId: string, policyId: string, tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await IamOrganisationPolicyApiAxiosParamCreator(configuration).iamOrganisationPolicyTagDelete(organisationId, policyId, tagId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get iam/policy.tag
         * @summary Get iam/policy.tag
         * @param {string} organisationId Organisation Id
         * @param {string} policyId Policy Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationPolicyTagGet(organisationId: string, policyId: string, tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await IamOrganisationPolicyApiAxiosParamCreator(configuration).iamOrganisationPolicyTagGet(organisationId, policyId, tagId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List iam/policy.tag
         * @summary List iam/policy.tag
         * @param {string} organisationId Organisation Id
         * @param {string} policyId Policy Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationPolicyTagList(organisationId: string, policyId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await IamOrganisationPolicyApiAxiosParamCreator(configuration).iamOrganisationPolicyTagList(organisationId, policyId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Replace iam/policy.tag
         * @summary Replace iam/policy.tag
         * @param {string} organisationId Organisation Id
         * @param {string} policyId Policy Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationPolicyTagPut(organisationId: string, policyId: string, tag: Array<Tag>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await IamOrganisationPolicyApiAxiosParamCreator(configuration).iamOrganisationPolicyTagPut(organisationId, policyId, tag, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns modified policy
         * @summary Update iam/policy
         * @param {string} organisationId Organisation Id
         * @param {string} policyId Policy Id
         * @param {IamProjectPolicyUpdate} iamProjectPolicyUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationPolicyUpdate(organisationId: string, policyId: string, iamProjectPolicyUpdate: IamProjectPolicyUpdate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Policy>> {
            const localVarAxiosArgs = await IamOrganisationPolicyApiAxiosParamCreator(configuration).iamOrganisationPolicyUpdate(organisationId, policyId, iamProjectPolicyUpdate, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * IamOrganisationPolicyApi - factory interface
 * @export
 */
export const IamOrganisationPolicyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Create iam/policy.actor
         * @summary Create iam/policy.actor
         * @param {string} organisationId Organisation Id
         * @param {string} policyId Policy Id
         * @param {IamActor} iamActor 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationPolicyActorCreate(organisationId: string, policyId: string, iamActor: IamActor, options?: any): AxiosPromise<IamActor> {
            return IamOrganisationPolicyApiFp(configuration).iamOrganisationPolicyActorCreate(organisationId, policyId, iamActor, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete iam/policy.actor
         * @summary Delete iam/policy.actor
         * @param {string} organisationId Organisation Id
         * @param {string} policyId Policy Id
         * @param {string} actorId actorId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationPolicyActorDelete(organisationId: string, policyId: string, actorId: string, options?: any): AxiosPromise<IamActor> {
            return IamOrganisationPolicyApiFp(configuration).iamOrganisationPolicyActorDelete(organisationId, policyId, actorId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get iam/policy.actor
         * @summary Get iam/policy.actor
         * @param {string} organisationId Organisation Id
         * @param {string} policyId Policy Id
         * @param {string} actorId actorId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationPolicyActorGet(organisationId: string, policyId: string, actorId: string, options?: any): AxiosPromise<IamActor> {
            return IamOrganisationPolicyApiFp(configuration).iamOrganisationPolicyActorGet(organisationId, policyId, actorId, options).then((request) => request(axios, basePath));
        },
        /**
         * List iam/policy.actor
         * @summary List iam/policy.actor
         * @param {string} organisationId Organisation Id
         * @param {string} policyId Policy Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationPolicyActorList(organisationId: string, policyId: string, options?: any): AxiosPromise<Array<IamActor>> {
            return IamOrganisationPolicyApiFp(configuration).iamOrganisationPolicyActorList(organisationId, policyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create policy
         * @summary Create iam/policy
         * @param {string} organisationId Organisation Id
         * @param {IamProjectPolicyCreate} iamProjectPolicyCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationPolicyCreate(organisationId: string, iamProjectPolicyCreate: IamProjectPolicyCreate, xIdempotencyKey?: string, options?: any): AxiosPromise<Policy> {
            return IamOrganisationPolicyApiFp(configuration).iamOrganisationPolicyCreate(organisationId, iamProjectPolicyCreate, xIdempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete policy
         * @summary Delete iam/policy
         * @param {string} organisationId Organisation Id
         * @param {string} policyId Policy Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationPolicyDelete(organisationId: string, policyId: string, options?: any): AxiosPromise<void> {
            return IamOrganisationPolicyApiFp(configuration).iamOrganisationPolicyDelete(organisationId, policyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get iam/policy.event
         * @summary Get iam/policy.event
         * @param {string} organisationId Organisation Id
         * @param {string} policyId Policy Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationPolicyEventGet(organisationId: string, policyId: string, eventId: string, options?: any): AxiosPromise<Event> {
            return IamOrganisationPolicyApiFp(configuration).iamOrganisationPolicyEventGet(organisationId, policyId, eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * List iam/policy.event
         * @summary List iam/policy.event
         * @param {string} organisationId Organisation Id
         * @param {string} policyId Policy Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationPolicyEventList(organisationId: string, policyId: string, $limit?: number, $skip?: number, options?: any): AxiosPromise<Array<Event>> {
            return IamOrganisationPolicyApiFp(configuration).iamOrganisationPolicyEventList(organisationId, policyId, $limit, $skip, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single policy
         * @summary Get iam/policy
         * @param {string} organisationId Organisation Id
         * @param {string} policyId Policy Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationPolicyGet(organisationId: string, policyId: string, options?: any): AxiosPromise<Policy> {
            return IamOrganisationPolicyApiFp(configuration).iamOrganisationPolicyGet(organisationId, policyId, options).then((request) => request(axios, basePath));
        },
        /**
         * List policy
         * @summary List iam/policy
         * @param {string} organisationId Organisation Id
         * @param {string} [name] Filter by name
         * @param {string} [resource] Filter by resource
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationPolicyList(organisationId: string, name?: string, resource?: string, tagValue?: string, tagKey?: string, options?: any): AxiosPromise<Array<Policy>> {
            return IamOrganisationPolicyApiFp(configuration).iamOrganisationPolicyList(organisationId, name, resource, tagValue, tagKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get iam/policy.service
         * @summary Get iam/policy.service
         * @param {string} organisationId Organisation Id
         * @param {string} policyId Policy Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationPolicyServiceGet(organisationId: string, policyId: string, serviceId: string, options?: any): AxiosPromise<ResourceService> {
            return IamOrganisationPolicyApiFp(configuration).iamOrganisationPolicyServiceGet(organisationId, policyId, serviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * List iam/policy.service
         * @summary List iam/policy.service
         * @param {string} organisationId Organisation Id
         * @param {string} policyId Policy Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationPolicyServiceList(organisationId: string, policyId: string, options?: any): AxiosPromise<Array<ResourceService>> {
            return IamOrganisationPolicyApiFp(configuration).iamOrganisationPolicyServiceList(organisationId, policyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create iam/policy.tag
         * @summary Create iam/policy.tag
         * @param {string} organisationId Organisation Id
         * @param {string} policyId Policy Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationPolicyTagCreate(organisationId: string, policyId: string, tag: Tag, options?: any): AxiosPromise<Tag> {
            return IamOrganisationPolicyApiFp(configuration).iamOrganisationPolicyTagCreate(organisationId, policyId, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete iam/policy.tag
         * @summary Delete iam/policy.tag
         * @param {string} organisationId Organisation Id
         * @param {string} policyId Policy Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationPolicyTagDelete(organisationId: string, policyId: string, tagId: string, options?: any): AxiosPromise<void> {
            return IamOrganisationPolicyApiFp(configuration).iamOrganisationPolicyTagDelete(organisationId, policyId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get iam/policy.tag
         * @summary Get iam/policy.tag
         * @param {string} organisationId Organisation Id
         * @param {string} policyId Policy Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationPolicyTagGet(organisationId: string, policyId: string, tagId: string, options?: any): AxiosPromise<Tag> {
            return IamOrganisationPolicyApiFp(configuration).iamOrganisationPolicyTagGet(organisationId, policyId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * List iam/policy.tag
         * @summary List iam/policy.tag
         * @param {string} organisationId Organisation Id
         * @param {string} policyId Policy Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationPolicyTagList(organisationId: string, policyId: string, options?: any): AxiosPromise<Array<Tag>> {
            return IamOrganisationPolicyApiFp(configuration).iamOrganisationPolicyTagList(organisationId, policyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Replace iam/policy.tag
         * @summary Replace iam/policy.tag
         * @param {string} organisationId Organisation Id
         * @param {string} policyId Policy Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationPolicyTagPut(organisationId: string, policyId: string, tag: Array<Tag>, options?: any): AxiosPromise<Array<Tag>> {
            return IamOrganisationPolicyApiFp(configuration).iamOrganisationPolicyTagPut(organisationId, policyId, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns modified policy
         * @summary Update iam/policy
         * @param {string} organisationId Organisation Id
         * @param {string} policyId Policy Id
         * @param {IamProjectPolicyUpdate} iamProjectPolicyUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationPolicyUpdate(organisationId: string, policyId: string, iamProjectPolicyUpdate: IamProjectPolicyUpdate, options?: any): AxiosPromise<Policy> {
            return IamOrganisationPolicyApiFp(configuration).iamOrganisationPolicyUpdate(organisationId, policyId, iamProjectPolicyUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IamOrganisationPolicyApi - object-oriented interface
 * @export
 * @class IamOrganisationPolicyApi
 * @extends {BaseAPI}
 */
export class IamOrganisationPolicyApi extends BaseAPI {
    /**
     * Create iam/policy.actor
     * @summary Create iam/policy.actor
     * @param {string} organisationId Organisation Id
     * @param {string} policyId Policy Id
     * @param {IamActor} iamActor 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationPolicyApi
     */
    public iamOrganisationPolicyActorCreate(organisationId: string, policyId: string, iamActor: IamActor, options?: any) {
        return IamOrganisationPolicyApiFp(this.configuration).iamOrganisationPolicyActorCreate(organisationId, policyId, iamActor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete iam/policy.actor
     * @summary Delete iam/policy.actor
     * @param {string} organisationId Organisation Id
     * @param {string} policyId Policy Id
     * @param {string} actorId actorId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationPolicyApi
     */
    public iamOrganisationPolicyActorDelete(organisationId: string, policyId: string, actorId: string, options?: any) {
        return IamOrganisationPolicyApiFp(this.configuration).iamOrganisationPolicyActorDelete(organisationId, policyId, actorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get iam/policy.actor
     * @summary Get iam/policy.actor
     * @param {string} organisationId Organisation Id
     * @param {string} policyId Policy Id
     * @param {string} actorId actorId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationPolicyApi
     */
    public iamOrganisationPolicyActorGet(organisationId: string, policyId: string, actorId: string, options?: any) {
        return IamOrganisationPolicyApiFp(this.configuration).iamOrganisationPolicyActorGet(organisationId, policyId, actorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List iam/policy.actor
     * @summary List iam/policy.actor
     * @param {string} organisationId Organisation Id
     * @param {string} policyId Policy Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationPolicyApi
     */
    public iamOrganisationPolicyActorList(organisationId: string, policyId: string, options?: any) {
        return IamOrganisationPolicyApiFp(this.configuration).iamOrganisationPolicyActorList(organisationId, policyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create policy
     * @summary Create iam/policy
     * @param {string} organisationId Organisation Id
     * @param {IamProjectPolicyCreate} iamProjectPolicyCreate 
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationPolicyApi
     */
    public iamOrganisationPolicyCreate(organisationId: string, iamProjectPolicyCreate: IamProjectPolicyCreate, xIdempotencyKey?: string, options?: any) {
        return IamOrganisationPolicyApiFp(this.configuration).iamOrganisationPolicyCreate(organisationId, iamProjectPolicyCreate, xIdempotencyKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete policy
     * @summary Delete iam/policy
     * @param {string} organisationId Organisation Id
     * @param {string} policyId Policy Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationPolicyApi
     */
    public iamOrganisationPolicyDelete(organisationId: string, policyId: string, options?: any) {
        return IamOrganisationPolicyApiFp(this.configuration).iamOrganisationPolicyDelete(organisationId, policyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get iam/policy.event
     * @summary Get iam/policy.event
     * @param {string} organisationId Organisation Id
     * @param {string} policyId Policy Id
     * @param {string} eventId eventId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationPolicyApi
     */
    public iamOrganisationPolicyEventGet(organisationId: string, policyId: string, eventId: string, options?: any) {
        return IamOrganisationPolicyApiFp(this.configuration).iamOrganisationPolicyEventGet(organisationId, policyId, eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List iam/policy.event
     * @summary List iam/policy.event
     * @param {string} organisationId Organisation Id
     * @param {string} policyId Policy Id
     * @param {number} [$limit] $limit
     * @param {number} [$skip] $skip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationPolicyApi
     */
    public iamOrganisationPolicyEventList(organisationId: string, policyId: string, $limit?: number, $skip?: number, options?: any) {
        return IamOrganisationPolicyApiFp(this.configuration).iamOrganisationPolicyEventList(organisationId, policyId, $limit, $skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single policy
     * @summary Get iam/policy
     * @param {string} organisationId Organisation Id
     * @param {string} policyId Policy Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationPolicyApi
     */
    public iamOrganisationPolicyGet(organisationId: string, policyId: string, options?: any) {
        return IamOrganisationPolicyApiFp(this.configuration).iamOrganisationPolicyGet(organisationId, policyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List policy
     * @summary List iam/policy
     * @param {string} organisationId Organisation Id
     * @param {string} [name] Filter by name
     * @param {string} [resource] Filter by resource
     * @param {string} [tagValue] Filter by tag.value
     * @param {string} [tagKey] Filter by tag.key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationPolicyApi
     */
    public iamOrganisationPolicyList(organisationId: string, name?: string, resource?: string, tagValue?: string, tagKey?: string, options?: any) {
        return IamOrganisationPolicyApiFp(this.configuration).iamOrganisationPolicyList(organisationId, name, resource, tagValue, tagKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get iam/policy.service
     * @summary Get iam/policy.service
     * @param {string} organisationId Organisation Id
     * @param {string} policyId Policy Id
     * @param {string} serviceId serviceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationPolicyApi
     */
    public iamOrganisationPolicyServiceGet(organisationId: string, policyId: string, serviceId: string, options?: any) {
        return IamOrganisationPolicyApiFp(this.configuration).iamOrganisationPolicyServiceGet(organisationId, policyId, serviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List iam/policy.service
     * @summary List iam/policy.service
     * @param {string} organisationId Organisation Id
     * @param {string} policyId Policy Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationPolicyApi
     */
    public iamOrganisationPolicyServiceList(organisationId: string, policyId: string, options?: any) {
        return IamOrganisationPolicyApiFp(this.configuration).iamOrganisationPolicyServiceList(organisationId, policyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create iam/policy.tag
     * @summary Create iam/policy.tag
     * @param {string} organisationId Organisation Id
     * @param {string} policyId Policy Id
     * @param {Tag} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationPolicyApi
     */
    public iamOrganisationPolicyTagCreate(organisationId: string, policyId: string, tag: Tag, options?: any) {
        return IamOrganisationPolicyApiFp(this.configuration).iamOrganisationPolicyTagCreate(organisationId, policyId, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete iam/policy.tag
     * @summary Delete iam/policy.tag
     * @param {string} organisationId Organisation Id
     * @param {string} policyId Policy Id
     * @param {string} tagId tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationPolicyApi
     */
    public iamOrganisationPolicyTagDelete(organisationId: string, policyId: string, tagId: string, options?: any) {
        return IamOrganisationPolicyApiFp(this.configuration).iamOrganisationPolicyTagDelete(organisationId, policyId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get iam/policy.tag
     * @summary Get iam/policy.tag
     * @param {string} organisationId Organisation Id
     * @param {string} policyId Policy Id
     * @param {string} tagId tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationPolicyApi
     */
    public iamOrganisationPolicyTagGet(organisationId: string, policyId: string, tagId: string, options?: any) {
        return IamOrganisationPolicyApiFp(this.configuration).iamOrganisationPolicyTagGet(organisationId, policyId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List iam/policy.tag
     * @summary List iam/policy.tag
     * @param {string} organisationId Organisation Id
     * @param {string} policyId Policy Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationPolicyApi
     */
    public iamOrganisationPolicyTagList(organisationId: string, policyId: string, options?: any) {
        return IamOrganisationPolicyApiFp(this.configuration).iamOrganisationPolicyTagList(organisationId, policyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replace iam/policy.tag
     * @summary Replace iam/policy.tag
     * @param {string} organisationId Organisation Id
     * @param {string} policyId Policy Id
     * @param {Array<Tag>} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationPolicyApi
     */
    public iamOrganisationPolicyTagPut(organisationId: string, policyId: string, tag: Array<Tag>, options?: any) {
        return IamOrganisationPolicyApiFp(this.configuration).iamOrganisationPolicyTagPut(organisationId, policyId, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns modified policy
     * @summary Update iam/policy
     * @param {string} organisationId Organisation Id
     * @param {string} policyId Policy Id
     * @param {IamProjectPolicyUpdate} iamProjectPolicyUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationPolicyApi
     */
    public iamOrganisationPolicyUpdate(organisationId: string, policyId: string, iamProjectPolicyUpdate: IamProjectPolicyUpdate, options?: any) {
        return IamOrganisationPolicyApiFp(this.configuration).iamOrganisationPolicyUpdate(organisationId, policyId, iamProjectPolicyUpdate, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * IamOrganisationRoleApi - axios parameter creator
 * @export
 */
export const IamOrganisationRoleApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create role
         * @summary Create iam/role
         * @param {string} organisationId Organisation Id
         * @param {IamProjectRoleCreate} iamProjectRoleCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationRoleCreate: async (organisationId: string, iamProjectRoleCreate: IamProjectRoleCreate, xIdempotencyKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            if (organisationId === null || organisationId === undefined) {
                throw new RequiredError('organisationId','Required parameter organisationId was null or undefined when calling iamOrganisationRoleCreate.');
            }
            // verify required parameter 'iamProjectRoleCreate' is not null or undefined
            if (iamProjectRoleCreate === null || iamProjectRoleCreate === undefined) {
                throw new RequiredError('iamProjectRoleCreate','Required parameter iamProjectRoleCreate was null or undefined when calling iamOrganisationRoleCreate.');
            }
            const localVarPath = `/iam/organisation/{organisationId}/role`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof iamProjectRoleCreate !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(iamProjectRoleCreate !== undefined ? iamProjectRoleCreate : {}) : (iamProjectRoleCreate || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete role
         * @summary Delete iam/role
         * @param {string} organisationId Organisation Id
         * @param {string} roleId Role Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationRoleDelete: async (organisationId: string, roleId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            if (organisationId === null || organisationId === undefined) {
                throw new RequiredError('organisationId','Required parameter organisationId was null or undefined when calling iamOrganisationRoleDelete.');
            }
            // verify required parameter 'roleId' is not null or undefined
            if (roleId === null || roleId === undefined) {
                throw new RequiredError('roleId','Required parameter roleId was null or undefined when calling iamOrganisationRoleDelete.');
            }
            const localVarPath = `/iam/organisation/{organisationId}/role/{roleId}`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)))
                .replace(`{${"roleId"}}`, encodeURIComponent(String(roleId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get iam/role.event
         * @summary Get iam/role.event
         * @param {string} organisationId Organisation Id
         * @param {string} roleId Role Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationRoleEventGet: async (organisationId: string, roleId: string, eventId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            if (organisationId === null || organisationId === undefined) {
                throw new RequiredError('organisationId','Required parameter organisationId was null or undefined when calling iamOrganisationRoleEventGet.');
            }
            // verify required parameter 'roleId' is not null or undefined
            if (roleId === null || roleId === undefined) {
                throw new RequiredError('roleId','Required parameter roleId was null or undefined when calling iamOrganisationRoleEventGet.');
            }
            // verify required parameter 'eventId' is not null or undefined
            if (eventId === null || eventId === undefined) {
                throw new RequiredError('eventId','Required parameter eventId was null or undefined when calling iamOrganisationRoleEventGet.');
            }
            const localVarPath = `/iam/organisation/{organisationId}/role/{roleId}/event/{eventId}`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)))
                .replace(`{${"roleId"}}`, encodeURIComponent(String(roleId)))
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List iam/role.event
         * @summary List iam/role.event
         * @param {string} organisationId Organisation Id
         * @param {string} roleId Role Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationRoleEventList: async (organisationId: string, roleId: string, $limit?: number, $skip?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            if (organisationId === null || organisationId === undefined) {
                throw new RequiredError('organisationId','Required parameter organisationId was null or undefined when calling iamOrganisationRoleEventList.');
            }
            // verify required parameter 'roleId' is not null or undefined
            if (roleId === null || roleId === undefined) {
                throw new RequiredError('roleId','Required parameter roleId was null or undefined when calling iamOrganisationRoleEventList.');
            }
            const localVarPath = `/iam/organisation/{organisationId}/role/{roleId}/event`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)))
                .replace(`{${"roleId"}}`, encodeURIComponent(String(roleId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if ($limit !== undefined) {
                localVarQueryParameter['$limit'] = $limit;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single role
         * @summary Get iam/role
         * @param {string} organisationId Organisation Id
         * @param {string} roleId Role Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationRoleGet: async (organisationId: string, roleId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            if (organisationId === null || organisationId === undefined) {
                throw new RequiredError('organisationId','Required parameter organisationId was null or undefined when calling iamOrganisationRoleGet.');
            }
            // verify required parameter 'roleId' is not null or undefined
            if (roleId === null || roleId === undefined) {
                throw new RequiredError('roleId','Required parameter roleId was null or undefined when calling iamOrganisationRoleGet.');
            }
            const localVarPath = `/iam/organisation/{organisationId}/role/{roleId}`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)))
                .replace(`{${"roleId"}}`, encodeURIComponent(String(roleId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List role
         * @summary List iam/role
         * @param {string} organisationId Organisation Id
         * @param {string} [name] Filter by name
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationRoleList: async (organisationId: string, name?: string, tagValue?: string, tagKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            if (organisationId === null || organisationId === undefined) {
                throw new RequiredError('organisationId','Required parameter organisationId was null or undefined when calling iamOrganisationRoleList.');
            }
            const localVarPath = `/iam/organisation/{organisationId}/role`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (tagValue !== undefined) {
                localVarQueryParameter['tag.value'] = tagValue;
            }

            if (tagKey !== undefined) {
                localVarQueryParameter['tag.key'] = tagKey;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create iam/role.permission
         * @summary Create iam/role.permission
         * @param {string} organisationId Organisation Id
         * @param {string} roleId Role Id
         * @param {IamPermission} iamPermission 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationRolePermissionCreate: async (organisationId: string, roleId: string, iamPermission: IamPermission, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            if (organisationId === null || organisationId === undefined) {
                throw new RequiredError('organisationId','Required parameter organisationId was null or undefined when calling iamOrganisationRolePermissionCreate.');
            }
            // verify required parameter 'roleId' is not null or undefined
            if (roleId === null || roleId === undefined) {
                throw new RequiredError('roleId','Required parameter roleId was null or undefined when calling iamOrganisationRolePermissionCreate.');
            }
            // verify required parameter 'iamPermission' is not null or undefined
            if (iamPermission === null || iamPermission === undefined) {
                throw new RequiredError('iamPermission','Required parameter iamPermission was null or undefined when calling iamOrganisationRolePermissionCreate.');
            }
            const localVarPath = `/iam/organisation/{organisationId}/role/{roleId}/permission`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)))
                .replace(`{${"roleId"}}`, encodeURIComponent(String(roleId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof iamPermission !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(iamPermission !== undefined ? iamPermission : {}) : (iamPermission || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete iam/role.permission
         * @summary Delete iam/role.permission
         * @param {string} organisationId Organisation Id
         * @param {string} roleId Role Id
         * @param {string} permissionId permissionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationRolePermissionDelete: async (organisationId: string, roleId: string, permissionId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            if (organisationId === null || organisationId === undefined) {
                throw new RequiredError('organisationId','Required parameter organisationId was null or undefined when calling iamOrganisationRolePermissionDelete.');
            }
            // verify required parameter 'roleId' is not null or undefined
            if (roleId === null || roleId === undefined) {
                throw new RequiredError('roleId','Required parameter roleId was null or undefined when calling iamOrganisationRolePermissionDelete.');
            }
            // verify required parameter 'permissionId' is not null or undefined
            if (permissionId === null || permissionId === undefined) {
                throw new RequiredError('permissionId','Required parameter permissionId was null or undefined when calling iamOrganisationRolePermissionDelete.');
            }
            const localVarPath = `/iam/organisation/{organisationId}/role/{roleId}/permission/{permissionId}`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)))
                .replace(`{${"roleId"}}`, encodeURIComponent(String(roleId)))
                .replace(`{${"permissionId"}}`, encodeURIComponent(String(permissionId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get iam/role.permission
         * @summary Get iam/role.permission
         * @param {string} organisationId Organisation Id
         * @param {string} roleId Role Id
         * @param {string} permissionId permissionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationRolePermissionGet: async (organisationId: string, roleId: string, permissionId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            if (organisationId === null || organisationId === undefined) {
                throw new RequiredError('organisationId','Required parameter organisationId was null or undefined when calling iamOrganisationRolePermissionGet.');
            }
            // verify required parameter 'roleId' is not null or undefined
            if (roleId === null || roleId === undefined) {
                throw new RequiredError('roleId','Required parameter roleId was null or undefined when calling iamOrganisationRolePermissionGet.');
            }
            // verify required parameter 'permissionId' is not null or undefined
            if (permissionId === null || permissionId === undefined) {
                throw new RequiredError('permissionId','Required parameter permissionId was null or undefined when calling iamOrganisationRolePermissionGet.');
            }
            const localVarPath = `/iam/organisation/{organisationId}/role/{roleId}/permission/{permissionId}`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)))
                .replace(`{${"roleId"}}`, encodeURIComponent(String(roleId)))
                .replace(`{${"permissionId"}}`, encodeURIComponent(String(permissionId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List iam/role.permission
         * @summary List iam/role.permission
         * @param {string} organisationId Organisation Id
         * @param {string} roleId Role Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationRolePermissionList: async (organisationId: string, roleId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            if (organisationId === null || organisationId === undefined) {
                throw new RequiredError('organisationId','Required parameter organisationId was null or undefined when calling iamOrganisationRolePermissionList.');
            }
            // verify required parameter 'roleId' is not null or undefined
            if (roleId === null || roleId === undefined) {
                throw new RequiredError('roleId','Required parameter roleId was null or undefined when calling iamOrganisationRolePermissionList.');
            }
            const localVarPath = `/iam/organisation/{organisationId}/role/{roleId}/permission`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)))
                .replace(`{${"roleId"}}`, encodeURIComponent(String(roleId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replace iam/role.permission
         * @summary Replace iam/role.permission
         * @param {string} organisationId Organisation Id
         * @param {string} roleId Role Id
         * @param {Array<IamPermission>} iamPermission 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationRolePermissionPut: async (organisationId: string, roleId: string, iamPermission: Array<IamPermission>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            if (organisationId === null || organisationId === undefined) {
                throw new RequiredError('organisationId','Required parameter organisationId was null or undefined when calling iamOrganisationRolePermissionPut.');
            }
            // verify required parameter 'roleId' is not null or undefined
            if (roleId === null || roleId === undefined) {
                throw new RequiredError('roleId','Required parameter roleId was null or undefined when calling iamOrganisationRolePermissionPut.');
            }
            // verify required parameter 'iamPermission' is not null or undefined
            if (iamPermission === null || iamPermission === undefined) {
                throw new RequiredError('iamPermission','Required parameter iamPermission was null or undefined when calling iamOrganisationRolePermissionPut.');
            }
            const localVarPath = `/iam/organisation/{organisationId}/role/{roleId}/permission`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)))
                .replace(`{${"roleId"}}`, encodeURIComponent(String(roleId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof iamPermission !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(iamPermission !== undefined ? iamPermission : {}) : (iamPermission || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get iam/role.service
         * @summary Get iam/role.service
         * @param {string} organisationId Organisation Id
         * @param {string} roleId Role Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationRoleServiceGet: async (organisationId: string, roleId: string, serviceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            if (organisationId === null || organisationId === undefined) {
                throw new RequiredError('organisationId','Required parameter organisationId was null or undefined when calling iamOrganisationRoleServiceGet.');
            }
            // verify required parameter 'roleId' is not null or undefined
            if (roleId === null || roleId === undefined) {
                throw new RequiredError('roleId','Required parameter roleId was null or undefined when calling iamOrganisationRoleServiceGet.');
            }
            // verify required parameter 'serviceId' is not null or undefined
            if (serviceId === null || serviceId === undefined) {
                throw new RequiredError('serviceId','Required parameter serviceId was null or undefined when calling iamOrganisationRoleServiceGet.');
            }
            const localVarPath = `/iam/organisation/{organisationId}/role/{roleId}/service/{serviceId}`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)))
                .replace(`{${"roleId"}}`, encodeURIComponent(String(roleId)))
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List iam/role.service
         * @summary List iam/role.service
         * @param {string} organisationId Organisation Id
         * @param {string} roleId Role Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationRoleServiceList: async (organisationId: string, roleId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            if (organisationId === null || organisationId === undefined) {
                throw new RequiredError('organisationId','Required parameter organisationId was null or undefined when calling iamOrganisationRoleServiceList.');
            }
            // verify required parameter 'roleId' is not null or undefined
            if (roleId === null || roleId === undefined) {
                throw new RequiredError('roleId','Required parameter roleId was null or undefined when calling iamOrganisationRoleServiceList.');
            }
            const localVarPath = `/iam/organisation/{organisationId}/role/{roleId}/service`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)))
                .replace(`{${"roleId"}}`, encodeURIComponent(String(roleId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create iam/role.tag
         * @summary Create iam/role.tag
         * @param {string} organisationId Organisation Id
         * @param {string} roleId Role Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationRoleTagCreate: async (organisationId: string, roleId: string, tag: Tag, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            if (organisationId === null || organisationId === undefined) {
                throw new RequiredError('organisationId','Required parameter organisationId was null or undefined when calling iamOrganisationRoleTagCreate.');
            }
            // verify required parameter 'roleId' is not null or undefined
            if (roleId === null || roleId === undefined) {
                throw new RequiredError('roleId','Required parameter roleId was null or undefined when calling iamOrganisationRoleTagCreate.');
            }
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling iamOrganisationRoleTagCreate.');
            }
            const localVarPath = `/iam/organisation/{organisationId}/role/{roleId}/tag`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)))
                .replace(`{${"roleId"}}`, encodeURIComponent(String(roleId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof tag !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(tag !== undefined ? tag : {}) : (tag || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete iam/role.tag
         * @summary Delete iam/role.tag
         * @param {string} organisationId Organisation Id
         * @param {string} roleId Role Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationRoleTagDelete: async (organisationId: string, roleId: string, tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            if (organisationId === null || organisationId === undefined) {
                throw new RequiredError('organisationId','Required parameter organisationId was null or undefined when calling iamOrganisationRoleTagDelete.');
            }
            // verify required parameter 'roleId' is not null or undefined
            if (roleId === null || roleId === undefined) {
                throw new RequiredError('roleId','Required parameter roleId was null or undefined when calling iamOrganisationRoleTagDelete.');
            }
            // verify required parameter 'tagId' is not null or undefined
            if (tagId === null || tagId === undefined) {
                throw new RequiredError('tagId','Required parameter tagId was null or undefined when calling iamOrganisationRoleTagDelete.');
            }
            const localVarPath = `/iam/organisation/{organisationId}/role/{roleId}/tag/{tagId}`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)))
                .replace(`{${"roleId"}}`, encodeURIComponent(String(roleId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get iam/role.tag
         * @summary Get iam/role.tag
         * @param {string} organisationId Organisation Id
         * @param {string} roleId Role Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationRoleTagGet: async (organisationId: string, roleId: string, tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            if (organisationId === null || organisationId === undefined) {
                throw new RequiredError('organisationId','Required parameter organisationId was null or undefined when calling iamOrganisationRoleTagGet.');
            }
            // verify required parameter 'roleId' is not null or undefined
            if (roleId === null || roleId === undefined) {
                throw new RequiredError('roleId','Required parameter roleId was null or undefined when calling iamOrganisationRoleTagGet.');
            }
            // verify required parameter 'tagId' is not null or undefined
            if (tagId === null || tagId === undefined) {
                throw new RequiredError('tagId','Required parameter tagId was null or undefined when calling iamOrganisationRoleTagGet.');
            }
            const localVarPath = `/iam/organisation/{organisationId}/role/{roleId}/tag/{tagId}`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)))
                .replace(`{${"roleId"}}`, encodeURIComponent(String(roleId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List iam/role.tag
         * @summary List iam/role.tag
         * @param {string} organisationId Organisation Id
         * @param {string} roleId Role Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationRoleTagList: async (organisationId: string, roleId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            if (organisationId === null || organisationId === undefined) {
                throw new RequiredError('organisationId','Required parameter organisationId was null or undefined when calling iamOrganisationRoleTagList.');
            }
            // verify required parameter 'roleId' is not null or undefined
            if (roleId === null || roleId === undefined) {
                throw new RequiredError('roleId','Required parameter roleId was null or undefined when calling iamOrganisationRoleTagList.');
            }
            const localVarPath = `/iam/organisation/{organisationId}/role/{roleId}/tag`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)))
                .replace(`{${"roleId"}}`, encodeURIComponent(String(roleId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replace iam/role.tag
         * @summary Replace iam/role.tag
         * @param {string} organisationId Organisation Id
         * @param {string} roleId Role Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationRoleTagPut: async (organisationId: string, roleId: string, tag: Array<Tag>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            if (organisationId === null || organisationId === undefined) {
                throw new RequiredError('organisationId','Required parameter organisationId was null or undefined when calling iamOrganisationRoleTagPut.');
            }
            // verify required parameter 'roleId' is not null or undefined
            if (roleId === null || roleId === undefined) {
                throw new RequiredError('roleId','Required parameter roleId was null or undefined when calling iamOrganisationRoleTagPut.');
            }
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling iamOrganisationRoleTagPut.');
            }
            const localVarPath = `/iam/organisation/{organisationId}/role/{roleId}/tag`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)))
                .replace(`{${"roleId"}}`, encodeURIComponent(String(roleId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof tag !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(tag !== undefined ? tag : {}) : (tag || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns modified role
         * @summary Update iam/role
         * @param {string} organisationId Organisation Id
         * @param {string} roleId Role Id
         * @param {IamProjectRoleUpdate} iamProjectRoleUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationRoleUpdate: async (organisationId: string, roleId: string, iamProjectRoleUpdate: IamProjectRoleUpdate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            if (organisationId === null || organisationId === undefined) {
                throw new RequiredError('organisationId','Required parameter organisationId was null or undefined when calling iamOrganisationRoleUpdate.');
            }
            // verify required parameter 'roleId' is not null or undefined
            if (roleId === null || roleId === undefined) {
                throw new RequiredError('roleId','Required parameter roleId was null or undefined when calling iamOrganisationRoleUpdate.');
            }
            // verify required parameter 'iamProjectRoleUpdate' is not null or undefined
            if (iamProjectRoleUpdate === null || iamProjectRoleUpdate === undefined) {
                throw new RequiredError('iamProjectRoleUpdate','Required parameter iamProjectRoleUpdate was null or undefined when calling iamOrganisationRoleUpdate.');
            }
            const localVarPath = `/iam/organisation/{organisationId}/role/{roleId}`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)))
                .replace(`{${"roleId"}}`, encodeURIComponent(String(roleId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof iamProjectRoleUpdate !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(iamProjectRoleUpdate !== undefined ? iamProjectRoleUpdate : {}) : (iamProjectRoleUpdate || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IamOrganisationRoleApi - functional programming interface
 * @export
 */
export const IamOrganisationRoleApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create role
         * @summary Create iam/role
         * @param {string} organisationId Organisation Id
         * @param {IamProjectRoleCreate} iamProjectRoleCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationRoleCreate(organisationId: string, iamProjectRoleCreate: IamProjectRoleCreate, xIdempotencyKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Role>> {
            const localVarAxiosArgs = await IamOrganisationRoleApiAxiosParamCreator(configuration).iamOrganisationRoleCreate(organisationId, iamProjectRoleCreate, xIdempotencyKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete role
         * @summary Delete iam/role
         * @param {string} organisationId Organisation Id
         * @param {string} roleId Role Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationRoleDelete(organisationId: string, roleId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await IamOrganisationRoleApiAxiosParamCreator(configuration).iamOrganisationRoleDelete(organisationId, roleId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get iam/role.event
         * @summary Get iam/role.event
         * @param {string} organisationId Organisation Id
         * @param {string} roleId Role Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationRoleEventGet(organisationId: string, roleId: string, eventId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>> {
            const localVarAxiosArgs = await IamOrganisationRoleApiAxiosParamCreator(configuration).iamOrganisationRoleEventGet(organisationId, roleId, eventId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List iam/role.event
         * @summary List iam/role.event
         * @param {string} organisationId Organisation Id
         * @param {string} roleId Role Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationRoleEventList(organisationId: string, roleId: string, $limit?: number, $skip?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Event>>> {
            const localVarAxiosArgs = await IamOrganisationRoleApiAxiosParamCreator(configuration).iamOrganisationRoleEventList(organisationId, roleId, $limit, $skip, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a single role
         * @summary Get iam/role
         * @param {string} organisationId Organisation Id
         * @param {string} roleId Role Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationRoleGet(organisationId: string, roleId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Role>> {
            const localVarAxiosArgs = await IamOrganisationRoleApiAxiosParamCreator(configuration).iamOrganisationRoleGet(organisationId, roleId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List role
         * @summary List iam/role
         * @param {string} organisationId Organisation Id
         * @param {string} [name] Filter by name
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationRoleList(organisationId: string, name?: string, tagValue?: string, tagKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Role>>> {
            const localVarAxiosArgs = await IamOrganisationRoleApiAxiosParamCreator(configuration).iamOrganisationRoleList(organisationId, name, tagValue, tagKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create iam/role.permission
         * @summary Create iam/role.permission
         * @param {string} organisationId Organisation Id
         * @param {string} roleId Role Id
         * @param {IamPermission} iamPermission 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationRolePermissionCreate(organisationId: string, roleId: string, iamPermission: IamPermission, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IamPermission>> {
            const localVarAxiosArgs = await IamOrganisationRoleApiAxiosParamCreator(configuration).iamOrganisationRolePermissionCreate(organisationId, roleId, iamPermission, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete iam/role.permission
         * @summary Delete iam/role.permission
         * @param {string} organisationId Organisation Id
         * @param {string} roleId Role Id
         * @param {string} permissionId permissionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationRolePermissionDelete(organisationId: string, roleId: string, permissionId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IamPermission>> {
            const localVarAxiosArgs = await IamOrganisationRoleApiAxiosParamCreator(configuration).iamOrganisationRolePermissionDelete(organisationId, roleId, permissionId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get iam/role.permission
         * @summary Get iam/role.permission
         * @param {string} organisationId Organisation Id
         * @param {string} roleId Role Id
         * @param {string} permissionId permissionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationRolePermissionGet(organisationId: string, roleId: string, permissionId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IamPermission>> {
            const localVarAxiosArgs = await IamOrganisationRoleApiAxiosParamCreator(configuration).iamOrganisationRolePermissionGet(organisationId, roleId, permissionId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List iam/role.permission
         * @summary List iam/role.permission
         * @param {string} organisationId Organisation Id
         * @param {string} roleId Role Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationRolePermissionList(organisationId: string, roleId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<IamPermission>>> {
            const localVarAxiosArgs = await IamOrganisationRoleApiAxiosParamCreator(configuration).iamOrganisationRolePermissionList(organisationId, roleId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Replace iam/role.permission
         * @summary Replace iam/role.permission
         * @param {string} organisationId Organisation Id
         * @param {string} roleId Role Id
         * @param {Array<IamPermission>} iamPermission 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationRolePermissionPut(organisationId: string, roleId: string, iamPermission: Array<IamPermission>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<IamPermission>>> {
            const localVarAxiosArgs = await IamOrganisationRoleApiAxiosParamCreator(configuration).iamOrganisationRolePermissionPut(organisationId, roleId, iamPermission, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get iam/role.service
         * @summary Get iam/role.service
         * @param {string} organisationId Organisation Id
         * @param {string} roleId Role Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationRoleServiceGet(organisationId: string, roleId: string, serviceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceService>> {
            const localVarAxiosArgs = await IamOrganisationRoleApiAxiosParamCreator(configuration).iamOrganisationRoleServiceGet(organisationId, roleId, serviceId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List iam/role.service
         * @summary List iam/role.service
         * @param {string} organisationId Organisation Id
         * @param {string} roleId Role Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationRoleServiceList(organisationId: string, roleId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResourceService>>> {
            const localVarAxiosArgs = await IamOrganisationRoleApiAxiosParamCreator(configuration).iamOrganisationRoleServiceList(organisationId, roleId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create iam/role.tag
         * @summary Create iam/role.tag
         * @param {string} organisationId Organisation Id
         * @param {string} roleId Role Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationRoleTagCreate(organisationId: string, roleId: string, tag: Tag, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await IamOrganisationRoleApiAxiosParamCreator(configuration).iamOrganisationRoleTagCreate(organisationId, roleId, tag, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete iam/role.tag
         * @summary Delete iam/role.tag
         * @param {string} organisationId Organisation Id
         * @param {string} roleId Role Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationRoleTagDelete(organisationId: string, roleId: string, tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await IamOrganisationRoleApiAxiosParamCreator(configuration).iamOrganisationRoleTagDelete(organisationId, roleId, tagId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get iam/role.tag
         * @summary Get iam/role.tag
         * @param {string} organisationId Organisation Id
         * @param {string} roleId Role Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationRoleTagGet(organisationId: string, roleId: string, tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await IamOrganisationRoleApiAxiosParamCreator(configuration).iamOrganisationRoleTagGet(organisationId, roleId, tagId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List iam/role.tag
         * @summary List iam/role.tag
         * @param {string} organisationId Organisation Id
         * @param {string} roleId Role Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationRoleTagList(organisationId: string, roleId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await IamOrganisationRoleApiAxiosParamCreator(configuration).iamOrganisationRoleTagList(organisationId, roleId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Replace iam/role.tag
         * @summary Replace iam/role.tag
         * @param {string} organisationId Organisation Id
         * @param {string} roleId Role Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationRoleTagPut(organisationId: string, roleId: string, tag: Array<Tag>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await IamOrganisationRoleApiAxiosParamCreator(configuration).iamOrganisationRoleTagPut(organisationId, roleId, tag, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns modified role
         * @summary Update iam/role
         * @param {string} organisationId Organisation Id
         * @param {string} roleId Role Id
         * @param {IamProjectRoleUpdate} iamProjectRoleUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationRoleUpdate(organisationId: string, roleId: string, iamProjectRoleUpdate: IamProjectRoleUpdate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Role>> {
            const localVarAxiosArgs = await IamOrganisationRoleApiAxiosParamCreator(configuration).iamOrganisationRoleUpdate(organisationId, roleId, iamProjectRoleUpdate, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * IamOrganisationRoleApi - factory interface
 * @export
 */
export const IamOrganisationRoleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Create role
         * @summary Create iam/role
         * @param {string} organisationId Organisation Id
         * @param {IamProjectRoleCreate} iamProjectRoleCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationRoleCreate(organisationId: string, iamProjectRoleCreate: IamProjectRoleCreate, xIdempotencyKey?: string, options?: any): AxiosPromise<Role> {
            return IamOrganisationRoleApiFp(configuration).iamOrganisationRoleCreate(organisationId, iamProjectRoleCreate, xIdempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete role
         * @summary Delete iam/role
         * @param {string} organisationId Organisation Id
         * @param {string} roleId Role Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationRoleDelete(organisationId: string, roleId: string, options?: any): AxiosPromise<void> {
            return IamOrganisationRoleApiFp(configuration).iamOrganisationRoleDelete(organisationId, roleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get iam/role.event
         * @summary Get iam/role.event
         * @param {string} organisationId Organisation Id
         * @param {string} roleId Role Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationRoleEventGet(organisationId: string, roleId: string, eventId: string, options?: any): AxiosPromise<Event> {
            return IamOrganisationRoleApiFp(configuration).iamOrganisationRoleEventGet(organisationId, roleId, eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * List iam/role.event
         * @summary List iam/role.event
         * @param {string} organisationId Organisation Id
         * @param {string} roleId Role Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationRoleEventList(organisationId: string, roleId: string, $limit?: number, $skip?: number, options?: any): AxiosPromise<Array<Event>> {
            return IamOrganisationRoleApiFp(configuration).iamOrganisationRoleEventList(organisationId, roleId, $limit, $skip, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single role
         * @summary Get iam/role
         * @param {string} organisationId Organisation Id
         * @param {string} roleId Role Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationRoleGet(organisationId: string, roleId: string, options?: any): AxiosPromise<Role> {
            return IamOrganisationRoleApiFp(configuration).iamOrganisationRoleGet(organisationId, roleId, options).then((request) => request(axios, basePath));
        },
        /**
         * List role
         * @summary List iam/role
         * @param {string} organisationId Organisation Id
         * @param {string} [name] Filter by name
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationRoleList(organisationId: string, name?: string, tagValue?: string, tagKey?: string, options?: any): AxiosPromise<Array<Role>> {
            return IamOrganisationRoleApiFp(configuration).iamOrganisationRoleList(organisationId, name, tagValue, tagKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Create iam/role.permission
         * @summary Create iam/role.permission
         * @param {string} organisationId Organisation Id
         * @param {string} roleId Role Id
         * @param {IamPermission} iamPermission 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationRolePermissionCreate(organisationId: string, roleId: string, iamPermission: IamPermission, options?: any): AxiosPromise<IamPermission> {
            return IamOrganisationRoleApiFp(configuration).iamOrganisationRolePermissionCreate(organisationId, roleId, iamPermission, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete iam/role.permission
         * @summary Delete iam/role.permission
         * @param {string} organisationId Organisation Id
         * @param {string} roleId Role Id
         * @param {string} permissionId permissionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationRolePermissionDelete(organisationId: string, roleId: string, permissionId: string, options?: any): AxiosPromise<IamPermission> {
            return IamOrganisationRoleApiFp(configuration).iamOrganisationRolePermissionDelete(organisationId, roleId, permissionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get iam/role.permission
         * @summary Get iam/role.permission
         * @param {string} organisationId Organisation Id
         * @param {string} roleId Role Id
         * @param {string} permissionId permissionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationRolePermissionGet(organisationId: string, roleId: string, permissionId: string, options?: any): AxiosPromise<IamPermission> {
            return IamOrganisationRoleApiFp(configuration).iamOrganisationRolePermissionGet(organisationId, roleId, permissionId, options).then((request) => request(axios, basePath));
        },
        /**
         * List iam/role.permission
         * @summary List iam/role.permission
         * @param {string} organisationId Organisation Id
         * @param {string} roleId Role Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationRolePermissionList(organisationId: string, roleId: string, options?: any): AxiosPromise<Array<IamPermission>> {
            return IamOrganisationRoleApiFp(configuration).iamOrganisationRolePermissionList(organisationId, roleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Replace iam/role.permission
         * @summary Replace iam/role.permission
         * @param {string} organisationId Organisation Id
         * @param {string} roleId Role Id
         * @param {Array<IamPermission>} iamPermission 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationRolePermissionPut(organisationId: string, roleId: string, iamPermission: Array<IamPermission>, options?: any): AxiosPromise<Array<IamPermission>> {
            return IamOrganisationRoleApiFp(configuration).iamOrganisationRolePermissionPut(organisationId, roleId, iamPermission, options).then((request) => request(axios, basePath));
        },
        /**
         * Get iam/role.service
         * @summary Get iam/role.service
         * @param {string} organisationId Organisation Id
         * @param {string} roleId Role Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationRoleServiceGet(organisationId: string, roleId: string, serviceId: string, options?: any): AxiosPromise<ResourceService> {
            return IamOrganisationRoleApiFp(configuration).iamOrganisationRoleServiceGet(organisationId, roleId, serviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * List iam/role.service
         * @summary List iam/role.service
         * @param {string} organisationId Organisation Id
         * @param {string} roleId Role Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationRoleServiceList(organisationId: string, roleId: string, options?: any): AxiosPromise<Array<ResourceService>> {
            return IamOrganisationRoleApiFp(configuration).iamOrganisationRoleServiceList(organisationId, roleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create iam/role.tag
         * @summary Create iam/role.tag
         * @param {string} organisationId Organisation Id
         * @param {string} roleId Role Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationRoleTagCreate(organisationId: string, roleId: string, tag: Tag, options?: any): AxiosPromise<Tag> {
            return IamOrganisationRoleApiFp(configuration).iamOrganisationRoleTagCreate(organisationId, roleId, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete iam/role.tag
         * @summary Delete iam/role.tag
         * @param {string} organisationId Organisation Id
         * @param {string} roleId Role Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationRoleTagDelete(organisationId: string, roleId: string, tagId: string, options?: any): AxiosPromise<void> {
            return IamOrganisationRoleApiFp(configuration).iamOrganisationRoleTagDelete(organisationId, roleId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get iam/role.tag
         * @summary Get iam/role.tag
         * @param {string} organisationId Organisation Id
         * @param {string} roleId Role Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationRoleTagGet(organisationId: string, roleId: string, tagId: string, options?: any): AxiosPromise<Tag> {
            return IamOrganisationRoleApiFp(configuration).iamOrganisationRoleTagGet(organisationId, roleId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * List iam/role.tag
         * @summary List iam/role.tag
         * @param {string} organisationId Organisation Id
         * @param {string} roleId Role Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationRoleTagList(organisationId: string, roleId: string, options?: any): AxiosPromise<Array<Tag>> {
            return IamOrganisationRoleApiFp(configuration).iamOrganisationRoleTagList(organisationId, roleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Replace iam/role.tag
         * @summary Replace iam/role.tag
         * @param {string} organisationId Organisation Id
         * @param {string} roleId Role Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationRoleTagPut(organisationId: string, roleId: string, tag: Array<Tag>, options?: any): AxiosPromise<Array<Tag>> {
            return IamOrganisationRoleApiFp(configuration).iamOrganisationRoleTagPut(organisationId, roleId, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns modified role
         * @summary Update iam/role
         * @param {string} organisationId Organisation Id
         * @param {string} roleId Role Id
         * @param {IamProjectRoleUpdate} iamProjectRoleUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationRoleUpdate(organisationId: string, roleId: string, iamProjectRoleUpdate: IamProjectRoleUpdate, options?: any): AxiosPromise<Role> {
            return IamOrganisationRoleApiFp(configuration).iamOrganisationRoleUpdate(organisationId, roleId, iamProjectRoleUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IamOrganisationRoleApi - object-oriented interface
 * @export
 * @class IamOrganisationRoleApi
 * @extends {BaseAPI}
 */
export class IamOrganisationRoleApi extends BaseAPI {
    /**
     * Create role
     * @summary Create iam/role
     * @param {string} organisationId Organisation Id
     * @param {IamProjectRoleCreate} iamProjectRoleCreate 
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationRoleApi
     */
    public iamOrganisationRoleCreate(organisationId: string, iamProjectRoleCreate: IamProjectRoleCreate, xIdempotencyKey?: string, options?: any) {
        return IamOrganisationRoleApiFp(this.configuration).iamOrganisationRoleCreate(organisationId, iamProjectRoleCreate, xIdempotencyKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete role
     * @summary Delete iam/role
     * @param {string} organisationId Organisation Id
     * @param {string} roleId Role Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationRoleApi
     */
    public iamOrganisationRoleDelete(organisationId: string, roleId: string, options?: any) {
        return IamOrganisationRoleApiFp(this.configuration).iamOrganisationRoleDelete(organisationId, roleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get iam/role.event
     * @summary Get iam/role.event
     * @param {string} organisationId Organisation Id
     * @param {string} roleId Role Id
     * @param {string} eventId eventId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationRoleApi
     */
    public iamOrganisationRoleEventGet(organisationId: string, roleId: string, eventId: string, options?: any) {
        return IamOrganisationRoleApiFp(this.configuration).iamOrganisationRoleEventGet(organisationId, roleId, eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List iam/role.event
     * @summary List iam/role.event
     * @param {string} organisationId Organisation Id
     * @param {string} roleId Role Id
     * @param {number} [$limit] $limit
     * @param {number} [$skip] $skip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationRoleApi
     */
    public iamOrganisationRoleEventList(organisationId: string, roleId: string, $limit?: number, $skip?: number, options?: any) {
        return IamOrganisationRoleApiFp(this.configuration).iamOrganisationRoleEventList(organisationId, roleId, $limit, $skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single role
     * @summary Get iam/role
     * @param {string} organisationId Organisation Id
     * @param {string} roleId Role Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationRoleApi
     */
    public iamOrganisationRoleGet(organisationId: string, roleId: string, options?: any) {
        return IamOrganisationRoleApiFp(this.configuration).iamOrganisationRoleGet(organisationId, roleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List role
     * @summary List iam/role
     * @param {string} organisationId Organisation Id
     * @param {string} [name] Filter by name
     * @param {string} [tagValue] Filter by tag.value
     * @param {string} [tagKey] Filter by tag.key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationRoleApi
     */
    public iamOrganisationRoleList(organisationId: string, name?: string, tagValue?: string, tagKey?: string, options?: any) {
        return IamOrganisationRoleApiFp(this.configuration).iamOrganisationRoleList(organisationId, name, tagValue, tagKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create iam/role.permission
     * @summary Create iam/role.permission
     * @param {string} organisationId Organisation Id
     * @param {string} roleId Role Id
     * @param {IamPermission} iamPermission 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationRoleApi
     */
    public iamOrganisationRolePermissionCreate(organisationId: string, roleId: string, iamPermission: IamPermission, options?: any) {
        return IamOrganisationRoleApiFp(this.configuration).iamOrganisationRolePermissionCreate(organisationId, roleId, iamPermission, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete iam/role.permission
     * @summary Delete iam/role.permission
     * @param {string} organisationId Organisation Id
     * @param {string} roleId Role Id
     * @param {string} permissionId permissionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationRoleApi
     */
    public iamOrganisationRolePermissionDelete(organisationId: string, roleId: string, permissionId: string, options?: any) {
        return IamOrganisationRoleApiFp(this.configuration).iamOrganisationRolePermissionDelete(organisationId, roleId, permissionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get iam/role.permission
     * @summary Get iam/role.permission
     * @param {string} organisationId Organisation Id
     * @param {string} roleId Role Id
     * @param {string} permissionId permissionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationRoleApi
     */
    public iamOrganisationRolePermissionGet(organisationId: string, roleId: string, permissionId: string, options?: any) {
        return IamOrganisationRoleApiFp(this.configuration).iamOrganisationRolePermissionGet(organisationId, roleId, permissionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List iam/role.permission
     * @summary List iam/role.permission
     * @param {string} organisationId Organisation Id
     * @param {string} roleId Role Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationRoleApi
     */
    public iamOrganisationRolePermissionList(organisationId: string, roleId: string, options?: any) {
        return IamOrganisationRoleApiFp(this.configuration).iamOrganisationRolePermissionList(organisationId, roleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replace iam/role.permission
     * @summary Replace iam/role.permission
     * @param {string} organisationId Organisation Id
     * @param {string} roleId Role Id
     * @param {Array<IamPermission>} iamPermission 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationRoleApi
     */
    public iamOrganisationRolePermissionPut(organisationId: string, roleId: string, iamPermission: Array<IamPermission>, options?: any) {
        return IamOrganisationRoleApiFp(this.configuration).iamOrganisationRolePermissionPut(organisationId, roleId, iamPermission, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get iam/role.service
     * @summary Get iam/role.service
     * @param {string} organisationId Organisation Id
     * @param {string} roleId Role Id
     * @param {string} serviceId serviceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationRoleApi
     */
    public iamOrganisationRoleServiceGet(organisationId: string, roleId: string, serviceId: string, options?: any) {
        return IamOrganisationRoleApiFp(this.configuration).iamOrganisationRoleServiceGet(organisationId, roleId, serviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List iam/role.service
     * @summary List iam/role.service
     * @param {string} organisationId Organisation Id
     * @param {string} roleId Role Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationRoleApi
     */
    public iamOrganisationRoleServiceList(organisationId: string, roleId: string, options?: any) {
        return IamOrganisationRoleApiFp(this.configuration).iamOrganisationRoleServiceList(organisationId, roleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create iam/role.tag
     * @summary Create iam/role.tag
     * @param {string} organisationId Organisation Id
     * @param {string} roleId Role Id
     * @param {Tag} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationRoleApi
     */
    public iamOrganisationRoleTagCreate(organisationId: string, roleId: string, tag: Tag, options?: any) {
        return IamOrganisationRoleApiFp(this.configuration).iamOrganisationRoleTagCreate(organisationId, roleId, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete iam/role.tag
     * @summary Delete iam/role.tag
     * @param {string} organisationId Organisation Id
     * @param {string} roleId Role Id
     * @param {string} tagId tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationRoleApi
     */
    public iamOrganisationRoleTagDelete(organisationId: string, roleId: string, tagId: string, options?: any) {
        return IamOrganisationRoleApiFp(this.configuration).iamOrganisationRoleTagDelete(organisationId, roleId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get iam/role.tag
     * @summary Get iam/role.tag
     * @param {string} organisationId Organisation Id
     * @param {string} roleId Role Id
     * @param {string} tagId tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationRoleApi
     */
    public iamOrganisationRoleTagGet(organisationId: string, roleId: string, tagId: string, options?: any) {
        return IamOrganisationRoleApiFp(this.configuration).iamOrganisationRoleTagGet(organisationId, roleId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List iam/role.tag
     * @summary List iam/role.tag
     * @param {string} organisationId Organisation Id
     * @param {string} roleId Role Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationRoleApi
     */
    public iamOrganisationRoleTagList(organisationId: string, roleId: string, options?: any) {
        return IamOrganisationRoleApiFp(this.configuration).iamOrganisationRoleTagList(organisationId, roleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replace iam/role.tag
     * @summary Replace iam/role.tag
     * @param {string} organisationId Organisation Id
     * @param {string} roleId Role Id
     * @param {Array<Tag>} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationRoleApi
     */
    public iamOrganisationRoleTagPut(organisationId: string, roleId: string, tag: Array<Tag>, options?: any) {
        return IamOrganisationRoleApiFp(this.configuration).iamOrganisationRoleTagPut(organisationId, roleId, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns modified role
     * @summary Update iam/role
     * @param {string} organisationId Organisation Id
     * @param {string} roleId Role Id
     * @param {IamProjectRoleUpdate} iamProjectRoleUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationRoleApi
     */
    public iamOrganisationRoleUpdate(organisationId: string, roleId: string, iamProjectRoleUpdate: IamProjectRoleUpdate, options?: any) {
        return IamOrganisationRoleApiFp(this.configuration).iamOrganisationRoleUpdate(organisationId, roleId, iamProjectRoleUpdate, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * IamProjectApi - axios parameter creator
 * @export
 */
export const IamProjectApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List iam/project.billing
         * @summary List iam/project.billing
         * @param {string} projectId Project Id
         * @param {string} [start] start
         * @param {string} [end] end
         * @param {string} [resourceType] resource.type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectBillingList: async (projectId: string, start?: string, end?: string, resourceType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling iamProjectBillingList.');
            }
            const localVarPath = `/iam/project/{projectId}/billing`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString() :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString() :
                    end;
            }

            if (resourceType !== undefined) {
                localVarQueryParameter['resource.type'] = resourceType;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create project
         * @summary Create iam/project
         * @param {IamProjectCreate} iamProjectCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectCreate: async (iamProjectCreate: IamProjectCreate, xIdempotencyKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'iamProjectCreate' is not null or undefined
            if (iamProjectCreate === null || iamProjectCreate === undefined) {
                throw new RequiredError('iamProjectCreate','Required parameter iamProjectCreate was null or undefined when calling iamProjectCreate.');
            }
            const localVarPath = `/iam/project`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof iamProjectCreate !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(iamProjectCreate !== undefined ? iamProjectCreate : {}) : (iamProjectCreate || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create iam/project.credentialStore
         * @summary Create iam/project.credentialStore
         * @param {string} projectId Project Id
         * @param {ProjectCredential} projectCredential 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectCredentialStoreCreate: async (projectId: string, projectCredential: ProjectCredential, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling iamProjectCredentialStoreCreate.');
            }
            // verify required parameter 'projectCredential' is not null or undefined
            if (projectCredential === null || projectCredential === undefined) {
                throw new RequiredError('projectCredential','Required parameter projectCredential was null or undefined when calling iamProjectCredentialStoreCreate.');
            }
            const localVarPath = `/iam/project/{projectId}/credentialStore`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof projectCredential !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(projectCredential !== undefined ? projectCredential : {}) : (projectCredential || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete iam/project.credentialStore
         * @summary Delete iam/project.credentialStore
         * @param {string} projectId Project Id
         * @param {string} credentialStoreId credentialStoreId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectCredentialStoreDelete: async (projectId: string, credentialStoreId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling iamProjectCredentialStoreDelete.');
            }
            // verify required parameter 'credentialStoreId' is not null or undefined
            if (credentialStoreId === null || credentialStoreId === undefined) {
                throw new RequiredError('credentialStoreId','Required parameter credentialStoreId was null or undefined when calling iamProjectCredentialStoreDelete.');
            }
            const localVarPath = `/iam/project/{projectId}/credentialStore/{credentialStoreId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"credentialStoreId"}}`, encodeURIComponent(String(credentialStoreId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get iam/project.credentialStore
         * @summary Get iam/project.credentialStore
         * @param {string} projectId Project Id
         * @param {string} credentialStoreId credentialStoreId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectCredentialStoreGet: async (projectId: string, credentialStoreId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling iamProjectCredentialStoreGet.');
            }
            // verify required parameter 'credentialStoreId' is not null or undefined
            if (credentialStoreId === null || credentialStoreId === undefined) {
                throw new RequiredError('credentialStoreId','Required parameter credentialStoreId was null or undefined when calling iamProjectCredentialStoreGet.');
            }
            const localVarPath = `/iam/project/{projectId}/credentialStore/{credentialStoreId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"credentialStoreId"}}`, encodeURIComponent(String(credentialStoreId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List iam/project.credentialStore
         * @summary List iam/project.credentialStore
         * @param {string} projectId Project Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectCredentialStoreList: async (projectId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling iamProjectCredentialStoreList.');
            }
            const localVarPath = `/iam/project/{projectId}/credentialStore`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update iam/project.credentialStore
         * @summary Update iam/project.credentialStore
         * @param {string} projectId Project Id
         * @param {string} credentialStoreId credentialStoreId
         * @param {IamProjectCredentialStorePatch} iamProjectCredentialStorePatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectCredentialStorePatch: async (projectId: string, credentialStoreId: string, iamProjectCredentialStorePatch: IamProjectCredentialStorePatch, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling iamProjectCredentialStorePatch.');
            }
            // verify required parameter 'credentialStoreId' is not null or undefined
            if (credentialStoreId === null || credentialStoreId === undefined) {
                throw new RequiredError('credentialStoreId','Required parameter credentialStoreId was null or undefined when calling iamProjectCredentialStorePatch.');
            }
            // verify required parameter 'iamProjectCredentialStorePatch' is not null or undefined
            if (iamProjectCredentialStorePatch === null || iamProjectCredentialStorePatch === undefined) {
                throw new RequiredError('iamProjectCredentialStorePatch','Required parameter iamProjectCredentialStorePatch was null or undefined when calling iamProjectCredentialStorePatch.');
            }
            const localVarPath = `/iam/project/{projectId}/credentialStore/{credentialStoreId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"credentialStoreId"}}`, encodeURIComponent(String(credentialStoreId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof iamProjectCredentialStorePatch !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(iamProjectCredentialStorePatch !== undefined ? iamProjectCredentialStorePatch : {}) : (iamProjectCredentialStorePatch || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete project
         * @summary Delete iam/project
         * @param {string} projectId Project Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectDelete: async (projectId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling iamProjectDelete.');
            }
            const localVarPath = `/iam/project/{projectId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get iam/project.event
         * @summary Get iam/project.event
         * @param {string} projectId Project Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectEventGet: async (projectId: string, eventId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling iamProjectEventGet.');
            }
            // verify required parameter 'eventId' is not null or undefined
            if (eventId === null || eventId === undefined) {
                throw new RequiredError('eventId','Required parameter eventId was null or undefined when calling iamProjectEventGet.');
            }
            const localVarPath = `/iam/project/{projectId}/event/{eventId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List iam/project.event
         * @summary List iam/project.event
         * @param {string} projectId Project Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectEventList: async (projectId: string, $limit?: number, $skip?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling iamProjectEventList.');
            }
            const localVarPath = `/iam/project/{projectId}/event`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if ($limit !== undefined) {
                localVarQueryParameter['$limit'] = $limit;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single project
         * @summary Get iam/project
         * @param {string} projectId Project Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectGet: async (projectId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling iamProjectGet.');
            }
            const localVarPath = `/iam/project/{projectId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * action accept
         * @summary Accept iam/project.invitation
         * @param {string} projectId Project Id
         * @param {string} invitationId invitationId
         * @param {IamProjectInvitationAccept} iamProjectInvitationAccept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectInvitationAccept: async (projectId: string, invitationId: string, iamProjectInvitationAccept: IamProjectInvitationAccept, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling iamProjectInvitationAccept.');
            }
            // verify required parameter 'invitationId' is not null or undefined
            if (invitationId === null || invitationId === undefined) {
                throw new RequiredError('invitationId','Required parameter invitationId was null or undefined when calling iamProjectInvitationAccept.');
            }
            // verify required parameter 'iamProjectInvitationAccept' is not null or undefined
            if (iamProjectInvitationAccept === null || iamProjectInvitationAccept === undefined) {
                throw new RequiredError('iamProjectInvitationAccept','Required parameter iamProjectInvitationAccept was null or undefined when calling iamProjectInvitationAccept.');
            }
            const localVarPath = `/iam/project/{projectId}/invitation/{invitationId}/actions/accept`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"invitationId"}}`, encodeURIComponent(String(invitationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof iamProjectInvitationAccept !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(iamProjectInvitationAccept !== undefined ? iamProjectInvitationAccept : {}) : (iamProjectInvitationAccept || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete iam/project.invitation
         * @summary Delete iam/project.invitation
         * @param {string} projectId Project Id
         * @param {string} invitationId invitationId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectInvitationDelete: async (projectId: string, invitationId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling iamProjectInvitationDelete.');
            }
            // verify required parameter 'invitationId' is not null or undefined
            if (invitationId === null || invitationId === undefined) {
                throw new RequiredError('invitationId','Required parameter invitationId was null or undefined when calling iamProjectInvitationDelete.');
            }
            const localVarPath = `/iam/project/{projectId}/invitation/{invitationId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"invitationId"}}`, encodeURIComponent(String(invitationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get iam/project.invitation
         * @summary Get iam/project.invitation
         * @param {string} projectId Project Id
         * @param {string} invitationId invitationId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectInvitationGet: async (projectId: string, invitationId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling iamProjectInvitationGet.');
            }
            // verify required parameter 'invitationId' is not null or undefined
            if (invitationId === null || invitationId === undefined) {
                throw new RequiredError('invitationId','Required parameter invitationId was null or undefined when calling iamProjectInvitationGet.');
            }
            const localVarPath = `/iam/project/{projectId}/invitation/{invitationId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"invitationId"}}`, encodeURIComponent(String(invitationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List iam/project.invitation
         * @summary List iam/project.invitation
         * @param {string} projectId Project Id
         * @param {string} [resource] resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectInvitationList: async (projectId: string, resource?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling iamProjectInvitationList.');
            }
            const localVarPath = `/iam/project/{projectId}/invitation`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (resource !== undefined) {
                localVarQueryParameter['resource'] = resource;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List iam/project.invoice
         * @summary List iam/project.invoice
         * @param {string} projectId Project Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectInvoiceList: async (projectId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling iamProjectInvoiceList.');
            }
            const localVarPath = `/iam/project/{projectId}/invoice`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List project
         * @summary List iam/project
         * @param {string} [name] Filter by name
         * @param {number} [$limit] Filter by $limit
         * @param {boolean} [active] Filter by active
         * @param {string} [organisation] Filter by organisation
         * @param {boolean} [$lean] return a lightweight version of the resource
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectList: async (name?: string, $limit?: number, active?: boolean, organisation?: string, $lean?: boolean, tagValue?: string, tagKey?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/iam/project`;
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if ($limit !== undefined) {
                localVarQueryParameter['$limit'] = $limit;
            }

            if (active !== undefined) {
                localVarQueryParameter['active'] = active;
            }

            if (organisation !== undefined) {
                localVarQueryParameter['organisation'] = organisation;
            }

            if ($lean !== undefined) {
                localVarQueryParameter['$lean'] = $lean;
            }

            if (tagValue !== undefined) {
                localVarQueryParameter['tag.value'] = tagValue;
            }

            if (tagKey !== undefined) {
                localVarQueryParameter['tag.key'] = tagKey;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create iam/project.ownership
         * @summary Create iam/project.ownership
         * @param {string} projectId Project Id
         * @param {IamProjectOwnershipCreate} iamProjectOwnershipCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectOwnershipCreate: async (projectId: string, iamProjectOwnershipCreate: IamProjectOwnershipCreate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling iamProjectOwnershipCreate.');
            }
            // verify required parameter 'iamProjectOwnershipCreate' is not null or undefined
            if (iamProjectOwnershipCreate === null || iamProjectOwnershipCreate === undefined) {
                throw new RequiredError('iamProjectOwnershipCreate','Required parameter iamProjectOwnershipCreate was null or undefined when calling iamProjectOwnershipCreate.');
            }
            const localVarPath = `/iam/project/{projectId}/ownership`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof iamProjectOwnershipCreate !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(iamProjectOwnershipCreate !== undefined ? iamProjectOwnershipCreate : {}) : (iamProjectOwnershipCreate || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete iam/project.ownership
         * @summary Delete iam/project.ownership
         * @param {string} projectId Project Id
         * @param {string} ownershipId ownershipId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectOwnershipDelete: async (projectId: string, ownershipId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling iamProjectOwnershipDelete.');
            }
            // verify required parameter 'ownershipId' is not null or undefined
            if (ownershipId === null || ownershipId === undefined) {
                throw new RequiredError('ownershipId','Required parameter ownershipId was null or undefined when calling iamProjectOwnershipDelete.');
            }
            const localVarPath = `/iam/project/{projectId}/ownership/{ownershipId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"ownershipId"}}`, encodeURIComponent(String(ownershipId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get iam/project.ownership
         * @summary Get iam/project.ownership
         * @param {string} projectId Project Id
         * @param {string} ownershipId ownershipId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectOwnershipGet: async (projectId: string, ownershipId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling iamProjectOwnershipGet.');
            }
            // verify required parameter 'ownershipId' is not null or undefined
            if (ownershipId === null || ownershipId === undefined) {
                throw new RequiredError('ownershipId','Required parameter ownershipId was null or undefined when calling iamProjectOwnershipGet.');
            }
            const localVarPath = `/iam/project/{projectId}/ownership/{ownershipId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"ownershipId"}}`, encodeURIComponent(String(ownershipId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List iam/project.ownership
         * @summary List iam/project.ownership
         * @param {string} projectId Project Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectOwnershipList: async (projectId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling iamProjectOwnershipList.');
            }
            const localVarPath = `/iam/project/{projectId}/ownership`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List iam/project.payment
         * @summary List iam/project.payment
         * @param {string} projectId Project Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectPaymentList: async (projectId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling iamProjectPaymentList.');
            }
            const localVarPath = `/iam/project/{projectId}/payment`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List iam/project.proforma
         * @summary List iam/project.proforma
         * @param {string} projectId Project Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectProformaList: async (projectId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling iamProjectProformaList.');
            }
            const localVarPath = `/iam/project/{projectId}/proforma`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get iam/project.quota
         * @summary Get iam/project.quota
         * @param {string} projectId Project Id
         * @param {string} quotaId quotaId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectQuotaGet: async (projectId: string, quotaId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling iamProjectQuotaGet.');
            }
            // verify required parameter 'quotaId' is not null or undefined
            if (quotaId === null || quotaId === undefined) {
                throw new RequiredError('quotaId','Required parameter quotaId was null or undefined when calling iamProjectQuotaGet.');
            }
            const localVarPath = `/iam/project/{projectId}/quota/{quotaId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"quotaId"}}`, encodeURIComponent(String(quotaId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update iam/project.limit
         * @summary Update iam/project.limit
         * @param {string} projectId Project Id
         * @param {string} quotaId quotaId
         * @param {IamProjectQuotaLimitPatch} iamProjectQuotaLimitPatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectQuotaLimitPatch: async (projectId: string, quotaId: string, iamProjectQuotaLimitPatch: IamProjectQuotaLimitPatch, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling iamProjectQuotaLimitPatch.');
            }
            // verify required parameter 'quotaId' is not null or undefined
            if (quotaId === null || quotaId === undefined) {
                throw new RequiredError('quotaId','Required parameter quotaId was null or undefined when calling iamProjectQuotaLimitPatch.');
            }
            // verify required parameter 'iamProjectQuotaLimitPatch' is not null or undefined
            if (iamProjectQuotaLimitPatch === null || iamProjectQuotaLimitPatch === undefined) {
                throw new RequiredError('iamProjectQuotaLimitPatch','Required parameter iamProjectQuotaLimitPatch was null or undefined when calling iamProjectQuotaLimitPatch.');
            }
            const localVarPath = `/iam/project/{projectId}/quota/{quotaId}/limit`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"quotaId"}}`, encodeURIComponent(String(quotaId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof iamProjectQuotaLimitPatch !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(iamProjectQuotaLimitPatch !== undefined ? iamProjectQuotaLimitPatch : {}) : (iamProjectQuotaLimitPatch || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List iam/project.quota
         * @summary List iam/project.quota
         * @param {string} projectId Project Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectQuotaList: async (projectId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling iamProjectQuotaList.');
            }
            const localVarPath = `/iam/project/{projectId}/quota`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get iam/project.service
         * @summary Get iam/project.service
         * @param {string} projectId Project Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectServiceGet: async (projectId: string, serviceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling iamProjectServiceGet.');
            }
            // verify required parameter 'serviceId' is not null or undefined
            if (serviceId === null || serviceId === undefined) {
                throw new RequiredError('serviceId','Required parameter serviceId was null or undefined when calling iamProjectServiceGet.');
            }
            const localVarPath = `/iam/project/{projectId}/service/{serviceId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List iam/project.service
         * @summary List iam/project.service
         * @param {string} projectId Project Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectServiceList: async (projectId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling iamProjectServiceList.');
            }
            const localVarPath = `/iam/project/{projectId}/service`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create iam/project.tag
         * @summary Create iam/project.tag
         * @param {string} projectId Project Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectTagCreate: async (projectId: string, tag: Tag, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling iamProjectTagCreate.');
            }
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling iamProjectTagCreate.');
            }
            const localVarPath = `/iam/project/{projectId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof tag !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(tag !== undefined ? tag : {}) : (tag || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete iam/project.tag
         * @summary Delete iam/project.tag
         * @param {string} projectId Project Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectTagDelete: async (projectId: string, tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling iamProjectTagDelete.');
            }
            // verify required parameter 'tagId' is not null or undefined
            if (tagId === null || tagId === undefined) {
                throw new RequiredError('tagId','Required parameter tagId was null or undefined when calling iamProjectTagDelete.');
            }
            const localVarPath = `/iam/project/{projectId}/tag/{tagId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get iam/project.tag
         * @summary Get iam/project.tag
         * @param {string} projectId Project Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectTagGet: async (projectId: string, tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling iamProjectTagGet.');
            }
            // verify required parameter 'tagId' is not null or undefined
            if (tagId === null || tagId === undefined) {
                throw new RequiredError('tagId','Required parameter tagId was null or undefined when calling iamProjectTagGet.');
            }
            const localVarPath = `/iam/project/{projectId}/tag/{tagId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List iam/project.tag
         * @summary List iam/project.tag
         * @param {string} projectId Project Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectTagList: async (projectId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling iamProjectTagList.');
            }
            const localVarPath = `/iam/project/{projectId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replace iam/project.tag
         * @summary Replace iam/project.tag
         * @param {string} projectId Project Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectTagPut: async (projectId: string, tag: Array<Tag>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling iamProjectTagPut.');
            }
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling iamProjectTagPut.');
            }
            const localVarPath = `/iam/project/{projectId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof tag !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(tag !== undefined ? tag : {}) : (tag || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create iam/project.threshold
         * @summary Create iam/project.threshold
         * @param {string} projectId Project Id
         * @param {IamProjectThresholdCreate} iamProjectThresholdCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectThresholdCreate: async (projectId: string, iamProjectThresholdCreate: IamProjectThresholdCreate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling iamProjectThresholdCreate.');
            }
            // verify required parameter 'iamProjectThresholdCreate' is not null or undefined
            if (iamProjectThresholdCreate === null || iamProjectThresholdCreate === undefined) {
                throw new RequiredError('iamProjectThresholdCreate','Required parameter iamProjectThresholdCreate was null or undefined when calling iamProjectThresholdCreate.');
            }
            const localVarPath = `/iam/project/{projectId}/threshold`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof iamProjectThresholdCreate !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(iamProjectThresholdCreate !== undefined ? iamProjectThresholdCreate : {}) : (iamProjectThresholdCreate || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete iam/project.threshold
         * @summary Delete iam/project.threshold
         * @param {string} projectId Project Id
         * @param {string} thresholdId thresholdId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectThresholdDelete: async (projectId: string, thresholdId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling iamProjectThresholdDelete.');
            }
            // verify required parameter 'thresholdId' is not null or undefined
            if (thresholdId === null || thresholdId === undefined) {
                throw new RequiredError('thresholdId','Required parameter thresholdId was null or undefined when calling iamProjectThresholdDelete.');
            }
            const localVarPath = `/iam/project/{projectId}/threshold/{thresholdId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"thresholdId"}}`, encodeURIComponent(String(thresholdId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get iam/project.threshold
         * @summary Get iam/project.threshold
         * @param {string} projectId Project Id
         * @param {string} thresholdId thresholdId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectThresholdGet: async (projectId: string, thresholdId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling iamProjectThresholdGet.');
            }
            // verify required parameter 'thresholdId' is not null or undefined
            if (thresholdId === null || thresholdId === undefined) {
                throw new RequiredError('thresholdId','Required parameter thresholdId was null or undefined when calling iamProjectThresholdGet.');
            }
            const localVarPath = `/iam/project/{projectId}/threshold/{thresholdId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"thresholdId"}}`, encodeURIComponent(String(thresholdId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List iam/project.threshold
         * @summary List iam/project.threshold
         * @param {string} projectId Project Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectThresholdList: async (projectId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling iamProjectThresholdList.');
            }
            const localVarPath = `/iam/project/{projectId}/threshold`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * action transfer
         * @summary Transfer iam/project
         * @param {string} projectId Project Id
         * @param {IamProjectTransfer} iamProjectTransfer 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectTransfer: async (projectId: string, iamProjectTransfer: IamProjectTransfer, xIdempotencyKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling iamProjectTransfer.');
            }
            // verify required parameter 'iamProjectTransfer' is not null or undefined
            if (iamProjectTransfer === null || iamProjectTransfer === undefined) {
                throw new RequiredError('iamProjectTransfer','Required parameter iamProjectTransfer was null or undefined when calling iamProjectTransfer.');
            }
            const localVarPath = `/iam/project/{projectId}/actions/transfer`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof iamProjectTransfer !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(iamProjectTransfer !== undefined ? iamProjectTransfer : {}) : (iamProjectTransfer || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns modified project
         * @summary Update iam/project
         * @param {string} projectId Project Id
         * @param {IamProjectUpdate} iamProjectUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectUpdate: async (projectId: string, iamProjectUpdate: IamProjectUpdate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling iamProjectUpdate.');
            }
            // verify required parameter 'iamProjectUpdate' is not null or undefined
            if (iamProjectUpdate === null || iamProjectUpdate === undefined) {
                throw new RequiredError('iamProjectUpdate','Required parameter iamProjectUpdate was null or undefined when calling iamProjectUpdate.');
            }
            const localVarPath = `/iam/project/{projectId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof iamProjectUpdate !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(iamProjectUpdate !== undefined ? iamProjectUpdate : {}) : (iamProjectUpdate || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IamProjectApi - functional programming interface
 * @export
 */
export const IamProjectApiFp = function(configuration?: Configuration) {
    return {
        /**
         * List iam/project.billing
         * @summary List iam/project.billing
         * @param {string} projectId Project Id
         * @param {string} [start] start
         * @param {string} [end] end
         * @param {string} [resourceType] resource.type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectBillingList(projectId: string, start?: string, end?: string, resourceType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Billing>>> {
            const localVarAxiosArgs = await IamProjectApiAxiosParamCreator(configuration).iamProjectBillingList(projectId, start, end, resourceType, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create project
         * @summary Create iam/project
         * @param {IamProjectCreate} iamProjectCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectCreate(iamProjectCreate: IamProjectCreate, xIdempotencyKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Project>> {
            const localVarAxiosArgs = await IamProjectApiAxiosParamCreator(configuration).iamProjectCreate(iamProjectCreate, xIdempotencyKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create iam/project.credentialStore
         * @summary Create iam/project.credentialStore
         * @param {string} projectId Project Id
         * @param {ProjectCredential} projectCredential 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectCredentialStoreCreate(projectId: string, projectCredential: ProjectCredential, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectCredential>> {
            const localVarAxiosArgs = await IamProjectApiAxiosParamCreator(configuration).iamProjectCredentialStoreCreate(projectId, projectCredential, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete iam/project.credentialStore
         * @summary Delete iam/project.credentialStore
         * @param {string} projectId Project Id
         * @param {string} credentialStoreId credentialStoreId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectCredentialStoreDelete(projectId: string, credentialStoreId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Project>> {
            const localVarAxiosArgs = await IamProjectApiAxiosParamCreator(configuration).iamProjectCredentialStoreDelete(projectId, credentialStoreId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get iam/project.credentialStore
         * @summary Get iam/project.credentialStore
         * @param {string} projectId Project Id
         * @param {string} credentialStoreId credentialStoreId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectCredentialStoreGet(projectId: string, credentialStoreId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectCredential>> {
            const localVarAxiosArgs = await IamProjectApiAxiosParamCreator(configuration).iamProjectCredentialStoreGet(projectId, credentialStoreId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List iam/project.credentialStore
         * @summary List iam/project.credentialStore
         * @param {string} projectId Project Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectCredentialStoreList(projectId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProjectCredential>>> {
            const localVarAxiosArgs = await IamProjectApiAxiosParamCreator(configuration).iamProjectCredentialStoreList(projectId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update iam/project.credentialStore
         * @summary Update iam/project.credentialStore
         * @param {string} projectId Project Id
         * @param {string} credentialStoreId credentialStoreId
         * @param {IamProjectCredentialStorePatch} iamProjectCredentialStorePatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectCredentialStorePatch(projectId: string, credentialStoreId: string, iamProjectCredentialStorePatch: IamProjectCredentialStorePatch, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectCredential>> {
            const localVarAxiosArgs = await IamProjectApiAxiosParamCreator(configuration).iamProjectCredentialStorePatch(projectId, credentialStoreId, iamProjectCredentialStorePatch, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete project
         * @summary Delete iam/project
         * @param {string} projectId Project Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectDelete(projectId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await IamProjectApiAxiosParamCreator(configuration).iamProjectDelete(projectId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get iam/project.event
         * @summary Get iam/project.event
         * @param {string} projectId Project Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectEventGet(projectId: string, eventId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>> {
            const localVarAxiosArgs = await IamProjectApiAxiosParamCreator(configuration).iamProjectEventGet(projectId, eventId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List iam/project.event
         * @summary List iam/project.event
         * @param {string} projectId Project Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectEventList(projectId: string, $limit?: number, $skip?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Event>>> {
            const localVarAxiosArgs = await IamProjectApiAxiosParamCreator(configuration).iamProjectEventList(projectId, $limit, $skip, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a single project
         * @summary Get iam/project
         * @param {string} projectId Project Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectGet(projectId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Project>> {
            const localVarAxiosArgs = await IamProjectApiAxiosParamCreator(configuration).iamProjectGet(projectId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * action accept
         * @summary Accept iam/project.invitation
         * @param {string} projectId Project Id
         * @param {string} invitationId invitationId
         * @param {IamProjectInvitationAccept} iamProjectInvitationAccept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectInvitationAccept(projectId: string, invitationId: string, iamProjectInvitationAccept: IamProjectInvitationAccept, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Invitation>> {
            const localVarAxiosArgs = await IamProjectApiAxiosParamCreator(configuration).iamProjectInvitationAccept(projectId, invitationId, iamProjectInvitationAccept, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete iam/project.invitation
         * @summary Delete iam/project.invitation
         * @param {string} projectId Project Id
         * @param {string} invitationId invitationId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectInvitationDelete(projectId: string, invitationId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await IamProjectApiAxiosParamCreator(configuration).iamProjectInvitationDelete(projectId, invitationId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get iam/project.invitation
         * @summary Get iam/project.invitation
         * @param {string} projectId Project Id
         * @param {string} invitationId invitationId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectInvitationGet(projectId: string, invitationId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Invitation>> {
            const localVarAxiosArgs = await IamProjectApiAxiosParamCreator(configuration).iamProjectInvitationGet(projectId, invitationId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List iam/project.invitation
         * @summary List iam/project.invitation
         * @param {string} projectId Project Id
         * @param {string} [resource] resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectInvitationList(projectId: string, resource?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Invitation>>> {
            const localVarAxiosArgs = await IamProjectApiAxiosParamCreator(configuration).iamProjectInvitationList(projectId, resource, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List iam/project.invoice
         * @summary List iam/project.invoice
         * @param {string} projectId Project Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectInvoiceList(projectId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Invoice>>> {
            const localVarAxiosArgs = await IamProjectApiAxiosParamCreator(configuration).iamProjectInvoiceList(projectId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List project
         * @summary List iam/project
         * @param {string} [name] Filter by name
         * @param {number} [$limit] Filter by $limit
         * @param {boolean} [active] Filter by active
         * @param {string} [organisation] Filter by organisation
         * @param {boolean} [$lean] return a lightweight version of the resource
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectList(name?: string, $limit?: number, active?: boolean, organisation?: string, $lean?: boolean, tagValue?: string, tagKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Project>>> {
            const localVarAxiosArgs = await IamProjectApiAxiosParamCreator(configuration).iamProjectList(name, $limit, active, organisation, $lean, tagValue, tagKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create iam/project.ownership
         * @summary Create iam/project.ownership
         * @param {string} projectId Project Id
         * @param {IamProjectOwnershipCreate} iamProjectOwnershipCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectOwnershipCreate(projectId: string, iamProjectOwnershipCreate: IamProjectOwnershipCreate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Project>> {
            const localVarAxiosArgs = await IamProjectApiAxiosParamCreator(configuration).iamProjectOwnershipCreate(projectId, iamProjectOwnershipCreate, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete iam/project.ownership
         * @summary Delete iam/project.ownership
         * @param {string} projectId Project Id
         * @param {string} ownershipId ownershipId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectOwnershipDelete(projectId: string, ownershipId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await IamProjectApiAxiosParamCreator(configuration).iamProjectOwnershipDelete(projectId, ownershipId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get iam/project.ownership
         * @summary Get iam/project.ownership
         * @param {string} projectId Project Id
         * @param {string} ownershipId ownershipId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectOwnershipGet(projectId: string, ownershipId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Ownership>> {
            const localVarAxiosArgs = await IamProjectApiAxiosParamCreator(configuration).iamProjectOwnershipGet(projectId, ownershipId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List iam/project.ownership
         * @summary List iam/project.ownership
         * @param {string} projectId Project Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectOwnershipList(projectId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Ownership>>> {
            const localVarAxiosArgs = await IamProjectApiAxiosParamCreator(configuration).iamProjectOwnershipList(projectId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List iam/project.payment
         * @summary List iam/project.payment
         * @param {string} projectId Project Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectPaymentList(projectId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Payment>>> {
            const localVarAxiosArgs = await IamProjectApiAxiosParamCreator(configuration).iamProjectPaymentList(projectId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List iam/project.proforma
         * @summary List iam/project.proforma
         * @param {string} projectId Project Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectProformaList(projectId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Proforma>>> {
            const localVarAxiosArgs = await IamProjectApiAxiosParamCreator(configuration).iamProjectProformaList(projectId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get iam/project.quota
         * @summary Get iam/project.quota
         * @param {string} projectId Project Id
         * @param {string} quotaId quotaId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectQuotaGet(projectId: string, quotaId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Quota>> {
            const localVarAxiosArgs = await IamProjectApiAxiosParamCreator(configuration).iamProjectQuotaGet(projectId, quotaId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update iam/project.limit
         * @summary Update iam/project.limit
         * @param {string} projectId Project Id
         * @param {string} quotaId quotaId
         * @param {IamProjectQuotaLimitPatch} iamProjectQuotaLimitPatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectQuotaLimitPatch(projectId: string, quotaId: string, iamProjectQuotaLimitPatch: IamProjectQuotaLimitPatch, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QuotaLimit>> {
            const localVarAxiosArgs = await IamProjectApiAxiosParamCreator(configuration).iamProjectQuotaLimitPatch(projectId, quotaId, iamProjectQuotaLimitPatch, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List iam/project.quota
         * @summary List iam/project.quota
         * @param {string} projectId Project Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectQuotaList(projectId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Quota>>> {
            const localVarAxiosArgs = await IamProjectApiAxiosParamCreator(configuration).iamProjectQuotaList(projectId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get iam/project.service
         * @summary Get iam/project.service
         * @param {string} projectId Project Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectServiceGet(projectId: string, serviceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceService>> {
            const localVarAxiosArgs = await IamProjectApiAxiosParamCreator(configuration).iamProjectServiceGet(projectId, serviceId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List iam/project.service
         * @summary List iam/project.service
         * @param {string} projectId Project Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectServiceList(projectId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResourceService>>> {
            const localVarAxiosArgs = await IamProjectApiAxiosParamCreator(configuration).iamProjectServiceList(projectId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create iam/project.tag
         * @summary Create iam/project.tag
         * @param {string} projectId Project Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectTagCreate(projectId: string, tag: Tag, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await IamProjectApiAxiosParamCreator(configuration).iamProjectTagCreate(projectId, tag, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete iam/project.tag
         * @summary Delete iam/project.tag
         * @param {string} projectId Project Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectTagDelete(projectId: string, tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await IamProjectApiAxiosParamCreator(configuration).iamProjectTagDelete(projectId, tagId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get iam/project.tag
         * @summary Get iam/project.tag
         * @param {string} projectId Project Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectTagGet(projectId: string, tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await IamProjectApiAxiosParamCreator(configuration).iamProjectTagGet(projectId, tagId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List iam/project.tag
         * @summary List iam/project.tag
         * @param {string} projectId Project Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectTagList(projectId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await IamProjectApiAxiosParamCreator(configuration).iamProjectTagList(projectId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Replace iam/project.tag
         * @summary Replace iam/project.tag
         * @param {string} projectId Project Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectTagPut(projectId: string, tag: Array<Tag>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await IamProjectApiAxiosParamCreator(configuration).iamProjectTagPut(projectId, tag, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create iam/project.threshold
         * @summary Create iam/project.threshold
         * @param {string} projectId Project Id
         * @param {IamProjectThresholdCreate} iamProjectThresholdCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectThresholdCreate(projectId: string, iamProjectThresholdCreate: IamProjectThresholdCreate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectThreshold>> {
            const localVarAxiosArgs = await IamProjectApiAxiosParamCreator(configuration).iamProjectThresholdCreate(projectId, iamProjectThresholdCreate, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete iam/project.threshold
         * @summary Delete iam/project.threshold
         * @param {string} projectId Project Id
         * @param {string} thresholdId thresholdId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectThresholdDelete(projectId: string, thresholdId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await IamProjectApiAxiosParamCreator(configuration).iamProjectThresholdDelete(projectId, thresholdId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get iam/project.threshold
         * @summary Get iam/project.threshold
         * @param {string} projectId Project Id
         * @param {string} thresholdId thresholdId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectThresholdGet(projectId: string, thresholdId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectThreshold>> {
            const localVarAxiosArgs = await IamProjectApiAxiosParamCreator(configuration).iamProjectThresholdGet(projectId, thresholdId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List iam/project.threshold
         * @summary List iam/project.threshold
         * @param {string} projectId Project Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectThresholdList(projectId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProjectThreshold>>> {
            const localVarAxiosArgs = await IamProjectApiAxiosParamCreator(configuration).iamProjectThresholdList(projectId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * action transfer
         * @summary Transfer iam/project
         * @param {string} projectId Project Id
         * @param {IamProjectTransfer} iamProjectTransfer 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectTransfer(projectId: string, iamProjectTransfer: IamProjectTransfer, xIdempotencyKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Project>> {
            const localVarAxiosArgs = await IamProjectApiAxiosParamCreator(configuration).iamProjectTransfer(projectId, iamProjectTransfer, xIdempotencyKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns modified project
         * @summary Update iam/project
         * @param {string} projectId Project Id
         * @param {IamProjectUpdate} iamProjectUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectUpdate(projectId: string, iamProjectUpdate: IamProjectUpdate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Project>> {
            const localVarAxiosArgs = await IamProjectApiAxiosParamCreator(configuration).iamProjectUpdate(projectId, iamProjectUpdate, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * IamProjectApi - factory interface
 * @export
 */
export const IamProjectApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * List iam/project.billing
         * @summary List iam/project.billing
         * @param {string} projectId Project Id
         * @param {string} [start] start
         * @param {string} [end] end
         * @param {string} [resourceType] resource.type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectBillingList(projectId: string, start?: string, end?: string, resourceType?: string, options?: any): AxiosPromise<Array<Billing>> {
            return IamProjectApiFp(configuration).iamProjectBillingList(projectId, start, end, resourceType, options).then((request) => request(axios, basePath));
        },
        /**
         * Create project
         * @summary Create iam/project
         * @param {IamProjectCreate} iamProjectCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectCreate(iamProjectCreate: IamProjectCreate, xIdempotencyKey?: string, options?: any): AxiosPromise<Project> {
            return IamProjectApiFp(configuration).iamProjectCreate(iamProjectCreate, xIdempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Create iam/project.credentialStore
         * @summary Create iam/project.credentialStore
         * @param {string} projectId Project Id
         * @param {ProjectCredential} projectCredential 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectCredentialStoreCreate(projectId: string, projectCredential: ProjectCredential, options?: any): AxiosPromise<ProjectCredential> {
            return IamProjectApiFp(configuration).iamProjectCredentialStoreCreate(projectId, projectCredential, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete iam/project.credentialStore
         * @summary Delete iam/project.credentialStore
         * @param {string} projectId Project Id
         * @param {string} credentialStoreId credentialStoreId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectCredentialStoreDelete(projectId: string, credentialStoreId: string, options?: any): AxiosPromise<Project> {
            return IamProjectApiFp(configuration).iamProjectCredentialStoreDelete(projectId, credentialStoreId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get iam/project.credentialStore
         * @summary Get iam/project.credentialStore
         * @param {string} projectId Project Id
         * @param {string} credentialStoreId credentialStoreId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectCredentialStoreGet(projectId: string, credentialStoreId: string, options?: any): AxiosPromise<ProjectCredential> {
            return IamProjectApiFp(configuration).iamProjectCredentialStoreGet(projectId, credentialStoreId, options).then((request) => request(axios, basePath));
        },
        /**
         * List iam/project.credentialStore
         * @summary List iam/project.credentialStore
         * @param {string} projectId Project Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectCredentialStoreList(projectId: string, options?: any): AxiosPromise<Array<ProjectCredential>> {
            return IamProjectApiFp(configuration).iamProjectCredentialStoreList(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update iam/project.credentialStore
         * @summary Update iam/project.credentialStore
         * @param {string} projectId Project Id
         * @param {string} credentialStoreId credentialStoreId
         * @param {IamProjectCredentialStorePatch} iamProjectCredentialStorePatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectCredentialStorePatch(projectId: string, credentialStoreId: string, iamProjectCredentialStorePatch: IamProjectCredentialStorePatch, options?: any): AxiosPromise<ProjectCredential> {
            return IamProjectApiFp(configuration).iamProjectCredentialStorePatch(projectId, credentialStoreId, iamProjectCredentialStorePatch, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete project
         * @summary Delete iam/project
         * @param {string} projectId Project Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectDelete(projectId: string, options?: any): AxiosPromise<void> {
            return IamProjectApiFp(configuration).iamProjectDelete(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get iam/project.event
         * @summary Get iam/project.event
         * @param {string} projectId Project Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectEventGet(projectId: string, eventId: string, options?: any): AxiosPromise<Event> {
            return IamProjectApiFp(configuration).iamProjectEventGet(projectId, eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * List iam/project.event
         * @summary List iam/project.event
         * @param {string} projectId Project Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectEventList(projectId: string, $limit?: number, $skip?: number, options?: any): AxiosPromise<Array<Event>> {
            return IamProjectApiFp(configuration).iamProjectEventList(projectId, $limit, $skip, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single project
         * @summary Get iam/project
         * @param {string} projectId Project Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectGet(projectId: string, options?: any): AxiosPromise<Project> {
            return IamProjectApiFp(configuration).iamProjectGet(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * action accept
         * @summary Accept iam/project.invitation
         * @param {string} projectId Project Id
         * @param {string} invitationId invitationId
         * @param {IamProjectInvitationAccept} iamProjectInvitationAccept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectInvitationAccept(projectId: string, invitationId: string, iamProjectInvitationAccept: IamProjectInvitationAccept, options?: any): AxiosPromise<Invitation> {
            return IamProjectApiFp(configuration).iamProjectInvitationAccept(projectId, invitationId, iamProjectInvitationAccept, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete iam/project.invitation
         * @summary Delete iam/project.invitation
         * @param {string} projectId Project Id
         * @param {string} invitationId invitationId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectInvitationDelete(projectId: string, invitationId: string, options?: any): AxiosPromise<void> {
            return IamProjectApiFp(configuration).iamProjectInvitationDelete(projectId, invitationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get iam/project.invitation
         * @summary Get iam/project.invitation
         * @param {string} projectId Project Id
         * @param {string} invitationId invitationId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectInvitationGet(projectId: string, invitationId: string, options?: any): AxiosPromise<Invitation> {
            return IamProjectApiFp(configuration).iamProjectInvitationGet(projectId, invitationId, options).then((request) => request(axios, basePath));
        },
        /**
         * List iam/project.invitation
         * @summary List iam/project.invitation
         * @param {string} projectId Project Id
         * @param {string} [resource] resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectInvitationList(projectId: string, resource?: string, options?: any): AxiosPromise<Array<Invitation>> {
            return IamProjectApiFp(configuration).iamProjectInvitationList(projectId, resource, options).then((request) => request(axios, basePath));
        },
        /**
         * List iam/project.invoice
         * @summary List iam/project.invoice
         * @param {string} projectId Project Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectInvoiceList(projectId: string, options?: any): AxiosPromise<Array<Invoice>> {
            return IamProjectApiFp(configuration).iamProjectInvoiceList(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * List project
         * @summary List iam/project
         * @param {string} [name] Filter by name
         * @param {number} [$limit] Filter by $limit
         * @param {boolean} [active] Filter by active
         * @param {string} [organisation] Filter by organisation
         * @param {boolean} [$lean] return a lightweight version of the resource
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectList(name?: string, $limit?: number, active?: boolean, organisation?: string, $lean?: boolean, tagValue?: string, tagKey?: string, options?: any): AxiosPromise<Array<Project>> {
            return IamProjectApiFp(configuration).iamProjectList(name, $limit, active, organisation, $lean, tagValue, tagKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Create iam/project.ownership
         * @summary Create iam/project.ownership
         * @param {string} projectId Project Id
         * @param {IamProjectOwnershipCreate} iamProjectOwnershipCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectOwnershipCreate(projectId: string, iamProjectOwnershipCreate: IamProjectOwnershipCreate, options?: any): AxiosPromise<Project> {
            return IamProjectApiFp(configuration).iamProjectOwnershipCreate(projectId, iamProjectOwnershipCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete iam/project.ownership
         * @summary Delete iam/project.ownership
         * @param {string} projectId Project Id
         * @param {string} ownershipId ownershipId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectOwnershipDelete(projectId: string, ownershipId: string, options?: any): AxiosPromise<void> {
            return IamProjectApiFp(configuration).iamProjectOwnershipDelete(projectId, ownershipId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get iam/project.ownership
         * @summary Get iam/project.ownership
         * @param {string} projectId Project Id
         * @param {string} ownershipId ownershipId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectOwnershipGet(projectId: string, ownershipId: string, options?: any): AxiosPromise<Ownership> {
            return IamProjectApiFp(configuration).iamProjectOwnershipGet(projectId, ownershipId, options).then((request) => request(axios, basePath));
        },
        /**
         * List iam/project.ownership
         * @summary List iam/project.ownership
         * @param {string} projectId Project Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectOwnershipList(projectId: string, options?: any): AxiosPromise<Array<Ownership>> {
            return IamProjectApiFp(configuration).iamProjectOwnershipList(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * List iam/project.payment
         * @summary List iam/project.payment
         * @param {string} projectId Project Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectPaymentList(projectId: string, options?: any): AxiosPromise<Array<Payment>> {
            return IamProjectApiFp(configuration).iamProjectPaymentList(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * List iam/project.proforma
         * @summary List iam/project.proforma
         * @param {string} projectId Project Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectProformaList(projectId: string, options?: any): AxiosPromise<Array<Proforma>> {
            return IamProjectApiFp(configuration).iamProjectProformaList(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get iam/project.quota
         * @summary Get iam/project.quota
         * @param {string} projectId Project Id
         * @param {string} quotaId quotaId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectQuotaGet(projectId: string, quotaId: string, options?: any): AxiosPromise<Quota> {
            return IamProjectApiFp(configuration).iamProjectQuotaGet(projectId, quotaId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update iam/project.limit
         * @summary Update iam/project.limit
         * @param {string} projectId Project Id
         * @param {string} quotaId quotaId
         * @param {IamProjectQuotaLimitPatch} iamProjectQuotaLimitPatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectQuotaLimitPatch(projectId: string, quotaId: string, iamProjectQuotaLimitPatch: IamProjectQuotaLimitPatch, options?: any): AxiosPromise<QuotaLimit> {
            return IamProjectApiFp(configuration).iamProjectQuotaLimitPatch(projectId, quotaId, iamProjectQuotaLimitPatch, options).then((request) => request(axios, basePath));
        },
        /**
         * List iam/project.quota
         * @summary List iam/project.quota
         * @param {string} projectId Project Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectQuotaList(projectId: string, options?: any): AxiosPromise<Array<Quota>> {
            return IamProjectApiFp(configuration).iamProjectQuotaList(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get iam/project.service
         * @summary Get iam/project.service
         * @param {string} projectId Project Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectServiceGet(projectId: string, serviceId: string, options?: any): AxiosPromise<ResourceService> {
            return IamProjectApiFp(configuration).iamProjectServiceGet(projectId, serviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * List iam/project.service
         * @summary List iam/project.service
         * @param {string} projectId Project Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectServiceList(projectId: string, options?: any): AxiosPromise<Array<ResourceService>> {
            return IamProjectApiFp(configuration).iamProjectServiceList(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create iam/project.tag
         * @summary Create iam/project.tag
         * @param {string} projectId Project Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectTagCreate(projectId: string, tag: Tag, options?: any): AxiosPromise<Tag> {
            return IamProjectApiFp(configuration).iamProjectTagCreate(projectId, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete iam/project.tag
         * @summary Delete iam/project.tag
         * @param {string} projectId Project Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectTagDelete(projectId: string, tagId: string, options?: any): AxiosPromise<void> {
            return IamProjectApiFp(configuration).iamProjectTagDelete(projectId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get iam/project.tag
         * @summary Get iam/project.tag
         * @param {string} projectId Project Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectTagGet(projectId: string, tagId: string, options?: any): AxiosPromise<Tag> {
            return IamProjectApiFp(configuration).iamProjectTagGet(projectId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * List iam/project.tag
         * @summary List iam/project.tag
         * @param {string} projectId Project Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectTagList(projectId: string, options?: any): AxiosPromise<Array<Tag>> {
            return IamProjectApiFp(configuration).iamProjectTagList(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * Replace iam/project.tag
         * @summary Replace iam/project.tag
         * @param {string} projectId Project Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectTagPut(projectId: string, tag: Array<Tag>, options?: any): AxiosPromise<Array<Tag>> {
            return IamProjectApiFp(configuration).iamProjectTagPut(projectId, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * Create iam/project.threshold
         * @summary Create iam/project.threshold
         * @param {string} projectId Project Id
         * @param {IamProjectThresholdCreate} iamProjectThresholdCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectThresholdCreate(projectId: string, iamProjectThresholdCreate: IamProjectThresholdCreate, options?: any): AxiosPromise<ProjectThreshold> {
            return IamProjectApiFp(configuration).iamProjectThresholdCreate(projectId, iamProjectThresholdCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete iam/project.threshold
         * @summary Delete iam/project.threshold
         * @param {string} projectId Project Id
         * @param {string} thresholdId thresholdId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectThresholdDelete(projectId: string, thresholdId: string, options?: any): AxiosPromise<void> {
            return IamProjectApiFp(configuration).iamProjectThresholdDelete(projectId, thresholdId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get iam/project.threshold
         * @summary Get iam/project.threshold
         * @param {string} projectId Project Id
         * @param {string} thresholdId thresholdId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectThresholdGet(projectId: string, thresholdId: string, options?: any): AxiosPromise<ProjectThreshold> {
            return IamProjectApiFp(configuration).iamProjectThresholdGet(projectId, thresholdId, options).then((request) => request(axios, basePath));
        },
        /**
         * List iam/project.threshold
         * @summary List iam/project.threshold
         * @param {string} projectId Project Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectThresholdList(projectId: string, options?: any): AxiosPromise<Array<ProjectThreshold>> {
            return IamProjectApiFp(configuration).iamProjectThresholdList(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * action transfer
         * @summary Transfer iam/project
         * @param {string} projectId Project Id
         * @param {IamProjectTransfer} iamProjectTransfer 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectTransfer(projectId: string, iamProjectTransfer: IamProjectTransfer, xIdempotencyKey?: string, options?: any): AxiosPromise<Project> {
            return IamProjectApiFp(configuration).iamProjectTransfer(projectId, iamProjectTransfer, xIdempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns modified project
         * @summary Update iam/project
         * @param {string} projectId Project Id
         * @param {IamProjectUpdate} iamProjectUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectUpdate(projectId: string, iamProjectUpdate: IamProjectUpdate, options?: any): AxiosPromise<Project> {
            return IamProjectApiFp(configuration).iamProjectUpdate(projectId, iamProjectUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IamProjectApi - object-oriented interface
 * @export
 * @class IamProjectApi
 * @extends {BaseAPI}
 */
export class IamProjectApi extends BaseAPI {
    /**
     * List iam/project.billing
     * @summary List iam/project.billing
     * @param {string} projectId Project Id
     * @param {string} [start] start
     * @param {string} [end] end
     * @param {string} [resourceType] resource.type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectApi
     */
    public iamProjectBillingList(projectId: string, start?: string, end?: string, resourceType?: string, options?: any) {
        return IamProjectApiFp(this.configuration).iamProjectBillingList(projectId, start, end, resourceType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create project
     * @summary Create iam/project
     * @param {IamProjectCreate} iamProjectCreate 
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectApi
     */
    public iamProjectCreate(iamProjectCreate: IamProjectCreate, xIdempotencyKey?: string, options?: any) {
        return IamProjectApiFp(this.configuration).iamProjectCreate(iamProjectCreate, xIdempotencyKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create iam/project.credentialStore
     * @summary Create iam/project.credentialStore
     * @param {string} projectId Project Id
     * @param {ProjectCredential} projectCredential 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectApi
     */
    public iamProjectCredentialStoreCreate(projectId: string, projectCredential: ProjectCredential, options?: any) {
        return IamProjectApiFp(this.configuration).iamProjectCredentialStoreCreate(projectId, projectCredential, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete iam/project.credentialStore
     * @summary Delete iam/project.credentialStore
     * @param {string} projectId Project Id
     * @param {string} credentialStoreId credentialStoreId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectApi
     */
    public iamProjectCredentialStoreDelete(projectId: string, credentialStoreId: string, options?: any) {
        return IamProjectApiFp(this.configuration).iamProjectCredentialStoreDelete(projectId, credentialStoreId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get iam/project.credentialStore
     * @summary Get iam/project.credentialStore
     * @param {string} projectId Project Id
     * @param {string} credentialStoreId credentialStoreId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectApi
     */
    public iamProjectCredentialStoreGet(projectId: string, credentialStoreId: string, options?: any) {
        return IamProjectApiFp(this.configuration).iamProjectCredentialStoreGet(projectId, credentialStoreId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List iam/project.credentialStore
     * @summary List iam/project.credentialStore
     * @param {string} projectId Project Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectApi
     */
    public iamProjectCredentialStoreList(projectId: string, options?: any) {
        return IamProjectApiFp(this.configuration).iamProjectCredentialStoreList(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update iam/project.credentialStore
     * @summary Update iam/project.credentialStore
     * @param {string} projectId Project Id
     * @param {string} credentialStoreId credentialStoreId
     * @param {IamProjectCredentialStorePatch} iamProjectCredentialStorePatch 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectApi
     */
    public iamProjectCredentialStorePatch(projectId: string, credentialStoreId: string, iamProjectCredentialStorePatch: IamProjectCredentialStorePatch, options?: any) {
        return IamProjectApiFp(this.configuration).iamProjectCredentialStorePatch(projectId, credentialStoreId, iamProjectCredentialStorePatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete project
     * @summary Delete iam/project
     * @param {string} projectId Project Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectApi
     */
    public iamProjectDelete(projectId: string, options?: any) {
        return IamProjectApiFp(this.configuration).iamProjectDelete(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get iam/project.event
     * @summary Get iam/project.event
     * @param {string} projectId Project Id
     * @param {string} eventId eventId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectApi
     */
    public iamProjectEventGet(projectId: string, eventId: string, options?: any) {
        return IamProjectApiFp(this.configuration).iamProjectEventGet(projectId, eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List iam/project.event
     * @summary List iam/project.event
     * @param {string} projectId Project Id
     * @param {number} [$limit] $limit
     * @param {number} [$skip] $skip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectApi
     */
    public iamProjectEventList(projectId: string, $limit?: number, $skip?: number, options?: any) {
        return IamProjectApiFp(this.configuration).iamProjectEventList(projectId, $limit, $skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single project
     * @summary Get iam/project
     * @param {string} projectId Project Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectApi
     */
    public iamProjectGet(projectId: string, options?: any) {
        return IamProjectApiFp(this.configuration).iamProjectGet(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * action accept
     * @summary Accept iam/project.invitation
     * @param {string} projectId Project Id
     * @param {string} invitationId invitationId
     * @param {IamProjectInvitationAccept} iamProjectInvitationAccept 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectApi
     */
    public iamProjectInvitationAccept(projectId: string, invitationId: string, iamProjectInvitationAccept: IamProjectInvitationAccept, options?: any) {
        return IamProjectApiFp(this.configuration).iamProjectInvitationAccept(projectId, invitationId, iamProjectInvitationAccept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete iam/project.invitation
     * @summary Delete iam/project.invitation
     * @param {string} projectId Project Id
     * @param {string} invitationId invitationId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectApi
     */
    public iamProjectInvitationDelete(projectId: string, invitationId: string, options?: any) {
        return IamProjectApiFp(this.configuration).iamProjectInvitationDelete(projectId, invitationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get iam/project.invitation
     * @summary Get iam/project.invitation
     * @param {string} projectId Project Id
     * @param {string} invitationId invitationId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectApi
     */
    public iamProjectInvitationGet(projectId: string, invitationId: string, options?: any) {
        return IamProjectApiFp(this.configuration).iamProjectInvitationGet(projectId, invitationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List iam/project.invitation
     * @summary List iam/project.invitation
     * @param {string} projectId Project Id
     * @param {string} [resource] resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectApi
     */
    public iamProjectInvitationList(projectId: string, resource?: string, options?: any) {
        return IamProjectApiFp(this.configuration).iamProjectInvitationList(projectId, resource, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List iam/project.invoice
     * @summary List iam/project.invoice
     * @param {string} projectId Project Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectApi
     */
    public iamProjectInvoiceList(projectId: string, options?: any) {
        return IamProjectApiFp(this.configuration).iamProjectInvoiceList(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List project
     * @summary List iam/project
     * @param {string} [name] Filter by name
     * @param {number} [$limit] Filter by $limit
     * @param {boolean} [active] Filter by active
     * @param {string} [organisation] Filter by organisation
     * @param {boolean} [$lean] return a lightweight version of the resource
     * @param {string} [tagValue] Filter by tag.value
     * @param {string} [tagKey] Filter by tag.key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectApi
     */
    public iamProjectList(name?: string, $limit?: number, active?: boolean, organisation?: string, $lean?: boolean, tagValue?: string, tagKey?: string, options?: any) {
        return IamProjectApiFp(this.configuration).iamProjectList(name, $limit, active, organisation, $lean, tagValue, tagKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create iam/project.ownership
     * @summary Create iam/project.ownership
     * @param {string} projectId Project Id
     * @param {IamProjectOwnershipCreate} iamProjectOwnershipCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectApi
     */
    public iamProjectOwnershipCreate(projectId: string, iamProjectOwnershipCreate: IamProjectOwnershipCreate, options?: any) {
        return IamProjectApiFp(this.configuration).iamProjectOwnershipCreate(projectId, iamProjectOwnershipCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete iam/project.ownership
     * @summary Delete iam/project.ownership
     * @param {string} projectId Project Id
     * @param {string} ownershipId ownershipId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectApi
     */
    public iamProjectOwnershipDelete(projectId: string, ownershipId: string, options?: any) {
        return IamProjectApiFp(this.configuration).iamProjectOwnershipDelete(projectId, ownershipId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get iam/project.ownership
     * @summary Get iam/project.ownership
     * @param {string} projectId Project Id
     * @param {string} ownershipId ownershipId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectApi
     */
    public iamProjectOwnershipGet(projectId: string, ownershipId: string, options?: any) {
        return IamProjectApiFp(this.configuration).iamProjectOwnershipGet(projectId, ownershipId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List iam/project.ownership
     * @summary List iam/project.ownership
     * @param {string} projectId Project Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectApi
     */
    public iamProjectOwnershipList(projectId: string, options?: any) {
        return IamProjectApiFp(this.configuration).iamProjectOwnershipList(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List iam/project.payment
     * @summary List iam/project.payment
     * @param {string} projectId Project Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectApi
     */
    public iamProjectPaymentList(projectId: string, options?: any) {
        return IamProjectApiFp(this.configuration).iamProjectPaymentList(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List iam/project.proforma
     * @summary List iam/project.proforma
     * @param {string} projectId Project Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectApi
     */
    public iamProjectProformaList(projectId: string, options?: any) {
        return IamProjectApiFp(this.configuration).iamProjectProformaList(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get iam/project.quota
     * @summary Get iam/project.quota
     * @param {string} projectId Project Id
     * @param {string} quotaId quotaId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectApi
     */
    public iamProjectQuotaGet(projectId: string, quotaId: string, options?: any) {
        return IamProjectApiFp(this.configuration).iamProjectQuotaGet(projectId, quotaId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update iam/project.limit
     * @summary Update iam/project.limit
     * @param {string} projectId Project Id
     * @param {string} quotaId quotaId
     * @param {IamProjectQuotaLimitPatch} iamProjectQuotaLimitPatch 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectApi
     */
    public iamProjectQuotaLimitPatch(projectId: string, quotaId: string, iamProjectQuotaLimitPatch: IamProjectQuotaLimitPatch, options?: any) {
        return IamProjectApiFp(this.configuration).iamProjectQuotaLimitPatch(projectId, quotaId, iamProjectQuotaLimitPatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List iam/project.quota
     * @summary List iam/project.quota
     * @param {string} projectId Project Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectApi
     */
    public iamProjectQuotaList(projectId: string, options?: any) {
        return IamProjectApiFp(this.configuration).iamProjectQuotaList(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get iam/project.service
     * @summary Get iam/project.service
     * @param {string} projectId Project Id
     * @param {string} serviceId serviceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectApi
     */
    public iamProjectServiceGet(projectId: string, serviceId: string, options?: any) {
        return IamProjectApiFp(this.configuration).iamProjectServiceGet(projectId, serviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List iam/project.service
     * @summary List iam/project.service
     * @param {string} projectId Project Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectApi
     */
    public iamProjectServiceList(projectId: string, options?: any) {
        return IamProjectApiFp(this.configuration).iamProjectServiceList(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create iam/project.tag
     * @summary Create iam/project.tag
     * @param {string} projectId Project Id
     * @param {Tag} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectApi
     */
    public iamProjectTagCreate(projectId: string, tag: Tag, options?: any) {
        return IamProjectApiFp(this.configuration).iamProjectTagCreate(projectId, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete iam/project.tag
     * @summary Delete iam/project.tag
     * @param {string} projectId Project Id
     * @param {string} tagId tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectApi
     */
    public iamProjectTagDelete(projectId: string, tagId: string, options?: any) {
        return IamProjectApiFp(this.configuration).iamProjectTagDelete(projectId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get iam/project.tag
     * @summary Get iam/project.tag
     * @param {string} projectId Project Id
     * @param {string} tagId tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectApi
     */
    public iamProjectTagGet(projectId: string, tagId: string, options?: any) {
        return IamProjectApiFp(this.configuration).iamProjectTagGet(projectId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List iam/project.tag
     * @summary List iam/project.tag
     * @param {string} projectId Project Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectApi
     */
    public iamProjectTagList(projectId: string, options?: any) {
        return IamProjectApiFp(this.configuration).iamProjectTagList(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replace iam/project.tag
     * @summary Replace iam/project.tag
     * @param {string} projectId Project Id
     * @param {Array<Tag>} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectApi
     */
    public iamProjectTagPut(projectId: string, tag: Array<Tag>, options?: any) {
        return IamProjectApiFp(this.configuration).iamProjectTagPut(projectId, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create iam/project.threshold
     * @summary Create iam/project.threshold
     * @param {string} projectId Project Id
     * @param {IamProjectThresholdCreate} iamProjectThresholdCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectApi
     */
    public iamProjectThresholdCreate(projectId: string, iamProjectThresholdCreate: IamProjectThresholdCreate, options?: any) {
        return IamProjectApiFp(this.configuration).iamProjectThresholdCreate(projectId, iamProjectThresholdCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete iam/project.threshold
     * @summary Delete iam/project.threshold
     * @param {string} projectId Project Id
     * @param {string} thresholdId thresholdId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectApi
     */
    public iamProjectThresholdDelete(projectId: string, thresholdId: string, options?: any) {
        return IamProjectApiFp(this.configuration).iamProjectThresholdDelete(projectId, thresholdId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get iam/project.threshold
     * @summary Get iam/project.threshold
     * @param {string} projectId Project Id
     * @param {string} thresholdId thresholdId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectApi
     */
    public iamProjectThresholdGet(projectId: string, thresholdId: string, options?: any) {
        return IamProjectApiFp(this.configuration).iamProjectThresholdGet(projectId, thresholdId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List iam/project.threshold
     * @summary List iam/project.threshold
     * @param {string} projectId Project Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectApi
     */
    public iamProjectThresholdList(projectId: string, options?: any) {
        return IamProjectApiFp(this.configuration).iamProjectThresholdList(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * action transfer
     * @summary Transfer iam/project
     * @param {string} projectId Project Id
     * @param {IamProjectTransfer} iamProjectTransfer 
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectApi
     */
    public iamProjectTransfer(projectId: string, iamProjectTransfer: IamProjectTransfer, xIdempotencyKey?: string, options?: any) {
        return IamProjectApiFp(this.configuration).iamProjectTransfer(projectId, iamProjectTransfer, xIdempotencyKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns modified project
     * @summary Update iam/project
     * @param {string} projectId Project Id
     * @param {IamProjectUpdate} iamProjectUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectApi
     */
    public iamProjectUpdate(projectId: string, iamProjectUpdate: IamProjectUpdate, options?: any) {
        return IamProjectApiFp(this.configuration).iamProjectUpdate(projectId, iamProjectUpdate, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * IamProjectPolicyApi - axios parameter creator
 * @export
 */
export const IamProjectPolicyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create iam/policy.actor
         * @summary Create iam/policy.actor
         * @param {string} projectId Project Id
         * @param {string} policyId Policy Id
         * @param {IamActor} iamActor 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectPolicyActorCreate: async (projectId: string, policyId: string, iamActor: IamActor, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling iamProjectPolicyActorCreate.');
            }
            // verify required parameter 'policyId' is not null or undefined
            if (policyId === null || policyId === undefined) {
                throw new RequiredError('policyId','Required parameter policyId was null or undefined when calling iamProjectPolicyActorCreate.');
            }
            // verify required parameter 'iamActor' is not null or undefined
            if (iamActor === null || iamActor === undefined) {
                throw new RequiredError('iamActor','Required parameter iamActor was null or undefined when calling iamProjectPolicyActorCreate.');
            }
            const localVarPath = `/iam/project/{projectId}/policy/{policyId}/actor`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"policyId"}}`, encodeURIComponent(String(policyId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof iamActor !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(iamActor !== undefined ? iamActor : {}) : (iamActor || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete iam/policy.actor
         * @summary Delete iam/policy.actor
         * @param {string} projectId Project Id
         * @param {string} policyId Policy Id
         * @param {string} actorId actorId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectPolicyActorDelete: async (projectId: string, policyId: string, actorId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling iamProjectPolicyActorDelete.');
            }
            // verify required parameter 'policyId' is not null or undefined
            if (policyId === null || policyId === undefined) {
                throw new RequiredError('policyId','Required parameter policyId was null or undefined when calling iamProjectPolicyActorDelete.');
            }
            // verify required parameter 'actorId' is not null or undefined
            if (actorId === null || actorId === undefined) {
                throw new RequiredError('actorId','Required parameter actorId was null or undefined when calling iamProjectPolicyActorDelete.');
            }
            const localVarPath = `/iam/project/{projectId}/policy/{policyId}/actor/{actorId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"policyId"}}`, encodeURIComponent(String(policyId)))
                .replace(`{${"actorId"}}`, encodeURIComponent(String(actorId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get iam/policy.actor
         * @summary Get iam/policy.actor
         * @param {string} projectId Project Id
         * @param {string} policyId Policy Id
         * @param {string} actorId actorId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectPolicyActorGet: async (projectId: string, policyId: string, actorId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling iamProjectPolicyActorGet.');
            }
            // verify required parameter 'policyId' is not null or undefined
            if (policyId === null || policyId === undefined) {
                throw new RequiredError('policyId','Required parameter policyId was null or undefined when calling iamProjectPolicyActorGet.');
            }
            // verify required parameter 'actorId' is not null or undefined
            if (actorId === null || actorId === undefined) {
                throw new RequiredError('actorId','Required parameter actorId was null or undefined when calling iamProjectPolicyActorGet.');
            }
            const localVarPath = `/iam/project/{projectId}/policy/{policyId}/actor/{actorId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"policyId"}}`, encodeURIComponent(String(policyId)))
                .replace(`{${"actorId"}}`, encodeURIComponent(String(actorId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List iam/policy.actor
         * @summary List iam/policy.actor
         * @param {string} projectId Project Id
         * @param {string} policyId Policy Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectPolicyActorList: async (projectId: string, policyId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling iamProjectPolicyActorList.');
            }
            // verify required parameter 'policyId' is not null or undefined
            if (policyId === null || policyId === undefined) {
                throw new RequiredError('policyId','Required parameter policyId was null or undefined when calling iamProjectPolicyActorList.');
            }
            const localVarPath = `/iam/project/{projectId}/policy/{policyId}/actor`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"policyId"}}`, encodeURIComponent(String(policyId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create policy
         * @summary Create iam/policy
         * @param {string} projectId Project Id
         * @param {IamProjectPolicyCreate} iamProjectPolicyCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectPolicyCreate: async (projectId: string, iamProjectPolicyCreate: IamProjectPolicyCreate, xIdempotencyKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling iamProjectPolicyCreate.');
            }
            // verify required parameter 'iamProjectPolicyCreate' is not null or undefined
            if (iamProjectPolicyCreate === null || iamProjectPolicyCreate === undefined) {
                throw new RequiredError('iamProjectPolicyCreate','Required parameter iamProjectPolicyCreate was null or undefined when calling iamProjectPolicyCreate.');
            }
            const localVarPath = `/iam/project/{projectId}/policy`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof iamProjectPolicyCreate !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(iamProjectPolicyCreate !== undefined ? iamProjectPolicyCreate : {}) : (iamProjectPolicyCreate || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete policy
         * @summary Delete iam/policy
         * @param {string} projectId Project Id
         * @param {string} policyId Policy Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectPolicyDelete: async (projectId: string, policyId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling iamProjectPolicyDelete.');
            }
            // verify required parameter 'policyId' is not null or undefined
            if (policyId === null || policyId === undefined) {
                throw new RequiredError('policyId','Required parameter policyId was null or undefined when calling iamProjectPolicyDelete.');
            }
            const localVarPath = `/iam/project/{projectId}/policy/{policyId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"policyId"}}`, encodeURIComponent(String(policyId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get iam/policy.event
         * @summary Get iam/policy.event
         * @param {string} projectId Project Id
         * @param {string} policyId Policy Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectPolicyEventGet: async (projectId: string, policyId: string, eventId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling iamProjectPolicyEventGet.');
            }
            // verify required parameter 'policyId' is not null or undefined
            if (policyId === null || policyId === undefined) {
                throw new RequiredError('policyId','Required parameter policyId was null or undefined when calling iamProjectPolicyEventGet.');
            }
            // verify required parameter 'eventId' is not null or undefined
            if (eventId === null || eventId === undefined) {
                throw new RequiredError('eventId','Required parameter eventId was null or undefined when calling iamProjectPolicyEventGet.');
            }
            const localVarPath = `/iam/project/{projectId}/policy/{policyId}/event/{eventId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"policyId"}}`, encodeURIComponent(String(policyId)))
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List iam/policy.event
         * @summary List iam/policy.event
         * @param {string} projectId Project Id
         * @param {string} policyId Policy Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectPolicyEventList: async (projectId: string, policyId: string, $limit?: number, $skip?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling iamProjectPolicyEventList.');
            }
            // verify required parameter 'policyId' is not null or undefined
            if (policyId === null || policyId === undefined) {
                throw new RequiredError('policyId','Required parameter policyId was null or undefined when calling iamProjectPolicyEventList.');
            }
            const localVarPath = `/iam/project/{projectId}/policy/{policyId}/event`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"policyId"}}`, encodeURIComponent(String(policyId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if ($limit !== undefined) {
                localVarQueryParameter['$limit'] = $limit;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single policy
         * @summary Get iam/policy
         * @param {string} projectId Project Id
         * @param {string} policyId Policy Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectPolicyGet: async (projectId: string, policyId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling iamProjectPolicyGet.');
            }
            // verify required parameter 'policyId' is not null or undefined
            if (policyId === null || policyId === undefined) {
                throw new RequiredError('policyId','Required parameter policyId was null or undefined when calling iamProjectPolicyGet.');
            }
            const localVarPath = `/iam/project/{projectId}/policy/{policyId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"policyId"}}`, encodeURIComponent(String(policyId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List policy
         * @summary List iam/policy
         * @param {string} projectId Project Id
         * @param {string} [name] Filter by name
         * @param {string} [resource] Filter by resource
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectPolicyList: async (projectId: string, name?: string, resource?: string, tagValue?: string, tagKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling iamProjectPolicyList.');
            }
            const localVarPath = `/iam/project/{projectId}/policy`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (resource !== undefined) {
                localVarQueryParameter['resource'] = resource;
            }

            if (tagValue !== undefined) {
                localVarQueryParameter['tag.value'] = tagValue;
            }

            if (tagKey !== undefined) {
                localVarQueryParameter['tag.key'] = tagKey;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get iam/policy.service
         * @summary Get iam/policy.service
         * @param {string} projectId Project Id
         * @param {string} policyId Policy Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectPolicyServiceGet: async (projectId: string, policyId: string, serviceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling iamProjectPolicyServiceGet.');
            }
            // verify required parameter 'policyId' is not null or undefined
            if (policyId === null || policyId === undefined) {
                throw new RequiredError('policyId','Required parameter policyId was null or undefined when calling iamProjectPolicyServiceGet.');
            }
            // verify required parameter 'serviceId' is not null or undefined
            if (serviceId === null || serviceId === undefined) {
                throw new RequiredError('serviceId','Required parameter serviceId was null or undefined when calling iamProjectPolicyServiceGet.');
            }
            const localVarPath = `/iam/project/{projectId}/policy/{policyId}/service/{serviceId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"policyId"}}`, encodeURIComponent(String(policyId)))
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List iam/policy.service
         * @summary List iam/policy.service
         * @param {string} projectId Project Id
         * @param {string} policyId Policy Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectPolicyServiceList: async (projectId: string, policyId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling iamProjectPolicyServiceList.');
            }
            // verify required parameter 'policyId' is not null or undefined
            if (policyId === null || policyId === undefined) {
                throw new RequiredError('policyId','Required parameter policyId was null or undefined when calling iamProjectPolicyServiceList.');
            }
            const localVarPath = `/iam/project/{projectId}/policy/{policyId}/service`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"policyId"}}`, encodeURIComponent(String(policyId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create iam/policy.tag
         * @summary Create iam/policy.tag
         * @param {string} projectId Project Id
         * @param {string} policyId Policy Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectPolicyTagCreate: async (projectId: string, policyId: string, tag: Tag, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling iamProjectPolicyTagCreate.');
            }
            // verify required parameter 'policyId' is not null or undefined
            if (policyId === null || policyId === undefined) {
                throw new RequiredError('policyId','Required parameter policyId was null or undefined when calling iamProjectPolicyTagCreate.');
            }
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling iamProjectPolicyTagCreate.');
            }
            const localVarPath = `/iam/project/{projectId}/policy/{policyId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"policyId"}}`, encodeURIComponent(String(policyId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof tag !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(tag !== undefined ? tag : {}) : (tag || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete iam/policy.tag
         * @summary Delete iam/policy.tag
         * @param {string} projectId Project Id
         * @param {string} policyId Policy Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectPolicyTagDelete: async (projectId: string, policyId: string, tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling iamProjectPolicyTagDelete.');
            }
            // verify required parameter 'policyId' is not null or undefined
            if (policyId === null || policyId === undefined) {
                throw new RequiredError('policyId','Required parameter policyId was null or undefined when calling iamProjectPolicyTagDelete.');
            }
            // verify required parameter 'tagId' is not null or undefined
            if (tagId === null || tagId === undefined) {
                throw new RequiredError('tagId','Required parameter tagId was null or undefined when calling iamProjectPolicyTagDelete.');
            }
            const localVarPath = `/iam/project/{projectId}/policy/{policyId}/tag/{tagId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"policyId"}}`, encodeURIComponent(String(policyId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get iam/policy.tag
         * @summary Get iam/policy.tag
         * @param {string} projectId Project Id
         * @param {string} policyId Policy Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectPolicyTagGet: async (projectId: string, policyId: string, tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling iamProjectPolicyTagGet.');
            }
            // verify required parameter 'policyId' is not null or undefined
            if (policyId === null || policyId === undefined) {
                throw new RequiredError('policyId','Required parameter policyId was null or undefined when calling iamProjectPolicyTagGet.');
            }
            // verify required parameter 'tagId' is not null or undefined
            if (tagId === null || tagId === undefined) {
                throw new RequiredError('tagId','Required parameter tagId was null or undefined when calling iamProjectPolicyTagGet.');
            }
            const localVarPath = `/iam/project/{projectId}/policy/{policyId}/tag/{tagId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"policyId"}}`, encodeURIComponent(String(policyId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List iam/policy.tag
         * @summary List iam/policy.tag
         * @param {string} projectId Project Id
         * @param {string} policyId Policy Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectPolicyTagList: async (projectId: string, policyId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling iamProjectPolicyTagList.');
            }
            // verify required parameter 'policyId' is not null or undefined
            if (policyId === null || policyId === undefined) {
                throw new RequiredError('policyId','Required parameter policyId was null or undefined when calling iamProjectPolicyTagList.');
            }
            const localVarPath = `/iam/project/{projectId}/policy/{policyId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"policyId"}}`, encodeURIComponent(String(policyId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replace iam/policy.tag
         * @summary Replace iam/policy.tag
         * @param {string} projectId Project Id
         * @param {string} policyId Policy Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectPolicyTagPut: async (projectId: string, policyId: string, tag: Array<Tag>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling iamProjectPolicyTagPut.');
            }
            // verify required parameter 'policyId' is not null or undefined
            if (policyId === null || policyId === undefined) {
                throw new RequiredError('policyId','Required parameter policyId was null or undefined when calling iamProjectPolicyTagPut.');
            }
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling iamProjectPolicyTagPut.');
            }
            const localVarPath = `/iam/project/{projectId}/policy/{policyId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"policyId"}}`, encodeURIComponent(String(policyId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof tag !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(tag !== undefined ? tag : {}) : (tag || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns modified policy
         * @summary Update iam/policy
         * @param {string} projectId Project Id
         * @param {string} policyId Policy Id
         * @param {IamProjectPolicyUpdate} iamProjectPolicyUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectPolicyUpdate: async (projectId: string, policyId: string, iamProjectPolicyUpdate: IamProjectPolicyUpdate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling iamProjectPolicyUpdate.');
            }
            // verify required parameter 'policyId' is not null or undefined
            if (policyId === null || policyId === undefined) {
                throw new RequiredError('policyId','Required parameter policyId was null or undefined when calling iamProjectPolicyUpdate.');
            }
            // verify required parameter 'iamProjectPolicyUpdate' is not null or undefined
            if (iamProjectPolicyUpdate === null || iamProjectPolicyUpdate === undefined) {
                throw new RequiredError('iamProjectPolicyUpdate','Required parameter iamProjectPolicyUpdate was null or undefined when calling iamProjectPolicyUpdate.');
            }
            const localVarPath = `/iam/project/{projectId}/policy/{policyId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"policyId"}}`, encodeURIComponent(String(policyId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof iamProjectPolicyUpdate !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(iamProjectPolicyUpdate !== undefined ? iamProjectPolicyUpdate : {}) : (iamProjectPolicyUpdate || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IamProjectPolicyApi - functional programming interface
 * @export
 */
export const IamProjectPolicyApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create iam/policy.actor
         * @summary Create iam/policy.actor
         * @param {string} projectId Project Id
         * @param {string} policyId Policy Id
         * @param {IamActor} iamActor 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectPolicyActorCreate(projectId: string, policyId: string, iamActor: IamActor, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IamActor>> {
            const localVarAxiosArgs = await IamProjectPolicyApiAxiosParamCreator(configuration).iamProjectPolicyActorCreate(projectId, policyId, iamActor, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete iam/policy.actor
         * @summary Delete iam/policy.actor
         * @param {string} projectId Project Id
         * @param {string} policyId Policy Id
         * @param {string} actorId actorId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectPolicyActorDelete(projectId: string, policyId: string, actorId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IamActor>> {
            const localVarAxiosArgs = await IamProjectPolicyApiAxiosParamCreator(configuration).iamProjectPolicyActorDelete(projectId, policyId, actorId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get iam/policy.actor
         * @summary Get iam/policy.actor
         * @param {string} projectId Project Id
         * @param {string} policyId Policy Id
         * @param {string} actorId actorId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectPolicyActorGet(projectId: string, policyId: string, actorId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IamActor>> {
            const localVarAxiosArgs = await IamProjectPolicyApiAxiosParamCreator(configuration).iamProjectPolicyActorGet(projectId, policyId, actorId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List iam/policy.actor
         * @summary List iam/policy.actor
         * @param {string} projectId Project Id
         * @param {string} policyId Policy Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectPolicyActorList(projectId: string, policyId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<IamActor>>> {
            const localVarAxiosArgs = await IamProjectPolicyApiAxiosParamCreator(configuration).iamProjectPolicyActorList(projectId, policyId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create policy
         * @summary Create iam/policy
         * @param {string} projectId Project Id
         * @param {IamProjectPolicyCreate} iamProjectPolicyCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectPolicyCreate(projectId: string, iamProjectPolicyCreate: IamProjectPolicyCreate, xIdempotencyKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Policy>> {
            const localVarAxiosArgs = await IamProjectPolicyApiAxiosParamCreator(configuration).iamProjectPolicyCreate(projectId, iamProjectPolicyCreate, xIdempotencyKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete policy
         * @summary Delete iam/policy
         * @param {string} projectId Project Id
         * @param {string} policyId Policy Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectPolicyDelete(projectId: string, policyId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await IamProjectPolicyApiAxiosParamCreator(configuration).iamProjectPolicyDelete(projectId, policyId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get iam/policy.event
         * @summary Get iam/policy.event
         * @param {string} projectId Project Id
         * @param {string} policyId Policy Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectPolicyEventGet(projectId: string, policyId: string, eventId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>> {
            const localVarAxiosArgs = await IamProjectPolicyApiAxiosParamCreator(configuration).iamProjectPolicyEventGet(projectId, policyId, eventId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List iam/policy.event
         * @summary List iam/policy.event
         * @param {string} projectId Project Id
         * @param {string} policyId Policy Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectPolicyEventList(projectId: string, policyId: string, $limit?: number, $skip?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Event>>> {
            const localVarAxiosArgs = await IamProjectPolicyApiAxiosParamCreator(configuration).iamProjectPolicyEventList(projectId, policyId, $limit, $skip, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a single policy
         * @summary Get iam/policy
         * @param {string} projectId Project Id
         * @param {string} policyId Policy Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectPolicyGet(projectId: string, policyId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Policy>> {
            const localVarAxiosArgs = await IamProjectPolicyApiAxiosParamCreator(configuration).iamProjectPolicyGet(projectId, policyId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List policy
         * @summary List iam/policy
         * @param {string} projectId Project Id
         * @param {string} [name] Filter by name
         * @param {string} [resource] Filter by resource
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectPolicyList(projectId: string, name?: string, resource?: string, tagValue?: string, tagKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Policy>>> {
            const localVarAxiosArgs = await IamProjectPolicyApiAxiosParamCreator(configuration).iamProjectPolicyList(projectId, name, resource, tagValue, tagKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get iam/policy.service
         * @summary Get iam/policy.service
         * @param {string} projectId Project Id
         * @param {string} policyId Policy Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectPolicyServiceGet(projectId: string, policyId: string, serviceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceService>> {
            const localVarAxiosArgs = await IamProjectPolicyApiAxiosParamCreator(configuration).iamProjectPolicyServiceGet(projectId, policyId, serviceId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List iam/policy.service
         * @summary List iam/policy.service
         * @param {string} projectId Project Id
         * @param {string} policyId Policy Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectPolicyServiceList(projectId: string, policyId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResourceService>>> {
            const localVarAxiosArgs = await IamProjectPolicyApiAxiosParamCreator(configuration).iamProjectPolicyServiceList(projectId, policyId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create iam/policy.tag
         * @summary Create iam/policy.tag
         * @param {string} projectId Project Id
         * @param {string} policyId Policy Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectPolicyTagCreate(projectId: string, policyId: string, tag: Tag, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await IamProjectPolicyApiAxiosParamCreator(configuration).iamProjectPolicyTagCreate(projectId, policyId, tag, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete iam/policy.tag
         * @summary Delete iam/policy.tag
         * @param {string} projectId Project Id
         * @param {string} policyId Policy Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectPolicyTagDelete(projectId: string, policyId: string, tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await IamProjectPolicyApiAxiosParamCreator(configuration).iamProjectPolicyTagDelete(projectId, policyId, tagId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get iam/policy.tag
         * @summary Get iam/policy.tag
         * @param {string} projectId Project Id
         * @param {string} policyId Policy Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectPolicyTagGet(projectId: string, policyId: string, tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await IamProjectPolicyApiAxiosParamCreator(configuration).iamProjectPolicyTagGet(projectId, policyId, tagId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List iam/policy.tag
         * @summary List iam/policy.tag
         * @param {string} projectId Project Id
         * @param {string} policyId Policy Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectPolicyTagList(projectId: string, policyId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await IamProjectPolicyApiAxiosParamCreator(configuration).iamProjectPolicyTagList(projectId, policyId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Replace iam/policy.tag
         * @summary Replace iam/policy.tag
         * @param {string} projectId Project Id
         * @param {string} policyId Policy Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectPolicyTagPut(projectId: string, policyId: string, tag: Array<Tag>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await IamProjectPolicyApiAxiosParamCreator(configuration).iamProjectPolicyTagPut(projectId, policyId, tag, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns modified policy
         * @summary Update iam/policy
         * @param {string} projectId Project Id
         * @param {string} policyId Policy Id
         * @param {IamProjectPolicyUpdate} iamProjectPolicyUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectPolicyUpdate(projectId: string, policyId: string, iamProjectPolicyUpdate: IamProjectPolicyUpdate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Policy>> {
            const localVarAxiosArgs = await IamProjectPolicyApiAxiosParamCreator(configuration).iamProjectPolicyUpdate(projectId, policyId, iamProjectPolicyUpdate, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * IamProjectPolicyApi - factory interface
 * @export
 */
export const IamProjectPolicyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Create iam/policy.actor
         * @summary Create iam/policy.actor
         * @param {string} projectId Project Id
         * @param {string} policyId Policy Id
         * @param {IamActor} iamActor 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectPolicyActorCreate(projectId: string, policyId: string, iamActor: IamActor, options?: any): AxiosPromise<IamActor> {
            return IamProjectPolicyApiFp(configuration).iamProjectPolicyActorCreate(projectId, policyId, iamActor, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete iam/policy.actor
         * @summary Delete iam/policy.actor
         * @param {string} projectId Project Id
         * @param {string} policyId Policy Id
         * @param {string} actorId actorId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectPolicyActorDelete(projectId: string, policyId: string, actorId: string, options?: any): AxiosPromise<IamActor> {
            return IamProjectPolicyApiFp(configuration).iamProjectPolicyActorDelete(projectId, policyId, actorId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get iam/policy.actor
         * @summary Get iam/policy.actor
         * @param {string} projectId Project Id
         * @param {string} policyId Policy Id
         * @param {string} actorId actorId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectPolicyActorGet(projectId: string, policyId: string, actorId: string, options?: any): AxiosPromise<IamActor> {
            return IamProjectPolicyApiFp(configuration).iamProjectPolicyActorGet(projectId, policyId, actorId, options).then((request) => request(axios, basePath));
        },
        /**
         * List iam/policy.actor
         * @summary List iam/policy.actor
         * @param {string} projectId Project Id
         * @param {string} policyId Policy Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectPolicyActorList(projectId: string, policyId: string, options?: any): AxiosPromise<Array<IamActor>> {
            return IamProjectPolicyApiFp(configuration).iamProjectPolicyActorList(projectId, policyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create policy
         * @summary Create iam/policy
         * @param {string} projectId Project Id
         * @param {IamProjectPolicyCreate} iamProjectPolicyCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectPolicyCreate(projectId: string, iamProjectPolicyCreate: IamProjectPolicyCreate, xIdempotencyKey?: string, options?: any): AxiosPromise<Policy> {
            return IamProjectPolicyApiFp(configuration).iamProjectPolicyCreate(projectId, iamProjectPolicyCreate, xIdempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete policy
         * @summary Delete iam/policy
         * @param {string} projectId Project Id
         * @param {string} policyId Policy Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectPolicyDelete(projectId: string, policyId: string, options?: any): AxiosPromise<void> {
            return IamProjectPolicyApiFp(configuration).iamProjectPolicyDelete(projectId, policyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get iam/policy.event
         * @summary Get iam/policy.event
         * @param {string} projectId Project Id
         * @param {string} policyId Policy Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectPolicyEventGet(projectId: string, policyId: string, eventId: string, options?: any): AxiosPromise<Event> {
            return IamProjectPolicyApiFp(configuration).iamProjectPolicyEventGet(projectId, policyId, eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * List iam/policy.event
         * @summary List iam/policy.event
         * @param {string} projectId Project Id
         * @param {string} policyId Policy Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectPolicyEventList(projectId: string, policyId: string, $limit?: number, $skip?: number, options?: any): AxiosPromise<Array<Event>> {
            return IamProjectPolicyApiFp(configuration).iamProjectPolicyEventList(projectId, policyId, $limit, $skip, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single policy
         * @summary Get iam/policy
         * @param {string} projectId Project Id
         * @param {string} policyId Policy Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectPolicyGet(projectId: string, policyId: string, options?: any): AxiosPromise<Policy> {
            return IamProjectPolicyApiFp(configuration).iamProjectPolicyGet(projectId, policyId, options).then((request) => request(axios, basePath));
        },
        /**
         * List policy
         * @summary List iam/policy
         * @param {string} projectId Project Id
         * @param {string} [name] Filter by name
         * @param {string} [resource] Filter by resource
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectPolicyList(projectId: string, name?: string, resource?: string, tagValue?: string, tagKey?: string, options?: any): AxiosPromise<Array<Policy>> {
            return IamProjectPolicyApiFp(configuration).iamProjectPolicyList(projectId, name, resource, tagValue, tagKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get iam/policy.service
         * @summary Get iam/policy.service
         * @param {string} projectId Project Id
         * @param {string} policyId Policy Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectPolicyServiceGet(projectId: string, policyId: string, serviceId: string, options?: any): AxiosPromise<ResourceService> {
            return IamProjectPolicyApiFp(configuration).iamProjectPolicyServiceGet(projectId, policyId, serviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * List iam/policy.service
         * @summary List iam/policy.service
         * @param {string} projectId Project Id
         * @param {string} policyId Policy Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectPolicyServiceList(projectId: string, policyId: string, options?: any): AxiosPromise<Array<ResourceService>> {
            return IamProjectPolicyApiFp(configuration).iamProjectPolicyServiceList(projectId, policyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create iam/policy.tag
         * @summary Create iam/policy.tag
         * @param {string} projectId Project Id
         * @param {string} policyId Policy Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectPolicyTagCreate(projectId: string, policyId: string, tag: Tag, options?: any): AxiosPromise<Tag> {
            return IamProjectPolicyApiFp(configuration).iamProjectPolicyTagCreate(projectId, policyId, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete iam/policy.tag
         * @summary Delete iam/policy.tag
         * @param {string} projectId Project Id
         * @param {string} policyId Policy Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectPolicyTagDelete(projectId: string, policyId: string, tagId: string, options?: any): AxiosPromise<void> {
            return IamProjectPolicyApiFp(configuration).iamProjectPolicyTagDelete(projectId, policyId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get iam/policy.tag
         * @summary Get iam/policy.tag
         * @param {string} projectId Project Id
         * @param {string} policyId Policy Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectPolicyTagGet(projectId: string, policyId: string, tagId: string, options?: any): AxiosPromise<Tag> {
            return IamProjectPolicyApiFp(configuration).iamProjectPolicyTagGet(projectId, policyId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * List iam/policy.tag
         * @summary List iam/policy.tag
         * @param {string} projectId Project Id
         * @param {string} policyId Policy Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectPolicyTagList(projectId: string, policyId: string, options?: any): AxiosPromise<Array<Tag>> {
            return IamProjectPolicyApiFp(configuration).iamProjectPolicyTagList(projectId, policyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Replace iam/policy.tag
         * @summary Replace iam/policy.tag
         * @param {string} projectId Project Id
         * @param {string} policyId Policy Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectPolicyTagPut(projectId: string, policyId: string, tag: Array<Tag>, options?: any): AxiosPromise<Array<Tag>> {
            return IamProjectPolicyApiFp(configuration).iamProjectPolicyTagPut(projectId, policyId, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns modified policy
         * @summary Update iam/policy
         * @param {string} projectId Project Id
         * @param {string} policyId Policy Id
         * @param {IamProjectPolicyUpdate} iamProjectPolicyUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectPolicyUpdate(projectId: string, policyId: string, iamProjectPolicyUpdate: IamProjectPolicyUpdate, options?: any): AxiosPromise<Policy> {
            return IamProjectPolicyApiFp(configuration).iamProjectPolicyUpdate(projectId, policyId, iamProjectPolicyUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IamProjectPolicyApi - object-oriented interface
 * @export
 * @class IamProjectPolicyApi
 * @extends {BaseAPI}
 */
export class IamProjectPolicyApi extends BaseAPI {
    /**
     * Create iam/policy.actor
     * @summary Create iam/policy.actor
     * @param {string} projectId Project Id
     * @param {string} policyId Policy Id
     * @param {IamActor} iamActor 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectPolicyApi
     */
    public iamProjectPolicyActorCreate(projectId: string, policyId: string, iamActor: IamActor, options?: any) {
        return IamProjectPolicyApiFp(this.configuration).iamProjectPolicyActorCreate(projectId, policyId, iamActor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete iam/policy.actor
     * @summary Delete iam/policy.actor
     * @param {string} projectId Project Id
     * @param {string} policyId Policy Id
     * @param {string} actorId actorId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectPolicyApi
     */
    public iamProjectPolicyActorDelete(projectId: string, policyId: string, actorId: string, options?: any) {
        return IamProjectPolicyApiFp(this.configuration).iamProjectPolicyActorDelete(projectId, policyId, actorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get iam/policy.actor
     * @summary Get iam/policy.actor
     * @param {string} projectId Project Id
     * @param {string} policyId Policy Id
     * @param {string} actorId actorId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectPolicyApi
     */
    public iamProjectPolicyActorGet(projectId: string, policyId: string, actorId: string, options?: any) {
        return IamProjectPolicyApiFp(this.configuration).iamProjectPolicyActorGet(projectId, policyId, actorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List iam/policy.actor
     * @summary List iam/policy.actor
     * @param {string} projectId Project Id
     * @param {string} policyId Policy Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectPolicyApi
     */
    public iamProjectPolicyActorList(projectId: string, policyId: string, options?: any) {
        return IamProjectPolicyApiFp(this.configuration).iamProjectPolicyActorList(projectId, policyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create policy
     * @summary Create iam/policy
     * @param {string} projectId Project Id
     * @param {IamProjectPolicyCreate} iamProjectPolicyCreate 
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectPolicyApi
     */
    public iamProjectPolicyCreate(projectId: string, iamProjectPolicyCreate: IamProjectPolicyCreate, xIdempotencyKey?: string, options?: any) {
        return IamProjectPolicyApiFp(this.configuration).iamProjectPolicyCreate(projectId, iamProjectPolicyCreate, xIdempotencyKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete policy
     * @summary Delete iam/policy
     * @param {string} projectId Project Id
     * @param {string} policyId Policy Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectPolicyApi
     */
    public iamProjectPolicyDelete(projectId: string, policyId: string, options?: any) {
        return IamProjectPolicyApiFp(this.configuration).iamProjectPolicyDelete(projectId, policyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get iam/policy.event
     * @summary Get iam/policy.event
     * @param {string} projectId Project Id
     * @param {string} policyId Policy Id
     * @param {string} eventId eventId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectPolicyApi
     */
    public iamProjectPolicyEventGet(projectId: string, policyId: string, eventId: string, options?: any) {
        return IamProjectPolicyApiFp(this.configuration).iamProjectPolicyEventGet(projectId, policyId, eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List iam/policy.event
     * @summary List iam/policy.event
     * @param {string} projectId Project Id
     * @param {string} policyId Policy Id
     * @param {number} [$limit] $limit
     * @param {number} [$skip] $skip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectPolicyApi
     */
    public iamProjectPolicyEventList(projectId: string, policyId: string, $limit?: number, $skip?: number, options?: any) {
        return IamProjectPolicyApiFp(this.configuration).iamProjectPolicyEventList(projectId, policyId, $limit, $skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single policy
     * @summary Get iam/policy
     * @param {string} projectId Project Id
     * @param {string} policyId Policy Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectPolicyApi
     */
    public iamProjectPolicyGet(projectId: string, policyId: string, options?: any) {
        return IamProjectPolicyApiFp(this.configuration).iamProjectPolicyGet(projectId, policyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List policy
     * @summary List iam/policy
     * @param {string} projectId Project Id
     * @param {string} [name] Filter by name
     * @param {string} [resource] Filter by resource
     * @param {string} [tagValue] Filter by tag.value
     * @param {string} [tagKey] Filter by tag.key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectPolicyApi
     */
    public iamProjectPolicyList(projectId: string, name?: string, resource?: string, tagValue?: string, tagKey?: string, options?: any) {
        return IamProjectPolicyApiFp(this.configuration).iamProjectPolicyList(projectId, name, resource, tagValue, tagKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get iam/policy.service
     * @summary Get iam/policy.service
     * @param {string} projectId Project Id
     * @param {string} policyId Policy Id
     * @param {string} serviceId serviceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectPolicyApi
     */
    public iamProjectPolicyServiceGet(projectId: string, policyId: string, serviceId: string, options?: any) {
        return IamProjectPolicyApiFp(this.configuration).iamProjectPolicyServiceGet(projectId, policyId, serviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List iam/policy.service
     * @summary List iam/policy.service
     * @param {string} projectId Project Id
     * @param {string} policyId Policy Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectPolicyApi
     */
    public iamProjectPolicyServiceList(projectId: string, policyId: string, options?: any) {
        return IamProjectPolicyApiFp(this.configuration).iamProjectPolicyServiceList(projectId, policyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create iam/policy.tag
     * @summary Create iam/policy.tag
     * @param {string} projectId Project Id
     * @param {string} policyId Policy Id
     * @param {Tag} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectPolicyApi
     */
    public iamProjectPolicyTagCreate(projectId: string, policyId: string, tag: Tag, options?: any) {
        return IamProjectPolicyApiFp(this.configuration).iamProjectPolicyTagCreate(projectId, policyId, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete iam/policy.tag
     * @summary Delete iam/policy.tag
     * @param {string} projectId Project Id
     * @param {string} policyId Policy Id
     * @param {string} tagId tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectPolicyApi
     */
    public iamProjectPolicyTagDelete(projectId: string, policyId: string, tagId: string, options?: any) {
        return IamProjectPolicyApiFp(this.configuration).iamProjectPolicyTagDelete(projectId, policyId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get iam/policy.tag
     * @summary Get iam/policy.tag
     * @param {string} projectId Project Id
     * @param {string} policyId Policy Id
     * @param {string} tagId tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectPolicyApi
     */
    public iamProjectPolicyTagGet(projectId: string, policyId: string, tagId: string, options?: any) {
        return IamProjectPolicyApiFp(this.configuration).iamProjectPolicyTagGet(projectId, policyId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List iam/policy.tag
     * @summary List iam/policy.tag
     * @param {string} projectId Project Id
     * @param {string} policyId Policy Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectPolicyApi
     */
    public iamProjectPolicyTagList(projectId: string, policyId: string, options?: any) {
        return IamProjectPolicyApiFp(this.configuration).iamProjectPolicyTagList(projectId, policyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replace iam/policy.tag
     * @summary Replace iam/policy.tag
     * @param {string} projectId Project Id
     * @param {string} policyId Policy Id
     * @param {Array<Tag>} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectPolicyApi
     */
    public iamProjectPolicyTagPut(projectId: string, policyId: string, tag: Array<Tag>, options?: any) {
        return IamProjectPolicyApiFp(this.configuration).iamProjectPolicyTagPut(projectId, policyId, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns modified policy
     * @summary Update iam/policy
     * @param {string} projectId Project Id
     * @param {string} policyId Policy Id
     * @param {IamProjectPolicyUpdate} iamProjectPolicyUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectPolicyApi
     */
    public iamProjectPolicyUpdate(projectId: string, policyId: string, iamProjectPolicyUpdate: IamProjectPolicyUpdate, options?: any) {
        return IamProjectPolicyApiFp(this.configuration).iamProjectPolicyUpdate(projectId, policyId, iamProjectPolicyUpdate, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * IamProjectRoleApi - axios parameter creator
 * @export
 */
export const IamProjectRoleApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create role
         * @summary Create iam/role
         * @param {string} projectId Project Id
         * @param {IamProjectRoleCreate} iamProjectRoleCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectRoleCreate: async (projectId: string, iamProjectRoleCreate: IamProjectRoleCreate, xIdempotencyKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling iamProjectRoleCreate.');
            }
            // verify required parameter 'iamProjectRoleCreate' is not null or undefined
            if (iamProjectRoleCreate === null || iamProjectRoleCreate === undefined) {
                throw new RequiredError('iamProjectRoleCreate','Required parameter iamProjectRoleCreate was null or undefined when calling iamProjectRoleCreate.');
            }
            const localVarPath = `/iam/project/{projectId}/role`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof iamProjectRoleCreate !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(iamProjectRoleCreate !== undefined ? iamProjectRoleCreate : {}) : (iamProjectRoleCreate || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete role
         * @summary Delete iam/role
         * @param {string} projectId Project Id
         * @param {string} roleId Role Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectRoleDelete: async (projectId: string, roleId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling iamProjectRoleDelete.');
            }
            // verify required parameter 'roleId' is not null or undefined
            if (roleId === null || roleId === undefined) {
                throw new RequiredError('roleId','Required parameter roleId was null or undefined when calling iamProjectRoleDelete.');
            }
            const localVarPath = `/iam/project/{projectId}/role/{roleId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"roleId"}}`, encodeURIComponent(String(roleId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get iam/role.event
         * @summary Get iam/role.event
         * @param {string} projectId Project Id
         * @param {string} roleId Role Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectRoleEventGet: async (projectId: string, roleId: string, eventId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling iamProjectRoleEventGet.');
            }
            // verify required parameter 'roleId' is not null or undefined
            if (roleId === null || roleId === undefined) {
                throw new RequiredError('roleId','Required parameter roleId was null or undefined when calling iamProjectRoleEventGet.');
            }
            // verify required parameter 'eventId' is not null or undefined
            if (eventId === null || eventId === undefined) {
                throw new RequiredError('eventId','Required parameter eventId was null or undefined when calling iamProjectRoleEventGet.');
            }
            const localVarPath = `/iam/project/{projectId}/role/{roleId}/event/{eventId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"roleId"}}`, encodeURIComponent(String(roleId)))
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List iam/role.event
         * @summary List iam/role.event
         * @param {string} projectId Project Id
         * @param {string} roleId Role Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectRoleEventList: async (projectId: string, roleId: string, $limit?: number, $skip?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling iamProjectRoleEventList.');
            }
            // verify required parameter 'roleId' is not null or undefined
            if (roleId === null || roleId === undefined) {
                throw new RequiredError('roleId','Required parameter roleId was null or undefined when calling iamProjectRoleEventList.');
            }
            const localVarPath = `/iam/project/{projectId}/role/{roleId}/event`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"roleId"}}`, encodeURIComponent(String(roleId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if ($limit !== undefined) {
                localVarQueryParameter['$limit'] = $limit;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single role
         * @summary Get iam/role
         * @param {string} projectId Project Id
         * @param {string} roleId Role Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectRoleGet: async (projectId: string, roleId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling iamProjectRoleGet.');
            }
            // verify required parameter 'roleId' is not null or undefined
            if (roleId === null || roleId === undefined) {
                throw new RequiredError('roleId','Required parameter roleId was null or undefined when calling iamProjectRoleGet.');
            }
            const localVarPath = `/iam/project/{projectId}/role/{roleId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"roleId"}}`, encodeURIComponent(String(roleId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List role
         * @summary List iam/role
         * @param {string} projectId Project Id
         * @param {string} [name] Filter by name
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectRoleList: async (projectId: string, name?: string, tagValue?: string, tagKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling iamProjectRoleList.');
            }
            const localVarPath = `/iam/project/{projectId}/role`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (tagValue !== undefined) {
                localVarQueryParameter['tag.value'] = tagValue;
            }

            if (tagKey !== undefined) {
                localVarQueryParameter['tag.key'] = tagKey;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create iam/role.permission
         * @summary Create iam/role.permission
         * @param {string} projectId Project Id
         * @param {string} roleId Role Id
         * @param {IamPermission} iamPermission 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectRolePermissionCreate: async (projectId: string, roleId: string, iamPermission: IamPermission, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling iamProjectRolePermissionCreate.');
            }
            // verify required parameter 'roleId' is not null or undefined
            if (roleId === null || roleId === undefined) {
                throw new RequiredError('roleId','Required parameter roleId was null or undefined when calling iamProjectRolePermissionCreate.');
            }
            // verify required parameter 'iamPermission' is not null or undefined
            if (iamPermission === null || iamPermission === undefined) {
                throw new RequiredError('iamPermission','Required parameter iamPermission was null or undefined when calling iamProjectRolePermissionCreate.');
            }
            const localVarPath = `/iam/project/{projectId}/role/{roleId}/permission`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"roleId"}}`, encodeURIComponent(String(roleId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof iamPermission !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(iamPermission !== undefined ? iamPermission : {}) : (iamPermission || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete iam/role.permission
         * @summary Delete iam/role.permission
         * @param {string} projectId Project Id
         * @param {string} roleId Role Id
         * @param {string} permissionId permissionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectRolePermissionDelete: async (projectId: string, roleId: string, permissionId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling iamProjectRolePermissionDelete.');
            }
            // verify required parameter 'roleId' is not null or undefined
            if (roleId === null || roleId === undefined) {
                throw new RequiredError('roleId','Required parameter roleId was null or undefined when calling iamProjectRolePermissionDelete.');
            }
            // verify required parameter 'permissionId' is not null or undefined
            if (permissionId === null || permissionId === undefined) {
                throw new RequiredError('permissionId','Required parameter permissionId was null or undefined when calling iamProjectRolePermissionDelete.');
            }
            const localVarPath = `/iam/project/{projectId}/role/{roleId}/permission/{permissionId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"roleId"}}`, encodeURIComponent(String(roleId)))
                .replace(`{${"permissionId"}}`, encodeURIComponent(String(permissionId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get iam/role.permission
         * @summary Get iam/role.permission
         * @param {string} projectId Project Id
         * @param {string} roleId Role Id
         * @param {string} permissionId permissionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectRolePermissionGet: async (projectId: string, roleId: string, permissionId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling iamProjectRolePermissionGet.');
            }
            // verify required parameter 'roleId' is not null or undefined
            if (roleId === null || roleId === undefined) {
                throw new RequiredError('roleId','Required parameter roleId was null or undefined when calling iamProjectRolePermissionGet.');
            }
            // verify required parameter 'permissionId' is not null or undefined
            if (permissionId === null || permissionId === undefined) {
                throw new RequiredError('permissionId','Required parameter permissionId was null or undefined when calling iamProjectRolePermissionGet.');
            }
            const localVarPath = `/iam/project/{projectId}/role/{roleId}/permission/{permissionId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"roleId"}}`, encodeURIComponent(String(roleId)))
                .replace(`{${"permissionId"}}`, encodeURIComponent(String(permissionId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List iam/role.permission
         * @summary List iam/role.permission
         * @param {string} projectId Project Id
         * @param {string} roleId Role Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectRolePermissionList: async (projectId: string, roleId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling iamProjectRolePermissionList.');
            }
            // verify required parameter 'roleId' is not null or undefined
            if (roleId === null || roleId === undefined) {
                throw new RequiredError('roleId','Required parameter roleId was null or undefined when calling iamProjectRolePermissionList.');
            }
            const localVarPath = `/iam/project/{projectId}/role/{roleId}/permission`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"roleId"}}`, encodeURIComponent(String(roleId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replace iam/role.permission
         * @summary Replace iam/role.permission
         * @param {string} projectId Project Id
         * @param {string} roleId Role Id
         * @param {Array<IamPermission>} iamPermission 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectRolePermissionPut: async (projectId: string, roleId: string, iamPermission: Array<IamPermission>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling iamProjectRolePermissionPut.');
            }
            // verify required parameter 'roleId' is not null or undefined
            if (roleId === null || roleId === undefined) {
                throw new RequiredError('roleId','Required parameter roleId was null or undefined when calling iamProjectRolePermissionPut.');
            }
            // verify required parameter 'iamPermission' is not null or undefined
            if (iamPermission === null || iamPermission === undefined) {
                throw new RequiredError('iamPermission','Required parameter iamPermission was null or undefined when calling iamProjectRolePermissionPut.');
            }
            const localVarPath = `/iam/project/{projectId}/role/{roleId}/permission`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"roleId"}}`, encodeURIComponent(String(roleId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof iamPermission !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(iamPermission !== undefined ? iamPermission : {}) : (iamPermission || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get iam/role.service
         * @summary Get iam/role.service
         * @param {string} projectId Project Id
         * @param {string} roleId Role Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectRoleServiceGet: async (projectId: string, roleId: string, serviceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling iamProjectRoleServiceGet.');
            }
            // verify required parameter 'roleId' is not null or undefined
            if (roleId === null || roleId === undefined) {
                throw new RequiredError('roleId','Required parameter roleId was null or undefined when calling iamProjectRoleServiceGet.');
            }
            // verify required parameter 'serviceId' is not null or undefined
            if (serviceId === null || serviceId === undefined) {
                throw new RequiredError('serviceId','Required parameter serviceId was null or undefined when calling iamProjectRoleServiceGet.');
            }
            const localVarPath = `/iam/project/{projectId}/role/{roleId}/service/{serviceId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"roleId"}}`, encodeURIComponent(String(roleId)))
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List iam/role.service
         * @summary List iam/role.service
         * @param {string} projectId Project Id
         * @param {string} roleId Role Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectRoleServiceList: async (projectId: string, roleId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling iamProjectRoleServiceList.');
            }
            // verify required parameter 'roleId' is not null or undefined
            if (roleId === null || roleId === undefined) {
                throw new RequiredError('roleId','Required parameter roleId was null or undefined when calling iamProjectRoleServiceList.');
            }
            const localVarPath = `/iam/project/{projectId}/role/{roleId}/service`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"roleId"}}`, encodeURIComponent(String(roleId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create iam/role.tag
         * @summary Create iam/role.tag
         * @param {string} projectId Project Id
         * @param {string} roleId Role Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectRoleTagCreate: async (projectId: string, roleId: string, tag: Tag, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling iamProjectRoleTagCreate.');
            }
            // verify required parameter 'roleId' is not null or undefined
            if (roleId === null || roleId === undefined) {
                throw new RequiredError('roleId','Required parameter roleId was null or undefined when calling iamProjectRoleTagCreate.');
            }
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling iamProjectRoleTagCreate.');
            }
            const localVarPath = `/iam/project/{projectId}/role/{roleId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"roleId"}}`, encodeURIComponent(String(roleId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof tag !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(tag !== undefined ? tag : {}) : (tag || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete iam/role.tag
         * @summary Delete iam/role.tag
         * @param {string} projectId Project Id
         * @param {string} roleId Role Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectRoleTagDelete: async (projectId: string, roleId: string, tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling iamProjectRoleTagDelete.');
            }
            // verify required parameter 'roleId' is not null or undefined
            if (roleId === null || roleId === undefined) {
                throw new RequiredError('roleId','Required parameter roleId was null or undefined when calling iamProjectRoleTagDelete.');
            }
            // verify required parameter 'tagId' is not null or undefined
            if (tagId === null || tagId === undefined) {
                throw new RequiredError('tagId','Required parameter tagId was null or undefined when calling iamProjectRoleTagDelete.');
            }
            const localVarPath = `/iam/project/{projectId}/role/{roleId}/tag/{tagId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"roleId"}}`, encodeURIComponent(String(roleId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get iam/role.tag
         * @summary Get iam/role.tag
         * @param {string} projectId Project Id
         * @param {string} roleId Role Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectRoleTagGet: async (projectId: string, roleId: string, tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling iamProjectRoleTagGet.');
            }
            // verify required parameter 'roleId' is not null or undefined
            if (roleId === null || roleId === undefined) {
                throw new RequiredError('roleId','Required parameter roleId was null or undefined when calling iamProjectRoleTagGet.');
            }
            // verify required parameter 'tagId' is not null or undefined
            if (tagId === null || tagId === undefined) {
                throw new RequiredError('tagId','Required parameter tagId was null or undefined when calling iamProjectRoleTagGet.');
            }
            const localVarPath = `/iam/project/{projectId}/role/{roleId}/tag/{tagId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"roleId"}}`, encodeURIComponent(String(roleId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List iam/role.tag
         * @summary List iam/role.tag
         * @param {string} projectId Project Id
         * @param {string} roleId Role Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectRoleTagList: async (projectId: string, roleId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling iamProjectRoleTagList.');
            }
            // verify required parameter 'roleId' is not null or undefined
            if (roleId === null || roleId === undefined) {
                throw new RequiredError('roleId','Required parameter roleId was null or undefined when calling iamProjectRoleTagList.');
            }
            const localVarPath = `/iam/project/{projectId}/role/{roleId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"roleId"}}`, encodeURIComponent(String(roleId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replace iam/role.tag
         * @summary Replace iam/role.tag
         * @param {string} projectId Project Id
         * @param {string} roleId Role Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectRoleTagPut: async (projectId: string, roleId: string, tag: Array<Tag>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling iamProjectRoleTagPut.');
            }
            // verify required parameter 'roleId' is not null or undefined
            if (roleId === null || roleId === undefined) {
                throw new RequiredError('roleId','Required parameter roleId was null or undefined when calling iamProjectRoleTagPut.');
            }
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling iamProjectRoleTagPut.');
            }
            const localVarPath = `/iam/project/{projectId}/role/{roleId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"roleId"}}`, encodeURIComponent(String(roleId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof tag !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(tag !== undefined ? tag : {}) : (tag || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns modified role
         * @summary Update iam/role
         * @param {string} projectId Project Id
         * @param {string} roleId Role Id
         * @param {IamProjectRoleUpdate} iamProjectRoleUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectRoleUpdate: async (projectId: string, roleId: string, iamProjectRoleUpdate: IamProjectRoleUpdate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling iamProjectRoleUpdate.');
            }
            // verify required parameter 'roleId' is not null or undefined
            if (roleId === null || roleId === undefined) {
                throw new RequiredError('roleId','Required parameter roleId was null or undefined when calling iamProjectRoleUpdate.');
            }
            // verify required parameter 'iamProjectRoleUpdate' is not null or undefined
            if (iamProjectRoleUpdate === null || iamProjectRoleUpdate === undefined) {
                throw new RequiredError('iamProjectRoleUpdate','Required parameter iamProjectRoleUpdate was null or undefined when calling iamProjectRoleUpdate.');
            }
            const localVarPath = `/iam/project/{projectId}/role/{roleId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"roleId"}}`, encodeURIComponent(String(roleId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof iamProjectRoleUpdate !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(iamProjectRoleUpdate !== undefined ? iamProjectRoleUpdate : {}) : (iamProjectRoleUpdate || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IamProjectRoleApi - functional programming interface
 * @export
 */
export const IamProjectRoleApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create role
         * @summary Create iam/role
         * @param {string} projectId Project Id
         * @param {IamProjectRoleCreate} iamProjectRoleCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectRoleCreate(projectId: string, iamProjectRoleCreate: IamProjectRoleCreate, xIdempotencyKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Role>> {
            const localVarAxiosArgs = await IamProjectRoleApiAxiosParamCreator(configuration).iamProjectRoleCreate(projectId, iamProjectRoleCreate, xIdempotencyKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete role
         * @summary Delete iam/role
         * @param {string} projectId Project Id
         * @param {string} roleId Role Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectRoleDelete(projectId: string, roleId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await IamProjectRoleApiAxiosParamCreator(configuration).iamProjectRoleDelete(projectId, roleId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get iam/role.event
         * @summary Get iam/role.event
         * @param {string} projectId Project Id
         * @param {string} roleId Role Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectRoleEventGet(projectId: string, roleId: string, eventId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>> {
            const localVarAxiosArgs = await IamProjectRoleApiAxiosParamCreator(configuration).iamProjectRoleEventGet(projectId, roleId, eventId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List iam/role.event
         * @summary List iam/role.event
         * @param {string} projectId Project Id
         * @param {string} roleId Role Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectRoleEventList(projectId: string, roleId: string, $limit?: number, $skip?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Event>>> {
            const localVarAxiosArgs = await IamProjectRoleApiAxiosParamCreator(configuration).iamProjectRoleEventList(projectId, roleId, $limit, $skip, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a single role
         * @summary Get iam/role
         * @param {string} projectId Project Id
         * @param {string} roleId Role Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectRoleGet(projectId: string, roleId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Role>> {
            const localVarAxiosArgs = await IamProjectRoleApiAxiosParamCreator(configuration).iamProjectRoleGet(projectId, roleId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List role
         * @summary List iam/role
         * @param {string} projectId Project Id
         * @param {string} [name] Filter by name
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectRoleList(projectId: string, name?: string, tagValue?: string, tagKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Role>>> {
            const localVarAxiosArgs = await IamProjectRoleApiAxiosParamCreator(configuration).iamProjectRoleList(projectId, name, tagValue, tagKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create iam/role.permission
         * @summary Create iam/role.permission
         * @param {string} projectId Project Id
         * @param {string} roleId Role Id
         * @param {IamPermission} iamPermission 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectRolePermissionCreate(projectId: string, roleId: string, iamPermission: IamPermission, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IamPermission>> {
            const localVarAxiosArgs = await IamProjectRoleApiAxiosParamCreator(configuration).iamProjectRolePermissionCreate(projectId, roleId, iamPermission, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete iam/role.permission
         * @summary Delete iam/role.permission
         * @param {string} projectId Project Id
         * @param {string} roleId Role Id
         * @param {string} permissionId permissionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectRolePermissionDelete(projectId: string, roleId: string, permissionId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IamPermission>> {
            const localVarAxiosArgs = await IamProjectRoleApiAxiosParamCreator(configuration).iamProjectRolePermissionDelete(projectId, roleId, permissionId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get iam/role.permission
         * @summary Get iam/role.permission
         * @param {string} projectId Project Id
         * @param {string} roleId Role Id
         * @param {string} permissionId permissionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectRolePermissionGet(projectId: string, roleId: string, permissionId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IamPermission>> {
            const localVarAxiosArgs = await IamProjectRoleApiAxiosParamCreator(configuration).iamProjectRolePermissionGet(projectId, roleId, permissionId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List iam/role.permission
         * @summary List iam/role.permission
         * @param {string} projectId Project Id
         * @param {string} roleId Role Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectRolePermissionList(projectId: string, roleId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<IamPermission>>> {
            const localVarAxiosArgs = await IamProjectRoleApiAxiosParamCreator(configuration).iamProjectRolePermissionList(projectId, roleId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Replace iam/role.permission
         * @summary Replace iam/role.permission
         * @param {string} projectId Project Id
         * @param {string} roleId Role Id
         * @param {Array<IamPermission>} iamPermission 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectRolePermissionPut(projectId: string, roleId: string, iamPermission: Array<IamPermission>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<IamPermission>>> {
            const localVarAxiosArgs = await IamProjectRoleApiAxiosParamCreator(configuration).iamProjectRolePermissionPut(projectId, roleId, iamPermission, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get iam/role.service
         * @summary Get iam/role.service
         * @param {string} projectId Project Id
         * @param {string} roleId Role Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectRoleServiceGet(projectId: string, roleId: string, serviceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceService>> {
            const localVarAxiosArgs = await IamProjectRoleApiAxiosParamCreator(configuration).iamProjectRoleServiceGet(projectId, roleId, serviceId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List iam/role.service
         * @summary List iam/role.service
         * @param {string} projectId Project Id
         * @param {string} roleId Role Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectRoleServiceList(projectId: string, roleId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResourceService>>> {
            const localVarAxiosArgs = await IamProjectRoleApiAxiosParamCreator(configuration).iamProjectRoleServiceList(projectId, roleId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create iam/role.tag
         * @summary Create iam/role.tag
         * @param {string} projectId Project Id
         * @param {string} roleId Role Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectRoleTagCreate(projectId: string, roleId: string, tag: Tag, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await IamProjectRoleApiAxiosParamCreator(configuration).iamProjectRoleTagCreate(projectId, roleId, tag, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete iam/role.tag
         * @summary Delete iam/role.tag
         * @param {string} projectId Project Id
         * @param {string} roleId Role Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectRoleTagDelete(projectId: string, roleId: string, tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await IamProjectRoleApiAxiosParamCreator(configuration).iamProjectRoleTagDelete(projectId, roleId, tagId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get iam/role.tag
         * @summary Get iam/role.tag
         * @param {string} projectId Project Id
         * @param {string} roleId Role Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectRoleTagGet(projectId: string, roleId: string, tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await IamProjectRoleApiAxiosParamCreator(configuration).iamProjectRoleTagGet(projectId, roleId, tagId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List iam/role.tag
         * @summary List iam/role.tag
         * @param {string} projectId Project Id
         * @param {string} roleId Role Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectRoleTagList(projectId: string, roleId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await IamProjectRoleApiAxiosParamCreator(configuration).iamProjectRoleTagList(projectId, roleId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Replace iam/role.tag
         * @summary Replace iam/role.tag
         * @param {string} projectId Project Id
         * @param {string} roleId Role Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectRoleTagPut(projectId: string, roleId: string, tag: Array<Tag>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await IamProjectRoleApiAxiosParamCreator(configuration).iamProjectRoleTagPut(projectId, roleId, tag, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns modified role
         * @summary Update iam/role
         * @param {string} projectId Project Id
         * @param {string} roleId Role Id
         * @param {IamProjectRoleUpdate} iamProjectRoleUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectRoleUpdate(projectId: string, roleId: string, iamProjectRoleUpdate: IamProjectRoleUpdate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Role>> {
            const localVarAxiosArgs = await IamProjectRoleApiAxiosParamCreator(configuration).iamProjectRoleUpdate(projectId, roleId, iamProjectRoleUpdate, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * IamProjectRoleApi - factory interface
 * @export
 */
export const IamProjectRoleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Create role
         * @summary Create iam/role
         * @param {string} projectId Project Id
         * @param {IamProjectRoleCreate} iamProjectRoleCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectRoleCreate(projectId: string, iamProjectRoleCreate: IamProjectRoleCreate, xIdempotencyKey?: string, options?: any): AxiosPromise<Role> {
            return IamProjectRoleApiFp(configuration).iamProjectRoleCreate(projectId, iamProjectRoleCreate, xIdempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete role
         * @summary Delete iam/role
         * @param {string} projectId Project Id
         * @param {string} roleId Role Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectRoleDelete(projectId: string, roleId: string, options?: any): AxiosPromise<void> {
            return IamProjectRoleApiFp(configuration).iamProjectRoleDelete(projectId, roleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get iam/role.event
         * @summary Get iam/role.event
         * @param {string} projectId Project Id
         * @param {string} roleId Role Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectRoleEventGet(projectId: string, roleId: string, eventId: string, options?: any): AxiosPromise<Event> {
            return IamProjectRoleApiFp(configuration).iamProjectRoleEventGet(projectId, roleId, eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * List iam/role.event
         * @summary List iam/role.event
         * @param {string} projectId Project Id
         * @param {string} roleId Role Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectRoleEventList(projectId: string, roleId: string, $limit?: number, $skip?: number, options?: any): AxiosPromise<Array<Event>> {
            return IamProjectRoleApiFp(configuration).iamProjectRoleEventList(projectId, roleId, $limit, $skip, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single role
         * @summary Get iam/role
         * @param {string} projectId Project Id
         * @param {string} roleId Role Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectRoleGet(projectId: string, roleId: string, options?: any): AxiosPromise<Role> {
            return IamProjectRoleApiFp(configuration).iamProjectRoleGet(projectId, roleId, options).then((request) => request(axios, basePath));
        },
        /**
         * List role
         * @summary List iam/role
         * @param {string} projectId Project Id
         * @param {string} [name] Filter by name
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectRoleList(projectId: string, name?: string, tagValue?: string, tagKey?: string, options?: any): AxiosPromise<Array<Role>> {
            return IamProjectRoleApiFp(configuration).iamProjectRoleList(projectId, name, tagValue, tagKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Create iam/role.permission
         * @summary Create iam/role.permission
         * @param {string} projectId Project Id
         * @param {string} roleId Role Id
         * @param {IamPermission} iamPermission 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectRolePermissionCreate(projectId: string, roleId: string, iamPermission: IamPermission, options?: any): AxiosPromise<IamPermission> {
            return IamProjectRoleApiFp(configuration).iamProjectRolePermissionCreate(projectId, roleId, iamPermission, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete iam/role.permission
         * @summary Delete iam/role.permission
         * @param {string} projectId Project Id
         * @param {string} roleId Role Id
         * @param {string} permissionId permissionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectRolePermissionDelete(projectId: string, roleId: string, permissionId: string, options?: any): AxiosPromise<IamPermission> {
            return IamProjectRoleApiFp(configuration).iamProjectRolePermissionDelete(projectId, roleId, permissionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get iam/role.permission
         * @summary Get iam/role.permission
         * @param {string} projectId Project Id
         * @param {string} roleId Role Id
         * @param {string} permissionId permissionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectRolePermissionGet(projectId: string, roleId: string, permissionId: string, options?: any): AxiosPromise<IamPermission> {
            return IamProjectRoleApiFp(configuration).iamProjectRolePermissionGet(projectId, roleId, permissionId, options).then((request) => request(axios, basePath));
        },
        /**
         * List iam/role.permission
         * @summary List iam/role.permission
         * @param {string} projectId Project Id
         * @param {string} roleId Role Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectRolePermissionList(projectId: string, roleId: string, options?: any): AxiosPromise<Array<IamPermission>> {
            return IamProjectRoleApiFp(configuration).iamProjectRolePermissionList(projectId, roleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Replace iam/role.permission
         * @summary Replace iam/role.permission
         * @param {string} projectId Project Id
         * @param {string} roleId Role Id
         * @param {Array<IamPermission>} iamPermission 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectRolePermissionPut(projectId: string, roleId: string, iamPermission: Array<IamPermission>, options?: any): AxiosPromise<Array<IamPermission>> {
            return IamProjectRoleApiFp(configuration).iamProjectRolePermissionPut(projectId, roleId, iamPermission, options).then((request) => request(axios, basePath));
        },
        /**
         * Get iam/role.service
         * @summary Get iam/role.service
         * @param {string} projectId Project Id
         * @param {string} roleId Role Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectRoleServiceGet(projectId: string, roleId: string, serviceId: string, options?: any): AxiosPromise<ResourceService> {
            return IamProjectRoleApiFp(configuration).iamProjectRoleServiceGet(projectId, roleId, serviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * List iam/role.service
         * @summary List iam/role.service
         * @param {string} projectId Project Id
         * @param {string} roleId Role Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectRoleServiceList(projectId: string, roleId: string, options?: any): AxiosPromise<Array<ResourceService>> {
            return IamProjectRoleApiFp(configuration).iamProjectRoleServiceList(projectId, roleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create iam/role.tag
         * @summary Create iam/role.tag
         * @param {string} projectId Project Id
         * @param {string} roleId Role Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectRoleTagCreate(projectId: string, roleId: string, tag: Tag, options?: any): AxiosPromise<Tag> {
            return IamProjectRoleApiFp(configuration).iamProjectRoleTagCreate(projectId, roleId, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete iam/role.tag
         * @summary Delete iam/role.tag
         * @param {string} projectId Project Id
         * @param {string} roleId Role Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectRoleTagDelete(projectId: string, roleId: string, tagId: string, options?: any): AxiosPromise<void> {
            return IamProjectRoleApiFp(configuration).iamProjectRoleTagDelete(projectId, roleId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get iam/role.tag
         * @summary Get iam/role.tag
         * @param {string} projectId Project Id
         * @param {string} roleId Role Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectRoleTagGet(projectId: string, roleId: string, tagId: string, options?: any): AxiosPromise<Tag> {
            return IamProjectRoleApiFp(configuration).iamProjectRoleTagGet(projectId, roleId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * List iam/role.tag
         * @summary List iam/role.tag
         * @param {string} projectId Project Id
         * @param {string} roleId Role Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectRoleTagList(projectId: string, roleId: string, options?: any): AxiosPromise<Array<Tag>> {
            return IamProjectRoleApiFp(configuration).iamProjectRoleTagList(projectId, roleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Replace iam/role.tag
         * @summary Replace iam/role.tag
         * @param {string} projectId Project Id
         * @param {string} roleId Role Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectRoleTagPut(projectId: string, roleId: string, tag: Array<Tag>, options?: any): AxiosPromise<Array<Tag>> {
            return IamProjectRoleApiFp(configuration).iamProjectRoleTagPut(projectId, roleId, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns modified role
         * @summary Update iam/role
         * @param {string} projectId Project Id
         * @param {string} roleId Role Id
         * @param {IamProjectRoleUpdate} iamProjectRoleUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectRoleUpdate(projectId: string, roleId: string, iamProjectRoleUpdate: IamProjectRoleUpdate, options?: any): AxiosPromise<Role> {
            return IamProjectRoleApiFp(configuration).iamProjectRoleUpdate(projectId, roleId, iamProjectRoleUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IamProjectRoleApi - object-oriented interface
 * @export
 * @class IamProjectRoleApi
 * @extends {BaseAPI}
 */
export class IamProjectRoleApi extends BaseAPI {
    /**
     * Create role
     * @summary Create iam/role
     * @param {string} projectId Project Id
     * @param {IamProjectRoleCreate} iamProjectRoleCreate 
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectRoleApi
     */
    public iamProjectRoleCreate(projectId: string, iamProjectRoleCreate: IamProjectRoleCreate, xIdempotencyKey?: string, options?: any) {
        return IamProjectRoleApiFp(this.configuration).iamProjectRoleCreate(projectId, iamProjectRoleCreate, xIdempotencyKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete role
     * @summary Delete iam/role
     * @param {string} projectId Project Id
     * @param {string} roleId Role Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectRoleApi
     */
    public iamProjectRoleDelete(projectId: string, roleId: string, options?: any) {
        return IamProjectRoleApiFp(this.configuration).iamProjectRoleDelete(projectId, roleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get iam/role.event
     * @summary Get iam/role.event
     * @param {string} projectId Project Id
     * @param {string} roleId Role Id
     * @param {string} eventId eventId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectRoleApi
     */
    public iamProjectRoleEventGet(projectId: string, roleId: string, eventId: string, options?: any) {
        return IamProjectRoleApiFp(this.configuration).iamProjectRoleEventGet(projectId, roleId, eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List iam/role.event
     * @summary List iam/role.event
     * @param {string} projectId Project Id
     * @param {string} roleId Role Id
     * @param {number} [$limit] $limit
     * @param {number} [$skip] $skip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectRoleApi
     */
    public iamProjectRoleEventList(projectId: string, roleId: string, $limit?: number, $skip?: number, options?: any) {
        return IamProjectRoleApiFp(this.configuration).iamProjectRoleEventList(projectId, roleId, $limit, $skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single role
     * @summary Get iam/role
     * @param {string} projectId Project Id
     * @param {string} roleId Role Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectRoleApi
     */
    public iamProjectRoleGet(projectId: string, roleId: string, options?: any) {
        return IamProjectRoleApiFp(this.configuration).iamProjectRoleGet(projectId, roleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List role
     * @summary List iam/role
     * @param {string} projectId Project Id
     * @param {string} [name] Filter by name
     * @param {string} [tagValue] Filter by tag.value
     * @param {string} [tagKey] Filter by tag.key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectRoleApi
     */
    public iamProjectRoleList(projectId: string, name?: string, tagValue?: string, tagKey?: string, options?: any) {
        return IamProjectRoleApiFp(this.configuration).iamProjectRoleList(projectId, name, tagValue, tagKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create iam/role.permission
     * @summary Create iam/role.permission
     * @param {string} projectId Project Id
     * @param {string} roleId Role Id
     * @param {IamPermission} iamPermission 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectRoleApi
     */
    public iamProjectRolePermissionCreate(projectId: string, roleId: string, iamPermission: IamPermission, options?: any) {
        return IamProjectRoleApiFp(this.configuration).iamProjectRolePermissionCreate(projectId, roleId, iamPermission, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete iam/role.permission
     * @summary Delete iam/role.permission
     * @param {string} projectId Project Id
     * @param {string} roleId Role Id
     * @param {string} permissionId permissionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectRoleApi
     */
    public iamProjectRolePermissionDelete(projectId: string, roleId: string, permissionId: string, options?: any) {
        return IamProjectRoleApiFp(this.configuration).iamProjectRolePermissionDelete(projectId, roleId, permissionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get iam/role.permission
     * @summary Get iam/role.permission
     * @param {string} projectId Project Id
     * @param {string} roleId Role Id
     * @param {string} permissionId permissionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectRoleApi
     */
    public iamProjectRolePermissionGet(projectId: string, roleId: string, permissionId: string, options?: any) {
        return IamProjectRoleApiFp(this.configuration).iamProjectRolePermissionGet(projectId, roleId, permissionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List iam/role.permission
     * @summary List iam/role.permission
     * @param {string} projectId Project Id
     * @param {string} roleId Role Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectRoleApi
     */
    public iamProjectRolePermissionList(projectId: string, roleId: string, options?: any) {
        return IamProjectRoleApiFp(this.configuration).iamProjectRolePermissionList(projectId, roleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replace iam/role.permission
     * @summary Replace iam/role.permission
     * @param {string} projectId Project Id
     * @param {string} roleId Role Id
     * @param {Array<IamPermission>} iamPermission 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectRoleApi
     */
    public iamProjectRolePermissionPut(projectId: string, roleId: string, iamPermission: Array<IamPermission>, options?: any) {
        return IamProjectRoleApiFp(this.configuration).iamProjectRolePermissionPut(projectId, roleId, iamPermission, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get iam/role.service
     * @summary Get iam/role.service
     * @param {string} projectId Project Id
     * @param {string} roleId Role Id
     * @param {string} serviceId serviceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectRoleApi
     */
    public iamProjectRoleServiceGet(projectId: string, roleId: string, serviceId: string, options?: any) {
        return IamProjectRoleApiFp(this.configuration).iamProjectRoleServiceGet(projectId, roleId, serviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List iam/role.service
     * @summary List iam/role.service
     * @param {string} projectId Project Id
     * @param {string} roleId Role Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectRoleApi
     */
    public iamProjectRoleServiceList(projectId: string, roleId: string, options?: any) {
        return IamProjectRoleApiFp(this.configuration).iamProjectRoleServiceList(projectId, roleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create iam/role.tag
     * @summary Create iam/role.tag
     * @param {string} projectId Project Id
     * @param {string} roleId Role Id
     * @param {Tag} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectRoleApi
     */
    public iamProjectRoleTagCreate(projectId: string, roleId: string, tag: Tag, options?: any) {
        return IamProjectRoleApiFp(this.configuration).iamProjectRoleTagCreate(projectId, roleId, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete iam/role.tag
     * @summary Delete iam/role.tag
     * @param {string} projectId Project Id
     * @param {string} roleId Role Id
     * @param {string} tagId tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectRoleApi
     */
    public iamProjectRoleTagDelete(projectId: string, roleId: string, tagId: string, options?: any) {
        return IamProjectRoleApiFp(this.configuration).iamProjectRoleTagDelete(projectId, roleId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get iam/role.tag
     * @summary Get iam/role.tag
     * @param {string} projectId Project Id
     * @param {string} roleId Role Id
     * @param {string} tagId tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectRoleApi
     */
    public iamProjectRoleTagGet(projectId: string, roleId: string, tagId: string, options?: any) {
        return IamProjectRoleApiFp(this.configuration).iamProjectRoleTagGet(projectId, roleId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List iam/role.tag
     * @summary List iam/role.tag
     * @param {string} projectId Project Id
     * @param {string} roleId Role Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectRoleApi
     */
    public iamProjectRoleTagList(projectId: string, roleId: string, options?: any) {
        return IamProjectRoleApiFp(this.configuration).iamProjectRoleTagList(projectId, roleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replace iam/role.tag
     * @summary Replace iam/role.tag
     * @param {string} projectId Project Id
     * @param {string} roleId Role Id
     * @param {Array<Tag>} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectRoleApi
     */
    public iamProjectRoleTagPut(projectId: string, roleId: string, tag: Array<Tag>, options?: any) {
        return IamProjectRoleApiFp(this.configuration).iamProjectRoleTagPut(projectId, roleId, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns modified role
     * @summary Update iam/role
     * @param {string} projectId Project Id
     * @param {string} roleId Role Id
     * @param {IamProjectRoleUpdate} iamProjectRoleUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectRoleApi
     */
    public iamProjectRoleUpdate(projectId: string, roleId: string, iamProjectRoleUpdate: IamProjectRoleUpdate, options?: any) {
        return IamProjectRoleApiFp(this.configuration).iamProjectRoleUpdate(projectId, roleId, iamProjectRoleUpdate, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * IamProjectSaApi - axios parameter creator
 * @export
 */
export const IamProjectSaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create sa
         * @summary Create iam/sa
         * @param {string} projectId Project Id
         * @param {IamProjectSaCreate} iamProjectSaCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectSaCreate: async (projectId: string, iamProjectSaCreate: IamProjectSaCreate, xIdempotencyKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling iamProjectSaCreate.');
            }
            // verify required parameter 'iamProjectSaCreate' is not null or undefined
            if (iamProjectSaCreate === null || iamProjectSaCreate === undefined) {
                throw new RequiredError('iamProjectSaCreate','Required parameter iamProjectSaCreate was null or undefined when calling iamProjectSaCreate.');
            }
            const localVarPath = `/iam/project/{projectId}/sa`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof iamProjectSaCreate !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(iamProjectSaCreate !== undefined ? iamProjectSaCreate : {}) : (iamProjectSaCreate || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create iam/sa.credential
         * @summary Create iam/sa.credential
         * @param {string} projectId Project Id
         * @param {string} saId Sa Id
         * @param {SaCredential} saCredential 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectSaCredentialCreate: async (projectId: string, saId: string, saCredential: SaCredential, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling iamProjectSaCredentialCreate.');
            }
            // verify required parameter 'saId' is not null or undefined
            if (saId === null || saId === undefined) {
                throw new RequiredError('saId','Required parameter saId was null or undefined when calling iamProjectSaCredentialCreate.');
            }
            // verify required parameter 'saCredential' is not null or undefined
            if (saCredential === null || saCredential === undefined) {
                throw new RequiredError('saCredential','Required parameter saCredential was null or undefined when calling iamProjectSaCredentialCreate.');
            }
            const localVarPath = `/iam/project/{projectId}/sa/{saId}/credential`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"saId"}}`, encodeURIComponent(String(saId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof saCredential !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(saCredential !== undefined ? saCredential : {}) : (saCredential || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete iam/sa.credential
         * @summary Delete iam/sa.credential
         * @param {string} projectId Project Id
         * @param {string} saId Sa Id
         * @param {string} credentialId credentialId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectSaCredentialDelete: async (projectId: string, saId: string, credentialId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling iamProjectSaCredentialDelete.');
            }
            // verify required parameter 'saId' is not null or undefined
            if (saId === null || saId === undefined) {
                throw new RequiredError('saId','Required parameter saId was null or undefined when calling iamProjectSaCredentialDelete.');
            }
            // verify required parameter 'credentialId' is not null or undefined
            if (credentialId === null || credentialId === undefined) {
                throw new RequiredError('credentialId','Required parameter credentialId was null or undefined when calling iamProjectSaCredentialDelete.');
            }
            const localVarPath = `/iam/project/{projectId}/sa/{saId}/credential/{credentialId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"saId"}}`, encodeURIComponent(String(saId)))
                .replace(`{${"credentialId"}}`, encodeURIComponent(String(credentialId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get iam/sa.credential
         * @summary Get iam/sa.credential
         * @param {string} projectId Project Id
         * @param {string} saId Sa Id
         * @param {string} credentialId credentialId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectSaCredentialGet: async (projectId: string, saId: string, credentialId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling iamProjectSaCredentialGet.');
            }
            // verify required parameter 'saId' is not null or undefined
            if (saId === null || saId === undefined) {
                throw new RequiredError('saId','Required parameter saId was null or undefined when calling iamProjectSaCredentialGet.');
            }
            // verify required parameter 'credentialId' is not null or undefined
            if (credentialId === null || credentialId === undefined) {
                throw new RequiredError('credentialId','Required parameter credentialId was null or undefined when calling iamProjectSaCredentialGet.');
            }
            const localVarPath = `/iam/project/{projectId}/sa/{saId}/credential/{credentialId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"saId"}}`, encodeURIComponent(String(saId)))
                .replace(`{${"credentialId"}}`, encodeURIComponent(String(credentialId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List iam/sa.credential
         * @summary List iam/sa.credential
         * @param {string} projectId Project Id
         * @param {string} saId Sa Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectSaCredentialList: async (projectId: string, saId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling iamProjectSaCredentialList.');
            }
            // verify required parameter 'saId' is not null or undefined
            if (saId === null || saId === undefined) {
                throw new RequiredError('saId','Required parameter saId was null or undefined when calling iamProjectSaCredentialList.');
            }
            const localVarPath = `/iam/project/{projectId}/sa/{saId}/credential`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"saId"}}`, encodeURIComponent(String(saId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update iam/sa.credential
         * @summary Update iam/sa.credential
         * @param {string} projectId Project Id
         * @param {string} saId Sa Id
         * @param {string} credentialId credentialId
         * @param {IamProjectSaCredentialPatch} iamProjectSaCredentialPatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectSaCredentialPatch: async (projectId: string, saId: string, credentialId: string, iamProjectSaCredentialPatch: IamProjectSaCredentialPatch, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling iamProjectSaCredentialPatch.');
            }
            // verify required parameter 'saId' is not null or undefined
            if (saId === null || saId === undefined) {
                throw new RequiredError('saId','Required parameter saId was null or undefined when calling iamProjectSaCredentialPatch.');
            }
            // verify required parameter 'credentialId' is not null or undefined
            if (credentialId === null || credentialId === undefined) {
                throw new RequiredError('credentialId','Required parameter credentialId was null or undefined when calling iamProjectSaCredentialPatch.');
            }
            // verify required parameter 'iamProjectSaCredentialPatch' is not null or undefined
            if (iamProjectSaCredentialPatch === null || iamProjectSaCredentialPatch === undefined) {
                throw new RequiredError('iamProjectSaCredentialPatch','Required parameter iamProjectSaCredentialPatch was null or undefined when calling iamProjectSaCredentialPatch.');
            }
            const localVarPath = `/iam/project/{projectId}/sa/{saId}/credential/{credentialId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"saId"}}`, encodeURIComponent(String(saId)))
                .replace(`{${"credentialId"}}`, encodeURIComponent(String(credentialId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof iamProjectSaCredentialPatch !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(iamProjectSaCredentialPatch !== undefined ? iamProjectSaCredentialPatch : {}) : (iamProjectSaCredentialPatch || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete sa
         * @summary Delete iam/sa
         * @param {string} projectId Project Id
         * @param {string} saId Sa Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectSaDelete: async (projectId: string, saId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling iamProjectSaDelete.');
            }
            // verify required parameter 'saId' is not null or undefined
            if (saId === null || saId === undefined) {
                throw new RequiredError('saId','Required parameter saId was null or undefined when calling iamProjectSaDelete.');
            }
            const localVarPath = `/iam/project/{projectId}/sa/{saId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"saId"}}`, encodeURIComponent(String(saId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get iam/sa.event
         * @summary Get iam/sa.event
         * @param {string} projectId Project Id
         * @param {string} saId Sa Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectSaEventGet: async (projectId: string, saId: string, eventId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling iamProjectSaEventGet.');
            }
            // verify required parameter 'saId' is not null or undefined
            if (saId === null || saId === undefined) {
                throw new RequiredError('saId','Required parameter saId was null or undefined when calling iamProjectSaEventGet.');
            }
            // verify required parameter 'eventId' is not null or undefined
            if (eventId === null || eventId === undefined) {
                throw new RequiredError('eventId','Required parameter eventId was null or undefined when calling iamProjectSaEventGet.');
            }
            const localVarPath = `/iam/project/{projectId}/sa/{saId}/event/{eventId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"saId"}}`, encodeURIComponent(String(saId)))
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List iam/sa.event
         * @summary List iam/sa.event
         * @param {string} projectId Project Id
         * @param {string} saId Sa Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectSaEventList: async (projectId: string, saId: string, $limit?: number, $skip?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling iamProjectSaEventList.');
            }
            // verify required parameter 'saId' is not null or undefined
            if (saId === null || saId === undefined) {
                throw new RequiredError('saId','Required parameter saId was null or undefined when calling iamProjectSaEventList.');
            }
            const localVarPath = `/iam/project/{projectId}/sa/{saId}/event`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"saId"}}`, encodeURIComponent(String(saId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if ($limit !== undefined) {
                localVarQueryParameter['$limit'] = $limit;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single sa
         * @summary Get iam/sa
         * @param {string} projectId Project Id
         * @param {string} saId Sa Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectSaGet: async (projectId: string, saId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling iamProjectSaGet.');
            }
            // verify required parameter 'saId' is not null or undefined
            if (saId === null || saId === undefined) {
                throw new RequiredError('saId','Required parameter saId was null or undefined when calling iamProjectSaGet.');
            }
            const localVarPath = `/iam/project/{projectId}/sa/{saId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"saId"}}`, encodeURIComponent(String(saId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List sa
         * @summary List iam/sa
         * @param {string} projectId Project Id
         * @param {string} [name] Filter by name
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectSaList: async (projectId: string, name?: string, tagValue?: string, tagKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling iamProjectSaList.');
            }
            const localVarPath = `/iam/project/{projectId}/sa`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (tagValue !== undefined) {
                localVarQueryParameter['tag.value'] = tagValue;
            }

            if (tagKey !== undefined) {
                localVarQueryParameter['tag.key'] = tagKey;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get iam/sa.service
         * @summary Get iam/sa.service
         * @param {string} projectId Project Id
         * @param {string} saId Sa Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectSaServiceGet: async (projectId: string, saId: string, serviceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling iamProjectSaServiceGet.');
            }
            // verify required parameter 'saId' is not null or undefined
            if (saId === null || saId === undefined) {
                throw new RequiredError('saId','Required parameter saId was null or undefined when calling iamProjectSaServiceGet.');
            }
            // verify required parameter 'serviceId' is not null or undefined
            if (serviceId === null || serviceId === undefined) {
                throw new RequiredError('serviceId','Required parameter serviceId was null or undefined when calling iamProjectSaServiceGet.');
            }
            const localVarPath = `/iam/project/{projectId}/sa/{saId}/service/{serviceId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"saId"}}`, encodeURIComponent(String(saId)))
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List iam/sa.service
         * @summary List iam/sa.service
         * @param {string} projectId Project Id
         * @param {string} saId Sa Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectSaServiceList: async (projectId: string, saId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling iamProjectSaServiceList.');
            }
            // verify required parameter 'saId' is not null or undefined
            if (saId === null || saId === undefined) {
                throw new RequiredError('saId','Required parameter saId was null or undefined when calling iamProjectSaServiceList.');
            }
            const localVarPath = `/iam/project/{projectId}/sa/{saId}/service`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"saId"}}`, encodeURIComponent(String(saId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create iam/sa.tag
         * @summary Create iam/sa.tag
         * @param {string} projectId Project Id
         * @param {string} saId Sa Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectSaTagCreate: async (projectId: string, saId: string, tag: Tag, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling iamProjectSaTagCreate.');
            }
            // verify required parameter 'saId' is not null or undefined
            if (saId === null || saId === undefined) {
                throw new RequiredError('saId','Required parameter saId was null or undefined when calling iamProjectSaTagCreate.');
            }
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling iamProjectSaTagCreate.');
            }
            const localVarPath = `/iam/project/{projectId}/sa/{saId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"saId"}}`, encodeURIComponent(String(saId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof tag !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(tag !== undefined ? tag : {}) : (tag || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete iam/sa.tag
         * @summary Delete iam/sa.tag
         * @param {string} projectId Project Id
         * @param {string} saId Sa Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectSaTagDelete: async (projectId: string, saId: string, tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling iamProjectSaTagDelete.');
            }
            // verify required parameter 'saId' is not null or undefined
            if (saId === null || saId === undefined) {
                throw new RequiredError('saId','Required parameter saId was null or undefined when calling iamProjectSaTagDelete.');
            }
            // verify required parameter 'tagId' is not null or undefined
            if (tagId === null || tagId === undefined) {
                throw new RequiredError('tagId','Required parameter tagId was null or undefined when calling iamProjectSaTagDelete.');
            }
            const localVarPath = `/iam/project/{projectId}/sa/{saId}/tag/{tagId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"saId"}}`, encodeURIComponent(String(saId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get iam/sa.tag
         * @summary Get iam/sa.tag
         * @param {string} projectId Project Id
         * @param {string} saId Sa Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectSaTagGet: async (projectId: string, saId: string, tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling iamProjectSaTagGet.');
            }
            // verify required parameter 'saId' is not null or undefined
            if (saId === null || saId === undefined) {
                throw new RequiredError('saId','Required parameter saId was null or undefined when calling iamProjectSaTagGet.');
            }
            // verify required parameter 'tagId' is not null or undefined
            if (tagId === null || tagId === undefined) {
                throw new RequiredError('tagId','Required parameter tagId was null or undefined when calling iamProjectSaTagGet.');
            }
            const localVarPath = `/iam/project/{projectId}/sa/{saId}/tag/{tagId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"saId"}}`, encodeURIComponent(String(saId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List iam/sa.tag
         * @summary List iam/sa.tag
         * @param {string} projectId Project Id
         * @param {string} saId Sa Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectSaTagList: async (projectId: string, saId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling iamProjectSaTagList.');
            }
            // verify required parameter 'saId' is not null or undefined
            if (saId === null || saId === undefined) {
                throw new RequiredError('saId','Required parameter saId was null or undefined when calling iamProjectSaTagList.');
            }
            const localVarPath = `/iam/project/{projectId}/sa/{saId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"saId"}}`, encodeURIComponent(String(saId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replace iam/sa.tag
         * @summary Replace iam/sa.tag
         * @param {string} projectId Project Id
         * @param {string} saId Sa Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectSaTagPut: async (projectId: string, saId: string, tag: Array<Tag>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling iamProjectSaTagPut.');
            }
            // verify required parameter 'saId' is not null or undefined
            if (saId === null || saId === undefined) {
                throw new RequiredError('saId','Required parameter saId was null or undefined when calling iamProjectSaTagPut.');
            }
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling iamProjectSaTagPut.');
            }
            const localVarPath = `/iam/project/{projectId}/sa/{saId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"saId"}}`, encodeURIComponent(String(saId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof tag !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(tag !== undefined ? tag : {}) : (tag || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns modified sa
         * @summary Update iam/sa
         * @param {string} projectId Project Id
         * @param {string} saId Sa Id
         * @param {IamProjectSaUpdate} iamProjectSaUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectSaUpdate: async (projectId: string, saId: string, iamProjectSaUpdate: IamProjectSaUpdate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling iamProjectSaUpdate.');
            }
            // verify required parameter 'saId' is not null or undefined
            if (saId === null || saId === undefined) {
                throw new RequiredError('saId','Required parameter saId was null or undefined when calling iamProjectSaUpdate.');
            }
            // verify required parameter 'iamProjectSaUpdate' is not null or undefined
            if (iamProjectSaUpdate === null || iamProjectSaUpdate === undefined) {
                throw new RequiredError('iamProjectSaUpdate','Required parameter iamProjectSaUpdate was null or undefined when calling iamProjectSaUpdate.');
            }
            const localVarPath = `/iam/project/{projectId}/sa/{saId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"saId"}}`, encodeURIComponent(String(saId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof iamProjectSaUpdate !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(iamProjectSaUpdate !== undefined ? iamProjectSaUpdate : {}) : (iamProjectSaUpdate || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IamProjectSaApi - functional programming interface
 * @export
 */
export const IamProjectSaApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create sa
         * @summary Create iam/sa
         * @param {string} projectId Project Id
         * @param {IamProjectSaCreate} iamProjectSaCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectSaCreate(projectId: string, iamProjectSaCreate: IamProjectSaCreate, xIdempotencyKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Sa>> {
            const localVarAxiosArgs = await IamProjectSaApiAxiosParamCreator(configuration).iamProjectSaCreate(projectId, iamProjectSaCreate, xIdempotencyKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create iam/sa.credential
         * @summary Create iam/sa.credential
         * @param {string} projectId Project Id
         * @param {string} saId Sa Id
         * @param {SaCredential} saCredential 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectSaCredentialCreate(projectId: string, saId: string, saCredential: SaCredential, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SaCredential>> {
            const localVarAxiosArgs = await IamProjectSaApiAxiosParamCreator(configuration).iamProjectSaCredentialCreate(projectId, saId, saCredential, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete iam/sa.credential
         * @summary Delete iam/sa.credential
         * @param {string} projectId Project Id
         * @param {string} saId Sa Id
         * @param {string} credentialId credentialId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectSaCredentialDelete(projectId: string, saId: string, credentialId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Sa>> {
            const localVarAxiosArgs = await IamProjectSaApiAxiosParamCreator(configuration).iamProjectSaCredentialDelete(projectId, saId, credentialId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get iam/sa.credential
         * @summary Get iam/sa.credential
         * @param {string} projectId Project Id
         * @param {string} saId Sa Id
         * @param {string} credentialId credentialId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectSaCredentialGet(projectId: string, saId: string, credentialId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SaCredential>> {
            const localVarAxiosArgs = await IamProjectSaApiAxiosParamCreator(configuration).iamProjectSaCredentialGet(projectId, saId, credentialId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List iam/sa.credential
         * @summary List iam/sa.credential
         * @param {string} projectId Project Id
         * @param {string} saId Sa Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectSaCredentialList(projectId: string, saId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SaCredential>>> {
            const localVarAxiosArgs = await IamProjectSaApiAxiosParamCreator(configuration).iamProjectSaCredentialList(projectId, saId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update iam/sa.credential
         * @summary Update iam/sa.credential
         * @param {string} projectId Project Id
         * @param {string} saId Sa Id
         * @param {string} credentialId credentialId
         * @param {IamProjectSaCredentialPatch} iamProjectSaCredentialPatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectSaCredentialPatch(projectId: string, saId: string, credentialId: string, iamProjectSaCredentialPatch: IamProjectSaCredentialPatch, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SaCredential>> {
            const localVarAxiosArgs = await IamProjectSaApiAxiosParamCreator(configuration).iamProjectSaCredentialPatch(projectId, saId, credentialId, iamProjectSaCredentialPatch, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete sa
         * @summary Delete iam/sa
         * @param {string} projectId Project Id
         * @param {string} saId Sa Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectSaDelete(projectId: string, saId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await IamProjectSaApiAxiosParamCreator(configuration).iamProjectSaDelete(projectId, saId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get iam/sa.event
         * @summary Get iam/sa.event
         * @param {string} projectId Project Id
         * @param {string} saId Sa Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectSaEventGet(projectId: string, saId: string, eventId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>> {
            const localVarAxiosArgs = await IamProjectSaApiAxiosParamCreator(configuration).iamProjectSaEventGet(projectId, saId, eventId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List iam/sa.event
         * @summary List iam/sa.event
         * @param {string} projectId Project Id
         * @param {string} saId Sa Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectSaEventList(projectId: string, saId: string, $limit?: number, $skip?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Event>>> {
            const localVarAxiosArgs = await IamProjectSaApiAxiosParamCreator(configuration).iamProjectSaEventList(projectId, saId, $limit, $skip, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a single sa
         * @summary Get iam/sa
         * @param {string} projectId Project Id
         * @param {string} saId Sa Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectSaGet(projectId: string, saId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Sa>> {
            const localVarAxiosArgs = await IamProjectSaApiAxiosParamCreator(configuration).iamProjectSaGet(projectId, saId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List sa
         * @summary List iam/sa
         * @param {string} projectId Project Id
         * @param {string} [name] Filter by name
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectSaList(projectId: string, name?: string, tagValue?: string, tagKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Sa>>> {
            const localVarAxiosArgs = await IamProjectSaApiAxiosParamCreator(configuration).iamProjectSaList(projectId, name, tagValue, tagKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get iam/sa.service
         * @summary Get iam/sa.service
         * @param {string} projectId Project Id
         * @param {string} saId Sa Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectSaServiceGet(projectId: string, saId: string, serviceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceService>> {
            const localVarAxiosArgs = await IamProjectSaApiAxiosParamCreator(configuration).iamProjectSaServiceGet(projectId, saId, serviceId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List iam/sa.service
         * @summary List iam/sa.service
         * @param {string} projectId Project Id
         * @param {string} saId Sa Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectSaServiceList(projectId: string, saId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResourceService>>> {
            const localVarAxiosArgs = await IamProjectSaApiAxiosParamCreator(configuration).iamProjectSaServiceList(projectId, saId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create iam/sa.tag
         * @summary Create iam/sa.tag
         * @param {string} projectId Project Id
         * @param {string} saId Sa Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectSaTagCreate(projectId: string, saId: string, tag: Tag, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await IamProjectSaApiAxiosParamCreator(configuration).iamProjectSaTagCreate(projectId, saId, tag, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete iam/sa.tag
         * @summary Delete iam/sa.tag
         * @param {string} projectId Project Id
         * @param {string} saId Sa Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectSaTagDelete(projectId: string, saId: string, tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await IamProjectSaApiAxiosParamCreator(configuration).iamProjectSaTagDelete(projectId, saId, tagId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get iam/sa.tag
         * @summary Get iam/sa.tag
         * @param {string} projectId Project Id
         * @param {string} saId Sa Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectSaTagGet(projectId: string, saId: string, tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await IamProjectSaApiAxiosParamCreator(configuration).iamProjectSaTagGet(projectId, saId, tagId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List iam/sa.tag
         * @summary List iam/sa.tag
         * @param {string} projectId Project Id
         * @param {string} saId Sa Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectSaTagList(projectId: string, saId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await IamProjectSaApiAxiosParamCreator(configuration).iamProjectSaTagList(projectId, saId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Replace iam/sa.tag
         * @summary Replace iam/sa.tag
         * @param {string} projectId Project Id
         * @param {string} saId Sa Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectSaTagPut(projectId: string, saId: string, tag: Array<Tag>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await IamProjectSaApiAxiosParamCreator(configuration).iamProjectSaTagPut(projectId, saId, tag, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns modified sa
         * @summary Update iam/sa
         * @param {string} projectId Project Id
         * @param {string} saId Sa Id
         * @param {IamProjectSaUpdate} iamProjectSaUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectSaUpdate(projectId: string, saId: string, iamProjectSaUpdate: IamProjectSaUpdate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Sa>> {
            const localVarAxiosArgs = await IamProjectSaApiAxiosParamCreator(configuration).iamProjectSaUpdate(projectId, saId, iamProjectSaUpdate, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * IamProjectSaApi - factory interface
 * @export
 */
export const IamProjectSaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Create sa
         * @summary Create iam/sa
         * @param {string} projectId Project Id
         * @param {IamProjectSaCreate} iamProjectSaCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectSaCreate(projectId: string, iamProjectSaCreate: IamProjectSaCreate, xIdempotencyKey?: string, options?: any): AxiosPromise<Sa> {
            return IamProjectSaApiFp(configuration).iamProjectSaCreate(projectId, iamProjectSaCreate, xIdempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Create iam/sa.credential
         * @summary Create iam/sa.credential
         * @param {string} projectId Project Id
         * @param {string} saId Sa Id
         * @param {SaCredential} saCredential 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectSaCredentialCreate(projectId: string, saId: string, saCredential: SaCredential, options?: any): AxiosPromise<SaCredential> {
            return IamProjectSaApiFp(configuration).iamProjectSaCredentialCreate(projectId, saId, saCredential, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete iam/sa.credential
         * @summary Delete iam/sa.credential
         * @param {string} projectId Project Id
         * @param {string} saId Sa Id
         * @param {string} credentialId credentialId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectSaCredentialDelete(projectId: string, saId: string, credentialId: string, options?: any): AxiosPromise<Sa> {
            return IamProjectSaApiFp(configuration).iamProjectSaCredentialDelete(projectId, saId, credentialId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get iam/sa.credential
         * @summary Get iam/sa.credential
         * @param {string} projectId Project Id
         * @param {string} saId Sa Id
         * @param {string} credentialId credentialId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectSaCredentialGet(projectId: string, saId: string, credentialId: string, options?: any): AxiosPromise<SaCredential> {
            return IamProjectSaApiFp(configuration).iamProjectSaCredentialGet(projectId, saId, credentialId, options).then((request) => request(axios, basePath));
        },
        /**
         * List iam/sa.credential
         * @summary List iam/sa.credential
         * @param {string} projectId Project Id
         * @param {string} saId Sa Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectSaCredentialList(projectId: string, saId: string, options?: any): AxiosPromise<Array<SaCredential>> {
            return IamProjectSaApiFp(configuration).iamProjectSaCredentialList(projectId, saId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update iam/sa.credential
         * @summary Update iam/sa.credential
         * @param {string} projectId Project Id
         * @param {string} saId Sa Id
         * @param {string} credentialId credentialId
         * @param {IamProjectSaCredentialPatch} iamProjectSaCredentialPatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectSaCredentialPatch(projectId: string, saId: string, credentialId: string, iamProjectSaCredentialPatch: IamProjectSaCredentialPatch, options?: any): AxiosPromise<SaCredential> {
            return IamProjectSaApiFp(configuration).iamProjectSaCredentialPatch(projectId, saId, credentialId, iamProjectSaCredentialPatch, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete sa
         * @summary Delete iam/sa
         * @param {string} projectId Project Id
         * @param {string} saId Sa Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectSaDelete(projectId: string, saId: string, options?: any): AxiosPromise<void> {
            return IamProjectSaApiFp(configuration).iamProjectSaDelete(projectId, saId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get iam/sa.event
         * @summary Get iam/sa.event
         * @param {string} projectId Project Id
         * @param {string} saId Sa Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectSaEventGet(projectId: string, saId: string, eventId: string, options?: any): AxiosPromise<Event> {
            return IamProjectSaApiFp(configuration).iamProjectSaEventGet(projectId, saId, eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * List iam/sa.event
         * @summary List iam/sa.event
         * @param {string} projectId Project Id
         * @param {string} saId Sa Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectSaEventList(projectId: string, saId: string, $limit?: number, $skip?: number, options?: any): AxiosPromise<Array<Event>> {
            return IamProjectSaApiFp(configuration).iamProjectSaEventList(projectId, saId, $limit, $skip, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single sa
         * @summary Get iam/sa
         * @param {string} projectId Project Id
         * @param {string} saId Sa Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectSaGet(projectId: string, saId: string, options?: any): AxiosPromise<Sa> {
            return IamProjectSaApiFp(configuration).iamProjectSaGet(projectId, saId, options).then((request) => request(axios, basePath));
        },
        /**
         * List sa
         * @summary List iam/sa
         * @param {string} projectId Project Id
         * @param {string} [name] Filter by name
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectSaList(projectId: string, name?: string, tagValue?: string, tagKey?: string, options?: any): AxiosPromise<Array<Sa>> {
            return IamProjectSaApiFp(configuration).iamProjectSaList(projectId, name, tagValue, tagKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get iam/sa.service
         * @summary Get iam/sa.service
         * @param {string} projectId Project Id
         * @param {string} saId Sa Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectSaServiceGet(projectId: string, saId: string, serviceId: string, options?: any): AxiosPromise<ResourceService> {
            return IamProjectSaApiFp(configuration).iamProjectSaServiceGet(projectId, saId, serviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * List iam/sa.service
         * @summary List iam/sa.service
         * @param {string} projectId Project Id
         * @param {string} saId Sa Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectSaServiceList(projectId: string, saId: string, options?: any): AxiosPromise<Array<ResourceService>> {
            return IamProjectSaApiFp(configuration).iamProjectSaServiceList(projectId, saId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create iam/sa.tag
         * @summary Create iam/sa.tag
         * @param {string} projectId Project Id
         * @param {string} saId Sa Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectSaTagCreate(projectId: string, saId: string, tag: Tag, options?: any): AxiosPromise<Tag> {
            return IamProjectSaApiFp(configuration).iamProjectSaTagCreate(projectId, saId, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete iam/sa.tag
         * @summary Delete iam/sa.tag
         * @param {string} projectId Project Id
         * @param {string} saId Sa Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectSaTagDelete(projectId: string, saId: string, tagId: string, options?: any): AxiosPromise<void> {
            return IamProjectSaApiFp(configuration).iamProjectSaTagDelete(projectId, saId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get iam/sa.tag
         * @summary Get iam/sa.tag
         * @param {string} projectId Project Id
         * @param {string} saId Sa Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectSaTagGet(projectId: string, saId: string, tagId: string, options?: any): AxiosPromise<Tag> {
            return IamProjectSaApiFp(configuration).iamProjectSaTagGet(projectId, saId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * List iam/sa.tag
         * @summary List iam/sa.tag
         * @param {string} projectId Project Id
         * @param {string} saId Sa Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectSaTagList(projectId: string, saId: string, options?: any): AxiosPromise<Array<Tag>> {
            return IamProjectSaApiFp(configuration).iamProjectSaTagList(projectId, saId, options).then((request) => request(axios, basePath));
        },
        /**
         * Replace iam/sa.tag
         * @summary Replace iam/sa.tag
         * @param {string} projectId Project Id
         * @param {string} saId Sa Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectSaTagPut(projectId: string, saId: string, tag: Array<Tag>, options?: any): AxiosPromise<Array<Tag>> {
            return IamProjectSaApiFp(configuration).iamProjectSaTagPut(projectId, saId, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns modified sa
         * @summary Update iam/sa
         * @param {string} projectId Project Id
         * @param {string} saId Sa Id
         * @param {IamProjectSaUpdate} iamProjectSaUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectSaUpdate(projectId: string, saId: string, iamProjectSaUpdate: IamProjectSaUpdate, options?: any): AxiosPromise<Sa> {
            return IamProjectSaApiFp(configuration).iamProjectSaUpdate(projectId, saId, iamProjectSaUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IamProjectSaApi - object-oriented interface
 * @export
 * @class IamProjectSaApi
 * @extends {BaseAPI}
 */
export class IamProjectSaApi extends BaseAPI {
    /**
     * Create sa
     * @summary Create iam/sa
     * @param {string} projectId Project Id
     * @param {IamProjectSaCreate} iamProjectSaCreate 
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectSaApi
     */
    public iamProjectSaCreate(projectId: string, iamProjectSaCreate: IamProjectSaCreate, xIdempotencyKey?: string, options?: any) {
        return IamProjectSaApiFp(this.configuration).iamProjectSaCreate(projectId, iamProjectSaCreate, xIdempotencyKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create iam/sa.credential
     * @summary Create iam/sa.credential
     * @param {string} projectId Project Id
     * @param {string} saId Sa Id
     * @param {SaCredential} saCredential 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectSaApi
     */
    public iamProjectSaCredentialCreate(projectId: string, saId: string, saCredential: SaCredential, options?: any) {
        return IamProjectSaApiFp(this.configuration).iamProjectSaCredentialCreate(projectId, saId, saCredential, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete iam/sa.credential
     * @summary Delete iam/sa.credential
     * @param {string} projectId Project Id
     * @param {string} saId Sa Id
     * @param {string} credentialId credentialId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectSaApi
     */
    public iamProjectSaCredentialDelete(projectId: string, saId: string, credentialId: string, options?: any) {
        return IamProjectSaApiFp(this.configuration).iamProjectSaCredentialDelete(projectId, saId, credentialId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get iam/sa.credential
     * @summary Get iam/sa.credential
     * @param {string} projectId Project Id
     * @param {string} saId Sa Id
     * @param {string} credentialId credentialId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectSaApi
     */
    public iamProjectSaCredentialGet(projectId: string, saId: string, credentialId: string, options?: any) {
        return IamProjectSaApiFp(this.configuration).iamProjectSaCredentialGet(projectId, saId, credentialId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List iam/sa.credential
     * @summary List iam/sa.credential
     * @param {string} projectId Project Id
     * @param {string} saId Sa Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectSaApi
     */
    public iamProjectSaCredentialList(projectId: string, saId: string, options?: any) {
        return IamProjectSaApiFp(this.configuration).iamProjectSaCredentialList(projectId, saId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update iam/sa.credential
     * @summary Update iam/sa.credential
     * @param {string} projectId Project Id
     * @param {string} saId Sa Id
     * @param {string} credentialId credentialId
     * @param {IamProjectSaCredentialPatch} iamProjectSaCredentialPatch 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectSaApi
     */
    public iamProjectSaCredentialPatch(projectId: string, saId: string, credentialId: string, iamProjectSaCredentialPatch: IamProjectSaCredentialPatch, options?: any) {
        return IamProjectSaApiFp(this.configuration).iamProjectSaCredentialPatch(projectId, saId, credentialId, iamProjectSaCredentialPatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete sa
     * @summary Delete iam/sa
     * @param {string} projectId Project Id
     * @param {string} saId Sa Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectSaApi
     */
    public iamProjectSaDelete(projectId: string, saId: string, options?: any) {
        return IamProjectSaApiFp(this.configuration).iamProjectSaDelete(projectId, saId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get iam/sa.event
     * @summary Get iam/sa.event
     * @param {string} projectId Project Id
     * @param {string} saId Sa Id
     * @param {string} eventId eventId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectSaApi
     */
    public iamProjectSaEventGet(projectId: string, saId: string, eventId: string, options?: any) {
        return IamProjectSaApiFp(this.configuration).iamProjectSaEventGet(projectId, saId, eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List iam/sa.event
     * @summary List iam/sa.event
     * @param {string} projectId Project Id
     * @param {string} saId Sa Id
     * @param {number} [$limit] $limit
     * @param {number} [$skip] $skip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectSaApi
     */
    public iamProjectSaEventList(projectId: string, saId: string, $limit?: number, $skip?: number, options?: any) {
        return IamProjectSaApiFp(this.configuration).iamProjectSaEventList(projectId, saId, $limit, $skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single sa
     * @summary Get iam/sa
     * @param {string} projectId Project Id
     * @param {string} saId Sa Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectSaApi
     */
    public iamProjectSaGet(projectId: string, saId: string, options?: any) {
        return IamProjectSaApiFp(this.configuration).iamProjectSaGet(projectId, saId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List sa
     * @summary List iam/sa
     * @param {string} projectId Project Id
     * @param {string} [name] Filter by name
     * @param {string} [tagValue] Filter by tag.value
     * @param {string} [tagKey] Filter by tag.key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectSaApi
     */
    public iamProjectSaList(projectId: string, name?: string, tagValue?: string, tagKey?: string, options?: any) {
        return IamProjectSaApiFp(this.configuration).iamProjectSaList(projectId, name, tagValue, tagKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get iam/sa.service
     * @summary Get iam/sa.service
     * @param {string} projectId Project Id
     * @param {string} saId Sa Id
     * @param {string} serviceId serviceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectSaApi
     */
    public iamProjectSaServiceGet(projectId: string, saId: string, serviceId: string, options?: any) {
        return IamProjectSaApiFp(this.configuration).iamProjectSaServiceGet(projectId, saId, serviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List iam/sa.service
     * @summary List iam/sa.service
     * @param {string} projectId Project Id
     * @param {string} saId Sa Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectSaApi
     */
    public iamProjectSaServiceList(projectId: string, saId: string, options?: any) {
        return IamProjectSaApiFp(this.configuration).iamProjectSaServiceList(projectId, saId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create iam/sa.tag
     * @summary Create iam/sa.tag
     * @param {string} projectId Project Id
     * @param {string} saId Sa Id
     * @param {Tag} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectSaApi
     */
    public iamProjectSaTagCreate(projectId: string, saId: string, tag: Tag, options?: any) {
        return IamProjectSaApiFp(this.configuration).iamProjectSaTagCreate(projectId, saId, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete iam/sa.tag
     * @summary Delete iam/sa.tag
     * @param {string} projectId Project Id
     * @param {string} saId Sa Id
     * @param {string} tagId tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectSaApi
     */
    public iamProjectSaTagDelete(projectId: string, saId: string, tagId: string, options?: any) {
        return IamProjectSaApiFp(this.configuration).iamProjectSaTagDelete(projectId, saId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get iam/sa.tag
     * @summary Get iam/sa.tag
     * @param {string} projectId Project Id
     * @param {string} saId Sa Id
     * @param {string} tagId tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectSaApi
     */
    public iamProjectSaTagGet(projectId: string, saId: string, tagId: string, options?: any) {
        return IamProjectSaApiFp(this.configuration).iamProjectSaTagGet(projectId, saId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List iam/sa.tag
     * @summary List iam/sa.tag
     * @param {string} projectId Project Id
     * @param {string} saId Sa Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectSaApi
     */
    public iamProjectSaTagList(projectId: string, saId: string, options?: any) {
        return IamProjectSaApiFp(this.configuration).iamProjectSaTagList(projectId, saId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replace iam/sa.tag
     * @summary Replace iam/sa.tag
     * @param {string} projectId Project Id
     * @param {string} saId Sa Id
     * @param {Array<Tag>} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectSaApi
     */
    public iamProjectSaTagPut(projectId: string, saId: string, tag: Array<Tag>, options?: any) {
        return IamProjectSaApiFp(this.configuration).iamProjectSaTagPut(projectId, saId, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns modified sa
     * @summary Update iam/sa
     * @param {string} projectId Project Id
     * @param {string} saId Sa Id
     * @param {IamProjectSaUpdate} iamProjectSaUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectSaApi
     */
    public iamProjectSaUpdate(projectId: string, saId: string, iamProjectSaUpdate: IamProjectSaUpdate, options?: any) {
        return IamProjectSaApiFp(this.configuration).iamProjectSaUpdate(projectId, saId, iamProjectSaUpdate, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * IamUserApi - axios parameter creator
 * @export
 */
export const IamUserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete iam/user.credential
         * @summary Delete iam/user.credential
         * @param {string} userId User Id
         * @param {string} authtokenId authtokenId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamUserCredentialAuthtokenDelete: async (userId: string, authtokenId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling iamUserCredentialAuthtokenDelete.');
            }
            // verify required parameter 'authtokenId' is not null or undefined
            if (authtokenId === null || authtokenId === undefined) {
                throw new RequiredError('authtokenId','Required parameter authtokenId was null or undefined when calling iamUserCredentialAuthtokenDelete.');
            }
            const localVarPath = `/iam/user/{userId}/credential/authtoken/{authtokenId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"authtokenId"}}`, encodeURIComponent(String(authtokenId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get iam/user.credential
         * @summary Get iam/user.credential
         * @param {string} userId User Id
         * @param {string} authtokenId authtokenId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamUserCredentialAuthtokenGet: async (userId: string, authtokenId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling iamUserCredentialAuthtokenGet.');
            }
            // verify required parameter 'authtokenId' is not null or undefined
            if (authtokenId === null || authtokenId === undefined) {
                throw new RequiredError('authtokenId','Required parameter authtokenId was null or undefined when calling iamUserCredentialAuthtokenGet.');
            }
            const localVarPath = `/iam/user/{userId}/credential/authtoken/{authtokenId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"authtokenId"}}`, encodeURIComponent(String(authtokenId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List iam/user.credential
         * @summary List iam/user.credential
         * @param {string} userId User Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamUserCredentialAuthtokenList: async (userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling iamUserCredentialAuthtokenList.');
            }
            const localVarPath = `/iam/user/{userId}/credential/authtoken`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create iam/user.credential
         * @summary Create iam/user.credential
         * @param {string} userId User Id
         * @param {UserCredential} userCredential 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamUserCredentialCreate: async (userId: string, userCredential: UserCredential, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling iamUserCredentialCreate.');
            }
            // verify required parameter 'userCredential' is not null or undefined
            if (userCredential === null || userCredential === undefined) {
                throw new RequiredError('userCredential','Required parameter userCredential was null or undefined when calling iamUserCredentialCreate.');
            }
            const localVarPath = `/iam/user/{userId}/credential`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof userCredential !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(userCredential !== undefined ? userCredential : {}) : (userCredential || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete iam/user.credential
         * @summary Delete iam/user.credential
         * @param {string} userId User Id
         * @param {string} credentialId credentialId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamUserCredentialDelete: async (userId: string, credentialId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling iamUserCredentialDelete.');
            }
            // verify required parameter 'credentialId' is not null or undefined
            if (credentialId === null || credentialId === undefined) {
                throw new RequiredError('credentialId','Required parameter credentialId was null or undefined when calling iamUserCredentialDelete.');
            }
            const localVarPath = `/iam/user/{userId}/credential/{credentialId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"credentialId"}}`, encodeURIComponent(String(credentialId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get iam/user.credential
         * @summary Get iam/user.credential
         * @param {string} userId User Id
         * @param {string} credentialId credentialId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamUserCredentialGet: async (userId: string, credentialId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling iamUserCredentialGet.');
            }
            // verify required parameter 'credentialId' is not null or undefined
            if (credentialId === null || credentialId === undefined) {
                throw new RequiredError('credentialId','Required parameter credentialId was null or undefined when calling iamUserCredentialGet.');
            }
            const localVarPath = `/iam/user/{userId}/credential/{credentialId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"credentialId"}}`, encodeURIComponent(String(credentialId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List iam/user.credential
         * @summary List iam/user.credential
         * @param {string} userId User Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamUserCredentialList: async (userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling iamUserCredentialList.');
            }
            const localVarPath = `/iam/user/{userId}/credential`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update iam/user.credential
         * @summary Update iam/user.credential
         * @param {string} userId User Id
         * @param {string} credentialId credentialId
         * @param {IamUserCredentialPatch} iamUserCredentialPatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamUserCredentialPatch: async (userId: string, credentialId: string, iamUserCredentialPatch: IamUserCredentialPatch, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling iamUserCredentialPatch.');
            }
            // verify required parameter 'credentialId' is not null or undefined
            if (credentialId === null || credentialId === undefined) {
                throw new RequiredError('credentialId','Required parameter credentialId was null or undefined when calling iamUserCredentialPatch.');
            }
            // verify required parameter 'iamUserCredentialPatch' is not null or undefined
            if (iamUserCredentialPatch === null || iamUserCredentialPatch === undefined) {
                throw new RequiredError('iamUserCredentialPatch','Required parameter iamUserCredentialPatch was null or undefined when calling iamUserCredentialPatch.');
            }
            const localVarPath = `/iam/user/{userId}/credential/{credentialId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"credentialId"}}`, encodeURIComponent(String(credentialId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof iamUserCredentialPatch !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(iamUserCredentialPatch !== undefined ? iamUserCredentialPatch : {}) : (iamUserCredentialPatch || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single user
         * @summary Get iam/user
         * @param {string} userId User Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamUserGet: async (userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling iamUserGet.');
            }
            const localVarPath = `/iam/user/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get iam/user.service
         * @summary Get iam/user.service
         * @param {string} userId User Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamUserServiceGet: async (userId: string, serviceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling iamUserServiceGet.');
            }
            // verify required parameter 'serviceId' is not null or undefined
            if (serviceId === null || serviceId === undefined) {
                throw new RequiredError('serviceId','Required parameter serviceId was null or undefined when calling iamUserServiceGet.');
            }
            const localVarPath = `/iam/user/{userId}/service/{serviceId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List iam/user.service
         * @summary List iam/user.service
         * @param {string} userId User Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamUserServiceList: async (userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling iamUserServiceList.');
            }
            const localVarPath = `/iam/user/{userId}/service`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns modified user
         * @summary Update iam/user
         * @param {string} userId User Id
         * @param {IamUserUpdate} iamUserUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamUserUpdate: async (userId: string, iamUserUpdate: IamUserUpdate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            if (userId === null || userId === undefined) {
                throw new RequiredError('userId','Required parameter userId was null or undefined when calling iamUserUpdate.');
            }
            // verify required parameter 'iamUserUpdate' is not null or undefined
            if (iamUserUpdate === null || iamUserUpdate === undefined) {
                throw new RequiredError('iamUserUpdate','Required parameter iamUserUpdate was null or undefined when calling iamUserUpdate.');
            }
            const localVarPath = `/iam/user/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof iamUserUpdate !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(iamUserUpdate !== undefined ? iamUserUpdate : {}) : (iamUserUpdate || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IamUserApi - functional programming interface
 * @export
 */
export const IamUserApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Delete iam/user.credential
         * @summary Delete iam/user.credential
         * @param {string} userId User Id
         * @param {string} authtokenId authtokenId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamUserCredentialAuthtokenDelete(userId: string, authtokenId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await IamUserApiAxiosParamCreator(configuration).iamUserCredentialAuthtokenDelete(userId, authtokenId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get iam/user.credential
         * @summary Get iam/user.credential
         * @param {string} userId User Id
         * @param {string} authtokenId authtokenId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamUserCredentialAuthtokenGet(userId: string, authtokenId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthToken>> {
            const localVarAxiosArgs = await IamUserApiAxiosParamCreator(configuration).iamUserCredentialAuthtokenGet(userId, authtokenId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List iam/user.credential
         * @summary List iam/user.credential
         * @param {string} userId User Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamUserCredentialAuthtokenList(userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AuthToken>>> {
            const localVarAxiosArgs = await IamUserApiAxiosParamCreator(configuration).iamUserCredentialAuthtokenList(userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create iam/user.credential
         * @summary Create iam/user.credential
         * @param {string} userId User Id
         * @param {UserCredential} userCredential 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamUserCredentialCreate(userId: string, userCredential: UserCredential, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserCredential>> {
            const localVarAxiosArgs = await IamUserApiAxiosParamCreator(configuration).iamUserCredentialCreate(userId, userCredential, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete iam/user.credential
         * @summary Delete iam/user.credential
         * @param {string} userId User Id
         * @param {string} credentialId credentialId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamUserCredentialDelete(userId: string, credentialId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await IamUserApiAxiosParamCreator(configuration).iamUserCredentialDelete(userId, credentialId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get iam/user.credential
         * @summary Get iam/user.credential
         * @param {string} userId User Id
         * @param {string} credentialId credentialId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamUserCredentialGet(userId: string, credentialId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserCredential>> {
            const localVarAxiosArgs = await IamUserApiAxiosParamCreator(configuration).iamUserCredentialGet(userId, credentialId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List iam/user.credential
         * @summary List iam/user.credential
         * @param {string} userId User Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamUserCredentialList(userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserCredential>>> {
            const localVarAxiosArgs = await IamUserApiAxiosParamCreator(configuration).iamUserCredentialList(userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update iam/user.credential
         * @summary Update iam/user.credential
         * @param {string} userId User Id
         * @param {string} credentialId credentialId
         * @param {IamUserCredentialPatch} iamUserCredentialPatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamUserCredentialPatch(userId: string, credentialId: string, iamUserCredentialPatch: IamUserCredentialPatch, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserCredential>> {
            const localVarAxiosArgs = await IamUserApiAxiosParamCreator(configuration).iamUserCredentialPatch(userId, credentialId, iamUserCredentialPatch, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a single user
         * @summary Get iam/user
         * @param {string} userId User Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamUserGet(userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await IamUserApiAxiosParamCreator(configuration).iamUserGet(userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get iam/user.service
         * @summary Get iam/user.service
         * @param {string} userId User Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamUserServiceGet(userId: string, serviceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceService>> {
            const localVarAxiosArgs = await IamUserApiAxiosParamCreator(configuration).iamUserServiceGet(userId, serviceId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List iam/user.service
         * @summary List iam/user.service
         * @param {string} userId User Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamUserServiceList(userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResourceService>>> {
            const localVarAxiosArgs = await IamUserApiAxiosParamCreator(configuration).iamUserServiceList(userId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns modified user
         * @summary Update iam/user
         * @param {string} userId User Id
         * @param {IamUserUpdate} iamUserUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamUserUpdate(userId: string, iamUserUpdate: IamUserUpdate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await IamUserApiAxiosParamCreator(configuration).iamUserUpdate(userId, iamUserUpdate, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * IamUserApi - factory interface
 * @export
 */
export const IamUserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Delete iam/user.credential
         * @summary Delete iam/user.credential
         * @param {string} userId User Id
         * @param {string} authtokenId authtokenId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamUserCredentialAuthtokenDelete(userId: string, authtokenId: string, options?: any): AxiosPromise<void> {
            return IamUserApiFp(configuration).iamUserCredentialAuthtokenDelete(userId, authtokenId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get iam/user.credential
         * @summary Get iam/user.credential
         * @param {string} userId User Id
         * @param {string} authtokenId authtokenId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamUserCredentialAuthtokenGet(userId: string, authtokenId: string, options?: any): AxiosPromise<AuthToken> {
            return IamUserApiFp(configuration).iamUserCredentialAuthtokenGet(userId, authtokenId, options).then((request) => request(axios, basePath));
        },
        /**
         * List iam/user.credential
         * @summary List iam/user.credential
         * @param {string} userId User Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamUserCredentialAuthtokenList(userId: string, options?: any): AxiosPromise<Array<AuthToken>> {
            return IamUserApiFp(configuration).iamUserCredentialAuthtokenList(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create iam/user.credential
         * @summary Create iam/user.credential
         * @param {string} userId User Id
         * @param {UserCredential} userCredential 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamUserCredentialCreate(userId: string, userCredential: UserCredential, options?: any): AxiosPromise<UserCredential> {
            return IamUserApiFp(configuration).iamUserCredentialCreate(userId, userCredential, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete iam/user.credential
         * @summary Delete iam/user.credential
         * @param {string} userId User Id
         * @param {string} credentialId credentialId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamUserCredentialDelete(userId: string, credentialId: string, options?: any): AxiosPromise<User> {
            return IamUserApiFp(configuration).iamUserCredentialDelete(userId, credentialId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get iam/user.credential
         * @summary Get iam/user.credential
         * @param {string} userId User Id
         * @param {string} credentialId credentialId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamUserCredentialGet(userId: string, credentialId: string, options?: any): AxiosPromise<UserCredential> {
            return IamUserApiFp(configuration).iamUserCredentialGet(userId, credentialId, options).then((request) => request(axios, basePath));
        },
        /**
         * List iam/user.credential
         * @summary List iam/user.credential
         * @param {string} userId User Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamUserCredentialList(userId: string, options?: any): AxiosPromise<Array<UserCredential>> {
            return IamUserApiFp(configuration).iamUserCredentialList(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update iam/user.credential
         * @summary Update iam/user.credential
         * @param {string} userId User Id
         * @param {string} credentialId credentialId
         * @param {IamUserCredentialPatch} iamUserCredentialPatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamUserCredentialPatch(userId: string, credentialId: string, iamUserCredentialPatch: IamUserCredentialPatch, options?: any): AxiosPromise<UserCredential> {
            return IamUserApiFp(configuration).iamUserCredentialPatch(userId, credentialId, iamUserCredentialPatch, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single user
         * @summary Get iam/user
         * @param {string} userId User Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamUserGet(userId: string, options?: any): AxiosPromise<User> {
            return IamUserApiFp(configuration).iamUserGet(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get iam/user.service
         * @summary Get iam/user.service
         * @param {string} userId User Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamUserServiceGet(userId: string, serviceId: string, options?: any): AxiosPromise<ResourceService> {
            return IamUserApiFp(configuration).iamUserServiceGet(userId, serviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * List iam/user.service
         * @summary List iam/user.service
         * @param {string} userId User Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamUserServiceList(userId: string, options?: any): AxiosPromise<Array<ResourceService>> {
            return IamUserApiFp(configuration).iamUserServiceList(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns modified user
         * @summary Update iam/user
         * @param {string} userId User Id
         * @param {IamUserUpdate} iamUserUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamUserUpdate(userId: string, iamUserUpdate: IamUserUpdate, options?: any): AxiosPromise<User> {
            return IamUserApiFp(configuration).iamUserUpdate(userId, iamUserUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IamUserApi - object-oriented interface
 * @export
 * @class IamUserApi
 * @extends {BaseAPI}
 */
export class IamUserApi extends BaseAPI {
    /**
     * Delete iam/user.credential
     * @summary Delete iam/user.credential
     * @param {string} userId User Id
     * @param {string} authtokenId authtokenId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamUserApi
     */
    public iamUserCredentialAuthtokenDelete(userId: string, authtokenId: string, options?: any) {
        return IamUserApiFp(this.configuration).iamUserCredentialAuthtokenDelete(userId, authtokenId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get iam/user.credential
     * @summary Get iam/user.credential
     * @param {string} userId User Id
     * @param {string} authtokenId authtokenId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamUserApi
     */
    public iamUserCredentialAuthtokenGet(userId: string, authtokenId: string, options?: any) {
        return IamUserApiFp(this.configuration).iamUserCredentialAuthtokenGet(userId, authtokenId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List iam/user.credential
     * @summary List iam/user.credential
     * @param {string} userId User Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamUserApi
     */
    public iamUserCredentialAuthtokenList(userId: string, options?: any) {
        return IamUserApiFp(this.configuration).iamUserCredentialAuthtokenList(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create iam/user.credential
     * @summary Create iam/user.credential
     * @param {string} userId User Id
     * @param {UserCredential} userCredential 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamUserApi
     */
    public iamUserCredentialCreate(userId: string, userCredential: UserCredential, options?: any) {
        return IamUserApiFp(this.configuration).iamUserCredentialCreate(userId, userCredential, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete iam/user.credential
     * @summary Delete iam/user.credential
     * @param {string} userId User Id
     * @param {string} credentialId credentialId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamUserApi
     */
    public iamUserCredentialDelete(userId: string, credentialId: string, options?: any) {
        return IamUserApiFp(this.configuration).iamUserCredentialDelete(userId, credentialId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get iam/user.credential
     * @summary Get iam/user.credential
     * @param {string} userId User Id
     * @param {string} credentialId credentialId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamUserApi
     */
    public iamUserCredentialGet(userId: string, credentialId: string, options?: any) {
        return IamUserApiFp(this.configuration).iamUserCredentialGet(userId, credentialId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List iam/user.credential
     * @summary List iam/user.credential
     * @param {string} userId User Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamUserApi
     */
    public iamUserCredentialList(userId: string, options?: any) {
        return IamUserApiFp(this.configuration).iamUserCredentialList(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update iam/user.credential
     * @summary Update iam/user.credential
     * @param {string} userId User Id
     * @param {string} credentialId credentialId
     * @param {IamUserCredentialPatch} iamUserCredentialPatch 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamUserApi
     */
    public iamUserCredentialPatch(userId: string, credentialId: string, iamUserCredentialPatch: IamUserCredentialPatch, options?: any) {
        return IamUserApiFp(this.configuration).iamUserCredentialPatch(userId, credentialId, iamUserCredentialPatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single user
     * @summary Get iam/user
     * @param {string} userId User Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamUserApi
     */
    public iamUserGet(userId: string, options?: any) {
        return IamUserApiFp(this.configuration).iamUserGet(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get iam/user.service
     * @summary Get iam/user.service
     * @param {string} userId User Id
     * @param {string} serviceId serviceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamUserApi
     */
    public iamUserServiceGet(userId: string, serviceId: string, options?: any) {
        return IamUserApiFp(this.configuration).iamUserServiceGet(userId, serviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List iam/user.service
     * @summary List iam/user.service
     * @param {string} userId User Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamUserApi
     */
    public iamUserServiceList(userId: string, options?: any) {
        return IamUserApiFp(this.configuration).iamUserServiceList(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns modified user
     * @summary Update iam/user
     * @param {string} userId User Id
     * @param {IamUserUpdate} iamUserUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamUserApi
     */
    public iamUserUpdate(userId: string, iamUserUpdate: IamUserUpdate, options?: any) {
        return IamUserApiFp(this.configuration).iamUserUpdate(userId, iamUserUpdate, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * InsightProjectJournalApi - axios parameter creator
 * @export
 */
export const InsightProjectJournalApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create journal
         * @summary Create insight/journal
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {InsightProjectJournalCreate} insightProjectJournalCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightProjectJournalCreate: async (projectId: string, locationId: string, insightProjectJournalCreate: InsightProjectJournalCreate, xIdempotencyKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling insightProjectJournalCreate.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling insightProjectJournalCreate.');
            }
            // verify required parameter 'insightProjectJournalCreate' is not null or undefined
            if (insightProjectJournalCreate === null || insightProjectJournalCreate === undefined) {
                throw new RequiredError('insightProjectJournalCreate','Required parameter insightProjectJournalCreate was null or undefined when calling insightProjectJournalCreate.');
            }
            const localVarPath = `/insight/{locationId}/project/{projectId}/journal`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof insightProjectJournalCreate !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(insightProjectJournalCreate !== undefined ? insightProjectJournalCreate : {}) : (insightProjectJournalCreate || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create insight/journal.credential
         * @summary Create insight/journal.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {JournalCredential} journalCredential 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightProjectJournalCredentialCreate: async (projectId: string, locationId: string, journalId: string, journalCredential: JournalCredential, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling insightProjectJournalCredentialCreate.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling insightProjectJournalCredentialCreate.');
            }
            // verify required parameter 'journalId' is not null or undefined
            if (journalId === null || journalId === undefined) {
                throw new RequiredError('journalId','Required parameter journalId was null or undefined when calling insightProjectJournalCredentialCreate.');
            }
            // verify required parameter 'journalCredential' is not null or undefined
            if (journalCredential === null || journalCredential === undefined) {
                throw new RequiredError('journalCredential','Required parameter journalCredential was null or undefined when calling insightProjectJournalCredentialCreate.');
            }
            const localVarPath = `/insight/{locationId}/project/{projectId}/journal/{journalId}/credential`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"journalId"}}`, encodeURIComponent(String(journalId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof journalCredential !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(journalCredential !== undefined ? journalCredential : {}) : (journalCredential || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete insight/journal.credential
         * @summary Delete insight/journal.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {string} credentialId credentialId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightProjectJournalCredentialDelete: async (projectId: string, locationId: string, journalId: string, credentialId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling insightProjectJournalCredentialDelete.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling insightProjectJournalCredentialDelete.');
            }
            // verify required parameter 'journalId' is not null or undefined
            if (journalId === null || journalId === undefined) {
                throw new RequiredError('journalId','Required parameter journalId was null or undefined when calling insightProjectJournalCredentialDelete.');
            }
            // verify required parameter 'credentialId' is not null or undefined
            if (credentialId === null || credentialId === undefined) {
                throw new RequiredError('credentialId','Required parameter credentialId was null or undefined when calling insightProjectJournalCredentialDelete.');
            }
            const localVarPath = `/insight/{locationId}/project/{projectId}/journal/{journalId}/credential/{credentialId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"journalId"}}`, encodeURIComponent(String(journalId)))
                .replace(`{${"credentialId"}}`, encodeURIComponent(String(credentialId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get insight/journal.credential
         * @summary Get insight/journal.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {string} credentialId credentialId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightProjectJournalCredentialGet: async (projectId: string, locationId: string, journalId: string, credentialId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling insightProjectJournalCredentialGet.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling insightProjectJournalCredentialGet.');
            }
            // verify required parameter 'journalId' is not null or undefined
            if (journalId === null || journalId === undefined) {
                throw new RequiredError('journalId','Required parameter journalId was null or undefined when calling insightProjectJournalCredentialGet.');
            }
            // verify required parameter 'credentialId' is not null or undefined
            if (credentialId === null || credentialId === undefined) {
                throw new RequiredError('credentialId','Required parameter credentialId was null or undefined when calling insightProjectJournalCredentialGet.');
            }
            const localVarPath = `/insight/{locationId}/project/{projectId}/journal/{journalId}/credential/{credentialId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"journalId"}}`, encodeURIComponent(String(journalId)))
                .replace(`{${"credentialId"}}`, encodeURIComponent(String(credentialId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List insight/journal.credential
         * @summary List insight/journal.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightProjectJournalCredentialList: async (projectId: string, locationId: string, journalId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling insightProjectJournalCredentialList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling insightProjectJournalCredentialList.');
            }
            // verify required parameter 'journalId' is not null or undefined
            if (journalId === null || journalId === undefined) {
                throw new RequiredError('journalId','Required parameter journalId was null or undefined when calling insightProjectJournalCredentialList.');
            }
            const localVarPath = `/insight/{locationId}/project/{projectId}/journal/{journalId}/credential`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"journalId"}}`, encodeURIComponent(String(journalId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update insight/journal.credential
         * @summary Update insight/journal.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {string} credentialId credentialId
         * @param {InsightProjectJournalCredentialPatch} insightProjectJournalCredentialPatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightProjectJournalCredentialPatch: async (projectId: string, locationId: string, journalId: string, credentialId: string, insightProjectJournalCredentialPatch: InsightProjectJournalCredentialPatch, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling insightProjectJournalCredentialPatch.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling insightProjectJournalCredentialPatch.');
            }
            // verify required parameter 'journalId' is not null or undefined
            if (journalId === null || journalId === undefined) {
                throw new RequiredError('journalId','Required parameter journalId was null or undefined when calling insightProjectJournalCredentialPatch.');
            }
            // verify required parameter 'credentialId' is not null or undefined
            if (credentialId === null || credentialId === undefined) {
                throw new RequiredError('credentialId','Required parameter credentialId was null or undefined when calling insightProjectJournalCredentialPatch.');
            }
            // verify required parameter 'insightProjectJournalCredentialPatch' is not null or undefined
            if (insightProjectJournalCredentialPatch === null || insightProjectJournalCredentialPatch === undefined) {
                throw new RequiredError('insightProjectJournalCredentialPatch','Required parameter insightProjectJournalCredentialPatch was null or undefined when calling insightProjectJournalCredentialPatch.');
            }
            const localVarPath = `/insight/{locationId}/project/{projectId}/journal/{journalId}/credential/{credentialId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"journalId"}}`, encodeURIComponent(String(journalId)))
                .replace(`{${"credentialId"}}`, encodeURIComponent(String(credentialId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof insightProjectJournalCredentialPatch !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(insightProjectJournalCredentialPatch !== undefined ? insightProjectJournalCredentialPatch : {}) : (insightProjectJournalCredentialPatch || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete journal
         * @summary Delete insight/journal
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightProjectJournalDelete: async (projectId: string, locationId: string, journalId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling insightProjectJournalDelete.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling insightProjectJournalDelete.');
            }
            // verify required parameter 'journalId' is not null or undefined
            if (journalId === null || journalId === undefined) {
                throw new RequiredError('journalId','Required parameter journalId was null or undefined when calling insightProjectJournalDelete.');
            }
            const localVarPath = `/insight/{locationId}/project/{projectId}/journal/{journalId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"journalId"}}`, encodeURIComponent(String(journalId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get insight/journal.event
         * @summary Get insight/journal.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightProjectJournalEventGet: async (projectId: string, locationId: string, journalId: string, eventId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling insightProjectJournalEventGet.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling insightProjectJournalEventGet.');
            }
            // verify required parameter 'journalId' is not null or undefined
            if (journalId === null || journalId === undefined) {
                throw new RequiredError('journalId','Required parameter journalId was null or undefined when calling insightProjectJournalEventGet.');
            }
            // verify required parameter 'eventId' is not null or undefined
            if (eventId === null || eventId === undefined) {
                throw new RequiredError('eventId','Required parameter eventId was null or undefined when calling insightProjectJournalEventGet.');
            }
            const localVarPath = `/insight/{locationId}/project/{projectId}/journal/{journalId}/event/{eventId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"journalId"}}`, encodeURIComponent(String(journalId)))
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List insight/journal.event
         * @summary List insight/journal.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightProjectJournalEventList: async (projectId: string, locationId: string, journalId: string, $limit?: number, $skip?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling insightProjectJournalEventList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling insightProjectJournalEventList.');
            }
            // verify required parameter 'journalId' is not null or undefined
            if (journalId === null || journalId === undefined) {
                throw new RequiredError('journalId','Required parameter journalId was null or undefined when calling insightProjectJournalEventList.');
            }
            const localVarPath = `/insight/{locationId}/project/{projectId}/journal/{journalId}/event`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"journalId"}}`, encodeURIComponent(String(journalId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if ($limit !== undefined) {
                localVarQueryParameter['$limit'] = $limit;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single journal
         * @summary Get insight/journal
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightProjectJournalGet: async (projectId: string, locationId: string, journalId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling insightProjectJournalGet.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling insightProjectJournalGet.');
            }
            // verify required parameter 'journalId' is not null or undefined
            if (journalId === null || journalId === undefined) {
                throw new RequiredError('journalId','Required parameter journalId was null or undefined when calling insightProjectJournalGet.');
            }
            const localVarPath = `/insight/{locationId}/project/{projectId}/journal/{journalId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"journalId"}}`, encodeURIComponent(String(journalId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List journal
         * @summary List insight/journal
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [name] Filter by name
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightProjectJournalList: async (projectId: string, locationId: string, name?: string, tagValue?: string, tagKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling insightProjectJournalList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling insightProjectJournalList.');
            }
            const localVarPath = `/insight/{locationId}/project/{projectId}/journal`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (tagValue !== undefined) {
                localVarQueryParameter['tag.value'] = tagValue;
            }

            if (tagKey !== undefined) {
                localVarQueryParameter['tag.key'] = tagKey;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * websocket is also supported
         * @summary Get insight/journal.log
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {string} [since] since
         * @param {string} [until] until
         * @param {boolean} [follow] follow
         * @param {number} [tail] tail
         * @param {Array<Tag>} [tag] tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightProjectJournalLogGet: async (projectId: string, locationId: string, journalId: string, since?: string, until?: string, follow?: boolean, tail?: number, tag?: Array<Tag>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling insightProjectJournalLogGet.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling insightProjectJournalLogGet.');
            }
            // verify required parameter 'journalId' is not null or undefined
            if (journalId === null || journalId === undefined) {
                throw new RequiredError('journalId','Required parameter journalId was null or undefined when calling insightProjectJournalLogGet.');
            }
            const localVarPath = `/insight/{locationId}/project/{projectId}/journal/{journalId}/log`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"journalId"}}`, encodeURIComponent(String(journalId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (since !== undefined) {
                localVarQueryParameter['since'] = (since as any instanceof Date) ?
                    (since as any).toISOString() :
                    since;
            }

            if (until !== undefined) {
                localVarQueryParameter['until'] = (until as any instanceof Date) ?
                    (until as any).toISOString() :
                    until;
            }

            if (follow !== undefined) {
                localVarQueryParameter['follow'] = follow;
            }

            if (tail !== undefined) {
                localVarQueryParameter['tail'] = tail;
            }

            if (tag) {
                localVarQueryParameter['tag'] = tag;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get insight/journal.service
         * @summary Get insight/journal.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightProjectJournalServiceGet: async (projectId: string, locationId: string, journalId: string, serviceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling insightProjectJournalServiceGet.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling insightProjectJournalServiceGet.');
            }
            // verify required parameter 'journalId' is not null or undefined
            if (journalId === null || journalId === undefined) {
                throw new RequiredError('journalId','Required parameter journalId was null or undefined when calling insightProjectJournalServiceGet.');
            }
            // verify required parameter 'serviceId' is not null or undefined
            if (serviceId === null || serviceId === undefined) {
                throw new RequiredError('serviceId','Required parameter serviceId was null or undefined when calling insightProjectJournalServiceGet.');
            }
            const localVarPath = `/insight/{locationId}/project/{projectId}/journal/{journalId}/service/{serviceId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"journalId"}}`, encodeURIComponent(String(journalId)))
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List insight/journal.service
         * @summary List insight/journal.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightProjectJournalServiceList: async (projectId: string, locationId: string, journalId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling insightProjectJournalServiceList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling insightProjectJournalServiceList.');
            }
            // verify required parameter 'journalId' is not null or undefined
            if (journalId === null || journalId === undefined) {
                throw new RequiredError('journalId','Required parameter journalId was null or undefined when calling insightProjectJournalServiceList.');
            }
            const localVarPath = `/insight/{locationId}/project/{projectId}/journal/{journalId}/service`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"journalId"}}`, encodeURIComponent(String(journalId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create insight/journal.tag
         * @summary Create insight/journal.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightProjectJournalTagCreate: async (projectId: string, locationId: string, journalId: string, tag: Tag, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling insightProjectJournalTagCreate.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling insightProjectJournalTagCreate.');
            }
            // verify required parameter 'journalId' is not null or undefined
            if (journalId === null || journalId === undefined) {
                throw new RequiredError('journalId','Required parameter journalId was null or undefined when calling insightProjectJournalTagCreate.');
            }
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling insightProjectJournalTagCreate.');
            }
            const localVarPath = `/insight/{locationId}/project/{projectId}/journal/{journalId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"journalId"}}`, encodeURIComponent(String(journalId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof tag !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(tag !== undefined ? tag : {}) : (tag || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete insight/journal.tag
         * @summary Delete insight/journal.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightProjectJournalTagDelete: async (projectId: string, locationId: string, journalId: string, tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling insightProjectJournalTagDelete.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling insightProjectJournalTagDelete.');
            }
            // verify required parameter 'journalId' is not null or undefined
            if (journalId === null || journalId === undefined) {
                throw new RequiredError('journalId','Required parameter journalId was null or undefined when calling insightProjectJournalTagDelete.');
            }
            // verify required parameter 'tagId' is not null or undefined
            if (tagId === null || tagId === undefined) {
                throw new RequiredError('tagId','Required parameter tagId was null or undefined when calling insightProjectJournalTagDelete.');
            }
            const localVarPath = `/insight/{locationId}/project/{projectId}/journal/{journalId}/tag/{tagId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"journalId"}}`, encodeURIComponent(String(journalId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get insight/journal.tag
         * @summary Get insight/journal.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightProjectJournalTagGet: async (projectId: string, locationId: string, journalId: string, tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling insightProjectJournalTagGet.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling insightProjectJournalTagGet.');
            }
            // verify required parameter 'journalId' is not null or undefined
            if (journalId === null || journalId === undefined) {
                throw new RequiredError('journalId','Required parameter journalId was null or undefined when calling insightProjectJournalTagGet.');
            }
            // verify required parameter 'tagId' is not null or undefined
            if (tagId === null || tagId === undefined) {
                throw new RequiredError('tagId','Required parameter tagId was null or undefined when calling insightProjectJournalTagGet.');
            }
            const localVarPath = `/insight/{locationId}/project/{projectId}/journal/{journalId}/tag/{tagId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"journalId"}}`, encodeURIComponent(String(journalId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List insight/journal.tag
         * @summary List insight/journal.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightProjectJournalTagList: async (projectId: string, locationId: string, journalId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling insightProjectJournalTagList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling insightProjectJournalTagList.');
            }
            // verify required parameter 'journalId' is not null or undefined
            if (journalId === null || journalId === undefined) {
                throw new RequiredError('journalId','Required parameter journalId was null or undefined when calling insightProjectJournalTagList.');
            }
            const localVarPath = `/insight/{locationId}/project/{projectId}/journal/{journalId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"journalId"}}`, encodeURIComponent(String(journalId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replace insight/journal.tag
         * @summary Replace insight/journal.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightProjectJournalTagPut: async (projectId: string, locationId: string, journalId: string, tag: Array<Tag>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling insightProjectJournalTagPut.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling insightProjectJournalTagPut.');
            }
            // verify required parameter 'journalId' is not null or undefined
            if (journalId === null || journalId === undefined) {
                throw new RequiredError('journalId','Required parameter journalId was null or undefined when calling insightProjectJournalTagPut.');
            }
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling insightProjectJournalTagPut.');
            }
            const localVarPath = `/insight/{locationId}/project/{projectId}/journal/{journalId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"journalId"}}`, encodeURIComponent(String(journalId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof tag !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(tag !== undefined ? tag : {}) : (tag || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * action transfer
         * @summary Transfer insight/journal
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {InsightProjectJournalTransfer} insightProjectJournalTransfer 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightProjectJournalTransfer: async (projectId: string, locationId: string, journalId: string, insightProjectJournalTransfer: InsightProjectJournalTransfer, xIdempotencyKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling insightProjectJournalTransfer.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling insightProjectJournalTransfer.');
            }
            // verify required parameter 'journalId' is not null or undefined
            if (journalId === null || journalId === undefined) {
                throw new RequiredError('journalId','Required parameter journalId was null or undefined when calling insightProjectJournalTransfer.');
            }
            // verify required parameter 'insightProjectJournalTransfer' is not null or undefined
            if (insightProjectJournalTransfer === null || insightProjectJournalTransfer === undefined) {
                throw new RequiredError('insightProjectJournalTransfer','Required parameter insightProjectJournalTransfer was null or undefined when calling insightProjectJournalTransfer.');
            }
            const localVarPath = `/insight/{locationId}/project/{projectId}/journal/{journalId}/actions/transfer`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"journalId"}}`, encodeURIComponent(String(journalId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof insightProjectJournalTransfer !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(insightProjectJournalTransfer !== undefined ? insightProjectJournalTransfer : {}) : (insightProjectJournalTransfer || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns modified journal
         * @summary Update insight/journal
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {InsightProjectJournalUpdate} insightProjectJournalUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightProjectJournalUpdate: async (projectId: string, locationId: string, journalId: string, insightProjectJournalUpdate: InsightProjectJournalUpdate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling insightProjectJournalUpdate.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling insightProjectJournalUpdate.');
            }
            // verify required parameter 'journalId' is not null or undefined
            if (journalId === null || journalId === undefined) {
                throw new RequiredError('journalId','Required parameter journalId was null or undefined when calling insightProjectJournalUpdate.');
            }
            // verify required parameter 'insightProjectJournalUpdate' is not null or undefined
            if (insightProjectJournalUpdate === null || insightProjectJournalUpdate === undefined) {
                throw new RequiredError('insightProjectJournalUpdate','Required parameter insightProjectJournalUpdate was null or undefined when calling insightProjectJournalUpdate.');
            }
            const localVarPath = `/insight/{locationId}/project/{projectId}/journal/{journalId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"journalId"}}`, encodeURIComponent(String(journalId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof insightProjectJournalUpdate !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(insightProjectJournalUpdate !== undefined ? insightProjectJournalUpdate : {}) : (insightProjectJournalUpdate || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InsightProjectJournalApi - functional programming interface
 * @export
 */
export const InsightProjectJournalApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create journal
         * @summary Create insight/journal
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {InsightProjectJournalCreate} insightProjectJournalCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async insightProjectJournalCreate(projectId: string, locationId: string, insightProjectJournalCreate: InsightProjectJournalCreate, xIdempotencyKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Journal>> {
            const localVarAxiosArgs = await InsightProjectJournalApiAxiosParamCreator(configuration).insightProjectJournalCreate(projectId, locationId, insightProjectJournalCreate, xIdempotencyKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create insight/journal.credential
         * @summary Create insight/journal.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {JournalCredential} journalCredential 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async insightProjectJournalCredentialCreate(projectId: string, locationId: string, journalId: string, journalCredential: JournalCredential, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JournalCredential>> {
            const localVarAxiosArgs = await InsightProjectJournalApiAxiosParamCreator(configuration).insightProjectJournalCredentialCreate(projectId, locationId, journalId, journalCredential, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete insight/journal.credential
         * @summary Delete insight/journal.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {string} credentialId credentialId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async insightProjectJournalCredentialDelete(projectId: string, locationId: string, journalId: string, credentialId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Journal>> {
            const localVarAxiosArgs = await InsightProjectJournalApiAxiosParamCreator(configuration).insightProjectJournalCredentialDelete(projectId, locationId, journalId, credentialId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get insight/journal.credential
         * @summary Get insight/journal.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {string} credentialId credentialId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async insightProjectJournalCredentialGet(projectId: string, locationId: string, journalId: string, credentialId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JournalCredential>> {
            const localVarAxiosArgs = await InsightProjectJournalApiAxiosParamCreator(configuration).insightProjectJournalCredentialGet(projectId, locationId, journalId, credentialId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List insight/journal.credential
         * @summary List insight/journal.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async insightProjectJournalCredentialList(projectId: string, locationId: string, journalId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<JournalCredential>>> {
            const localVarAxiosArgs = await InsightProjectJournalApiAxiosParamCreator(configuration).insightProjectJournalCredentialList(projectId, locationId, journalId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update insight/journal.credential
         * @summary Update insight/journal.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {string} credentialId credentialId
         * @param {InsightProjectJournalCredentialPatch} insightProjectJournalCredentialPatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async insightProjectJournalCredentialPatch(projectId: string, locationId: string, journalId: string, credentialId: string, insightProjectJournalCredentialPatch: InsightProjectJournalCredentialPatch, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JournalCredential>> {
            const localVarAxiosArgs = await InsightProjectJournalApiAxiosParamCreator(configuration).insightProjectJournalCredentialPatch(projectId, locationId, journalId, credentialId, insightProjectJournalCredentialPatch, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete journal
         * @summary Delete insight/journal
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async insightProjectJournalDelete(projectId: string, locationId: string, journalId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await InsightProjectJournalApiAxiosParamCreator(configuration).insightProjectJournalDelete(projectId, locationId, journalId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get insight/journal.event
         * @summary Get insight/journal.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async insightProjectJournalEventGet(projectId: string, locationId: string, journalId: string, eventId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>> {
            const localVarAxiosArgs = await InsightProjectJournalApiAxiosParamCreator(configuration).insightProjectJournalEventGet(projectId, locationId, journalId, eventId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List insight/journal.event
         * @summary List insight/journal.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async insightProjectJournalEventList(projectId: string, locationId: string, journalId: string, $limit?: number, $skip?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Event>>> {
            const localVarAxiosArgs = await InsightProjectJournalApiAxiosParamCreator(configuration).insightProjectJournalEventList(projectId, locationId, journalId, $limit, $skip, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a single journal
         * @summary Get insight/journal
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async insightProjectJournalGet(projectId: string, locationId: string, journalId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Journal>> {
            const localVarAxiosArgs = await InsightProjectJournalApiAxiosParamCreator(configuration).insightProjectJournalGet(projectId, locationId, journalId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List journal
         * @summary List insight/journal
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [name] Filter by name
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async insightProjectJournalList(projectId: string, locationId: string, name?: string, tagValue?: string, tagKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Journal>>> {
            const localVarAxiosArgs = await InsightProjectJournalApiAxiosParamCreator(configuration).insightProjectJournalList(projectId, locationId, name, tagValue, tagKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * websocket is also supported
         * @summary Get insight/journal.log
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {string} [since] since
         * @param {string} [until] until
         * @param {boolean} [follow] follow
         * @param {number} [tail] tail
         * @param {Array<Tag>} [tag] tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async insightProjectJournalLogGet(projectId: string, locationId: string, journalId: string, since?: string, until?: string, follow?: boolean, tail?: number, tag?: Array<Tag>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await InsightProjectJournalApiAxiosParamCreator(configuration).insightProjectJournalLogGet(projectId, locationId, journalId, since, until, follow, tail, tag, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get insight/journal.service
         * @summary Get insight/journal.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async insightProjectJournalServiceGet(projectId: string, locationId: string, journalId: string, serviceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceService>> {
            const localVarAxiosArgs = await InsightProjectJournalApiAxiosParamCreator(configuration).insightProjectJournalServiceGet(projectId, locationId, journalId, serviceId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List insight/journal.service
         * @summary List insight/journal.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async insightProjectJournalServiceList(projectId: string, locationId: string, journalId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResourceService>>> {
            const localVarAxiosArgs = await InsightProjectJournalApiAxiosParamCreator(configuration).insightProjectJournalServiceList(projectId, locationId, journalId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create insight/journal.tag
         * @summary Create insight/journal.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async insightProjectJournalTagCreate(projectId: string, locationId: string, journalId: string, tag: Tag, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await InsightProjectJournalApiAxiosParamCreator(configuration).insightProjectJournalTagCreate(projectId, locationId, journalId, tag, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete insight/journal.tag
         * @summary Delete insight/journal.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async insightProjectJournalTagDelete(projectId: string, locationId: string, journalId: string, tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await InsightProjectJournalApiAxiosParamCreator(configuration).insightProjectJournalTagDelete(projectId, locationId, journalId, tagId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get insight/journal.tag
         * @summary Get insight/journal.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async insightProjectJournalTagGet(projectId: string, locationId: string, journalId: string, tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await InsightProjectJournalApiAxiosParamCreator(configuration).insightProjectJournalTagGet(projectId, locationId, journalId, tagId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List insight/journal.tag
         * @summary List insight/journal.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async insightProjectJournalTagList(projectId: string, locationId: string, journalId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await InsightProjectJournalApiAxiosParamCreator(configuration).insightProjectJournalTagList(projectId, locationId, journalId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Replace insight/journal.tag
         * @summary Replace insight/journal.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async insightProjectJournalTagPut(projectId: string, locationId: string, journalId: string, tag: Array<Tag>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await InsightProjectJournalApiAxiosParamCreator(configuration).insightProjectJournalTagPut(projectId, locationId, journalId, tag, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * action transfer
         * @summary Transfer insight/journal
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {InsightProjectJournalTransfer} insightProjectJournalTransfer 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async insightProjectJournalTransfer(projectId: string, locationId: string, journalId: string, insightProjectJournalTransfer: InsightProjectJournalTransfer, xIdempotencyKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Journal>> {
            const localVarAxiosArgs = await InsightProjectJournalApiAxiosParamCreator(configuration).insightProjectJournalTransfer(projectId, locationId, journalId, insightProjectJournalTransfer, xIdempotencyKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns modified journal
         * @summary Update insight/journal
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {InsightProjectJournalUpdate} insightProjectJournalUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async insightProjectJournalUpdate(projectId: string, locationId: string, journalId: string, insightProjectJournalUpdate: InsightProjectJournalUpdate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Journal>> {
            const localVarAxiosArgs = await InsightProjectJournalApiAxiosParamCreator(configuration).insightProjectJournalUpdate(projectId, locationId, journalId, insightProjectJournalUpdate, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * InsightProjectJournalApi - factory interface
 * @export
 */
export const InsightProjectJournalApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Create journal
         * @summary Create insight/journal
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {InsightProjectJournalCreate} insightProjectJournalCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightProjectJournalCreate(projectId: string, locationId: string, insightProjectJournalCreate: InsightProjectJournalCreate, xIdempotencyKey?: string, options?: any): AxiosPromise<Journal> {
            return InsightProjectJournalApiFp(configuration).insightProjectJournalCreate(projectId, locationId, insightProjectJournalCreate, xIdempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Create insight/journal.credential
         * @summary Create insight/journal.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {JournalCredential} journalCredential 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightProjectJournalCredentialCreate(projectId: string, locationId: string, journalId: string, journalCredential: JournalCredential, options?: any): AxiosPromise<JournalCredential> {
            return InsightProjectJournalApiFp(configuration).insightProjectJournalCredentialCreate(projectId, locationId, journalId, journalCredential, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete insight/journal.credential
         * @summary Delete insight/journal.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {string} credentialId credentialId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightProjectJournalCredentialDelete(projectId: string, locationId: string, journalId: string, credentialId: string, options?: any): AxiosPromise<Journal> {
            return InsightProjectJournalApiFp(configuration).insightProjectJournalCredentialDelete(projectId, locationId, journalId, credentialId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get insight/journal.credential
         * @summary Get insight/journal.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {string} credentialId credentialId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightProjectJournalCredentialGet(projectId: string, locationId: string, journalId: string, credentialId: string, options?: any): AxiosPromise<JournalCredential> {
            return InsightProjectJournalApiFp(configuration).insightProjectJournalCredentialGet(projectId, locationId, journalId, credentialId, options).then((request) => request(axios, basePath));
        },
        /**
         * List insight/journal.credential
         * @summary List insight/journal.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightProjectJournalCredentialList(projectId: string, locationId: string, journalId: string, options?: any): AxiosPromise<Array<JournalCredential>> {
            return InsightProjectJournalApiFp(configuration).insightProjectJournalCredentialList(projectId, locationId, journalId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update insight/journal.credential
         * @summary Update insight/journal.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {string} credentialId credentialId
         * @param {InsightProjectJournalCredentialPatch} insightProjectJournalCredentialPatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightProjectJournalCredentialPatch(projectId: string, locationId: string, journalId: string, credentialId: string, insightProjectJournalCredentialPatch: InsightProjectJournalCredentialPatch, options?: any): AxiosPromise<JournalCredential> {
            return InsightProjectJournalApiFp(configuration).insightProjectJournalCredentialPatch(projectId, locationId, journalId, credentialId, insightProjectJournalCredentialPatch, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete journal
         * @summary Delete insight/journal
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightProjectJournalDelete(projectId: string, locationId: string, journalId: string, options?: any): AxiosPromise<void> {
            return InsightProjectJournalApiFp(configuration).insightProjectJournalDelete(projectId, locationId, journalId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get insight/journal.event
         * @summary Get insight/journal.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightProjectJournalEventGet(projectId: string, locationId: string, journalId: string, eventId: string, options?: any): AxiosPromise<Event> {
            return InsightProjectJournalApiFp(configuration).insightProjectJournalEventGet(projectId, locationId, journalId, eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * List insight/journal.event
         * @summary List insight/journal.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightProjectJournalEventList(projectId: string, locationId: string, journalId: string, $limit?: number, $skip?: number, options?: any): AxiosPromise<Array<Event>> {
            return InsightProjectJournalApiFp(configuration).insightProjectJournalEventList(projectId, locationId, journalId, $limit, $skip, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single journal
         * @summary Get insight/journal
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightProjectJournalGet(projectId: string, locationId: string, journalId: string, options?: any): AxiosPromise<Journal> {
            return InsightProjectJournalApiFp(configuration).insightProjectJournalGet(projectId, locationId, journalId, options).then((request) => request(axios, basePath));
        },
        /**
         * List journal
         * @summary List insight/journal
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [name] Filter by name
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightProjectJournalList(projectId: string, locationId: string, name?: string, tagValue?: string, tagKey?: string, options?: any): AxiosPromise<Array<Journal>> {
            return InsightProjectJournalApiFp(configuration).insightProjectJournalList(projectId, locationId, name, tagValue, tagKey, options).then((request) => request(axios, basePath));
        },
        /**
         * websocket is also supported
         * @summary Get insight/journal.log
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {string} [since] since
         * @param {string} [until] until
         * @param {boolean} [follow] follow
         * @param {number} [tail] tail
         * @param {Array<Tag>} [tag] tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightProjectJournalLogGet(projectId: string, locationId: string, journalId: string, since?: string, until?: string, follow?: boolean, tail?: number, tag?: Array<Tag>, options?: any): AxiosPromise<void> {
            return InsightProjectJournalApiFp(configuration).insightProjectJournalLogGet(projectId, locationId, journalId, since, until, follow, tail, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * Get insight/journal.service
         * @summary Get insight/journal.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightProjectJournalServiceGet(projectId: string, locationId: string, journalId: string, serviceId: string, options?: any): AxiosPromise<ResourceService> {
            return InsightProjectJournalApiFp(configuration).insightProjectJournalServiceGet(projectId, locationId, journalId, serviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * List insight/journal.service
         * @summary List insight/journal.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightProjectJournalServiceList(projectId: string, locationId: string, journalId: string, options?: any): AxiosPromise<Array<ResourceService>> {
            return InsightProjectJournalApiFp(configuration).insightProjectJournalServiceList(projectId, locationId, journalId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create insight/journal.tag
         * @summary Create insight/journal.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightProjectJournalTagCreate(projectId: string, locationId: string, journalId: string, tag: Tag, options?: any): AxiosPromise<Tag> {
            return InsightProjectJournalApiFp(configuration).insightProjectJournalTagCreate(projectId, locationId, journalId, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete insight/journal.tag
         * @summary Delete insight/journal.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightProjectJournalTagDelete(projectId: string, locationId: string, journalId: string, tagId: string, options?: any): AxiosPromise<void> {
            return InsightProjectJournalApiFp(configuration).insightProjectJournalTagDelete(projectId, locationId, journalId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get insight/journal.tag
         * @summary Get insight/journal.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightProjectJournalTagGet(projectId: string, locationId: string, journalId: string, tagId: string, options?: any): AxiosPromise<Tag> {
            return InsightProjectJournalApiFp(configuration).insightProjectJournalTagGet(projectId, locationId, journalId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * List insight/journal.tag
         * @summary List insight/journal.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightProjectJournalTagList(projectId: string, locationId: string, journalId: string, options?: any): AxiosPromise<Array<Tag>> {
            return InsightProjectJournalApiFp(configuration).insightProjectJournalTagList(projectId, locationId, journalId, options).then((request) => request(axios, basePath));
        },
        /**
         * Replace insight/journal.tag
         * @summary Replace insight/journal.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightProjectJournalTagPut(projectId: string, locationId: string, journalId: string, tag: Array<Tag>, options?: any): AxiosPromise<Array<Tag>> {
            return InsightProjectJournalApiFp(configuration).insightProjectJournalTagPut(projectId, locationId, journalId, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * action transfer
         * @summary Transfer insight/journal
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {InsightProjectJournalTransfer} insightProjectJournalTransfer 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightProjectJournalTransfer(projectId: string, locationId: string, journalId: string, insightProjectJournalTransfer: InsightProjectJournalTransfer, xIdempotencyKey?: string, options?: any): AxiosPromise<Journal> {
            return InsightProjectJournalApiFp(configuration).insightProjectJournalTransfer(projectId, locationId, journalId, insightProjectJournalTransfer, xIdempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns modified journal
         * @summary Update insight/journal
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {InsightProjectJournalUpdate} insightProjectJournalUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightProjectJournalUpdate(projectId: string, locationId: string, journalId: string, insightProjectJournalUpdate: InsightProjectJournalUpdate, options?: any): AxiosPromise<Journal> {
            return InsightProjectJournalApiFp(configuration).insightProjectJournalUpdate(projectId, locationId, journalId, insightProjectJournalUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InsightProjectJournalApi - object-oriented interface
 * @export
 * @class InsightProjectJournalApi
 * @extends {BaseAPI}
 */
export class InsightProjectJournalApi extends BaseAPI {
    /**
     * Create journal
     * @summary Create insight/journal
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {InsightProjectJournalCreate} insightProjectJournalCreate 
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightProjectJournalApi
     */
    public insightProjectJournalCreate(projectId: string, locationId: string, insightProjectJournalCreate: InsightProjectJournalCreate, xIdempotencyKey?: string, options?: any) {
        return InsightProjectJournalApiFp(this.configuration).insightProjectJournalCreate(projectId, locationId, insightProjectJournalCreate, xIdempotencyKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create insight/journal.credential
     * @summary Create insight/journal.credential
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} journalId Journal Id
     * @param {JournalCredential} journalCredential 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightProjectJournalApi
     */
    public insightProjectJournalCredentialCreate(projectId: string, locationId: string, journalId: string, journalCredential: JournalCredential, options?: any) {
        return InsightProjectJournalApiFp(this.configuration).insightProjectJournalCredentialCreate(projectId, locationId, journalId, journalCredential, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete insight/journal.credential
     * @summary Delete insight/journal.credential
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} journalId Journal Id
     * @param {string} credentialId credentialId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightProjectJournalApi
     */
    public insightProjectJournalCredentialDelete(projectId: string, locationId: string, journalId: string, credentialId: string, options?: any) {
        return InsightProjectJournalApiFp(this.configuration).insightProjectJournalCredentialDelete(projectId, locationId, journalId, credentialId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get insight/journal.credential
     * @summary Get insight/journal.credential
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} journalId Journal Id
     * @param {string} credentialId credentialId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightProjectJournalApi
     */
    public insightProjectJournalCredentialGet(projectId: string, locationId: string, journalId: string, credentialId: string, options?: any) {
        return InsightProjectJournalApiFp(this.configuration).insightProjectJournalCredentialGet(projectId, locationId, journalId, credentialId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List insight/journal.credential
     * @summary List insight/journal.credential
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} journalId Journal Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightProjectJournalApi
     */
    public insightProjectJournalCredentialList(projectId: string, locationId: string, journalId: string, options?: any) {
        return InsightProjectJournalApiFp(this.configuration).insightProjectJournalCredentialList(projectId, locationId, journalId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update insight/journal.credential
     * @summary Update insight/journal.credential
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} journalId Journal Id
     * @param {string} credentialId credentialId
     * @param {InsightProjectJournalCredentialPatch} insightProjectJournalCredentialPatch 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightProjectJournalApi
     */
    public insightProjectJournalCredentialPatch(projectId: string, locationId: string, journalId: string, credentialId: string, insightProjectJournalCredentialPatch: InsightProjectJournalCredentialPatch, options?: any) {
        return InsightProjectJournalApiFp(this.configuration).insightProjectJournalCredentialPatch(projectId, locationId, journalId, credentialId, insightProjectJournalCredentialPatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete journal
     * @summary Delete insight/journal
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} journalId Journal Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightProjectJournalApi
     */
    public insightProjectJournalDelete(projectId: string, locationId: string, journalId: string, options?: any) {
        return InsightProjectJournalApiFp(this.configuration).insightProjectJournalDelete(projectId, locationId, journalId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get insight/journal.event
     * @summary Get insight/journal.event
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} journalId Journal Id
     * @param {string} eventId eventId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightProjectJournalApi
     */
    public insightProjectJournalEventGet(projectId: string, locationId: string, journalId: string, eventId: string, options?: any) {
        return InsightProjectJournalApiFp(this.configuration).insightProjectJournalEventGet(projectId, locationId, journalId, eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List insight/journal.event
     * @summary List insight/journal.event
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} journalId Journal Id
     * @param {number} [$limit] $limit
     * @param {number} [$skip] $skip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightProjectJournalApi
     */
    public insightProjectJournalEventList(projectId: string, locationId: string, journalId: string, $limit?: number, $skip?: number, options?: any) {
        return InsightProjectJournalApiFp(this.configuration).insightProjectJournalEventList(projectId, locationId, journalId, $limit, $skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single journal
     * @summary Get insight/journal
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} journalId Journal Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightProjectJournalApi
     */
    public insightProjectJournalGet(projectId: string, locationId: string, journalId: string, options?: any) {
        return InsightProjectJournalApiFp(this.configuration).insightProjectJournalGet(projectId, locationId, journalId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List journal
     * @summary List insight/journal
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} [name] Filter by name
     * @param {string} [tagValue] Filter by tag.value
     * @param {string} [tagKey] Filter by tag.key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightProjectJournalApi
     */
    public insightProjectJournalList(projectId: string, locationId: string, name?: string, tagValue?: string, tagKey?: string, options?: any) {
        return InsightProjectJournalApiFp(this.configuration).insightProjectJournalList(projectId, locationId, name, tagValue, tagKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * websocket is also supported
     * @summary Get insight/journal.log
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} journalId Journal Id
     * @param {string} [since] since
     * @param {string} [until] until
     * @param {boolean} [follow] follow
     * @param {number} [tail] tail
     * @param {Array<Tag>} [tag] tag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightProjectJournalApi
     */
    public insightProjectJournalLogGet(projectId: string, locationId: string, journalId: string, since?: string, until?: string, follow?: boolean, tail?: number, tag?: Array<Tag>, options?: any) {
        return InsightProjectJournalApiFp(this.configuration).insightProjectJournalLogGet(projectId, locationId, journalId, since, until, follow, tail, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get insight/journal.service
     * @summary Get insight/journal.service
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} journalId Journal Id
     * @param {string} serviceId serviceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightProjectJournalApi
     */
    public insightProjectJournalServiceGet(projectId: string, locationId: string, journalId: string, serviceId: string, options?: any) {
        return InsightProjectJournalApiFp(this.configuration).insightProjectJournalServiceGet(projectId, locationId, journalId, serviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List insight/journal.service
     * @summary List insight/journal.service
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} journalId Journal Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightProjectJournalApi
     */
    public insightProjectJournalServiceList(projectId: string, locationId: string, journalId: string, options?: any) {
        return InsightProjectJournalApiFp(this.configuration).insightProjectJournalServiceList(projectId, locationId, journalId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create insight/journal.tag
     * @summary Create insight/journal.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} journalId Journal Id
     * @param {Tag} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightProjectJournalApi
     */
    public insightProjectJournalTagCreate(projectId: string, locationId: string, journalId: string, tag: Tag, options?: any) {
        return InsightProjectJournalApiFp(this.configuration).insightProjectJournalTagCreate(projectId, locationId, journalId, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete insight/journal.tag
     * @summary Delete insight/journal.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} journalId Journal Id
     * @param {string} tagId tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightProjectJournalApi
     */
    public insightProjectJournalTagDelete(projectId: string, locationId: string, journalId: string, tagId: string, options?: any) {
        return InsightProjectJournalApiFp(this.configuration).insightProjectJournalTagDelete(projectId, locationId, journalId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get insight/journal.tag
     * @summary Get insight/journal.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} journalId Journal Id
     * @param {string} tagId tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightProjectJournalApi
     */
    public insightProjectJournalTagGet(projectId: string, locationId: string, journalId: string, tagId: string, options?: any) {
        return InsightProjectJournalApiFp(this.configuration).insightProjectJournalTagGet(projectId, locationId, journalId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List insight/journal.tag
     * @summary List insight/journal.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} journalId Journal Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightProjectJournalApi
     */
    public insightProjectJournalTagList(projectId: string, locationId: string, journalId: string, options?: any) {
        return InsightProjectJournalApiFp(this.configuration).insightProjectJournalTagList(projectId, locationId, journalId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replace insight/journal.tag
     * @summary Replace insight/journal.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} journalId Journal Id
     * @param {Array<Tag>} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightProjectJournalApi
     */
    public insightProjectJournalTagPut(projectId: string, locationId: string, journalId: string, tag: Array<Tag>, options?: any) {
        return InsightProjectJournalApiFp(this.configuration).insightProjectJournalTagPut(projectId, locationId, journalId, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * action transfer
     * @summary Transfer insight/journal
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} journalId Journal Id
     * @param {InsightProjectJournalTransfer} insightProjectJournalTransfer 
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightProjectJournalApi
     */
    public insightProjectJournalTransfer(projectId: string, locationId: string, journalId: string, insightProjectJournalTransfer: InsightProjectJournalTransfer, xIdempotencyKey?: string, options?: any) {
        return InsightProjectJournalApiFp(this.configuration).insightProjectJournalTransfer(projectId, locationId, journalId, insightProjectJournalTransfer, xIdempotencyKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns modified journal
     * @summary Update insight/journal
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} journalId Journal Id
     * @param {InsightProjectJournalUpdate} insightProjectJournalUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightProjectJournalApi
     */
    public insightProjectJournalUpdate(projectId: string, locationId: string, journalId: string, insightProjectJournalUpdate: InsightProjectJournalUpdate, options?: any) {
        return InsightProjectJournalApiFp(this.configuration).insightProjectJournalUpdate(projectId, locationId, journalId, insightProjectJournalUpdate, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * NetworkingProjectFirewallApi - axios parameter creator
 * @export
 */
export const NetworkingProjectFirewallApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create firewall
         * @summary Create networking/firewall
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {NetworkingProjectFirewallCreate} networkingProjectFirewallCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectFirewallCreate: async (projectId: string, locationId: string, networkingProjectFirewallCreate: NetworkingProjectFirewallCreate, xIdempotencyKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling networkingProjectFirewallCreate.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling networkingProjectFirewallCreate.');
            }
            // verify required parameter 'networkingProjectFirewallCreate' is not null or undefined
            if (networkingProjectFirewallCreate === null || networkingProjectFirewallCreate === undefined) {
                throw new RequiredError('networkingProjectFirewallCreate','Required parameter networkingProjectFirewallCreate was null or undefined when calling networkingProjectFirewallCreate.');
            }
            const localVarPath = `/networking/{locationId}/project/{projectId}/firewall`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof networkingProjectFirewallCreate !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(networkingProjectFirewallCreate !== undefined ? networkingProjectFirewallCreate : {}) : (networkingProjectFirewallCreate || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete firewall
         * @summary Delete networking/firewall
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectFirewallDelete: async (projectId: string, locationId: string, firewallId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling networkingProjectFirewallDelete.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling networkingProjectFirewallDelete.');
            }
            // verify required parameter 'firewallId' is not null or undefined
            if (firewallId === null || firewallId === undefined) {
                throw new RequiredError('firewallId','Required parameter firewallId was null or undefined when calling networkingProjectFirewallDelete.');
            }
            const localVarPath = `/networking/{locationId}/project/{projectId}/firewall/{firewallId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"firewallId"}}`, encodeURIComponent(String(firewallId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create networking/firewall.egress
         * @summary Create networking/firewall.egress
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {NetworkingRule} networkingRule 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectFirewallEgressCreate: async (projectId: string, locationId: string, firewallId: string, networkingRule: NetworkingRule, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling networkingProjectFirewallEgressCreate.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling networkingProjectFirewallEgressCreate.');
            }
            // verify required parameter 'firewallId' is not null or undefined
            if (firewallId === null || firewallId === undefined) {
                throw new RequiredError('firewallId','Required parameter firewallId was null or undefined when calling networkingProjectFirewallEgressCreate.');
            }
            // verify required parameter 'networkingRule' is not null or undefined
            if (networkingRule === null || networkingRule === undefined) {
                throw new RequiredError('networkingRule','Required parameter networkingRule was null or undefined when calling networkingProjectFirewallEgressCreate.');
            }
            const localVarPath = `/networking/{locationId}/project/{projectId}/firewall/{firewallId}/egress`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"firewallId"}}`, encodeURIComponent(String(firewallId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof networkingRule !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(networkingRule !== undefined ? networkingRule : {}) : (networkingRule || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete networking/firewall.egress
         * @summary Delete networking/firewall.egress
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {string} egressId egressId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectFirewallEgressDelete: async (projectId: string, locationId: string, firewallId: string, egressId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling networkingProjectFirewallEgressDelete.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling networkingProjectFirewallEgressDelete.');
            }
            // verify required parameter 'firewallId' is not null or undefined
            if (firewallId === null || firewallId === undefined) {
                throw new RequiredError('firewallId','Required parameter firewallId was null or undefined when calling networkingProjectFirewallEgressDelete.');
            }
            // verify required parameter 'egressId' is not null or undefined
            if (egressId === null || egressId === undefined) {
                throw new RequiredError('egressId','Required parameter egressId was null or undefined when calling networkingProjectFirewallEgressDelete.');
            }
            const localVarPath = `/networking/{locationId}/project/{projectId}/firewall/{firewallId}/egress/{egressId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"firewallId"}}`, encodeURIComponent(String(firewallId)))
                .replace(`{${"egressId"}}`, encodeURIComponent(String(egressId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get networking/firewall.egress
         * @summary Get networking/firewall.egress
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {string} egressId egressId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectFirewallEgressGet: async (projectId: string, locationId: string, firewallId: string, egressId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling networkingProjectFirewallEgressGet.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling networkingProjectFirewallEgressGet.');
            }
            // verify required parameter 'firewallId' is not null or undefined
            if (firewallId === null || firewallId === undefined) {
                throw new RequiredError('firewallId','Required parameter firewallId was null or undefined when calling networkingProjectFirewallEgressGet.');
            }
            // verify required parameter 'egressId' is not null or undefined
            if (egressId === null || egressId === undefined) {
                throw new RequiredError('egressId','Required parameter egressId was null or undefined when calling networkingProjectFirewallEgressGet.');
            }
            const localVarPath = `/networking/{locationId}/project/{projectId}/firewall/{firewallId}/egress/{egressId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"firewallId"}}`, encodeURIComponent(String(firewallId)))
                .replace(`{${"egressId"}}`, encodeURIComponent(String(egressId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List networking/firewall.egress
         * @summary List networking/firewall.egress
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectFirewallEgressList: async (projectId: string, locationId: string, firewallId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling networkingProjectFirewallEgressList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling networkingProjectFirewallEgressList.');
            }
            // verify required parameter 'firewallId' is not null or undefined
            if (firewallId === null || firewallId === undefined) {
                throw new RequiredError('firewallId','Required parameter firewallId was null or undefined when calling networkingProjectFirewallEgressList.');
            }
            const localVarPath = `/networking/{locationId}/project/{projectId}/firewall/{firewallId}/egress`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"firewallId"}}`, encodeURIComponent(String(firewallId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replace networking/firewall.egress
         * @summary Replace networking/firewall.egress
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {Array<NetworkingRule>} networkingRule 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectFirewallEgressPut: async (projectId: string, locationId: string, firewallId: string, networkingRule: Array<NetworkingRule>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling networkingProjectFirewallEgressPut.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling networkingProjectFirewallEgressPut.');
            }
            // verify required parameter 'firewallId' is not null or undefined
            if (firewallId === null || firewallId === undefined) {
                throw new RequiredError('firewallId','Required parameter firewallId was null or undefined when calling networkingProjectFirewallEgressPut.');
            }
            // verify required parameter 'networkingRule' is not null or undefined
            if (networkingRule === null || networkingRule === undefined) {
                throw new RequiredError('networkingRule','Required parameter networkingRule was null or undefined when calling networkingProjectFirewallEgressPut.');
            }
            const localVarPath = `/networking/{locationId}/project/{projectId}/firewall/{firewallId}/egress`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"firewallId"}}`, encodeURIComponent(String(firewallId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof networkingRule !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(networkingRule !== undefined ? networkingRule : {}) : (networkingRule || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get networking/firewall.event
         * @summary Get networking/firewall.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectFirewallEventGet: async (projectId: string, locationId: string, firewallId: string, eventId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling networkingProjectFirewallEventGet.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling networkingProjectFirewallEventGet.');
            }
            // verify required parameter 'firewallId' is not null or undefined
            if (firewallId === null || firewallId === undefined) {
                throw new RequiredError('firewallId','Required parameter firewallId was null or undefined when calling networkingProjectFirewallEventGet.');
            }
            // verify required parameter 'eventId' is not null or undefined
            if (eventId === null || eventId === undefined) {
                throw new RequiredError('eventId','Required parameter eventId was null or undefined when calling networkingProjectFirewallEventGet.');
            }
            const localVarPath = `/networking/{locationId}/project/{projectId}/firewall/{firewallId}/event/{eventId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"firewallId"}}`, encodeURIComponent(String(firewallId)))
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List networking/firewall.event
         * @summary List networking/firewall.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectFirewallEventList: async (projectId: string, locationId: string, firewallId: string, $limit?: number, $skip?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling networkingProjectFirewallEventList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling networkingProjectFirewallEventList.');
            }
            // verify required parameter 'firewallId' is not null or undefined
            if (firewallId === null || firewallId === undefined) {
                throw new RequiredError('firewallId','Required parameter firewallId was null or undefined when calling networkingProjectFirewallEventList.');
            }
            const localVarPath = `/networking/{locationId}/project/{projectId}/firewall/{firewallId}/event`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"firewallId"}}`, encodeURIComponent(String(firewallId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if ($limit !== undefined) {
                localVarQueryParameter['$limit'] = $limit;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single firewall
         * @summary Get networking/firewall
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectFirewallGet: async (projectId: string, locationId: string, firewallId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling networkingProjectFirewallGet.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling networkingProjectFirewallGet.');
            }
            // verify required parameter 'firewallId' is not null or undefined
            if (firewallId === null || firewallId === undefined) {
                throw new RequiredError('firewallId','Required parameter firewallId was null or undefined when calling networkingProjectFirewallGet.');
            }
            const localVarPath = `/networking/{locationId}/project/{projectId}/firewall/{firewallId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"firewallId"}}`, encodeURIComponent(String(firewallId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create networking/firewall.ingress
         * @summary Create networking/firewall.ingress
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {NetworkingRule} networkingRule 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectFirewallIngressCreate: async (projectId: string, locationId: string, firewallId: string, networkingRule: NetworkingRule, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling networkingProjectFirewallIngressCreate.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling networkingProjectFirewallIngressCreate.');
            }
            // verify required parameter 'firewallId' is not null or undefined
            if (firewallId === null || firewallId === undefined) {
                throw new RequiredError('firewallId','Required parameter firewallId was null or undefined when calling networkingProjectFirewallIngressCreate.');
            }
            // verify required parameter 'networkingRule' is not null or undefined
            if (networkingRule === null || networkingRule === undefined) {
                throw new RequiredError('networkingRule','Required parameter networkingRule was null or undefined when calling networkingProjectFirewallIngressCreate.');
            }
            const localVarPath = `/networking/{locationId}/project/{projectId}/firewall/{firewallId}/ingress`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"firewallId"}}`, encodeURIComponent(String(firewallId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof networkingRule !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(networkingRule !== undefined ? networkingRule : {}) : (networkingRule || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete networking/firewall.ingress
         * @summary Delete networking/firewall.ingress
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {string} ingressId ingressId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectFirewallIngressDelete: async (projectId: string, locationId: string, firewallId: string, ingressId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling networkingProjectFirewallIngressDelete.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling networkingProjectFirewallIngressDelete.');
            }
            // verify required parameter 'firewallId' is not null or undefined
            if (firewallId === null || firewallId === undefined) {
                throw new RequiredError('firewallId','Required parameter firewallId was null or undefined when calling networkingProjectFirewallIngressDelete.');
            }
            // verify required parameter 'ingressId' is not null or undefined
            if (ingressId === null || ingressId === undefined) {
                throw new RequiredError('ingressId','Required parameter ingressId was null or undefined when calling networkingProjectFirewallIngressDelete.');
            }
            const localVarPath = `/networking/{locationId}/project/{projectId}/firewall/{firewallId}/ingress/{ingressId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"firewallId"}}`, encodeURIComponent(String(firewallId)))
                .replace(`{${"ingressId"}}`, encodeURIComponent(String(ingressId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get networking/firewall.ingress
         * @summary Get networking/firewall.ingress
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {string} ingressId ingressId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectFirewallIngressGet: async (projectId: string, locationId: string, firewallId: string, ingressId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling networkingProjectFirewallIngressGet.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling networkingProjectFirewallIngressGet.');
            }
            // verify required parameter 'firewallId' is not null or undefined
            if (firewallId === null || firewallId === undefined) {
                throw new RequiredError('firewallId','Required parameter firewallId was null or undefined when calling networkingProjectFirewallIngressGet.');
            }
            // verify required parameter 'ingressId' is not null or undefined
            if (ingressId === null || ingressId === undefined) {
                throw new RequiredError('ingressId','Required parameter ingressId was null or undefined when calling networkingProjectFirewallIngressGet.');
            }
            const localVarPath = `/networking/{locationId}/project/{projectId}/firewall/{firewallId}/ingress/{ingressId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"firewallId"}}`, encodeURIComponent(String(firewallId)))
                .replace(`{${"ingressId"}}`, encodeURIComponent(String(ingressId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List networking/firewall.ingress
         * @summary List networking/firewall.ingress
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectFirewallIngressList: async (projectId: string, locationId: string, firewallId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling networkingProjectFirewallIngressList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling networkingProjectFirewallIngressList.');
            }
            // verify required parameter 'firewallId' is not null or undefined
            if (firewallId === null || firewallId === undefined) {
                throw new RequiredError('firewallId','Required parameter firewallId was null or undefined when calling networkingProjectFirewallIngressList.');
            }
            const localVarPath = `/networking/{locationId}/project/{projectId}/firewall/{firewallId}/ingress`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"firewallId"}}`, encodeURIComponent(String(firewallId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replace networking/firewall.ingress
         * @summary Replace networking/firewall.ingress
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {Array<NetworkingRule>} networkingRule 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectFirewallIngressPut: async (projectId: string, locationId: string, firewallId: string, networkingRule: Array<NetworkingRule>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling networkingProjectFirewallIngressPut.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling networkingProjectFirewallIngressPut.');
            }
            // verify required parameter 'firewallId' is not null or undefined
            if (firewallId === null || firewallId === undefined) {
                throw new RequiredError('firewallId','Required parameter firewallId was null or undefined when calling networkingProjectFirewallIngressPut.');
            }
            // verify required parameter 'networkingRule' is not null or undefined
            if (networkingRule === null || networkingRule === undefined) {
                throw new RequiredError('networkingRule','Required parameter networkingRule was null or undefined when calling networkingProjectFirewallIngressPut.');
            }
            const localVarPath = `/networking/{locationId}/project/{projectId}/firewall/{firewallId}/ingress`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"firewallId"}}`, encodeURIComponent(String(firewallId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof networkingRule !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(networkingRule !== undefined ? networkingRule : {}) : (networkingRule || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List firewall
         * @summary List networking/firewall
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [name] Filter by name
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectFirewallList: async (projectId: string, locationId: string, name?: string, tagValue?: string, tagKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling networkingProjectFirewallList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling networkingProjectFirewallList.');
            }
            const localVarPath = `/networking/{locationId}/project/{projectId}/firewall`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (tagValue !== undefined) {
                localVarQueryParameter['tag.value'] = tagValue;
            }

            if (tagKey !== undefined) {
                localVarQueryParameter['tag.key'] = tagKey;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get networking/firewall.service
         * @summary Get networking/firewall.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectFirewallServiceGet: async (projectId: string, locationId: string, firewallId: string, serviceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling networkingProjectFirewallServiceGet.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling networkingProjectFirewallServiceGet.');
            }
            // verify required parameter 'firewallId' is not null or undefined
            if (firewallId === null || firewallId === undefined) {
                throw new RequiredError('firewallId','Required parameter firewallId was null or undefined when calling networkingProjectFirewallServiceGet.');
            }
            // verify required parameter 'serviceId' is not null or undefined
            if (serviceId === null || serviceId === undefined) {
                throw new RequiredError('serviceId','Required parameter serviceId was null or undefined when calling networkingProjectFirewallServiceGet.');
            }
            const localVarPath = `/networking/{locationId}/project/{projectId}/firewall/{firewallId}/service/{serviceId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"firewallId"}}`, encodeURIComponent(String(firewallId)))
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List networking/firewall.service
         * @summary List networking/firewall.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectFirewallServiceList: async (projectId: string, locationId: string, firewallId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling networkingProjectFirewallServiceList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling networkingProjectFirewallServiceList.');
            }
            // verify required parameter 'firewallId' is not null or undefined
            if (firewallId === null || firewallId === undefined) {
                throw new RequiredError('firewallId','Required parameter firewallId was null or undefined when calling networkingProjectFirewallServiceList.');
            }
            const localVarPath = `/networking/{locationId}/project/{projectId}/firewall/{firewallId}/service`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"firewallId"}}`, encodeURIComponent(String(firewallId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create networking/firewall.tag
         * @summary Create networking/firewall.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectFirewallTagCreate: async (projectId: string, locationId: string, firewallId: string, tag: Tag, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling networkingProjectFirewallTagCreate.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling networkingProjectFirewallTagCreate.');
            }
            // verify required parameter 'firewallId' is not null or undefined
            if (firewallId === null || firewallId === undefined) {
                throw new RequiredError('firewallId','Required parameter firewallId was null or undefined when calling networkingProjectFirewallTagCreate.');
            }
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling networkingProjectFirewallTagCreate.');
            }
            const localVarPath = `/networking/{locationId}/project/{projectId}/firewall/{firewallId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"firewallId"}}`, encodeURIComponent(String(firewallId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof tag !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(tag !== undefined ? tag : {}) : (tag || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete networking/firewall.tag
         * @summary Delete networking/firewall.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectFirewallTagDelete: async (projectId: string, locationId: string, firewallId: string, tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling networkingProjectFirewallTagDelete.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling networkingProjectFirewallTagDelete.');
            }
            // verify required parameter 'firewallId' is not null or undefined
            if (firewallId === null || firewallId === undefined) {
                throw new RequiredError('firewallId','Required parameter firewallId was null or undefined when calling networkingProjectFirewallTagDelete.');
            }
            // verify required parameter 'tagId' is not null or undefined
            if (tagId === null || tagId === undefined) {
                throw new RequiredError('tagId','Required parameter tagId was null or undefined when calling networkingProjectFirewallTagDelete.');
            }
            const localVarPath = `/networking/{locationId}/project/{projectId}/firewall/{firewallId}/tag/{tagId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"firewallId"}}`, encodeURIComponent(String(firewallId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get networking/firewall.tag
         * @summary Get networking/firewall.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectFirewallTagGet: async (projectId: string, locationId: string, firewallId: string, tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling networkingProjectFirewallTagGet.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling networkingProjectFirewallTagGet.');
            }
            // verify required parameter 'firewallId' is not null or undefined
            if (firewallId === null || firewallId === undefined) {
                throw new RequiredError('firewallId','Required parameter firewallId was null or undefined when calling networkingProjectFirewallTagGet.');
            }
            // verify required parameter 'tagId' is not null or undefined
            if (tagId === null || tagId === undefined) {
                throw new RequiredError('tagId','Required parameter tagId was null or undefined when calling networkingProjectFirewallTagGet.');
            }
            const localVarPath = `/networking/{locationId}/project/{projectId}/firewall/{firewallId}/tag/{tagId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"firewallId"}}`, encodeURIComponent(String(firewallId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List networking/firewall.tag
         * @summary List networking/firewall.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectFirewallTagList: async (projectId: string, locationId: string, firewallId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling networkingProjectFirewallTagList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling networkingProjectFirewallTagList.');
            }
            // verify required parameter 'firewallId' is not null or undefined
            if (firewallId === null || firewallId === undefined) {
                throw new RequiredError('firewallId','Required parameter firewallId was null or undefined when calling networkingProjectFirewallTagList.');
            }
            const localVarPath = `/networking/{locationId}/project/{projectId}/firewall/{firewallId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"firewallId"}}`, encodeURIComponent(String(firewallId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replace networking/firewall.tag
         * @summary Replace networking/firewall.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectFirewallTagPut: async (projectId: string, locationId: string, firewallId: string, tag: Array<Tag>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling networkingProjectFirewallTagPut.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling networkingProjectFirewallTagPut.');
            }
            // verify required parameter 'firewallId' is not null or undefined
            if (firewallId === null || firewallId === undefined) {
                throw new RequiredError('firewallId','Required parameter firewallId was null or undefined when calling networkingProjectFirewallTagPut.');
            }
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling networkingProjectFirewallTagPut.');
            }
            const localVarPath = `/networking/{locationId}/project/{projectId}/firewall/{firewallId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"firewallId"}}`, encodeURIComponent(String(firewallId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof tag !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(tag !== undefined ? tag : {}) : (tag || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * action transfer
         * @summary Transfer networking/firewall
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {NetworkingProjectFirewallTransfer} networkingProjectFirewallTransfer 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectFirewallTransfer: async (projectId: string, locationId: string, firewallId: string, networkingProjectFirewallTransfer: NetworkingProjectFirewallTransfer, xIdempotencyKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling networkingProjectFirewallTransfer.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling networkingProjectFirewallTransfer.');
            }
            // verify required parameter 'firewallId' is not null or undefined
            if (firewallId === null || firewallId === undefined) {
                throw new RequiredError('firewallId','Required parameter firewallId was null or undefined when calling networkingProjectFirewallTransfer.');
            }
            // verify required parameter 'networkingProjectFirewallTransfer' is not null or undefined
            if (networkingProjectFirewallTransfer === null || networkingProjectFirewallTransfer === undefined) {
                throw new RequiredError('networkingProjectFirewallTransfer','Required parameter networkingProjectFirewallTransfer was null or undefined when calling networkingProjectFirewallTransfer.');
            }
            const localVarPath = `/networking/{locationId}/project/{projectId}/firewall/{firewallId}/actions/transfer`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"firewallId"}}`, encodeURIComponent(String(firewallId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof networkingProjectFirewallTransfer !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(networkingProjectFirewallTransfer !== undefined ? networkingProjectFirewallTransfer : {}) : (networkingProjectFirewallTransfer || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns modified firewall
         * @summary Update networking/firewall
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {NetworkingProjectFirewallUpdate} networkingProjectFirewallUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectFirewallUpdate: async (projectId: string, locationId: string, firewallId: string, networkingProjectFirewallUpdate: NetworkingProjectFirewallUpdate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling networkingProjectFirewallUpdate.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling networkingProjectFirewallUpdate.');
            }
            // verify required parameter 'firewallId' is not null or undefined
            if (firewallId === null || firewallId === undefined) {
                throw new RequiredError('firewallId','Required parameter firewallId was null or undefined when calling networkingProjectFirewallUpdate.');
            }
            // verify required parameter 'networkingProjectFirewallUpdate' is not null or undefined
            if (networkingProjectFirewallUpdate === null || networkingProjectFirewallUpdate === undefined) {
                throw new RequiredError('networkingProjectFirewallUpdate','Required parameter networkingProjectFirewallUpdate was null or undefined when calling networkingProjectFirewallUpdate.');
            }
            const localVarPath = `/networking/{locationId}/project/{projectId}/firewall/{firewallId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"firewallId"}}`, encodeURIComponent(String(firewallId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof networkingProjectFirewallUpdate !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(networkingProjectFirewallUpdate !== undefined ? networkingProjectFirewallUpdate : {}) : (networkingProjectFirewallUpdate || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NetworkingProjectFirewallApi - functional programming interface
 * @export
 */
export const NetworkingProjectFirewallApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create firewall
         * @summary Create networking/firewall
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {NetworkingProjectFirewallCreate} networkingProjectFirewallCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectFirewallCreate(projectId: string, locationId: string, networkingProjectFirewallCreate: NetworkingProjectFirewallCreate, xIdempotencyKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Firewall>> {
            const localVarAxiosArgs = await NetworkingProjectFirewallApiAxiosParamCreator(configuration).networkingProjectFirewallCreate(projectId, locationId, networkingProjectFirewallCreate, xIdempotencyKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete firewall
         * @summary Delete networking/firewall
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectFirewallDelete(projectId: string, locationId: string, firewallId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await NetworkingProjectFirewallApiAxiosParamCreator(configuration).networkingProjectFirewallDelete(projectId, locationId, firewallId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create networking/firewall.egress
         * @summary Create networking/firewall.egress
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {NetworkingRule} networkingRule 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectFirewallEgressCreate(projectId: string, locationId: string, firewallId: string, networkingRule: NetworkingRule, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NetworkingRule>> {
            const localVarAxiosArgs = await NetworkingProjectFirewallApiAxiosParamCreator(configuration).networkingProjectFirewallEgressCreate(projectId, locationId, firewallId, networkingRule, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete networking/firewall.egress
         * @summary Delete networking/firewall.egress
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {string} egressId egressId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectFirewallEgressDelete(projectId: string, locationId: string, firewallId: string, egressId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await NetworkingProjectFirewallApiAxiosParamCreator(configuration).networkingProjectFirewallEgressDelete(projectId, locationId, firewallId, egressId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get networking/firewall.egress
         * @summary Get networking/firewall.egress
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {string} egressId egressId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectFirewallEgressGet(projectId: string, locationId: string, firewallId: string, egressId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NetworkingRule>> {
            const localVarAxiosArgs = await NetworkingProjectFirewallApiAxiosParamCreator(configuration).networkingProjectFirewallEgressGet(projectId, locationId, firewallId, egressId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List networking/firewall.egress
         * @summary List networking/firewall.egress
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectFirewallEgressList(projectId: string, locationId: string, firewallId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NetworkingRule>>> {
            const localVarAxiosArgs = await NetworkingProjectFirewallApiAxiosParamCreator(configuration).networkingProjectFirewallEgressList(projectId, locationId, firewallId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Replace networking/firewall.egress
         * @summary Replace networking/firewall.egress
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {Array<NetworkingRule>} networkingRule 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectFirewallEgressPut(projectId: string, locationId: string, firewallId: string, networkingRule: Array<NetworkingRule>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NetworkingRule>>> {
            const localVarAxiosArgs = await NetworkingProjectFirewallApiAxiosParamCreator(configuration).networkingProjectFirewallEgressPut(projectId, locationId, firewallId, networkingRule, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get networking/firewall.event
         * @summary Get networking/firewall.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectFirewallEventGet(projectId: string, locationId: string, firewallId: string, eventId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>> {
            const localVarAxiosArgs = await NetworkingProjectFirewallApiAxiosParamCreator(configuration).networkingProjectFirewallEventGet(projectId, locationId, firewallId, eventId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List networking/firewall.event
         * @summary List networking/firewall.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectFirewallEventList(projectId: string, locationId: string, firewallId: string, $limit?: number, $skip?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Event>>> {
            const localVarAxiosArgs = await NetworkingProjectFirewallApiAxiosParamCreator(configuration).networkingProjectFirewallEventList(projectId, locationId, firewallId, $limit, $skip, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a single firewall
         * @summary Get networking/firewall
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectFirewallGet(projectId: string, locationId: string, firewallId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Firewall>> {
            const localVarAxiosArgs = await NetworkingProjectFirewallApiAxiosParamCreator(configuration).networkingProjectFirewallGet(projectId, locationId, firewallId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create networking/firewall.ingress
         * @summary Create networking/firewall.ingress
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {NetworkingRule} networkingRule 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectFirewallIngressCreate(projectId: string, locationId: string, firewallId: string, networkingRule: NetworkingRule, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NetworkingRule>> {
            const localVarAxiosArgs = await NetworkingProjectFirewallApiAxiosParamCreator(configuration).networkingProjectFirewallIngressCreate(projectId, locationId, firewallId, networkingRule, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete networking/firewall.ingress
         * @summary Delete networking/firewall.ingress
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {string} ingressId ingressId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectFirewallIngressDelete(projectId: string, locationId: string, firewallId: string, ingressId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await NetworkingProjectFirewallApiAxiosParamCreator(configuration).networkingProjectFirewallIngressDelete(projectId, locationId, firewallId, ingressId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get networking/firewall.ingress
         * @summary Get networking/firewall.ingress
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {string} ingressId ingressId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectFirewallIngressGet(projectId: string, locationId: string, firewallId: string, ingressId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NetworkingRule>> {
            const localVarAxiosArgs = await NetworkingProjectFirewallApiAxiosParamCreator(configuration).networkingProjectFirewallIngressGet(projectId, locationId, firewallId, ingressId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List networking/firewall.ingress
         * @summary List networking/firewall.ingress
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectFirewallIngressList(projectId: string, locationId: string, firewallId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NetworkingRule>>> {
            const localVarAxiosArgs = await NetworkingProjectFirewallApiAxiosParamCreator(configuration).networkingProjectFirewallIngressList(projectId, locationId, firewallId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Replace networking/firewall.ingress
         * @summary Replace networking/firewall.ingress
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {Array<NetworkingRule>} networkingRule 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectFirewallIngressPut(projectId: string, locationId: string, firewallId: string, networkingRule: Array<NetworkingRule>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NetworkingRule>>> {
            const localVarAxiosArgs = await NetworkingProjectFirewallApiAxiosParamCreator(configuration).networkingProjectFirewallIngressPut(projectId, locationId, firewallId, networkingRule, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List firewall
         * @summary List networking/firewall
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [name] Filter by name
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectFirewallList(projectId: string, locationId: string, name?: string, tagValue?: string, tagKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Firewall>>> {
            const localVarAxiosArgs = await NetworkingProjectFirewallApiAxiosParamCreator(configuration).networkingProjectFirewallList(projectId, locationId, name, tagValue, tagKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get networking/firewall.service
         * @summary Get networking/firewall.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectFirewallServiceGet(projectId: string, locationId: string, firewallId: string, serviceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceService>> {
            const localVarAxiosArgs = await NetworkingProjectFirewallApiAxiosParamCreator(configuration).networkingProjectFirewallServiceGet(projectId, locationId, firewallId, serviceId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List networking/firewall.service
         * @summary List networking/firewall.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectFirewallServiceList(projectId: string, locationId: string, firewallId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResourceService>>> {
            const localVarAxiosArgs = await NetworkingProjectFirewallApiAxiosParamCreator(configuration).networkingProjectFirewallServiceList(projectId, locationId, firewallId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create networking/firewall.tag
         * @summary Create networking/firewall.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectFirewallTagCreate(projectId: string, locationId: string, firewallId: string, tag: Tag, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await NetworkingProjectFirewallApiAxiosParamCreator(configuration).networkingProjectFirewallTagCreate(projectId, locationId, firewallId, tag, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete networking/firewall.tag
         * @summary Delete networking/firewall.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectFirewallTagDelete(projectId: string, locationId: string, firewallId: string, tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await NetworkingProjectFirewallApiAxiosParamCreator(configuration).networkingProjectFirewallTagDelete(projectId, locationId, firewallId, tagId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get networking/firewall.tag
         * @summary Get networking/firewall.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectFirewallTagGet(projectId: string, locationId: string, firewallId: string, tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await NetworkingProjectFirewallApiAxiosParamCreator(configuration).networkingProjectFirewallTagGet(projectId, locationId, firewallId, tagId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List networking/firewall.tag
         * @summary List networking/firewall.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectFirewallTagList(projectId: string, locationId: string, firewallId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await NetworkingProjectFirewallApiAxiosParamCreator(configuration).networkingProjectFirewallTagList(projectId, locationId, firewallId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Replace networking/firewall.tag
         * @summary Replace networking/firewall.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectFirewallTagPut(projectId: string, locationId: string, firewallId: string, tag: Array<Tag>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await NetworkingProjectFirewallApiAxiosParamCreator(configuration).networkingProjectFirewallTagPut(projectId, locationId, firewallId, tag, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * action transfer
         * @summary Transfer networking/firewall
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {NetworkingProjectFirewallTransfer} networkingProjectFirewallTransfer 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectFirewallTransfer(projectId: string, locationId: string, firewallId: string, networkingProjectFirewallTransfer: NetworkingProjectFirewallTransfer, xIdempotencyKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Firewall>> {
            const localVarAxiosArgs = await NetworkingProjectFirewallApiAxiosParamCreator(configuration).networkingProjectFirewallTransfer(projectId, locationId, firewallId, networkingProjectFirewallTransfer, xIdempotencyKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns modified firewall
         * @summary Update networking/firewall
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {NetworkingProjectFirewallUpdate} networkingProjectFirewallUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectFirewallUpdate(projectId: string, locationId: string, firewallId: string, networkingProjectFirewallUpdate: NetworkingProjectFirewallUpdate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Firewall>> {
            const localVarAxiosArgs = await NetworkingProjectFirewallApiAxiosParamCreator(configuration).networkingProjectFirewallUpdate(projectId, locationId, firewallId, networkingProjectFirewallUpdate, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * NetworkingProjectFirewallApi - factory interface
 * @export
 */
export const NetworkingProjectFirewallApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Create firewall
         * @summary Create networking/firewall
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {NetworkingProjectFirewallCreate} networkingProjectFirewallCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectFirewallCreate(projectId: string, locationId: string, networkingProjectFirewallCreate: NetworkingProjectFirewallCreate, xIdempotencyKey?: string, options?: any): AxiosPromise<Firewall> {
            return NetworkingProjectFirewallApiFp(configuration).networkingProjectFirewallCreate(projectId, locationId, networkingProjectFirewallCreate, xIdempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete firewall
         * @summary Delete networking/firewall
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectFirewallDelete(projectId: string, locationId: string, firewallId: string, options?: any): AxiosPromise<void> {
            return NetworkingProjectFirewallApiFp(configuration).networkingProjectFirewallDelete(projectId, locationId, firewallId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create networking/firewall.egress
         * @summary Create networking/firewall.egress
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {NetworkingRule} networkingRule 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectFirewallEgressCreate(projectId: string, locationId: string, firewallId: string, networkingRule: NetworkingRule, options?: any): AxiosPromise<NetworkingRule> {
            return NetworkingProjectFirewallApiFp(configuration).networkingProjectFirewallEgressCreate(projectId, locationId, firewallId, networkingRule, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete networking/firewall.egress
         * @summary Delete networking/firewall.egress
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {string} egressId egressId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectFirewallEgressDelete(projectId: string, locationId: string, firewallId: string, egressId: string, options?: any): AxiosPromise<void> {
            return NetworkingProjectFirewallApiFp(configuration).networkingProjectFirewallEgressDelete(projectId, locationId, firewallId, egressId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get networking/firewall.egress
         * @summary Get networking/firewall.egress
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {string} egressId egressId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectFirewallEgressGet(projectId: string, locationId: string, firewallId: string, egressId: string, options?: any): AxiosPromise<NetworkingRule> {
            return NetworkingProjectFirewallApiFp(configuration).networkingProjectFirewallEgressGet(projectId, locationId, firewallId, egressId, options).then((request) => request(axios, basePath));
        },
        /**
         * List networking/firewall.egress
         * @summary List networking/firewall.egress
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectFirewallEgressList(projectId: string, locationId: string, firewallId: string, options?: any): AxiosPromise<Array<NetworkingRule>> {
            return NetworkingProjectFirewallApiFp(configuration).networkingProjectFirewallEgressList(projectId, locationId, firewallId, options).then((request) => request(axios, basePath));
        },
        /**
         * Replace networking/firewall.egress
         * @summary Replace networking/firewall.egress
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {Array<NetworkingRule>} networkingRule 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectFirewallEgressPut(projectId: string, locationId: string, firewallId: string, networkingRule: Array<NetworkingRule>, options?: any): AxiosPromise<Array<NetworkingRule>> {
            return NetworkingProjectFirewallApiFp(configuration).networkingProjectFirewallEgressPut(projectId, locationId, firewallId, networkingRule, options).then((request) => request(axios, basePath));
        },
        /**
         * Get networking/firewall.event
         * @summary Get networking/firewall.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectFirewallEventGet(projectId: string, locationId: string, firewallId: string, eventId: string, options?: any): AxiosPromise<Event> {
            return NetworkingProjectFirewallApiFp(configuration).networkingProjectFirewallEventGet(projectId, locationId, firewallId, eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * List networking/firewall.event
         * @summary List networking/firewall.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectFirewallEventList(projectId: string, locationId: string, firewallId: string, $limit?: number, $skip?: number, options?: any): AxiosPromise<Array<Event>> {
            return NetworkingProjectFirewallApiFp(configuration).networkingProjectFirewallEventList(projectId, locationId, firewallId, $limit, $skip, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single firewall
         * @summary Get networking/firewall
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectFirewallGet(projectId: string, locationId: string, firewallId: string, options?: any): AxiosPromise<Firewall> {
            return NetworkingProjectFirewallApiFp(configuration).networkingProjectFirewallGet(projectId, locationId, firewallId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create networking/firewall.ingress
         * @summary Create networking/firewall.ingress
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {NetworkingRule} networkingRule 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectFirewallIngressCreate(projectId: string, locationId: string, firewallId: string, networkingRule: NetworkingRule, options?: any): AxiosPromise<NetworkingRule> {
            return NetworkingProjectFirewallApiFp(configuration).networkingProjectFirewallIngressCreate(projectId, locationId, firewallId, networkingRule, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete networking/firewall.ingress
         * @summary Delete networking/firewall.ingress
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {string} ingressId ingressId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectFirewallIngressDelete(projectId: string, locationId: string, firewallId: string, ingressId: string, options?: any): AxiosPromise<void> {
            return NetworkingProjectFirewallApiFp(configuration).networkingProjectFirewallIngressDelete(projectId, locationId, firewallId, ingressId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get networking/firewall.ingress
         * @summary Get networking/firewall.ingress
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {string} ingressId ingressId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectFirewallIngressGet(projectId: string, locationId: string, firewallId: string, ingressId: string, options?: any): AxiosPromise<NetworkingRule> {
            return NetworkingProjectFirewallApiFp(configuration).networkingProjectFirewallIngressGet(projectId, locationId, firewallId, ingressId, options).then((request) => request(axios, basePath));
        },
        /**
         * List networking/firewall.ingress
         * @summary List networking/firewall.ingress
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectFirewallIngressList(projectId: string, locationId: string, firewallId: string, options?: any): AxiosPromise<Array<NetworkingRule>> {
            return NetworkingProjectFirewallApiFp(configuration).networkingProjectFirewallIngressList(projectId, locationId, firewallId, options).then((request) => request(axios, basePath));
        },
        /**
         * Replace networking/firewall.ingress
         * @summary Replace networking/firewall.ingress
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {Array<NetworkingRule>} networkingRule 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectFirewallIngressPut(projectId: string, locationId: string, firewallId: string, networkingRule: Array<NetworkingRule>, options?: any): AxiosPromise<Array<NetworkingRule>> {
            return NetworkingProjectFirewallApiFp(configuration).networkingProjectFirewallIngressPut(projectId, locationId, firewallId, networkingRule, options).then((request) => request(axios, basePath));
        },
        /**
         * List firewall
         * @summary List networking/firewall
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [name] Filter by name
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectFirewallList(projectId: string, locationId: string, name?: string, tagValue?: string, tagKey?: string, options?: any): AxiosPromise<Array<Firewall>> {
            return NetworkingProjectFirewallApiFp(configuration).networkingProjectFirewallList(projectId, locationId, name, tagValue, tagKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get networking/firewall.service
         * @summary Get networking/firewall.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectFirewallServiceGet(projectId: string, locationId: string, firewallId: string, serviceId: string, options?: any): AxiosPromise<ResourceService> {
            return NetworkingProjectFirewallApiFp(configuration).networkingProjectFirewallServiceGet(projectId, locationId, firewallId, serviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * List networking/firewall.service
         * @summary List networking/firewall.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectFirewallServiceList(projectId: string, locationId: string, firewallId: string, options?: any): AxiosPromise<Array<ResourceService>> {
            return NetworkingProjectFirewallApiFp(configuration).networkingProjectFirewallServiceList(projectId, locationId, firewallId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create networking/firewall.tag
         * @summary Create networking/firewall.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectFirewallTagCreate(projectId: string, locationId: string, firewallId: string, tag: Tag, options?: any): AxiosPromise<Tag> {
            return NetworkingProjectFirewallApiFp(configuration).networkingProjectFirewallTagCreate(projectId, locationId, firewallId, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete networking/firewall.tag
         * @summary Delete networking/firewall.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectFirewallTagDelete(projectId: string, locationId: string, firewallId: string, tagId: string, options?: any): AxiosPromise<void> {
            return NetworkingProjectFirewallApiFp(configuration).networkingProjectFirewallTagDelete(projectId, locationId, firewallId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get networking/firewall.tag
         * @summary Get networking/firewall.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectFirewallTagGet(projectId: string, locationId: string, firewallId: string, tagId: string, options?: any): AxiosPromise<Tag> {
            return NetworkingProjectFirewallApiFp(configuration).networkingProjectFirewallTagGet(projectId, locationId, firewallId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * List networking/firewall.tag
         * @summary List networking/firewall.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectFirewallTagList(projectId: string, locationId: string, firewallId: string, options?: any): AxiosPromise<Array<Tag>> {
            return NetworkingProjectFirewallApiFp(configuration).networkingProjectFirewallTagList(projectId, locationId, firewallId, options).then((request) => request(axios, basePath));
        },
        /**
         * Replace networking/firewall.tag
         * @summary Replace networking/firewall.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectFirewallTagPut(projectId: string, locationId: string, firewallId: string, tag: Array<Tag>, options?: any): AxiosPromise<Array<Tag>> {
            return NetworkingProjectFirewallApiFp(configuration).networkingProjectFirewallTagPut(projectId, locationId, firewallId, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * action transfer
         * @summary Transfer networking/firewall
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {NetworkingProjectFirewallTransfer} networkingProjectFirewallTransfer 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectFirewallTransfer(projectId: string, locationId: string, firewallId: string, networkingProjectFirewallTransfer: NetworkingProjectFirewallTransfer, xIdempotencyKey?: string, options?: any): AxiosPromise<Firewall> {
            return NetworkingProjectFirewallApiFp(configuration).networkingProjectFirewallTransfer(projectId, locationId, firewallId, networkingProjectFirewallTransfer, xIdempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns modified firewall
         * @summary Update networking/firewall
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {NetworkingProjectFirewallUpdate} networkingProjectFirewallUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectFirewallUpdate(projectId: string, locationId: string, firewallId: string, networkingProjectFirewallUpdate: NetworkingProjectFirewallUpdate, options?: any): AxiosPromise<Firewall> {
            return NetworkingProjectFirewallApiFp(configuration).networkingProjectFirewallUpdate(projectId, locationId, firewallId, networkingProjectFirewallUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NetworkingProjectFirewallApi - object-oriented interface
 * @export
 * @class NetworkingProjectFirewallApi
 * @extends {BaseAPI}
 */
export class NetworkingProjectFirewallApi extends BaseAPI {
    /**
     * Create firewall
     * @summary Create networking/firewall
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {NetworkingProjectFirewallCreate} networkingProjectFirewallCreate 
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectFirewallApi
     */
    public networkingProjectFirewallCreate(projectId: string, locationId: string, networkingProjectFirewallCreate: NetworkingProjectFirewallCreate, xIdempotencyKey?: string, options?: any) {
        return NetworkingProjectFirewallApiFp(this.configuration).networkingProjectFirewallCreate(projectId, locationId, networkingProjectFirewallCreate, xIdempotencyKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete firewall
     * @summary Delete networking/firewall
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} firewallId Firewall Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectFirewallApi
     */
    public networkingProjectFirewallDelete(projectId: string, locationId: string, firewallId: string, options?: any) {
        return NetworkingProjectFirewallApiFp(this.configuration).networkingProjectFirewallDelete(projectId, locationId, firewallId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create networking/firewall.egress
     * @summary Create networking/firewall.egress
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} firewallId Firewall Id
     * @param {NetworkingRule} networkingRule 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectFirewallApi
     */
    public networkingProjectFirewallEgressCreate(projectId: string, locationId: string, firewallId: string, networkingRule: NetworkingRule, options?: any) {
        return NetworkingProjectFirewallApiFp(this.configuration).networkingProjectFirewallEgressCreate(projectId, locationId, firewallId, networkingRule, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete networking/firewall.egress
     * @summary Delete networking/firewall.egress
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} firewallId Firewall Id
     * @param {string} egressId egressId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectFirewallApi
     */
    public networkingProjectFirewallEgressDelete(projectId: string, locationId: string, firewallId: string, egressId: string, options?: any) {
        return NetworkingProjectFirewallApiFp(this.configuration).networkingProjectFirewallEgressDelete(projectId, locationId, firewallId, egressId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get networking/firewall.egress
     * @summary Get networking/firewall.egress
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} firewallId Firewall Id
     * @param {string} egressId egressId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectFirewallApi
     */
    public networkingProjectFirewallEgressGet(projectId: string, locationId: string, firewallId: string, egressId: string, options?: any) {
        return NetworkingProjectFirewallApiFp(this.configuration).networkingProjectFirewallEgressGet(projectId, locationId, firewallId, egressId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List networking/firewall.egress
     * @summary List networking/firewall.egress
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} firewallId Firewall Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectFirewallApi
     */
    public networkingProjectFirewallEgressList(projectId: string, locationId: string, firewallId: string, options?: any) {
        return NetworkingProjectFirewallApiFp(this.configuration).networkingProjectFirewallEgressList(projectId, locationId, firewallId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replace networking/firewall.egress
     * @summary Replace networking/firewall.egress
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} firewallId Firewall Id
     * @param {Array<NetworkingRule>} networkingRule 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectFirewallApi
     */
    public networkingProjectFirewallEgressPut(projectId: string, locationId: string, firewallId: string, networkingRule: Array<NetworkingRule>, options?: any) {
        return NetworkingProjectFirewallApiFp(this.configuration).networkingProjectFirewallEgressPut(projectId, locationId, firewallId, networkingRule, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get networking/firewall.event
     * @summary Get networking/firewall.event
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} firewallId Firewall Id
     * @param {string} eventId eventId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectFirewallApi
     */
    public networkingProjectFirewallEventGet(projectId: string, locationId: string, firewallId: string, eventId: string, options?: any) {
        return NetworkingProjectFirewallApiFp(this.configuration).networkingProjectFirewallEventGet(projectId, locationId, firewallId, eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List networking/firewall.event
     * @summary List networking/firewall.event
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} firewallId Firewall Id
     * @param {number} [$limit] $limit
     * @param {number} [$skip] $skip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectFirewallApi
     */
    public networkingProjectFirewallEventList(projectId: string, locationId: string, firewallId: string, $limit?: number, $skip?: number, options?: any) {
        return NetworkingProjectFirewallApiFp(this.configuration).networkingProjectFirewallEventList(projectId, locationId, firewallId, $limit, $skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single firewall
     * @summary Get networking/firewall
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} firewallId Firewall Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectFirewallApi
     */
    public networkingProjectFirewallGet(projectId: string, locationId: string, firewallId: string, options?: any) {
        return NetworkingProjectFirewallApiFp(this.configuration).networkingProjectFirewallGet(projectId, locationId, firewallId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create networking/firewall.ingress
     * @summary Create networking/firewall.ingress
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} firewallId Firewall Id
     * @param {NetworkingRule} networkingRule 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectFirewallApi
     */
    public networkingProjectFirewallIngressCreate(projectId: string, locationId: string, firewallId: string, networkingRule: NetworkingRule, options?: any) {
        return NetworkingProjectFirewallApiFp(this.configuration).networkingProjectFirewallIngressCreate(projectId, locationId, firewallId, networkingRule, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete networking/firewall.ingress
     * @summary Delete networking/firewall.ingress
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} firewallId Firewall Id
     * @param {string} ingressId ingressId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectFirewallApi
     */
    public networkingProjectFirewallIngressDelete(projectId: string, locationId: string, firewallId: string, ingressId: string, options?: any) {
        return NetworkingProjectFirewallApiFp(this.configuration).networkingProjectFirewallIngressDelete(projectId, locationId, firewallId, ingressId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get networking/firewall.ingress
     * @summary Get networking/firewall.ingress
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} firewallId Firewall Id
     * @param {string} ingressId ingressId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectFirewallApi
     */
    public networkingProjectFirewallIngressGet(projectId: string, locationId: string, firewallId: string, ingressId: string, options?: any) {
        return NetworkingProjectFirewallApiFp(this.configuration).networkingProjectFirewallIngressGet(projectId, locationId, firewallId, ingressId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List networking/firewall.ingress
     * @summary List networking/firewall.ingress
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} firewallId Firewall Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectFirewallApi
     */
    public networkingProjectFirewallIngressList(projectId: string, locationId: string, firewallId: string, options?: any) {
        return NetworkingProjectFirewallApiFp(this.configuration).networkingProjectFirewallIngressList(projectId, locationId, firewallId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replace networking/firewall.ingress
     * @summary Replace networking/firewall.ingress
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} firewallId Firewall Id
     * @param {Array<NetworkingRule>} networkingRule 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectFirewallApi
     */
    public networkingProjectFirewallIngressPut(projectId: string, locationId: string, firewallId: string, networkingRule: Array<NetworkingRule>, options?: any) {
        return NetworkingProjectFirewallApiFp(this.configuration).networkingProjectFirewallIngressPut(projectId, locationId, firewallId, networkingRule, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List firewall
     * @summary List networking/firewall
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} [name] Filter by name
     * @param {string} [tagValue] Filter by tag.value
     * @param {string} [tagKey] Filter by tag.key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectFirewallApi
     */
    public networkingProjectFirewallList(projectId: string, locationId: string, name?: string, tagValue?: string, tagKey?: string, options?: any) {
        return NetworkingProjectFirewallApiFp(this.configuration).networkingProjectFirewallList(projectId, locationId, name, tagValue, tagKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get networking/firewall.service
     * @summary Get networking/firewall.service
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} firewallId Firewall Id
     * @param {string} serviceId serviceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectFirewallApi
     */
    public networkingProjectFirewallServiceGet(projectId: string, locationId: string, firewallId: string, serviceId: string, options?: any) {
        return NetworkingProjectFirewallApiFp(this.configuration).networkingProjectFirewallServiceGet(projectId, locationId, firewallId, serviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List networking/firewall.service
     * @summary List networking/firewall.service
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} firewallId Firewall Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectFirewallApi
     */
    public networkingProjectFirewallServiceList(projectId: string, locationId: string, firewallId: string, options?: any) {
        return NetworkingProjectFirewallApiFp(this.configuration).networkingProjectFirewallServiceList(projectId, locationId, firewallId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create networking/firewall.tag
     * @summary Create networking/firewall.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} firewallId Firewall Id
     * @param {Tag} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectFirewallApi
     */
    public networkingProjectFirewallTagCreate(projectId: string, locationId: string, firewallId: string, tag: Tag, options?: any) {
        return NetworkingProjectFirewallApiFp(this.configuration).networkingProjectFirewallTagCreate(projectId, locationId, firewallId, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete networking/firewall.tag
     * @summary Delete networking/firewall.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} firewallId Firewall Id
     * @param {string} tagId tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectFirewallApi
     */
    public networkingProjectFirewallTagDelete(projectId: string, locationId: string, firewallId: string, tagId: string, options?: any) {
        return NetworkingProjectFirewallApiFp(this.configuration).networkingProjectFirewallTagDelete(projectId, locationId, firewallId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get networking/firewall.tag
     * @summary Get networking/firewall.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} firewallId Firewall Id
     * @param {string} tagId tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectFirewallApi
     */
    public networkingProjectFirewallTagGet(projectId: string, locationId: string, firewallId: string, tagId: string, options?: any) {
        return NetworkingProjectFirewallApiFp(this.configuration).networkingProjectFirewallTagGet(projectId, locationId, firewallId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List networking/firewall.tag
     * @summary List networking/firewall.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} firewallId Firewall Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectFirewallApi
     */
    public networkingProjectFirewallTagList(projectId: string, locationId: string, firewallId: string, options?: any) {
        return NetworkingProjectFirewallApiFp(this.configuration).networkingProjectFirewallTagList(projectId, locationId, firewallId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replace networking/firewall.tag
     * @summary Replace networking/firewall.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} firewallId Firewall Id
     * @param {Array<Tag>} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectFirewallApi
     */
    public networkingProjectFirewallTagPut(projectId: string, locationId: string, firewallId: string, tag: Array<Tag>, options?: any) {
        return NetworkingProjectFirewallApiFp(this.configuration).networkingProjectFirewallTagPut(projectId, locationId, firewallId, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * action transfer
     * @summary Transfer networking/firewall
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} firewallId Firewall Id
     * @param {NetworkingProjectFirewallTransfer} networkingProjectFirewallTransfer 
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectFirewallApi
     */
    public networkingProjectFirewallTransfer(projectId: string, locationId: string, firewallId: string, networkingProjectFirewallTransfer: NetworkingProjectFirewallTransfer, xIdempotencyKey?: string, options?: any) {
        return NetworkingProjectFirewallApiFp(this.configuration).networkingProjectFirewallTransfer(projectId, locationId, firewallId, networkingProjectFirewallTransfer, xIdempotencyKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns modified firewall
     * @summary Update networking/firewall
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} firewallId Firewall Id
     * @param {NetworkingProjectFirewallUpdate} networkingProjectFirewallUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectFirewallApi
     */
    public networkingProjectFirewallUpdate(projectId: string, locationId: string, firewallId: string, networkingProjectFirewallUpdate: NetworkingProjectFirewallUpdate, options?: any) {
        return NetworkingProjectFirewallApiFp(this.configuration).networkingProjectFirewallUpdate(projectId, locationId, firewallId, networkingProjectFirewallUpdate, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * NetworkingProjectIpApi - axios parameter creator
 * @export
 */
export const NetworkingProjectIpApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * action associate
         * @summary Associate networking/ip
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} ipId Ip Id
         * @param {NetworkingProjectIpAssociate} networkingProjectIpAssociate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectIpAssociate: async (projectId: string, locationId: string, ipId: string, networkingProjectIpAssociate: NetworkingProjectIpAssociate, xIdempotencyKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling networkingProjectIpAssociate.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling networkingProjectIpAssociate.');
            }
            // verify required parameter 'ipId' is not null or undefined
            if (ipId === null || ipId === undefined) {
                throw new RequiredError('ipId','Required parameter ipId was null or undefined when calling networkingProjectIpAssociate.');
            }
            // verify required parameter 'networkingProjectIpAssociate' is not null or undefined
            if (networkingProjectIpAssociate === null || networkingProjectIpAssociate === undefined) {
                throw new RequiredError('networkingProjectIpAssociate','Required parameter networkingProjectIpAssociate was null or undefined when calling networkingProjectIpAssociate.');
            }
            const localVarPath = `/networking/{locationId}/project/{projectId}/ip/{ipId}/actions/associate`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"ipId"}}`, encodeURIComponent(String(ipId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof networkingProjectIpAssociate !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(networkingProjectIpAssociate !== undefined ? networkingProjectIpAssociate : {}) : (networkingProjectIpAssociate || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create ip
         * @summary Create networking/ip
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {NetworkingProjectIpCreate} networkingProjectIpCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectIpCreate: async (projectId: string, locationId: string, networkingProjectIpCreate: NetworkingProjectIpCreate, xIdempotencyKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling networkingProjectIpCreate.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling networkingProjectIpCreate.');
            }
            // verify required parameter 'networkingProjectIpCreate' is not null or undefined
            if (networkingProjectIpCreate === null || networkingProjectIpCreate === undefined) {
                throw new RequiredError('networkingProjectIpCreate','Required parameter networkingProjectIpCreate was null or undefined when calling networkingProjectIpCreate.');
            }
            const localVarPath = `/networking/{locationId}/project/{projectId}/ip`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof networkingProjectIpCreate !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(networkingProjectIpCreate !== undefined ? networkingProjectIpCreate : {}) : (networkingProjectIpCreate || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete ip
         * @summary Delete networking/ip
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} ipId Ip Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectIpDelete: async (projectId: string, locationId: string, ipId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling networkingProjectIpDelete.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling networkingProjectIpDelete.');
            }
            // verify required parameter 'ipId' is not null or undefined
            if (ipId === null || ipId === undefined) {
                throw new RequiredError('ipId','Required parameter ipId was null or undefined when calling networkingProjectIpDelete.');
            }
            const localVarPath = `/networking/{locationId}/project/{projectId}/ip/{ipId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"ipId"}}`, encodeURIComponent(String(ipId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * action disassociate
         * @summary Disassociate networking/ip
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} ipId Ip Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectIpDisassociate: async (projectId: string, locationId: string, ipId: string, xIdempotencyKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling networkingProjectIpDisassociate.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling networkingProjectIpDisassociate.');
            }
            // verify required parameter 'ipId' is not null or undefined
            if (ipId === null || ipId === undefined) {
                throw new RequiredError('ipId','Required parameter ipId was null or undefined when calling networkingProjectIpDisassociate.');
            }
            const localVarPath = `/networking/{locationId}/project/{projectId}/ip/{ipId}/actions/disassociate`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"ipId"}}`, encodeURIComponent(String(ipId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get networking/ip.event
         * @summary Get networking/ip.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} ipId Ip Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectIpEventGet: async (projectId: string, locationId: string, ipId: string, eventId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling networkingProjectIpEventGet.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling networkingProjectIpEventGet.');
            }
            // verify required parameter 'ipId' is not null or undefined
            if (ipId === null || ipId === undefined) {
                throw new RequiredError('ipId','Required parameter ipId was null or undefined when calling networkingProjectIpEventGet.');
            }
            // verify required parameter 'eventId' is not null or undefined
            if (eventId === null || eventId === undefined) {
                throw new RequiredError('eventId','Required parameter eventId was null or undefined when calling networkingProjectIpEventGet.');
            }
            const localVarPath = `/networking/{locationId}/project/{projectId}/ip/{ipId}/event/{eventId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"ipId"}}`, encodeURIComponent(String(ipId)))
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List networking/ip.event
         * @summary List networking/ip.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} ipId Ip Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectIpEventList: async (projectId: string, locationId: string, ipId: string, $limit?: number, $skip?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling networkingProjectIpEventList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling networkingProjectIpEventList.');
            }
            // verify required parameter 'ipId' is not null or undefined
            if (ipId === null || ipId === undefined) {
                throw new RequiredError('ipId','Required parameter ipId was null or undefined when calling networkingProjectIpEventList.');
            }
            const localVarPath = `/networking/{locationId}/project/{projectId}/ip/{ipId}/event`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"ipId"}}`, encodeURIComponent(String(ipId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if ($limit !== undefined) {
                localVarQueryParameter['$limit'] = $limit;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single ip
         * @summary Get networking/ip
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} ipId Ip Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectIpGet: async (projectId: string, locationId: string, ipId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling networkingProjectIpGet.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling networkingProjectIpGet.');
            }
            // verify required parameter 'ipId' is not null or undefined
            if (ipId === null || ipId === undefined) {
                throw new RequiredError('ipId','Required parameter ipId was null or undefined when calling networkingProjectIpGet.');
            }
            const localVarPath = `/networking/{locationId}/project/{projectId}/ip/{ipId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"ipId"}}`, encodeURIComponent(String(ipId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List ip
         * @summary List networking/ip
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [network] Filter by network
         * @param {string} [associatedNetadp] Filter by associated.netadp
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectIpList: async (projectId: string, locationId: string, network?: string, associatedNetadp?: string, tagValue?: string, tagKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling networkingProjectIpList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling networkingProjectIpList.');
            }
            const localVarPath = `/networking/{locationId}/project/{projectId}/ip`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (network !== undefined) {
                localVarQueryParameter['network'] = network;
            }

            if (associatedNetadp !== undefined) {
                localVarQueryParameter['associated.netadp'] = associatedNetadp;
            }

            if (tagValue !== undefined) {
                localVarQueryParameter['tag.value'] = tagValue;
            }

            if (tagKey !== undefined) {
                localVarQueryParameter['tag.key'] = tagKey;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * action persist
         * @summary Persist networking/ip
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} ipId Ip Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectIpPersist: async (projectId: string, locationId: string, ipId: string, xIdempotencyKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling networkingProjectIpPersist.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling networkingProjectIpPersist.');
            }
            // verify required parameter 'ipId' is not null or undefined
            if (ipId === null || ipId === undefined) {
                throw new RequiredError('ipId','Required parameter ipId was null or undefined when calling networkingProjectIpPersist.');
            }
            const localVarPath = `/networking/{locationId}/project/{projectId}/ip/{ipId}/actions/persist`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"ipId"}}`, encodeURIComponent(String(ipId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get networking/ip.service
         * @summary Get networking/ip.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} ipId Ip Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectIpServiceGet: async (projectId: string, locationId: string, ipId: string, serviceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling networkingProjectIpServiceGet.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling networkingProjectIpServiceGet.');
            }
            // verify required parameter 'ipId' is not null or undefined
            if (ipId === null || ipId === undefined) {
                throw new RequiredError('ipId','Required parameter ipId was null or undefined when calling networkingProjectIpServiceGet.');
            }
            // verify required parameter 'serviceId' is not null or undefined
            if (serviceId === null || serviceId === undefined) {
                throw new RequiredError('serviceId','Required parameter serviceId was null or undefined when calling networkingProjectIpServiceGet.');
            }
            const localVarPath = `/networking/{locationId}/project/{projectId}/ip/{ipId}/service/{serviceId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"ipId"}}`, encodeURIComponent(String(ipId)))
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List networking/ip.service
         * @summary List networking/ip.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} ipId Ip Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectIpServiceList: async (projectId: string, locationId: string, ipId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling networkingProjectIpServiceList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling networkingProjectIpServiceList.');
            }
            // verify required parameter 'ipId' is not null or undefined
            if (ipId === null || ipId === undefined) {
                throw new RequiredError('ipId','Required parameter ipId was null or undefined when calling networkingProjectIpServiceList.');
            }
            const localVarPath = `/networking/{locationId}/project/{projectId}/ip/{ipId}/service`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"ipId"}}`, encodeURIComponent(String(ipId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create networking/ip.tag
         * @summary Create networking/ip.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} ipId Ip Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectIpTagCreate: async (projectId: string, locationId: string, ipId: string, tag: Tag, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling networkingProjectIpTagCreate.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling networkingProjectIpTagCreate.');
            }
            // verify required parameter 'ipId' is not null or undefined
            if (ipId === null || ipId === undefined) {
                throw new RequiredError('ipId','Required parameter ipId was null or undefined when calling networkingProjectIpTagCreate.');
            }
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling networkingProjectIpTagCreate.');
            }
            const localVarPath = `/networking/{locationId}/project/{projectId}/ip/{ipId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"ipId"}}`, encodeURIComponent(String(ipId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof tag !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(tag !== undefined ? tag : {}) : (tag || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete networking/ip.tag
         * @summary Delete networking/ip.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} ipId Ip Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectIpTagDelete: async (projectId: string, locationId: string, ipId: string, tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling networkingProjectIpTagDelete.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling networkingProjectIpTagDelete.');
            }
            // verify required parameter 'ipId' is not null or undefined
            if (ipId === null || ipId === undefined) {
                throw new RequiredError('ipId','Required parameter ipId was null or undefined when calling networkingProjectIpTagDelete.');
            }
            // verify required parameter 'tagId' is not null or undefined
            if (tagId === null || tagId === undefined) {
                throw new RequiredError('tagId','Required parameter tagId was null or undefined when calling networkingProjectIpTagDelete.');
            }
            const localVarPath = `/networking/{locationId}/project/{projectId}/ip/{ipId}/tag/{tagId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"ipId"}}`, encodeURIComponent(String(ipId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get networking/ip.tag
         * @summary Get networking/ip.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} ipId Ip Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectIpTagGet: async (projectId: string, locationId: string, ipId: string, tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling networkingProjectIpTagGet.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling networkingProjectIpTagGet.');
            }
            // verify required parameter 'ipId' is not null or undefined
            if (ipId === null || ipId === undefined) {
                throw new RequiredError('ipId','Required parameter ipId was null or undefined when calling networkingProjectIpTagGet.');
            }
            // verify required parameter 'tagId' is not null or undefined
            if (tagId === null || tagId === undefined) {
                throw new RequiredError('tagId','Required parameter tagId was null or undefined when calling networkingProjectIpTagGet.');
            }
            const localVarPath = `/networking/{locationId}/project/{projectId}/ip/{ipId}/tag/{tagId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"ipId"}}`, encodeURIComponent(String(ipId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List networking/ip.tag
         * @summary List networking/ip.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} ipId Ip Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectIpTagList: async (projectId: string, locationId: string, ipId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling networkingProjectIpTagList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling networkingProjectIpTagList.');
            }
            // verify required parameter 'ipId' is not null or undefined
            if (ipId === null || ipId === undefined) {
                throw new RequiredError('ipId','Required parameter ipId was null or undefined when calling networkingProjectIpTagList.');
            }
            const localVarPath = `/networking/{locationId}/project/{projectId}/ip/{ipId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"ipId"}}`, encodeURIComponent(String(ipId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replace networking/ip.tag
         * @summary Replace networking/ip.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} ipId Ip Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectIpTagPut: async (projectId: string, locationId: string, ipId: string, tag: Array<Tag>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling networkingProjectIpTagPut.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling networkingProjectIpTagPut.');
            }
            // verify required parameter 'ipId' is not null or undefined
            if (ipId === null || ipId === undefined) {
                throw new RequiredError('ipId','Required parameter ipId was null or undefined when calling networkingProjectIpTagPut.');
            }
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling networkingProjectIpTagPut.');
            }
            const localVarPath = `/networking/{locationId}/project/{projectId}/ip/{ipId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"ipId"}}`, encodeURIComponent(String(ipId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof tag !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(tag !== undefined ? tag : {}) : (tag || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * action transfer
         * @summary Transfer networking/ip
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} ipId Ip Id
         * @param {NetworkingProjectIpTransfer} networkingProjectIpTransfer 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectIpTransfer: async (projectId: string, locationId: string, ipId: string, networkingProjectIpTransfer: NetworkingProjectIpTransfer, xIdempotencyKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling networkingProjectIpTransfer.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling networkingProjectIpTransfer.');
            }
            // verify required parameter 'ipId' is not null or undefined
            if (ipId === null || ipId === undefined) {
                throw new RequiredError('ipId','Required parameter ipId was null or undefined when calling networkingProjectIpTransfer.');
            }
            // verify required parameter 'networkingProjectIpTransfer' is not null or undefined
            if (networkingProjectIpTransfer === null || networkingProjectIpTransfer === undefined) {
                throw new RequiredError('networkingProjectIpTransfer','Required parameter networkingProjectIpTransfer was null or undefined when calling networkingProjectIpTransfer.');
            }
            const localVarPath = `/networking/{locationId}/project/{projectId}/ip/{ipId}/actions/transfer`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"ipId"}}`, encodeURIComponent(String(ipId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof networkingProjectIpTransfer !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(networkingProjectIpTransfer !== undefined ? networkingProjectIpTransfer : {}) : (networkingProjectIpTransfer || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns modified ip
         * @summary Update networking/ip
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} ipId Ip Id
         * @param {NetworkingProjectIpUpdate} networkingProjectIpUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectIpUpdate: async (projectId: string, locationId: string, ipId: string, networkingProjectIpUpdate: NetworkingProjectIpUpdate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling networkingProjectIpUpdate.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling networkingProjectIpUpdate.');
            }
            // verify required parameter 'ipId' is not null or undefined
            if (ipId === null || ipId === undefined) {
                throw new RequiredError('ipId','Required parameter ipId was null or undefined when calling networkingProjectIpUpdate.');
            }
            // verify required parameter 'networkingProjectIpUpdate' is not null or undefined
            if (networkingProjectIpUpdate === null || networkingProjectIpUpdate === undefined) {
                throw new RequiredError('networkingProjectIpUpdate','Required parameter networkingProjectIpUpdate was null or undefined when calling networkingProjectIpUpdate.');
            }
            const localVarPath = `/networking/{locationId}/project/{projectId}/ip/{ipId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"ipId"}}`, encodeURIComponent(String(ipId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof networkingProjectIpUpdate !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(networkingProjectIpUpdate !== undefined ? networkingProjectIpUpdate : {}) : (networkingProjectIpUpdate || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NetworkingProjectIpApi - functional programming interface
 * @export
 */
export const NetworkingProjectIpApiFp = function(configuration?: Configuration) {
    return {
        /**
         * action associate
         * @summary Associate networking/ip
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} ipId Ip Id
         * @param {NetworkingProjectIpAssociate} networkingProjectIpAssociate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectIpAssociate(projectId: string, locationId: string, ipId: string, networkingProjectIpAssociate: NetworkingProjectIpAssociate, xIdempotencyKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Ip>> {
            const localVarAxiosArgs = await NetworkingProjectIpApiAxiosParamCreator(configuration).networkingProjectIpAssociate(projectId, locationId, ipId, networkingProjectIpAssociate, xIdempotencyKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create ip
         * @summary Create networking/ip
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {NetworkingProjectIpCreate} networkingProjectIpCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectIpCreate(projectId: string, locationId: string, networkingProjectIpCreate: NetworkingProjectIpCreate, xIdempotencyKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Ip>> {
            const localVarAxiosArgs = await NetworkingProjectIpApiAxiosParamCreator(configuration).networkingProjectIpCreate(projectId, locationId, networkingProjectIpCreate, xIdempotencyKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete ip
         * @summary Delete networking/ip
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} ipId Ip Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectIpDelete(projectId: string, locationId: string, ipId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await NetworkingProjectIpApiAxiosParamCreator(configuration).networkingProjectIpDelete(projectId, locationId, ipId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * action disassociate
         * @summary Disassociate networking/ip
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} ipId Ip Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectIpDisassociate(projectId: string, locationId: string, ipId: string, xIdempotencyKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Ip>> {
            const localVarAxiosArgs = await NetworkingProjectIpApiAxiosParamCreator(configuration).networkingProjectIpDisassociate(projectId, locationId, ipId, xIdempotencyKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get networking/ip.event
         * @summary Get networking/ip.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} ipId Ip Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectIpEventGet(projectId: string, locationId: string, ipId: string, eventId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>> {
            const localVarAxiosArgs = await NetworkingProjectIpApiAxiosParamCreator(configuration).networkingProjectIpEventGet(projectId, locationId, ipId, eventId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List networking/ip.event
         * @summary List networking/ip.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} ipId Ip Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectIpEventList(projectId: string, locationId: string, ipId: string, $limit?: number, $skip?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Event>>> {
            const localVarAxiosArgs = await NetworkingProjectIpApiAxiosParamCreator(configuration).networkingProjectIpEventList(projectId, locationId, ipId, $limit, $skip, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a single ip
         * @summary Get networking/ip
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} ipId Ip Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectIpGet(projectId: string, locationId: string, ipId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Ip>> {
            const localVarAxiosArgs = await NetworkingProjectIpApiAxiosParamCreator(configuration).networkingProjectIpGet(projectId, locationId, ipId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List ip
         * @summary List networking/ip
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [network] Filter by network
         * @param {string} [associatedNetadp] Filter by associated.netadp
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectIpList(projectId: string, locationId: string, network?: string, associatedNetadp?: string, tagValue?: string, tagKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Ip>>> {
            const localVarAxiosArgs = await NetworkingProjectIpApiAxiosParamCreator(configuration).networkingProjectIpList(projectId, locationId, network, associatedNetadp, tagValue, tagKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * action persist
         * @summary Persist networking/ip
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} ipId Ip Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectIpPersist(projectId: string, locationId: string, ipId: string, xIdempotencyKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Ip>> {
            const localVarAxiosArgs = await NetworkingProjectIpApiAxiosParamCreator(configuration).networkingProjectIpPersist(projectId, locationId, ipId, xIdempotencyKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get networking/ip.service
         * @summary Get networking/ip.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} ipId Ip Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectIpServiceGet(projectId: string, locationId: string, ipId: string, serviceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceService>> {
            const localVarAxiosArgs = await NetworkingProjectIpApiAxiosParamCreator(configuration).networkingProjectIpServiceGet(projectId, locationId, ipId, serviceId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List networking/ip.service
         * @summary List networking/ip.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} ipId Ip Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectIpServiceList(projectId: string, locationId: string, ipId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResourceService>>> {
            const localVarAxiosArgs = await NetworkingProjectIpApiAxiosParamCreator(configuration).networkingProjectIpServiceList(projectId, locationId, ipId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create networking/ip.tag
         * @summary Create networking/ip.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} ipId Ip Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectIpTagCreate(projectId: string, locationId: string, ipId: string, tag: Tag, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await NetworkingProjectIpApiAxiosParamCreator(configuration).networkingProjectIpTagCreate(projectId, locationId, ipId, tag, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete networking/ip.tag
         * @summary Delete networking/ip.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} ipId Ip Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectIpTagDelete(projectId: string, locationId: string, ipId: string, tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await NetworkingProjectIpApiAxiosParamCreator(configuration).networkingProjectIpTagDelete(projectId, locationId, ipId, tagId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get networking/ip.tag
         * @summary Get networking/ip.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} ipId Ip Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectIpTagGet(projectId: string, locationId: string, ipId: string, tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await NetworkingProjectIpApiAxiosParamCreator(configuration).networkingProjectIpTagGet(projectId, locationId, ipId, tagId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List networking/ip.tag
         * @summary List networking/ip.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} ipId Ip Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectIpTagList(projectId: string, locationId: string, ipId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await NetworkingProjectIpApiAxiosParamCreator(configuration).networkingProjectIpTagList(projectId, locationId, ipId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Replace networking/ip.tag
         * @summary Replace networking/ip.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} ipId Ip Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectIpTagPut(projectId: string, locationId: string, ipId: string, tag: Array<Tag>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await NetworkingProjectIpApiAxiosParamCreator(configuration).networkingProjectIpTagPut(projectId, locationId, ipId, tag, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * action transfer
         * @summary Transfer networking/ip
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} ipId Ip Id
         * @param {NetworkingProjectIpTransfer} networkingProjectIpTransfer 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectIpTransfer(projectId: string, locationId: string, ipId: string, networkingProjectIpTransfer: NetworkingProjectIpTransfer, xIdempotencyKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Ip>> {
            const localVarAxiosArgs = await NetworkingProjectIpApiAxiosParamCreator(configuration).networkingProjectIpTransfer(projectId, locationId, ipId, networkingProjectIpTransfer, xIdempotencyKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns modified ip
         * @summary Update networking/ip
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} ipId Ip Id
         * @param {NetworkingProjectIpUpdate} networkingProjectIpUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectIpUpdate(projectId: string, locationId: string, ipId: string, networkingProjectIpUpdate: NetworkingProjectIpUpdate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Ip>> {
            const localVarAxiosArgs = await NetworkingProjectIpApiAxiosParamCreator(configuration).networkingProjectIpUpdate(projectId, locationId, ipId, networkingProjectIpUpdate, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * NetworkingProjectIpApi - factory interface
 * @export
 */
export const NetworkingProjectIpApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * action associate
         * @summary Associate networking/ip
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} ipId Ip Id
         * @param {NetworkingProjectIpAssociate} networkingProjectIpAssociate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectIpAssociate(projectId: string, locationId: string, ipId: string, networkingProjectIpAssociate: NetworkingProjectIpAssociate, xIdempotencyKey?: string, options?: any): AxiosPromise<Ip> {
            return NetworkingProjectIpApiFp(configuration).networkingProjectIpAssociate(projectId, locationId, ipId, networkingProjectIpAssociate, xIdempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Create ip
         * @summary Create networking/ip
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {NetworkingProjectIpCreate} networkingProjectIpCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectIpCreate(projectId: string, locationId: string, networkingProjectIpCreate: NetworkingProjectIpCreate, xIdempotencyKey?: string, options?: any): AxiosPromise<Ip> {
            return NetworkingProjectIpApiFp(configuration).networkingProjectIpCreate(projectId, locationId, networkingProjectIpCreate, xIdempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete ip
         * @summary Delete networking/ip
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} ipId Ip Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectIpDelete(projectId: string, locationId: string, ipId: string, options?: any): AxiosPromise<void> {
            return NetworkingProjectIpApiFp(configuration).networkingProjectIpDelete(projectId, locationId, ipId, options).then((request) => request(axios, basePath));
        },
        /**
         * action disassociate
         * @summary Disassociate networking/ip
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} ipId Ip Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectIpDisassociate(projectId: string, locationId: string, ipId: string, xIdempotencyKey?: string, options?: any): AxiosPromise<Ip> {
            return NetworkingProjectIpApiFp(configuration).networkingProjectIpDisassociate(projectId, locationId, ipId, xIdempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get networking/ip.event
         * @summary Get networking/ip.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} ipId Ip Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectIpEventGet(projectId: string, locationId: string, ipId: string, eventId: string, options?: any): AxiosPromise<Event> {
            return NetworkingProjectIpApiFp(configuration).networkingProjectIpEventGet(projectId, locationId, ipId, eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * List networking/ip.event
         * @summary List networking/ip.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} ipId Ip Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectIpEventList(projectId: string, locationId: string, ipId: string, $limit?: number, $skip?: number, options?: any): AxiosPromise<Array<Event>> {
            return NetworkingProjectIpApiFp(configuration).networkingProjectIpEventList(projectId, locationId, ipId, $limit, $skip, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single ip
         * @summary Get networking/ip
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} ipId Ip Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectIpGet(projectId: string, locationId: string, ipId: string, options?: any): AxiosPromise<Ip> {
            return NetworkingProjectIpApiFp(configuration).networkingProjectIpGet(projectId, locationId, ipId, options).then((request) => request(axios, basePath));
        },
        /**
         * List ip
         * @summary List networking/ip
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [network] Filter by network
         * @param {string} [associatedNetadp] Filter by associated.netadp
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectIpList(projectId: string, locationId: string, network?: string, associatedNetadp?: string, tagValue?: string, tagKey?: string, options?: any): AxiosPromise<Array<Ip>> {
            return NetworkingProjectIpApiFp(configuration).networkingProjectIpList(projectId, locationId, network, associatedNetadp, tagValue, tagKey, options).then((request) => request(axios, basePath));
        },
        /**
         * action persist
         * @summary Persist networking/ip
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} ipId Ip Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectIpPersist(projectId: string, locationId: string, ipId: string, xIdempotencyKey?: string, options?: any): AxiosPromise<Ip> {
            return NetworkingProjectIpApiFp(configuration).networkingProjectIpPersist(projectId, locationId, ipId, xIdempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get networking/ip.service
         * @summary Get networking/ip.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} ipId Ip Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectIpServiceGet(projectId: string, locationId: string, ipId: string, serviceId: string, options?: any): AxiosPromise<ResourceService> {
            return NetworkingProjectIpApiFp(configuration).networkingProjectIpServiceGet(projectId, locationId, ipId, serviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * List networking/ip.service
         * @summary List networking/ip.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} ipId Ip Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectIpServiceList(projectId: string, locationId: string, ipId: string, options?: any): AxiosPromise<Array<ResourceService>> {
            return NetworkingProjectIpApiFp(configuration).networkingProjectIpServiceList(projectId, locationId, ipId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create networking/ip.tag
         * @summary Create networking/ip.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} ipId Ip Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectIpTagCreate(projectId: string, locationId: string, ipId: string, tag: Tag, options?: any): AxiosPromise<Tag> {
            return NetworkingProjectIpApiFp(configuration).networkingProjectIpTagCreate(projectId, locationId, ipId, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete networking/ip.tag
         * @summary Delete networking/ip.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} ipId Ip Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectIpTagDelete(projectId: string, locationId: string, ipId: string, tagId: string, options?: any): AxiosPromise<void> {
            return NetworkingProjectIpApiFp(configuration).networkingProjectIpTagDelete(projectId, locationId, ipId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get networking/ip.tag
         * @summary Get networking/ip.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} ipId Ip Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectIpTagGet(projectId: string, locationId: string, ipId: string, tagId: string, options?: any): AxiosPromise<Tag> {
            return NetworkingProjectIpApiFp(configuration).networkingProjectIpTagGet(projectId, locationId, ipId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * List networking/ip.tag
         * @summary List networking/ip.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} ipId Ip Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectIpTagList(projectId: string, locationId: string, ipId: string, options?: any): AxiosPromise<Array<Tag>> {
            return NetworkingProjectIpApiFp(configuration).networkingProjectIpTagList(projectId, locationId, ipId, options).then((request) => request(axios, basePath));
        },
        /**
         * Replace networking/ip.tag
         * @summary Replace networking/ip.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} ipId Ip Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectIpTagPut(projectId: string, locationId: string, ipId: string, tag: Array<Tag>, options?: any): AxiosPromise<Array<Tag>> {
            return NetworkingProjectIpApiFp(configuration).networkingProjectIpTagPut(projectId, locationId, ipId, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * action transfer
         * @summary Transfer networking/ip
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} ipId Ip Id
         * @param {NetworkingProjectIpTransfer} networkingProjectIpTransfer 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectIpTransfer(projectId: string, locationId: string, ipId: string, networkingProjectIpTransfer: NetworkingProjectIpTransfer, xIdempotencyKey?: string, options?: any): AxiosPromise<Ip> {
            return NetworkingProjectIpApiFp(configuration).networkingProjectIpTransfer(projectId, locationId, ipId, networkingProjectIpTransfer, xIdempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns modified ip
         * @summary Update networking/ip
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} ipId Ip Id
         * @param {NetworkingProjectIpUpdate} networkingProjectIpUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectIpUpdate(projectId: string, locationId: string, ipId: string, networkingProjectIpUpdate: NetworkingProjectIpUpdate, options?: any): AxiosPromise<Ip> {
            return NetworkingProjectIpApiFp(configuration).networkingProjectIpUpdate(projectId, locationId, ipId, networkingProjectIpUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NetworkingProjectIpApi - object-oriented interface
 * @export
 * @class NetworkingProjectIpApi
 * @extends {BaseAPI}
 */
export class NetworkingProjectIpApi extends BaseAPI {
    /**
     * action associate
     * @summary Associate networking/ip
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} ipId Ip Id
     * @param {NetworkingProjectIpAssociate} networkingProjectIpAssociate 
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectIpApi
     */
    public networkingProjectIpAssociate(projectId: string, locationId: string, ipId: string, networkingProjectIpAssociate: NetworkingProjectIpAssociate, xIdempotencyKey?: string, options?: any) {
        return NetworkingProjectIpApiFp(this.configuration).networkingProjectIpAssociate(projectId, locationId, ipId, networkingProjectIpAssociate, xIdempotencyKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create ip
     * @summary Create networking/ip
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {NetworkingProjectIpCreate} networkingProjectIpCreate 
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectIpApi
     */
    public networkingProjectIpCreate(projectId: string, locationId: string, networkingProjectIpCreate: NetworkingProjectIpCreate, xIdempotencyKey?: string, options?: any) {
        return NetworkingProjectIpApiFp(this.configuration).networkingProjectIpCreate(projectId, locationId, networkingProjectIpCreate, xIdempotencyKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete ip
     * @summary Delete networking/ip
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} ipId Ip Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectIpApi
     */
    public networkingProjectIpDelete(projectId: string, locationId: string, ipId: string, options?: any) {
        return NetworkingProjectIpApiFp(this.configuration).networkingProjectIpDelete(projectId, locationId, ipId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * action disassociate
     * @summary Disassociate networking/ip
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} ipId Ip Id
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectIpApi
     */
    public networkingProjectIpDisassociate(projectId: string, locationId: string, ipId: string, xIdempotencyKey?: string, options?: any) {
        return NetworkingProjectIpApiFp(this.configuration).networkingProjectIpDisassociate(projectId, locationId, ipId, xIdempotencyKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get networking/ip.event
     * @summary Get networking/ip.event
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} ipId Ip Id
     * @param {string} eventId eventId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectIpApi
     */
    public networkingProjectIpEventGet(projectId: string, locationId: string, ipId: string, eventId: string, options?: any) {
        return NetworkingProjectIpApiFp(this.configuration).networkingProjectIpEventGet(projectId, locationId, ipId, eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List networking/ip.event
     * @summary List networking/ip.event
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} ipId Ip Id
     * @param {number} [$limit] $limit
     * @param {number} [$skip] $skip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectIpApi
     */
    public networkingProjectIpEventList(projectId: string, locationId: string, ipId: string, $limit?: number, $skip?: number, options?: any) {
        return NetworkingProjectIpApiFp(this.configuration).networkingProjectIpEventList(projectId, locationId, ipId, $limit, $skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single ip
     * @summary Get networking/ip
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} ipId Ip Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectIpApi
     */
    public networkingProjectIpGet(projectId: string, locationId: string, ipId: string, options?: any) {
        return NetworkingProjectIpApiFp(this.configuration).networkingProjectIpGet(projectId, locationId, ipId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List ip
     * @summary List networking/ip
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} [network] Filter by network
     * @param {string} [associatedNetadp] Filter by associated.netadp
     * @param {string} [tagValue] Filter by tag.value
     * @param {string} [tagKey] Filter by tag.key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectIpApi
     */
    public networkingProjectIpList(projectId: string, locationId: string, network?: string, associatedNetadp?: string, tagValue?: string, tagKey?: string, options?: any) {
        return NetworkingProjectIpApiFp(this.configuration).networkingProjectIpList(projectId, locationId, network, associatedNetadp, tagValue, tagKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * action persist
     * @summary Persist networking/ip
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} ipId Ip Id
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectIpApi
     */
    public networkingProjectIpPersist(projectId: string, locationId: string, ipId: string, xIdempotencyKey?: string, options?: any) {
        return NetworkingProjectIpApiFp(this.configuration).networkingProjectIpPersist(projectId, locationId, ipId, xIdempotencyKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get networking/ip.service
     * @summary Get networking/ip.service
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} ipId Ip Id
     * @param {string} serviceId serviceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectIpApi
     */
    public networkingProjectIpServiceGet(projectId: string, locationId: string, ipId: string, serviceId: string, options?: any) {
        return NetworkingProjectIpApiFp(this.configuration).networkingProjectIpServiceGet(projectId, locationId, ipId, serviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List networking/ip.service
     * @summary List networking/ip.service
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} ipId Ip Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectIpApi
     */
    public networkingProjectIpServiceList(projectId: string, locationId: string, ipId: string, options?: any) {
        return NetworkingProjectIpApiFp(this.configuration).networkingProjectIpServiceList(projectId, locationId, ipId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create networking/ip.tag
     * @summary Create networking/ip.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} ipId Ip Id
     * @param {Tag} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectIpApi
     */
    public networkingProjectIpTagCreate(projectId: string, locationId: string, ipId: string, tag: Tag, options?: any) {
        return NetworkingProjectIpApiFp(this.configuration).networkingProjectIpTagCreate(projectId, locationId, ipId, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete networking/ip.tag
     * @summary Delete networking/ip.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} ipId Ip Id
     * @param {string} tagId tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectIpApi
     */
    public networkingProjectIpTagDelete(projectId: string, locationId: string, ipId: string, tagId: string, options?: any) {
        return NetworkingProjectIpApiFp(this.configuration).networkingProjectIpTagDelete(projectId, locationId, ipId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get networking/ip.tag
     * @summary Get networking/ip.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} ipId Ip Id
     * @param {string} tagId tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectIpApi
     */
    public networkingProjectIpTagGet(projectId: string, locationId: string, ipId: string, tagId: string, options?: any) {
        return NetworkingProjectIpApiFp(this.configuration).networkingProjectIpTagGet(projectId, locationId, ipId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List networking/ip.tag
     * @summary List networking/ip.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} ipId Ip Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectIpApi
     */
    public networkingProjectIpTagList(projectId: string, locationId: string, ipId: string, options?: any) {
        return NetworkingProjectIpApiFp(this.configuration).networkingProjectIpTagList(projectId, locationId, ipId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replace networking/ip.tag
     * @summary Replace networking/ip.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} ipId Ip Id
     * @param {Array<Tag>} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectIpApi
     */
    public networkingProjectIpTagPut(projectId: string, locationId: string, ipId: string, tag: Array<Tag>, options?: any) {
        return NetworkingProjectIpApiFp(this.configuration).networkingProjectIpTagPut(projectId, locationId, ipId, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * action transfer
     * @summary Transfer networking/ip
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} ipId Ip Id
     * @param {NetworkingProjectIpTransfer} networkingProjectIpTransfer 
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectIpApi
     */
    public networkingProjectIpTransfer(projectId: string, locationId: string, ipId: string, networkingProjectIpTransfer: NetworkingProjectIpTransfer, xIdempotencyKey?: string, options?: any) {
        return NetworkingProjectIpApiFp(this.configuration).networkingProjectIpTransfer(projectId, locationId, ipId, networkingProjectIpTransfer, xIdempotencyKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns modified ip
     * @summary Update networking/ip
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} ipId Ip Id
     * @param {NetworkingProjectIpUpdate} networkingProjectIpUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectIpApi
     */
    public networkingProjectIpUpdate(projectId: string, locationId: string, ipId: string, networkingProjectIpUpdate: NetworkingProjectIpUpdate, options?: any) {
        return NetworkingProjectIpApiFp(this.configuration).networkingProjectIpUpdate(projectId, locationId, ipId, networkingProjectIpUpdate, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * NetworkingProjectNetadpApi - axios parameter creator
 * @export
 */
export const NetworkingProjectNetadpApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create netadp
         * @summary Create networking/netadp
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {NetworkingProjectNetadpCreate} networkingProjectNetadpCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetadpCreate: async (projectId: string, locationId: string, networkingProjectNetadpCreate: NetworkingProjectNetadpCreate, xIdempotencyKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling networkingProjectNetadpCreate.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling networkingProjectNetadpCreate.');
            }
            // verify required parameter 'networkingProjectNetadpCreate' is not null or undefined
            if (networkingProjectNetadpCreate === null || networkingProjectNetadpCreate === undefined) {
                throw new RequiredError('networkingProjectNetadpCreate','Required parameter networkingProjectNetadpCreate was null or undefined when calling networkingProjectNetadpCreate.');
            }
            const localVarPath = `/networking/{locationId}/project/{projectId}/netadp`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof networkingProjectNetadpCreate !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(networkingProjectNetadpCreate !== undefined ? networkingProjectNetadpCreate : {}) : (networkingProjectNetadpCreate || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete netadp
         * @summary Delete networking/netadp
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netadpId Netadp Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetadpDelete: async (projectId: string, locationId: string, netadpId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling networkingProjectNetadpDelete.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling networkingProjectNetadpDelete.');
            }
            // verify required parameter 'netadpId' is not null or undefined
            if (netadpId === null || netadpId === undefined) {
                throw new RequiredError('netadpId','Required parameter netadpId was null or undefined when calling networkingProjectNetadpDelete.');
            }
            const localVarPath = `/networking/{locationId}/project/{projectId}/netadp/{netadpId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"netadpId"}}`, encodeURIComponent(String(netadpId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get networking/netadp.event
         * @summary Get networking/netadp.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netadpId Netadp Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetadpEventGet: async (projectId: string, locationId: string, netadpId: string, eventId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling networkingProjectNetadpEventGet.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling networkingProjectNetadpEventGet.');
            }
            // verify required parameter 'netadpId' is not null or undefined
            if (netadpId === null || netadpId === undefined) {
                throw new RequiredError('netadpId','Required parameter netadpId was null or undefined when calling networkingProjectNetadpEventGet.');
            }
            // verify required parameter 'eventId' is not null or undefined
            if (eventId === null || eventId === undefined) {
                throw new RequiredError('eventId','Required parameter eventId was null or undefined when calling networkingProjectNetadpEventGet.');
            }
            const localVarPath = `/networking/{locationId}/project/{projectId}/netadp/{netadpId}/event/{eventId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"netadpId"}}`, encodeURIComponent(String(netadpId)))
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List networking/netadp.event
         * @summary List networking/netadp.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netadpId Netadp Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetadpEventList: async (projectId: string, locationId: string, netadpId: string, $limit?: number, $skip?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling networkingProjectNetadpEventList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling networkingProjectNetadpEventList.');
            }
            // verify required parameter 'netadpId' is not null or undefined
            if (netadpId === null || netadpId === undefined) {
                throw new RequiredError('netadpId','Required parameter netadpId was null or undefined when calling networkingProjectNetadpEventList.');
            }
            const localVarPath = `/networking/{locationId}/project/{projectId}/netadp/{netadpId}/event`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"netadpId"}}`, encodeURIComponent(String(netadpId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if ($limit !== undefined) {
                localVarQueryParameter['$limit'] = $limit;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single netadp
         * @summary Get networking/netadp
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netadpId Netadp Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetadpGet: async (projectId: string, locationId: string, netadpId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling networkingProjectNetadpGet.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling networkingProjectNetadpGet.');
            }
            // verify required parameter 'netadpId' is not null or undefined
            if (netadpId === null || netadpId === undefined) {
                throw new RequiredError('netadpId','Required parameter netadpId was null or undefined when calling networkingProjectNetadpGet.');
            }
            const localVarPath = `/networking/{locationId}/project/{projectId}/netadp/{netadpId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"netadpId"}}`, encodeURIComponent(String(netadpId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List netadp
         * @summary List networking/netadp
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [assignedResource] Filter by assigned.resource
         * @param {string} [assignedId] Filter by assigned.id
         * @param {string} [network] Filter by network
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetadpList: async (projectId: string, locationId: string, assignedResource?: string, assignedId?: string, network?: string, tagValue?: string, tagKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling networkingProjectNetadpList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling networkingProjectNetadpList.');
            }
            const localVarPath = `/networking/{locationId}/project/{projectId}/netadp`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (assignedResource !== undefined) {
                localVarQueryParameter['assigned.resource'] = assignedResource;
            }

            if (assignedId !== undefined) {
                localVarQueryParameter['assigned.id'] = assignedId;
            }

            if (network !== undefined) {
                localVarQueryParameter['network'] = network;
            }

            if (tagValue !== undefined) {
                localVarQueryParameter['tag.value'] = tagValue;
            }

            if (tagKey !== undefined) {
                localVarQueryParameter['tag.key'] = tagKey;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get networking/netadp.metric
         * @summary Get networking/netadp.metric
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netadpId Netadp Id
         * @param {string} metricId metricId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetadpMetricGet: async (projectId: string, locationId: string, netadpId: string, metricId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling networkingProjectNetadpMetricGet.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling networkingProjectNetadpMetricGet.');
            }
            // verify required parameter 'netadpId' is not null or undefined
            if (netadpId === null || netadpId === undefined) {
                throw new RequiredError('netadpId','Required parameter netadpId was null or undefined when calling networkingProjectNetadpMetricGet.');
            }
            // verify required parameter 'metricId' is not null or undefined
            if (metricId === null || metricId === undefined) {
                throw new RequiredError('metricId','Required parameter metricId was null or undefined when calling networkingProjectNetadpMetricGet.');
            }
            const localVarPath = `/networking/{locationId}/project/{projectId}/netadp/{netadpId}/metric/{metricId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"netadpId"}}`, encodeURIComponent(String(netadpId)))
                .replace(`{${"metricId"}}`, encodeURIComponent(String(metricId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List networking/netadp.metric
         * @summary List networking/netadp.metric
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netadpId Netadp Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetadpMetricList: async (projectId: string, locationId: string, netadpId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling networkingProjectNetadpMetricList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling networkingProjectNetadpMetricList.');
            }
            // verify required parameter 'netadpId' is not null or undefined
            if (netadpId === null || netadpId === undefined) {
                throw new RequiredError('netadpId','Required parameter netadpId was null or undefined when calling networkingProjectNetadpMetricList.');
            }
            const localVarPath = `/networking/{locationId}/project/{projectId}/netadp/{netadpId}/metric`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"netadpId"}}`, encodeURIComponent(String(netadpId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List networking/netadp.point
         * @summary List networking/netadp.point
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netadpId Netadp Id
         * @param {string} metricId metricId
         * @param {string} [interval] interval
         * @param {string} [timespan] timespan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetadpMetricPointList: async (projectId: string, locationId: string, netadpId: string, metricId: string, interval?: string, timespan?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling networkingProjectNetadpMetricPointList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling networkingProjectNetadpMetricPointList.');
            }
            // verify required parameter 'netadpId' is not null or undefined
            if (netadpId === null || netadpId === undefined) {
                throw new RequiredError('netadpId','Required parameter netadpId was null or undefined when calling networkingProjectNetadpMetricPointList.');
            }
            // verify required parameter 'metricId' is not null or undefined
            if (metricId === null || metricId === undefined) {
                throw new RequiredError('metricId','Required parameter metricId was null or undefined when calling networkingProjectNetadpMetricPointList.');
            }
            const localVarPath = `/networking/{locationId}/project/{projectId}/netadp/{netadpId}/metric/{metricId}/point`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"netadpId"}}`, encodeURIComponent(String(netadpId)))
                .replace(`{${"metricId"}}`, encodeURIComponent(String(metricId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (timespan !== undefined) {
                localVarQueryParameter['timespan'] = timespan;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get networking/netadp.service
         * @summary Get networking/netadp.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netadpId Netadp Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetadpServiceGet: async (projectId: string, locationId: string, netadpId: string, serviceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling networkingProjectNetadpServiceGet.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling networkingProjectNetadpServiceGet.');
            }
            // verify required parameter 'netadpId' is not null or undefined
            if (netadpId === null || netadpId === undefined) {
                throw new RequiredError('netadpId','Required parameter netadpId was null or undefined when calling networkingProjectNetadpServiceGet.');
            }
            // verify required parameter 'serviceId' is not null or undefined
            if (serviceId === null || serviceId === undefined) {
                throw new RequiredError('serviceId','Required parameter serviceId was null or undefined when calling networkingProjectNetadpServiceGet.');
            }
            const localVarPath = `/networking/{locationId}/project/{projectId}/netadp/{netadpId}/service/{serviceId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"netadpId"}}`, encodeURIComponent(String(netadpId)))
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List networking/netadp.service
         * @summary List networking/netadp.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netadpId Netadp Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetadpServiceList: async (projectId: string, locationId: string, netadpId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling networkingProjectNetadpServiceList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling networkingProjectNetadpServiceList.');
            }
            // verify required parameter 'netadpId' is not null or undefined
            if (netadpId === null || netadpId === undefined) {
                throw new RequiredError('netadpId','Required parameter netadpId was null or undefined when calling networkingProjectNetadpServiceList.');
            }
            const localVarPath = `/networking/{locationId}/project/{projectId}/netadp/{netadpId}/service`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"netadpId"}}`, encodeURIComponent(String(netadpId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create networking/netadp.tag
         * @summary Create networking/netadp.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netadpId Netadp Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetadpTagCreate: async (projectId: string, locationId: string, netadpId: string, tag: Tag, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling networkingProjectNetadpTagCreate.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling networkingProjectNetadpTagCreate.');
            }
            // verify required parameter 'netadpId' is not null or undefined
            if (netadpId === null || netadpId === undefined) {
                throw new RequiredError('netadpId','Required parameter netadpId was null or undefined when calling networkingProjectNetadpTagCreate.');
            }
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling networkingProjectNetadpTagCreate.');
            }
            const localVarPath = `/networking/{locationId}/project/{projectId}/netadp/{netadpId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"netadpId"}}`, encodeURIComponent(String(netadpId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof tag !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(tag !== undefined ? tag : {}) : (tag || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete networking/netadp.tag
         * @summary Delete networking/netadp.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netadpId Netadp Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetadpTagDelete: async (projectId: string, locationId: string, netadpId: string, tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling networkingProjectNetadpTagDelete.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling networkingProjectNetadpTagDelete.');
            }
            // verify required parameter 'netadpId' is not null or undefined
            if (netadpId === null || netadpId === undefined) {
                throw new RequiredError('netadpId','Required parameter netadpId was null or undefined when calling networkingProjectNetadpTagDelete.');
            }
            // verify required parameter 'tagId' is not null or undefined
            if (tagId === null || tagId === undefined) {
                throw new RequiredError('tagId','Required parameter tagId was null or undefined when calling networkingProjectNetadpTagDelete.');
            }
            const localVarPath = `/networking/{locationId}/project/{projectId}/netadp/{netadpId}/tag/{tagId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"netadpId"}}`, encodeURIComponent(String(netadpId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get networking/netadp.tag
         * @summary Get networking/netadp.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netadpId Netadp Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetadpTagGet: async (projectId: string, locationId: string, netadpId: string, tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling networkingProjectNetadpTagGet.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling networkingProjectNetadpTagGet.');
            }
            // verify required parameter 'netadpId' is not null or undefined
            if (netadpId === null || netadpId === undefined) {
                throw new RequiredError('netadpId','Required parameter netadpId was null or undefined when calling networkingProjectNetadpTagGet.');
            }
            // verify required parameter 'tagId' is not null or undefined
            if (tagId === null || tagId === undefined) {
                throw new RequiredError('tagId','Required parameter tagId was null or undefined when calling networkingProjectNetadpTagGet.');
            }
            const localVarPath = `/networking/{locationId}/project/{projectId}/netadp/{netadpId}/tag/{tagId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"netadpId"}}`, encodeURIComponent(String(netadpId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List networking/netadp.tag
         * @summary List networking/netadp.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netadpId Netadp Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetadpTagList: async (projectId: string, locationId: string, netadpId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling networkingProjectNetadpTagList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling networkingProjectNetadpTagList.');
            }
            // verify required parameter 'netadpId' is not null or undefined
            if (netadpId === null || netadpId === undefined) {
                throw new RequiredError('netadpId','Required parameter netadpId was null or undefined when calling networkingProjectNetadpTagList.');
            }
            const localVarPath = `/networking/{locationId}/project/{projectId}/netadp/{netadpId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"netadpId"}}`, encodeURIComponent(String(netadpId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replace networking/netadp.tag
         * @summary Replace networking/netadp.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netadpId Netadp Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetadpTagPut: async (projectId: string, locationId: string, netadpId: string, tag: Array<Tag>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling networkingProjectNetadpTagPut.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling networkingProjectNetadpTagPut.');
            }
            // verify required parameter 'netadpId' is not null or undefined
            if (netadpId === null || netadpId === undefined) {
                throw new RequiredError('netadpId','Required parameter netadpId was null or undefined when calling networkingProjectNetadpTagPut.');
            }
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling networkingProjectNetadpTagPut.');
            }
            const localVarPath = `/networking/{locationId}/project/{projectId}/netadp/{netadpId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"netadpId"}}`, encodeURIComponent(String(netadpId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof tag !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(tag !== undefined ? tag : {}) : (tag || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns modified netadp
         * @summary Update networking/netadp
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netadpId Netadp Id
         * @param {NetworkingProjectNetadpUpdate} networkingProjectNetadpUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetadpUpdate: async (projectId: string, locationId: string, netadpId: string, networkingProjectNetadpUpdate: NetworkingProjectNetadpUpdate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling networkingProjectNetadpUpdate.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling networkingProjectNetadpUpdate.');
            }
            // verify required parameter 'netadpId' is not null or undefined
            if (netadpId === null || netadpId === undefined) {
                throw new RequiredError('netadpId','Required parameter netadpId was null or undefined when calling networkingProjectNetadpUpdate.');
            }
            // verify required parameter 'networkingProjectNetadpUpdate' is not null or undefined
            if (networkingProjectNetadpUpdate === null || networkingProjectNetadpUpdate === undefined) {
                throw new RequiredError('networkingProjectNetadpUpdate','Required parameter networkingProjectNetadpUpdate was null or undefined when calling networkingProjectNetadpUpdate.');
            }
            const localVarPath = `/networking/{locationId}/project/{projectId}/netadp/{netadpId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"netadpId"}}`, encodeURIComponent(String(netadpId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof networkingProjectNetadpUpdate !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(networkingProjectNetadpUpdate !== undefined ? networkingProjectNetadpUpdate : {}) : (networkingProjectNetadpUpdate || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NetworkingProjectNetadpApi - functional programming interface
 * @export
 */
export const NetworkingProjectNetadpApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create netadp
         * @summary Create networking/netadp
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {NetworkingProjectNetadpCreate} networkingProjectNetadpCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectNetadpCreate(projectId: string, locationId: string, networkingProjectNetadpCreate: NetworkingProjectNetadpCreate, xIdempotencyKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Netadp>> {
            const localVarAxiosArgs = await NetworkingProjectNetadpApiAxiosParamCreator(configuration).networkingProjectNetadpCreate(projectId, locationId, networkingProjectNetadpCreate, xIdempotencyKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete netadp
         * @summary Delete networking/netadp
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netadpId Netadp Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectNetadpDelete(projectId: string, locationId: string, netadpId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await NetworkingProjectNetadpApiAxiosParamCreator(configuration).networkingProjectNetadpDelete(projectId, locationId, netadpId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get networking/netadp.event
         * @summary Get networking/netadp.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netadpId Netadp Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectNetadpEventGet(projectId: string, locationId: string, netadpId: string, eventId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>> {
            const localVarAxiosArgs = await NetworkingProjectNetadpApiAxiosParamCreator(configuration).networkingProjectNetadpEventGet(projectId, locationId, netadpId, eventId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List networking/netadp.event
         * @summary List networking/netadp.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netadpId Netadp Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectNetadpEventList(projectId: string, locationId: string, netadpId: string, $limit?: number, $skip?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Event>>> {
            const localVarAxiosArgs = await NetworkingProjectNetadpApiAxiosParamCreator(configuration).networkingProjectNetadpEventList(projectId, locationId, netadpId, $limit, $skip, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a single netadp
         * @summary Get networking/netadp
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netadpId Netadp Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectNetadpGet(projectId: string, locationId: string, netadpId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Netadp>> {
            const localVarAxiosArgs = await NetworkingProjectNetadpApiAxiosParamCreator(configuration).networkingProjectNetadpGet(projectId, locationId, netadpId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List netadp
         * @summary List networking/netadp
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [assignedResource] Filter by assigned.resource
         * @param {string} [assignedId] Filter by assigned.id
         * @param {string} [network] Filter by network
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectNetadpList(projectId: string, locationId: string, assignedResource?: string, assignedId?: string, network?: string, tagValue?: string, tagKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Netadp>>> {
            const localVarAxiosArgs = await NetworkingProjectNetadpApiAxiosParamCreator(configuration).networkingProjectNetadpList(projectId, locationId, assignedResource, assignedId, network, tagValue, tagKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get networking/netadp.metric
         * @summary Get networking/netadp.metric
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netadpId Netadp Id
         * @param {string} metricId metricId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectNetadpMetricGet(projectId: string, locationId: string, netadpId: string, metricId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Metric>> {
            const localVarAxiosArgs = await NetworkingProjectNetadpApiAxiosParamCreator(configuration).networkingProjectNetadpMetricGet(projectId, locationId, netadpId, metricId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List networking/netadp.metric
         * @summary List networking/netadp.metric
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netadpId Netadp Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectNetadpMetricList(projectId: string, locationId: string, netadpId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Metric>>> {
            const localVarAxiosArgs = await NetworkingProjectNetadpApiAxiosParamCreator(configuration).networkingProjectNetadpMetricList(projectId, locationId, netadpId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List networking/netadp.point
         * @summary List networking/netadp.point
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netadpId Netadp Id
         * @param {string} metricId metricId
         * @param {string} [interval] interval
         * @param {string} [timespan] timespan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectNetadpMetricPointList(projectId: string, locationId: string, netadpId: string, metricId: string, interval?: string, timespan?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Point>>> {
            const localVarAxiosArgs = await NetworkingProjectNetadpApiAxiosParamCreator(configuration).networkingProjectNetadpMetricPointList(projectId, locationId, netadpId, metricId, interval, timespan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get networking/netadp.service
         * @summary Get networking/netadp.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netadpId Netadp Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectNetadpServiceGet(projectId: string, locationId: string, netadpId: string, serviceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceService>> {
            const localVarAxiosArgs = await NetworkingProjectNetadpApiAxiosParamCreator(configuration).networkingProjectNetadpServiceGet(projectId, locationId, netadpId, serviceId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List networking/netadp.service
         * @summary List networking/netadp.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netadpId Netadp Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectNetadpServiceList(projectId: string, locationId: string, netadpId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResourceService>>> {
            const localVarAxiosArgs = await NetworkingProjectNetadpApiAxiosParamCreator(configuration).networkingProjectNetadpServiceList(projectId, locationId, netadpId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create networking/netadp.tag
         * @summary Create networking/netadp.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netadpId Netadp Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectNetadpTagCreate(projectId: string, locationId: string, netadpId: string, tag: Tag, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await NetworkingProjectNetadpApiAxiosParamCreator(configuration).networkingProjectNetadpTagCreate(projectId, locationId, netadpId, tag, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete networking/netadp.tag
         * @summary Delete networking/netadp.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netadpId Netadp Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectNetadpTagDelete(projectId: string, locationId: string, netadpId: string, tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await NetworkingProjectNetadpApiAxiosParamCreator(configuration).networkingProjectNetadpTagDelete(projectId, locationId, netadpId, tagId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get networking/netadp.tag
         * @summary Get networking/netadp.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netadpId Netadp Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectNetadpTagGet(projectId: string, locationId: string, netadpId: string, tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await NetworkingProjectNetadpApiAxiosParamCreator(configuration).networkingProjectNetadpTagGet(projectId, locationId, netadpId, tagId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List networking/netadp.tag
         * @summary List networking/netadp.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netadpId Netadp Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectNetadpTagList(projectId: string, locationId: string, netadpId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await NetworkingProjectNetadpApiAxiosParamCreator(configuration).networkingProjectNetadpTagList(projectId, locationId, netadpId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Replace networking/netadp.tag
         * @summary Replace networking/netadp.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netadpId Netadp Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectNetadpTagPut(projectId: string, locationId: string, netadpId: string, tag: Array<Tag>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await NetworkingProjectNetadpApiAxiosParamCreator(configuration).networkingProjectNetadpTagPut(projectId, locationId, netadpId, tag, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns modified netadp
         * @summary Update networking/netadp
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netadpId Netadp Id
         * @param {NetworkingProjectNetadpUpdate} networkingProjectNetadpUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectNetadpUpdate(projectId: string, locationId: string, netadpId: string, networkingProjectNetadpUpdate: NetworkingProjectNetadpUpdate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Netadp>> {
            const localVarAxiosArgs = await NetworkingProjectNetadpApiAxiosParamCreator(configuration).networkingProjectNetadpUpdate(projectId, locationId, netadpId, networkingProjectNetadpUpdate, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * NetworkingProjectNetadpApi - factory interface
 * @export
 */
export const NetworkingProjectNetadpApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Create netadp
         * @summary Create networking/netadp
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {NetworkingProjectNetadpCreate} networkingProjectNetadpCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetadpCreate(projectId: string, locationId: string, networkingProjectNetadpCreate: NetworkingProjectNetadpCreate, xIdempotencyKey?: string, options?: any): AxiosPromise<Netadp> {
            return NetworkingProjectNetadpApiFp(configuration).networkingProjectNetadpCreate(projectId, locationId, networkingProjectNetadpCreate, xIdempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete netadp
         * @summary Delete networking/netadp
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netadpId Netadp Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetadpDelete(projectId: string, locationId: string, netadpId: string, options?: any): AxiosPromise<void> {
            return NetworkingProjectNetadpApiFp(configuration).networkingProjectNetadpDelete(projectId, locationId, netadpId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get networking/netadp.event
         * @summary Get networking/netadp.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netadpId Netadp Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetadpEventGet(projectId: string, locationId: string, netadpId: string, eventId: string, options?: any): AxiosPromise<Event> {
            return NetworkingProjectNetadpApiFp(configuration).networkingProjectNetadpEventGet(projectId, locationId, netadpId, eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * List networking/netadp.event
         * @summary List networking/netadp.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netadpId Netadp Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetadpEventList(projectId: string, locationId: string, netadpId: string, $limit?: number, $skip?: number, options?: any): AxiosPromise<Array<Event>> {
            return NetworkingProjectNetadpApiFp(configuration).networkingProjectNetadpEventList(projectId, locationId, netadpId, $limit, $skip, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single netadp
         * @summary Get networking/netadp
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netadpId Netadp Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetadpGet(projectId: string, locationId: string, netadpId: string, options?: any): AxiosPromise<Netadp> {
            return NetworkingProjectNetadpApiFp(configuration).networkingProjectNetadpGet(projectId, locationId, netadpId, options).then((request) => request(axios, basePath));
        },
        /**
         * List netadp
         * @summary List networking/netadp
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [assignedResource] Filter by assigned.resource
         * @param {string} [assignedId] Filter by assigned.id
         * @param {string} [network] Filter by network
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetadpList(projectId: string, locationId: string, assignedResource?: string, assignedId?: string, network?: string, tagValue?: string, tagKey?: string, options?: any): AxiosPromise<Array<Netadp>> {
            return NetworkingProjectNetadpApiFp(configuration).networkingProjectNetadpList(projectId, locationId, assignedResource, assignedId, network, tagValue, tagKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get networking/netadp.metric
         * @summary Get networking/netadp.metric
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netadpId Netadp Id
         * @param {string} metricId metricId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetadpMetricGet(projectId: string, locationId: string, netadpId: string, metricId: string, options?: any): AxiosPromise<Metric> {
            return NetworkingProjectNetadpApiFp(configuration).networkingProjectNetadpMetricGet(projectId, locationId, netadpId, metricId, options).then((request) => request(axios, basePath));
        },
        /**
         * List networking/netadp.metric
         * @summary List networking/netadp.metric
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netadpId Netadp Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetadpMetricList(projectId: string, locationId: string, netadpId: string, options?: any): AxiosPromise<Array<Metric>> {
            return NetworkingProjectNetadpApiFp(configuration).networkingProjectNetadpMetricList(projectId, locationId, netadpId, options).then((request) => request(axios, basePath));
        },
        /**
         * List networking/netadp.point
         * @summary List networking/netadp.point
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netadpId Netadp Id
         * @param {string} metricId metricId
         * @param {string} [interval] interval
         * @param {string} [timespan] timespan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetadpMetricPointList(projectId: string, locationId: string, netadpId: string, metricId: string, interval?: string, timespan?: string, options?: any): AxiosPromise<Array<Point>> {
            return NetworkingProjectNetadpApiFp(configuration).networkingProjectNetadpMetricPointList(projectId, locationId, netadpId, metricId, interval, timespan, options).then((request) => request(axios, basePath));
        },
        /**
         * Get networking/netadp.service
         * @summary Get networking/netadp.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netadpId Netadp Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetadpServiceGet(projectId: string, locationId: string, netadpId: string, serviceId: string, options?: any): AxiosPromise<ResourceService> {
            return NetworkingProjectNetadpApiFp(configuration).networkingProjectNetadpServiceGet(projectId, locationId, netadpId, serviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * List networking/netadp.service
         * @summary List networking/netadp.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netadpId Netadp Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetadpServiceList(projectId: string, locationId: string, netadpId: string, options?: any): AxiosPromise<Array<ResourceService>> {
            return NetworkingProjectNetadpApiFp(configuration).networkingProjectNetadpServiceList(projectId, locationId, netadpId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create networking/netadp.tag
         * @summary Create networking/netadp.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netadpId Netadp Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetadpTagCreate(projectId: string, locationId: string, netadpId: string, tag: Tag, options?: any): AxiosPromise<Tag> {
            return NetworkingProjectNetadpApiFp(configuration).networkingProjectNetadpTagCreate(projectId, locationId, netadpId, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete networking/netadp.tag
         * @summary Delete networking/netadp.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netadpId Netadp Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetadpTagDelete(projectId: string, locationId: string, netadpId: string, tagId: string, options?: any): AxiosPromise<void> {
            return NetworkingProjectNetadpApiFp(configuration).networkingProjectNetadpTagDelete(projectId, locationId, netadpId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get networking/netadp.tag
         * @summary Get networking/netadp.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netadpId Netadp Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetadpTagGet(projectId: string, locationId: string, netadpId: string, tagId: string, options?: any): AxiosPromise<Tag> {
            return NetworkingProjectNetadpApiFp(configuration).networkingProjectNetadpTagGet(projectId, locationId, netadpId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * List networking/netadp.tag
         * @summary List networking/netadp.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netadpId Netadp Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetadpTagList(projectId: string, locationId: string, netadpId: string, options?: any): AxiosPromise<Array<Tag>> {
            return NetworkingProjectNetadpApiFp(configuration).networkingProjectNetadpTagList(projectId, locationId, netadpId, options).then((request) => request(axios, basePath));
        },
        /**
         * Replace networking/netadp.tag
         * @summary Replace networking/netadp.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netadpId Netadp Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetadpTagPut(projectId: string, locationId: string, netadpId: string, tag: Array<Tag>, options?: any): AxiosPromise<Array<Tag>> {
            return NetworkingProjectNetadpApiFp(configuration).networkingProjectNetadpTagPut(projectId, locationId, netadpId, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns modified netadp
         * @summary Update networking/netadp
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netadpId Netadp Id
         * @param {NetworkingProjectNetadpUpdate} networkingProjectNetadpUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetadpUpdate(projectId: string, locationId: string, netadpId: string, networkingProjectNetadpUpdate: NetworkingProjectNetadpUpdate, options?: any): AxiosPromise<Netadp> {
            return NetworkingProjectNetadpApiFp(configuration).networkingProjectNetadpUpdate(projectId, locationId, netadpId, networkingProjectNetadpUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NetworkingProjectNetadpApi - object-oriented interface
 * @export
 * @class NetworkingProjectNetadpApi
 * @extends {BaseAPI}
 */
export class NetworkingProjectNetadpApi extends BaseAPI {
    /**
     * Create netadp
     * @summary Create networking/netadp
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {NetworkingProjectNetadpCreate} networkingProjectNetadpCreate 
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectNetadpApi
     */
    public networkingProjectNetadpCreate(projectId: string, locationId: string, networkingProjectNetadpCreate: NetworkingProjectNetadpCreate, xIdempotencyKey?: string, options?: any) {
        return NetworkingProjectNetadpApiFp(this.configuration).networkingProjectNetadpCreate(projectId, locationId, networkingProjectNetadpCreate, xIdempotencyKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete netadp
     * @summary Delete networking/netadp
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} netadpId Netadp Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectNetadpApi
     */
    public networkingProjectNetadpDelete(projectId: string, locationId: string, netadpId: string, options?: any) {
        return NetworkingProjectNetadpApiFp(this.configuration).networkingProjectNetadpDelete(projectId, locationId, netadpId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get networking/netadp.event
     * @summary Get networking/netadp.event
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} netadpId Netadp Id
     * @param {string} eventId eventId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectNetadpApi
     */
    public networkingProjectNetadpEventGet(projectId: string, locationId: string, netadpId: string, eventId: string, options?: any) {
        return NetworkingProjectNetadpApiFp(this.configuration).networkingProjectNetadpEventGet(projectId, locationId, netadpId, eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List networking/netadp.event
     * @summary List networking/netadp.event
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} netadpId Netadp Id
     * @param {number} [$limit] $limit
     * @param {number} [$skip] $skip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectNetadpApi
     */
    public networkingProjectNetadpEventList(projectId: string, locationId: string, netadpId: string, $limit?: number, $skip?: number, options?: any) {
        return NetworkingProjectNetadpApiFp(this.configuration).networkingProjectNetadpEventList(projectId, locationId, netadpId, $limit, $skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single netadp
     * @summary Get networking/netadp
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} netadpId Netadp Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectNetadpApi
     */
    public networkingProjectNetadpGet(projectId: string, locationId: string, netadpId: string, options?: any) {
        return NetworkingProjectNetadpApiFp(this.configuration).networkingProjectNetadpGet(projectId, locationId, netadpId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List netadp
     * @summary List networking/netadp
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} [assignedResource] Filter by assigned.resource
     * @param {string} [assignedId] Filter by assigned.id
     * @param {string} [network] Filter by network
     * @param {string} [tagValue] Filter by tag.value
     * @param {string} [tagKey] Filter by tag.key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectNetadpApi
     */
    public networkingProjectNetadpList(projectId: string, locationId: string, assignedResource?: string, assignedId?: string, network?: string, tagValue?: string, tagKey?: string, options?: any) {
        return NetworkingProjectNetadpApiFp(this.configuration).networkingProjectNetadpList(projectId, locationId, assignedResource, assignedId, network, tagValue, tagKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get networking/netadp.metric
     * @summary Get networking/netadp.metric
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} netadpId Netadp Id
     * @param {string} metricId metricId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectNetadpApi
     */
    public networkingProjectNetadpMetricGet(projectId: string, locationId: string, netadpId: string, metricId: string, options?: any) {
        return NetworkingProjectNetadpApiFp(this.configuration).networkingProjectNetadpMetricGet(projectId, locationId, netadpId, metricId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List networking/netadp.metric
     * @summary List networking/netadp.metric
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} netadpId Netadp Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectNetadpApi
     */
    public networkingProjectNetadpMetricList(projectId: string, locationId: string, netadpId: string, options?: any) {
        return NetworkingProjectNetadpApiFp(this.configuration).networkingProjectNetadpMetricList(projectId, locationId, netadpId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List networking/netadp.point
     * @summary List networking/netadp.point
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} netadpId Netadp Id
     * @param {string} metricId metricId
     * @param {string} [interval] interval
     * @param {string} [timespan] timespan
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectNetadpApi
     */
    public networkingProjectNetadpMetricPointList(projectId: string, locationId: string, netadpId: string, metricId: string, interval?: string, timespan?: string, options?: any) {
        return NetworkingProjectNetadpApiFp(this.configuration).networkingProjectNetadpMetricPointList(projectId, locationId, netadpId, metricId, interval, timespan, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get networking/netadp.service
     * @summary Get networking/netadp.service
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} netadpId Netadp Id
     * @param {string} serviceId serviceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectNetadpApi
     */
    public networkingProjectNetadpServiceGet(projectId: string, locationId: string, netadpId: string, serviceId: string, options?: any) {
        return NetworkingProjectNetadpApiFp(this.configuration).networkingProjectNetadpServiceGet(projectId, locationId, netadpId, serviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List networking/netadp.service
     * @summary List networking/netadp.service
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} netadpId Netadp Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectNetadpApi
     */
    public networkingProjectNetadpServiceList(projectId: string, locationId: string, netadpId: string, options?: any) {
        return NetworkingProjectNetadpApiFp(this.configuration).networkingProjectNetadpServiceList(projectId, locationId, netadpId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create networking/netadp.tag
     * @summary Create networking/netadp.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} netadpId Netadp Id
     * @param {Tag} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectNetadpApi
     */
    public networkingProjectNetadpTagCreate(projectId: string, locationId: string, netadpId: string, tag: Tag, options?: any) {
        return NetworkingProjectNetadpApiFp(this.configuration).networkingProjectNetadpTagCreate(projectId, locationId, netadpId, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete networking/netadp.tag
     * @summary Delete networking/netadp.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} netadpId Netadp Id
     * @param {string} tagId tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectNetadpApi
     */
    public networkingProjectNetadpTagDelete(projectId: string, locationId: string, netadpId: string, tagId: string, options?: any) {
        return NetworkingProjectNetadpApiFp(this.configuration).networkingProjectNetadpTagDelete(projectId, locationId, netadpId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get networking/netadp.tag
     * @summary Get networking/netadp.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} netadpId Netadp Id
     * @param {string} tagId tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectNetadpApi
     */
    public networkingProjectNetadpTagGet(projectId: string, locationId: string, netadpId: string, tagId: string, options?: any) {
        return NetworkingProjectNetadpApiFp(this.configuration).networkingProjectNetadpTagGet(projectId, locationId, netadpId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List networking/netadp.tag
     * @summary List networking/netadp.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} netadpId Netadp Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectNetadpApi
     */
    public networkingProjectNetadpTagList(projectId: string, locationId: string, netadpId: string, options?: any) {
        return NetworkingProjectNetadpApiFp(this.configuration).networkingProjectNetadpTagList(projectId, locationId, netadpId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replace networking/netadp.tag
     * @summary Replace networking/netadp.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} netadpId Netadp Id
     * @param {Array<Tag>} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectNetadpApi
     */
    public networkingProjectNetadpTagPut(projectId: string, locationId: string, netadpId: string, tag: Array<Tag>, options?: any) {
        return NetworkingProjectNetadpApiFp(this.configuration).networkingProjectNetadpTagPut(projectId, locationId, netadpId, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns modified netadp
     * @summary Update networking/netadp
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} netadpId Netadp Id
     * @param {NetworkingProjectNetadpUpdate} networkingProjectNetadpUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectNetadpApi
     */
    public networkingProjectNetadpUpdate(projectId: string, locationId: string, netadpId: string, networkingProjectNetadpUpdate: NetworkingProjectNetadpUpdate, options?: any) {
        return NetworkingProjectNetadpApiFp(this.configuration).networkingProjectNetadpUpdate(projectId, locationId, netadpId, networkingProjectNetadpUpdate, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * NetworkingProjectNetgwApi - axios parameter creator
 * @export
 */
export const NetworkingProjectNetgwApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * action attach
         * @summary Attach networking/netgw
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netgwId Netgw Id
         * @param {NetworkingProjectNetgwAttach} networkingProjectNetgwAttach 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetgwAttach: async (projectId: string, locationId: string, netgwId: string, networkingProjectNetgwAttach: NetworkingProjectNetgwAttach, xIdempotencyKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling networkingProjectNetgwAttach.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling networkingProjectNetgwAttach.');
            }
            // verify required parameter 'netgwId' is not null or undefined
            if (netgwId === null || netgwId === undefined) {
                throw new RequiredError('netgwId','Required parameter netgwId was null or undefined when calling networkingProjectNetgwAttach.');
            }
            // verify required parameter 'networkingProjectNetgwAttach' is not null or undefined
            if (networkingProjectNetgwAttach === null || networkingProjectNetgwAttach === undefined) {
                throw new RequiredError('networkingProjectNetgwAttach','Required parameter networkingProjectNetgwAttach was null or undefined when calling networkingProjectNetgwAttach.');
            }
            const localVarPath = `/networking/{locationId}/project/{projectId}/netgw/{netgwId}/actions/attach`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"netgwId"}}`, encodeURIComponent(String(netgwId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof networkingProjectNetgwAttach !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(networkingProjectNetgwAttach !== undefined ? networkingProjectNetgwAttach : {}) : (networkingProjectNetgwAttach || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create netgw
         * @summary Create networking/netgw
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {NetworkingProjectNetgwCreate} networkingProjectNetgwCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetgwCreate: async (projectId: string, locationId: string, networkingProjectNetgwCreate: NetworkingProjectNetgwCreate, xIdempotencyKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling networkingProjectNetgwCreate.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling networkingProjectNetgwCreate.');
            }
            // verify required parameter 'networkingProjectNetgwCreate' is not null or undefined
            if (networkingProjectNetgwCreate === null || networkingProjectNetgwCreate === undefined) {
                throw new RequiredError('networkingProjectNetgwCreate','Required parameter networkingProjectNetgwCreate was null or undefined when calling networkingProjectNetgwCreate.');
            }
            const localVarPath = `/networking/{locationId}/project/{projectId}/netgw`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof networkingProjectNetgwCreate !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(networkingProjectNetgwCreate !== undefined ? networkingProjectNetgwCreate : {}) : (networkingProjectNetgwCreate || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete netgw
         * @summary Delete networking/netgw
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netgwId Netgw Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetgwDelete: async (projectId: string, locationId: string, netgwId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling networkingProjectNetgwDelete.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling networkingProjectNetgwDelete.');
            }
            // verify required parameter 'netgwId' is not null or undefined
            if (netgwId === null || netgwId === undefined) {
                throw new RequiredError('netgwId','Required parameter netgwId was null or undefined when calling networkingProjectNetgwDelete.');
            }
            const localVarPath = `/networking/{locationId}/project/{projectId}/netgw/{netgwId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"netgwId"}}`, encodeURIComponent(String(netgwId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * action detach
         * @summary Detach networking/netgw
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netgwId Netgw Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetgwDetach: async (projectId: string, locationId: string, netgwId: string, xIdempotencyKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling networkingProjectNetgwDetach.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling networkingProjectNetgwDetach.');
            }
            // verify required parameter 'netgwId' is not null or undefined
            if (netgwId === null || netgwId === undefined) {
                throw new RequiredError('netgwId','Required parameter netgwId was null or undefined when calling networkingProjectNetgwDetach.');
            }
            const localVarPath = `/networking/{locationId}/project/{projectId}/netgw/{netgwId}/actions/detach`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"netgwId"}}`, encodeURIComponent(String(netgwId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get networking/netgw.event
         * @summary Get networking/netgw.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netgwId Netgw Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetgwEventGet: async (projectId: string, locationId: string, netgwId: string, eventId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling networkingProjectNetgwEventGet.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling networkingProjectNetgwEventGet.');
            }
            // verify required parameter 'netgwId' is not null or undefined
            if (netgwId === null || netgwId === undefined) {
                throw new RequiredError('netgwId','Required parameter netgwId was null or undefined when calling networkingProjectNetgwEventGet.');
            }
            // verify required parameter 'eventId' is not null or undefined
            if (eventId === null || eventId === undefined) {
                throw new RequiredError('eventId','Required parameter eventId was null or undefined when calling networkingProjectNetgwEventGet.');
            }
            const localVarPath = `/networking/{locationId}/project/{projectId}/netgw/{netgwId}/event/{eventId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"netgwId"}}`, encodeURIComponent(String(netgwId)))
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List networking/netgw.event
         * @summary List networking/netgw.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netgwId Netgw Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetgwEventList: async (projectId: string, locationId: string, netgwId: string, $limit?: number, $skip?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling networkingProjectNetgwEventList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling networkingProjectNetgwEventList.');
            }
            // verify required parameter 'netgwId' is not null or undefined
            if (netgwId === null || netgwId === undefined) {
                throw new RequiredError('netgwId','Required parameter netgwId was null or undefined when calling networkingProjectNetgwEventList.');
            }
            const localVarPath = `/networking/{locationId}/project/{projectId}/netgw/{netgwId}/event`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"netgwId"}}`, encodeURIComponent(String(netgwId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if ($limit !== undefined) {
                localVarQueryParameter['$limit'] = $limit;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single netgw
         * @summary Get networking/netgw
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netgwId Netgw Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetgwGet: async (projectId: string, locationId: string, netgwId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling networkingProjectNetgwGet.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling networkingProjectNetgwGet.');
            }
            // verify required parameter 'netgwId' is not null or undefined
            if (netgwId === null || netgwId === undefined) {
                throw new RequiredError('netgwId','Required parameter netgwId was null or undefined when calling networkingProjectNetgwGet.');
            }
            const localVarPath = `/networking/{locationId}/project/{projectId}/netgw/{netgwId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"netgwId"}}`, encodeURIComponent(String(netgwId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List netgw
         * @summary List networking/netgw
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [name] Filter by name
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetgwList: async (projectId: string, locationId: string, name?: string, tagValue?: string, tagKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling networkingProjectNetgwList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling networkingProjectNetgwList.');
            }
            const localVarPath = `/networking/{locationId}/project/{projectId}/netgw`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (tagValue !== undefined) {
                localVarQueryParameter['tag.value'] = tagValue;
            }

            if (tagKey !== undefined) {
                localVarQueryParameter['tag.key'] = tagKey;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get networking/netgw.service
         * @summary Get networking/netgw.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netgwId Netgw Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetgwServiceGet: async (projectId: string, locationId: string, netgwId: string, serviceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling networkingProjectNetgwServiceGet.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling networkingProjectNetgwServiceGet.');
            }
            // verify required parameter 'netgwId' is not null or undefined
            if (netgwId === null || netgwId === undefined) {
                throw new RequiredError('netgwId','Required parameter netgwId was null or undefined when calling networkingProjectNetgwServiceGet.');
            }
            // verify required parameter 'serviceId' is not null or undefined
            if (serviceId === null || serviceId === undefined) {
                throw new RequiredError('serviceId','Required parameter serviceId was null or undefined when calling networkingProjectNetgwServiceGet.');
            }
            const localVarPath = `/networking/{locationId}/project/{projectId}/netgw/{netgwId}/service/{serviceId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"netgwId"}}`, encodeURIComponent(String(netgwId)))
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List networking/netgw.service
         * @summary List networking/netgw.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netgwId Netgw Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetgwServiceList: async (projectId: string, locationId: string, netgwId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling networkingProjectNetgwServiceList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling networkingProjectNetgwServiceList.');
            }
            // verify required parameter 'netgwId' is not null or undefined
            if (netgwId === null || netgwId === undefined) {
                throw new RequiredError('netgwId','Required parameter netgwId was null or undefined when calling networkingProjectNetgwServiceList.');
            }
            const localVarPath = `/networking/{locationId}/project/{projectId}/netgw/{netgwId}/service`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"netgwId"}}`, encodeURIComponent(String(netgwId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create networking/netgw.tag
         * @summary Create networking/netgw.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netgwId Netgw Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetgwTagCreate: async (projectId: string, locationId: string, netgwId: string, tag: Tag, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling networkingProjectNetgwTagCreate.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling networkingProjectNetgwTagCreate.');
            }
            // verify required parameter 'netgwId' is not null or undefined
            if (netgwId === null || netgwId === undefined) {
                throw new RequiredError('netgwId','Required parameter netgwId was null or undefined when calling networkingProjectNetgwTagCreate.');
            }
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling networkingProjectNetgwTagCreate.');
            }
            const localVarPath = `/networking/{locationId}/project/{projectId}/netgw/{netgwId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"netgwId"}}`, encodeURIComponent(String(netgwId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof tag !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(tag !== undefined ? tag : {}) : (tag || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete networking/netgw.tag
         * @summary Delete networking/netgw.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netgwId Netgw Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetgwTagDelete: async (projectId: string, locationId: string, netgwId: string, tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling networkingProjectNetgwTagDelete.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling networkingProjectNetgwTagDelete.');
            }
            // verify required parameter 'netgwId' is not null or undefined
            if (netgwId === null || netgwId === undefined) {
                throw new RequiredError('netgwId','Required parameter netgwId was null or undefined when calling networkingProjectNetgwTagDelete.');
            }
            // verify required parameter 'tagId' is not null or undefined
            if (tagId === null || tagId === undefined) {
                throw new RequiredError('tagId','Required parameter tagId was null or undefined when calling networkingProjectNetgwTagDelete.');
            }
            const localVarPath = `/networking/{locationId}/project/{projectId}/netgw/{netgwId}/tag/{tagId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"netgwId"}}`, encodeURIComponent(String(netgwId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get networking/netgw.tag
         * @summary Get networking/netgw.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netgwId Netgw Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetgwTagGet: async (projectId: string, locationId: string, netgwId: string, tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling networkingProjectNetgwTagGet.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling networkingProjectNetgwTagGet.');
            }
            // verify required parameter 'netgwId' is not null or undefined
            if (netgwId === null || netgwId === undefined) {
                throw new RequiredError('netgwId','Required parameter netgwId was null or undefined when calling networkingProjectNetgwTagGet.');
            }
            // verify required parameter 'tagId' is not null or undefined
            if (tagId === null || tagId === undefined) {
                throw new RequiredError('tagId','Required parameter tagId was null or undefined when calling networkingProjectNetgwTagGet.');
            }
            const localVarPath = `/networking/{locationId}/project/{projectId}/netgw/{netgwId}/tag/{tagId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"netgwId"}}`, encodeURIComponent(String(netgwId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List networking/netgw.tag
         * @summary List networking/netgw.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netgwId Netgw Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetgwTagList: async (projectId: string, locationId: string, netgwId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling networkingProjectNetgwTagList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling networkingProjectNetgwTagList.');
            }
            // verify required parameter 'netgwId' is not null or undefined
            if (netgwId === null || netgwId === undefined) {
                throw new RequiredError('netgwId','Required parameter netgwId was null or undefined when calling networkingProjectNetgwTagList.');
            }
            const localVarPath = `/networking/{locationId}/project/{projectId}/netgw/{netgwId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"netgwId"}}`, encodeURIComponent(String(netgwId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replace networking/netgw.tag
         * @summary Replace networking/netgw.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netgwId Netgw Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetgwTagPut: async (projectId: string, locationId: string, netgwId: string, tag: Array<Tag>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling networkingProjectNetgwTagPut.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling networkingProjectNetgwTagPut.');
            }
            // verify required parameter 'netgwId' is not null or undefined
            if (netgwId === null || netgwId === undefined) {
                throw new RequiredError('netgwId','Required parameter netgwId was null or undefined when calling networkingProjectNetgwTagPut.');
            }
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling networkingProjectNetgwTagPut.');
            }
            const localVarPath = `/networking/{locationId}/project/{projectId}/netgw/{netgwId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"netgwId"}}`, encodeURIComponent(String(netgwId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof tag !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(tag !== undefined ? tag : {}) : (tag || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns modified netgw
         * @summary Update networking/netgw
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netgwId Netgw Id
         * @param {NetworkingProjectNetgwUpdate} networkingProjectNetgwUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetgwUpdate: async (projectId: string, locationId: string, netgwId: string, networkingProjectNetgwUpdate: NetworkingProjectNetgwUpdate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling networkingProjectNetgwUpdate.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling networkingProjectNetgwUpdate.');
            }
            // verify required parameter 'netgwId' is not null or undefined
            if (netgwId === null || netgwId === undefined) {
                throw new RequiredError('netgwId','Required parameter netgwId was null or undefined when calling networkingProjectNetgwUpdate.');
            }
            // verify required parameter 'networkingProjectNetgwUpdate' is not null or undefined
            if (networkingProjectNetgwUpdate === null || networkingProjectNetgwUpdate === undefined) {
                throw new RequiredError('networkingProjectNetgwUpdate','Required parameter networkingProjectNetgwUpdate was null or undefined when calling networkingProjectNetgwUpdate.');
            }
            const localVarPath = `/networking/{locationId}/project/{projectId}/netgw/{netgwId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"netgwId"}}`, encodeURIComponent(String(netgwId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof networkingProjectNetgwUpdate !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(networkingProjectNetgwUpdate !== undefined ? networkingProjectNetgwUpdate : {}) : (networkingProjectNetgwUpdate || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NetworkingProjectNetgwApi - functional programming interface
 * @export
 */
export const NetworkingProjectNetgwApiFp = function(configuration?: Configuration) {
    return {
        /**
         * action attach
         * @summary Attach networking/netgw
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netgwId Netgw Id
         * @param {NetworkingProjectNetgwAttach} networkingProjectNetgwAttach 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectNetgwAttach(projectId: string, locationId: string, netgwId: string, networkingProjectNetgwAttach: NetworkingProjectNetgwAttach, xIdempotencyKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Netgw>> {
            const localVarAxiosArgs = await NetworkingProjectNetgwApiAxiosParamCreator(configuration).networkingProjectNetgwAttach(projectId, locationId, netgwId, networkingProjectNetgwAttach, xIdempotencyKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create netgw
         * @summary Create networking/netgw
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {NetworkingProjectNetgwCreate} networkingProjectNetgwCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectNetgwCreate(projectId: string, locationId: string, networkingProjectNetgwCreate: NetworkingProjectNetgwCreate, xIdempotencyKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Netgw>> {
            const localVarAxiosArgs = await NetworkingProjectNetgwApiAxiosParamCreator(configuration).networkingProjectNetgwCreate(projectId, locationId, networkingProjectNetgwCreate, xIdempotencyKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete netgw
         * @summary Delete networking/netgw
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netgwId Netgw Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectNetgwDelete(projectId: string, locationId: string, netgwId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await NetworkingProjectNetgwApiAxiosParamCreator(configuration).networkingProjectNetgwDelete(projectId, locationId, netgwId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * action detach
         * @summary Detach networking/netgw
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netgwId Netgw Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectNetgwDetach(projectId: string, locationId: string, netgwId: string, xIdempotencyKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Netgw>> {
            const localVarAxiosArgs = await NetworkingProjectNetgwApiAxiosParamCreator(configuration).networkingProjectNetgwDetach(projectId, locationId, netgwId, xIdempotencyKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get networking/netgw.event
         * @summary Get networking/netgw.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netgwId Netgw Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectNetgwEventGet(projectId: string, locationId: string, netgwId: string, eventId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>> {
            const localVarAxiosArgs = await NetworkingProjectNetgwApiAxiosParamCreator(configuration).networkingProjectNetgwEventGet(projectId, locationId, netgwId, eventId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List networking/netgw.event
         * @summary List networking/netgw.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netgwId Netgw Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectNetgwEventList(projectId: string, locationId: string, netgwId: string, $limit?: number, $skip?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Event>>> {
            const localVarAxiosArgs = await NetworkingProjectNetgwApiAxiosParamCreator(configuration).networkingProjectNetgwEventList(projectId, locationId, netgwId, $limit, $skip, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a single netgw
         * @summary Get networking/netgw
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netgwId Netgw Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectNetgwGet(projectId: string, locationId: string, netgwId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Netgw>> {
            const localVarAxiosArgs = await NetworkingProjectNetgwApiAxiosParamCreator(configuration).networkingProjectNetgwGet(projectId, locationId, netgwId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List netgw
         * @summary List networking/netgw
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [name] Filter by name
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectNetgwList(projectId: string, locationId: string, name?: string, tagValue?: string, tagKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Netgw>>> {
            const localVarAxiosArgs = await NetworkingProjectNetgwApiAxiosParamCreator(configuration).networkingProjectNetgwList(projectId, locationId, name, tagValue, tagKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get networking/netgw.service
         * @summary Get networking/netgw.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netgwId Netgw Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectNetgwServiceGet(projectId: string, locationId: string, netgwId: string, serviceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceService>> {
            const localVarAxiosArgs = await NetworkingProjectNetgwApiAxiosParamCreator(configuration).networkingProjectNetgwServiceGet(projectId, locationId, netgwId, serviceId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List networking/netgw.service
         * @summary List networking/netgw.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netgwId Netgw Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectNetgwServiceList(projectId: string, locationId: string, netgwId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResourceService>>> {
            const localVarAxiosArgs = await NetworkingProjectNetgwApiAxiosParamCreator(configuration).networkingProjectNetgwServiceList(projectId, locationId, netgwId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create networking/netgw.tag
         * @summary Create networking/netgw.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netgwId Netgw Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectNetgwTagCreate(projectId: string, locationId: string, netgwId: string, tag: Tag, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await NetworkingProjectNetgwApiAxiosParamCreator(configuration).networkingProjectNetgwTagCreate(projectId, locationId, netgwId, tag, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete networking/netgw.tag
         * @summary Delete networking/netgw.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netgwId Netgw Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectNetgwTagDelete(projectId: string, locationId: string, netgwId: string, tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await NetworkingProjectNetgwApiAxiosParamCreator(configuration).networkingProjectNetgwTagDelete(projectId, locationId, netgwId, tagId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get networking/netgw.tag
         * @summary Get networking/netgw.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netgwId Netgw Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectNetgwTagGet(projectId: string, locationId: string, netgwId: string, tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await NetworkingProjectNetgwApiAxiosParamCreator(configuration).networkingProjectNetgwTagGet(projectId, locationId, netgwId, tagId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List networking/netgw.tag
         * @summary List networking/netgw.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netgwId Netgw Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectNetgwTagList(projectId: string, locationId: string, netgwId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await NetworkingProjectNetgwApiAxiosParamCreator(configuration).networkingProjectNetgwTagList(projectId, locationId, netgwId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Replace networking/netgw.tag
         * @summary Replace networking/netgw.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netgwId Netgw Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectNetgwTagPut(projectId: string, locationId: string, netgwId: string, tag: Array<Tag>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await NetworkingProjectNetgwApiAxiosParamCreator(configuration).networkingProjectNetgwTagPut(projectId, locationId, netgwId, tag, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns modified netgw
         * @summary Update networking/netgw
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netgwId Netgw Id
         * @param {NetworkingProjectNetgwUpdate} networkingProjectNetgwUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectNetgwUpdate(projectId: string, locationId: string, netgwId: string, networkingProjectNetgwUpdate: NetworkingProjectNetgwUpdate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Netgw>> {
            const localVarAxiosArgs = await NetworkingProjectNetgwApiAxiosParamCreator(configuration).networkingProjectNetgwUpdate(projectId, locationId, netgwId, networkingProjectNetgwUpdate, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * NetworkingProjectNetgwApi - factory interface
 * @export
 */
export const NetworkingProjectNetgwApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * action attach
         * @summary Attach networking/netgw
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netgwId Netgw Id
         * @param {NetworkingProjectNetgwAttach} networkingProjectNetgwAttach 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetgwAttach(projectId: string, locationId: string, netgwId: string, networkingProjectNetgwAttach: NetworkingProjectNetgwAttach, xIdempotencyKey?: string, options?: any): AxiosPromise<Netgw> {
            return NetworkingProjectNetgwApiFp(configuration).networkingProjectNetgwAttach(projectId, locationId, netgwId, networkingProjectNetgwAttach, xIdempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Create netgw
         * @summary Create networking/netgw
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {NetworkingProjectNetgwCreate} networkingProjectNetgwCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetgwCreate(projectId: string, locationId: string, networkingProjectNetgwCreate: NetworkingProjectNetgwCreate, xIdempotencyKey?: string, options?: any): AxiosPromise<Netgw> {
            return NetworkingProjectNetgwApiFp(configuration).networkingProjectNetgwCreate(projectId, locationId, networkingProjectNetgwCreate, xIdempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete netgw
         * @summary Delete networking/netgw
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netgwId Netgw Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetgwDelete(projectId: string, locationId: string, netgwId: string, options?: any): AxiosPromise<void> {
            return NetworkingProjectNetgwApiFp(configuration).networkingProjectNetgwDelete(projectId, locationId, netgwId, options).then((request) => request(axios, basePath));
        },
        /**
         * action detach
         * @summary Detach networking/netgw
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netgwId Netgw Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetgwDetach(projectId: string, locationId: string, netgwId: string, xIdempotencyKey?: string, options?: any): AxiosPromise<Netgw> {
            return NetworkingProjectNetgwApiFp(configuration).networkingProjectNetgwDetach(projectId, locationId, netgwId, xIdempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get networking/netgw.event
         * @summary Get networking/netgw.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netgwId Netgw Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetgwEventGet(projectId: string, locationId: string, netgwId: string, eventId: string, options?: any): AxiosPromise<Event> {
            return NetworkingProjectNetgwApiFp(configuration).networkingProjectNetgwEventGet(projectId, locationId, netgwId, eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * List networking/netgw.event
         * @summary List networking/netgw.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netgwId Netgw Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetgwEventList(projectId: string, locationId: string, netgwId: string, $limit?: number, $skip?: number, options?: any): AxiosPromise<Array<Event>> {
            return NetworkingProjectNetgwApiFp(configuration).networkingProjectNetgwEventList(projectId, locationId, netgwId, $limit, $skip, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single netgw
         * @summary Get networking/netgw
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netgwId Netgw Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetgwGet(projectId: string, locationId: string, netgwId: string, options?: any): AxiosPromise<Netgw> {
            return NetworkingProjectNetgwApiFp(configuration).networkingProjectNetgwGet(projectId, locationId, netgwId, options).then((request) => request(axios, basePath));
        },
        /**
         * List netgw
         * @summary List networking/netgw
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [name] Filter by name
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetgwList(projectId: string, locationId: string, name?: string, tagValue?: string, tagKey?: string, options?: any): AxiosPromise<Array<Netgw>> {
            return NetworkingProjectNetgwApiFp(configuration).networkingProjectNetgwList(projectId, locationId, name, tagValue, tagKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get networking/netgw.service
         * @summary Get networking/netgw.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netgwId Netgw Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetgwServiceGet(projectId: string, locationId: string, netgwId: string, serviceId: string, options?: any): AxiosPromise<ResourceService> {
            return NetworkingProjectNetgwApiFp(configuration).networkingProjectNetgwServiceGet(projectId, locationId, netgwId, serviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * List networking/netgw.service
         * @summary List networking/netgw.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netgwId Netgw Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetgwServiceList(projectId: string, locationId: string, netgwId: string, options?: any): AxiosPromise<Array<ResourceService>> {
            return NetworkingProjectNetgwApiFp(configuration).networkingProjectNetgwServiceList(projectId, locationId, netgwId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create networking/netgw.tag
         * @summary Create networking/netgw.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netgwId Netgw Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetgwTagCreate(projectId: string, locationId: string, netgwId: string, tag: Tag, options?: any): AxiosPromise<Tag> {
            return NetworkingProjectNetgwApiFp(configuration).networkingProjectNetgwTagCreate(projectId, locationId, netgwId, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete networking/netgw.tag
         * @summary Delete networking/netgw.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netgwId Netgw Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetgwTagDelete(projectId: string, locationId: string, netgwId: string, tagId: string, options?: any): AxiosPromise<void> {
            return NetworkingProjectNetgwApiFp(configuration).networkingProjectNetgwTagDelete(projectId, locationId, netgwId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get networking/netgw.tag
         * @summary Get networking/netgw.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netgwId Netgw Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetgwTagGet(projectId: string, locationId: string, netgwId: string, tagId: string, options?: any): AxiosPromise<Tag> {
            return NetworkingProjectNetgwApiFp(configuration).networkingProjectNetgwTagGet(projectId, locationId, netgwId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * List networking/netgw.tag
         * @summary List networking/netgw.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netgwId Netgw Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetgwTagList(projectId: string, locationId: string, netgwId: string, options?: any): AxiosPromise<Array<Tag>> {
            return NetworkingProjectNetgwApiFp(configuration).networkingProjectNetgwTagList(projectId, locationId, netgwId, options).then((request) => request(axios, basePath));
        },
        /**
         * Replace networking/netgw.tag
         * @summary Replace networking/netgw.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netgwId Netgw Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetgwTagPut(projectId: string, locationId: string, netgwId: string, tag: Array<Tag>, options?: any): AxiosPromise<Array<Tag>> {
            return NetworkingProjectNetgwApiFp(configuration).networkingProjectNetgwTagPut(projectId, locationId, netgwId, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns modified netgw
         * @summary Update networking/netgw
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netgwId Netgw Id
         * @param {NetworkingProjectNetgwUpdate} networkingProjectNetgwUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetgwUpdate(projectId: string, locationId: string, netgwId: string, networkingProjectNetgwUpdate: NetworkingProjectNetgwUpdate, options?: any): AxiosPromise<Netgw> {
            return NetworkingProjectNetgwApiFp(configuration).networkingProjectNetgwUpdate(projectId, locationId, netgwId, networkingProjectNetgwUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NetworkingProjectNetgwApi - object-oriented interface
 * @export
 * @class NetworkingProjectNetgwApi
 * @extends {BaseAPI}
 */
export class NetworkingProjectNetgwApi extends BaseAPI {
    /**
     * action attach
     * @summary Attach networking/netgw
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} netgwId Netgw Id
     * @param {NetworkingProjectNetgwAttach} networkingProjectNetgwAttach 
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectNetgwApi
     */
    public networkingProjectNetgwAttach(projectId: string, locationId: string, netgwId: string, networkingProjectNetgwAttach: NetworkingProjectNetgwAttach, xIdempotencyKey?: string, options?: any) {
        return NetworkingProjectNetgwApiFp(this.configuration).networkingProjectNetgwAttach(projectId, locationId, netgwId, networkingProjectNetgwAttach, xIdempotencyKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create netgw
     * @summary Create networking/netgw
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {NetworkingProjectNetgwCreate} networkingProjectNetgwCreate 
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectNetgwApi
     */
    public networkingProjectNetgwCreate(projectId: string, locationId: string, networkingProjectNetgwCreate: NetworkingProjectNetgwCreate, xIdempotencyKey?: string, options?: any) {
        return NetworkingProjectNetgwApiFp(this.configuration).networkingProjectNetgwCreate(projectId, locationId, networkingProjectNetgwCreate, xIdempotencyKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete netgw
     * @summary Delete networking/netgw
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} netgwId Netgw Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectNetgwApi
     */
    public networkingProjectNetgwDelete(projectId: string, locationId: string, netgwId: string, options?: any) {
        return NetworkingProjectNetgwApiFp(this.configuration).networkingProjectNetgwDelete(projectId, locationId, netgwId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * action detach
     * @summary Detach networking/netgw
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} netgwId Netgw Id
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectNetgwApi
     */
    public networkingProjectNetgwDetach(projectId: string, locationId: string, netgwId: string, xIdempotencyKey?: string, options?: any) {
        return NetworkingProjectNetgwApiFp(this.configuration).networkingProjectNetgwDetach(projectId, locationId, netgwId, xIdempotencyKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get networking/netgw.event
     * @summary Get networking/netgw.event
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} netgwId Netgw Id
     * @param {string} eventId eventId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectNetgwApi
     */
    public networkingProjectNetgwEventGet(projectId: string, locationId: string, netgwId: string, eventId: string, options?: any) {
        return NetworkingProjectNetgwApiFp(this.configuration).networkingProjectNetgwEventGet(projectId, locationId, netgwId, eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List networking/netgw.event
     * @summary List networking/netgw.event
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} netgwId Netgw Id
     * @param {number} [$limit] $limit
     * @param {number} [$skip] $skip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectNetgwApi
     */
    public networkingProjectNetgwEventList(projectId: string, locationId: string, netgwId: string, $limit?: number, $skip?: number, options?: any) {
        return NetworkingProjectNetgwApiFp(this.configuration).networkingProjectNetgwEventList(projectId, locationId, netgwId, $limit, $skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single netgw
     * @summary Get networking/netgw
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} netgwId Netgw Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectNetgwApi
     */
    public networkingProjectNetgwGet(projectId: string, locationId: string, netgwId: string, options?: any) {
        return NetworkingProjectNetgwApiFp(this.configuration).networkingProjectNetgwGet(projectId, locationId, netgwId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List netgw
     * @summary List networking/netgw
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} [name] Filter by name
     * @param {string} [tagValue] Filter by tag.value
     * @param {string} [tagKey] Filter by tag.key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectNetgwApi
     */
    public networkingProjectNetgwList(projectId: string, locationId: string, name?: string, tagValue?: string, tagKey?: string, options?: any) {
        return NetworkingProjectNetgwApiFp(this.configuration).networkingProjectNetgwList(projectId, locationId, name, tagValue, tagKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get networking/netgw.service
     * @summary Get networking/netgw.service
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} netgwId Netgw Id
     * @param {string} serviceId serviceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectNetgwApi
     */
    public networkingProjectNetgwServiceGet(projectId: string, locationId: string, netgwId: string, serviceId: string, options?: any) {
        return NetworkingProjectNetgwApiFp(this.configuration).networkingProjectNetgwServiceGet(projectId, locationId, netgwId, serviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List networking/netgw.service
     * @summary List networking/netgw.service
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} netgwId Netgw Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectNetgwApi
     */
    public networkingProjectNetgwServiceList(projectId: string, locationId: string, netgwId: string, options?: any) {
        return NetworkingProjectNetgwApiFp(this.configuration).networkingProjectNetgwServiceList(projectId, locationId, netgwId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create networking/netgw.tag
     * @summary Create networking/netgw.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} netgwId Netgw Id
     * @param {Tag} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectNetgwApi
     */
    public networkingProjectNetgwTagCreate(projectId: string, locationId: string, netgwId: string, tag: Tag, options?: any) {
        return NetworkingProjectNetgwApiFp(this.configuration).networkingProjectNetgwTagCreate(projectId, locationId, netgwId, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete networking/netgw.tag
     * @summary Delete networking/netgw.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} netgwId Netgw Id
     * @param {string} tagId tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectNetgwApi
     */
    public networkingProjectNetgwTagDelete(projectId: string, locationId: string, netgwId: string, tagId: string, options?: any) {
        return NetworkingProjectNetgwApiFp(this.configuration).networkingProjectNetgwTagDelete(projectId, locationId, netgwId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get networking/netgw.tag
     * @summary Get networking/netgw.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} netgwId Netgw Id
     * @param {string} tagId tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectNetgwApi
     */
    public networkingProjectNetgwTagGet(projectId: string, locationId: string, netgwId: string, tagId: string, options?: any) {
        return NetworkingProjectNetgwApiFp(this.configuration).networkingProjectNetgwTagGet(projectId, locationId, netgwId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List networking/netgw.tag
     * @summary List networking/netgw.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} netgwId Netgw Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectNetgwApi
     */
    public networkingProjectNetgwTagList(projectId: string, locationId: string, netgwId: string, options?: any) {
        return NetworkingProjectNetgwApiFp(this.configuration).networkingProjectNetgwTagList(projectId, locationId, netgwId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replace networking/netgw.tag
     * @summary Replace networking/netgw.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} netgwId Netgw Id
     * @param {Array<Tag>} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectNetgwApi
     */
    public networkingProjectNetgwTagPut(projectId: string, locationId: string, netgwId: string, tag: Array<Tag>, options?: any) {
        return NetworkingProjectNetgwApiFp(this.configuration).networkingProjectNetgwTagPut(projectId, locationId, netgwId, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns modified netgw
     * @summary Update networking/netgw
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} netgwId Netgw Id
     * @param {NetworkingProjectNetgwUpdate} networkingProjectNetgwUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectNetgwApi
     */
    public networkingProjectNetgwUpdate(projectId: string, locationId: string, netgwId: string, networkingProjectNetgwUpdate: NetworkingProjectNetgwUpdate, options?: any) {
        return NetworkingProjectNetgwApiFp(this.configuration).networkingProjectNetgwUpdate(projectId, locationId, netgwId, networkingProjectNetgwUpdate, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * NetworkingProjectNetworkApi - axios parameter creator
 * @export
 */
export const NetworkingProjectNetworkApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create network
         * @summary Create networking/network
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {NetworkingProjectNetworkCreate} networkingProjectNetworkCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetworkCreate: async (projectId: string, locationId: string, networkingProjectNetworkCreate: NetworkingProjectNetworkCreate, xIdempotencyKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling networkingProjectNetworkCreate.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling networkingProjectNetworkCreate.');
            }
            // verify required parameter 'networkingProjectNetworkCreate' is not null or undefined
            if (networkingProjectNetworkCreate === null || networkingProjectNetworkCreate === undefined) {
                throw new RequiredError('networkingProjectNetworkCreate','Required parameter networkingProjectNetworkCreate was null or undefined when calling networkingProjectNetworkCreate.');
            }
            const localVarPath = `/networking/{locationId}/project/{projectId}/network`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof networkingProjectNetworkCreate !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(networkingProjectNetworkCreate !== undefined ? networkingProjectNetworkCreate : {}) : (networkingProjectNetworkCreate || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete network
         * @summary Delete networking/network
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} networkId Network Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetworkDelete: async (projectId: string, locationId: string, networkId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling networkingProjectNetworkDelete.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling networkingProjectNetworkDelete.');
            }
            // verify required parameter 'networkId' is not null or undefined
            if (networkId === null || networkId === undefined) {
                throw new RequiredError('networkId','Required parameter networkId was null or undefined when calling networkingProjectNetworkDelete.');
            }
            const localVarPath = `/networking/{locationId}/project/{projectId}/network/{networkId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"networkId"}}`, encodeURIComponent(String(networkId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get networking/network.event
         * @summary Get networking/network.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} networkId Network Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetworkEventGet: async (projectId: string, locationId: string, networkId: string, eventId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling networkingProjectNetworkEventGet.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling networkingProjectNetworkEventGet.');
            }
            // verify required parameter 'networkId' is not null or undefined
            if (networkId === null || networkId === undefined) {
                throw new RequiredError('networkId','Required parameter networkId was null or undefined when calling networkingProjectNetworkEventGet.');
            }
            // verify required parameter 'eventId' is not null or undefined
            if (eventId === null || eventId === undefined) {
                throw new RequiredError('eventId','Required parameter eventId was null or undefined when calling networkingProjectNetworkEventGet.');
            }
            const localVarPath = `/networking/{locationId}/project/{projectId}/network/{networkId}/event/{eventId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"networkId"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List networking/network.event
         * @summary List networking/network.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} networkId Network Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetworkEventList: async (projectId: string, locationId: string, networkId: string, $limit?: number, $skip?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling networkingProjectNetworkEventList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling networkingProjectNetworkEventList.');
            }
            // verify required parameter 'networkId' is not null or undefined
            if (networkId === null || networkId === undefined) {
                throw new RequiredError('networkId','Required parameter networkId was null or undefined when calling networkingProjectNetworkEventList.');
            }
            const localVarPath = `/networking/{locationId}/project/{projectId}/network/{networkId}/event`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"networkId"}}`, encodeURIComponent(String(networkId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if ($limit !== undefined) {
                localVarQueryParameter['$limit'] = $limit;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single network
         * @summary Get networking/network
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} networkId Network Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetworkGet: async (projectId: string, locationId: string, networkId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling networkingProjectNetworkGet.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling networkingProjectNetworkGet.');
            }
            // verify required parameter 'networkId' is not null or undefined
            if (networkId === null || networkId === undefined) {
                throw new RequiredError('networkId','Required parameter networkId was null or undefined when calling networkingProjectNetworkGet.');
            }
            const localVarPath = `/networking/{locationId}/project/{projectId}/network/{networkId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"networkId"}}`, encodeURIComponent(String(networkId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List network
         * @summary List networking/network
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [name] Filter by name
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetworkList: async (projectId: string, locationId: string, name?: string, tagValue?: string, tagKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling networkingProjectNetworkList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling networkingProjectNetworkList.');
            }
            const localVarPath = `/networking/{locationId}/project/{projectId}/network`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (tagValue !== undefined) {
                localVarQueryParameter['tag.value'] = tagValue;
            }

            if (tagKey !== undefined) {
                localVarQueryParameter['tag.key'] = tagKey;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get networking/network.service
         * @summary Get networking/network.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} networkId Network Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetworkServiceGet: async (projectId: string, locationId: string, networkId: string, serviceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling networkingProjectNetworkServiceGet.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling networkingProjectNetworkServiceGet.');
            }
            // verify required parameter 'networkId' is not null or undefined
            if (networkId === null || networkId === undefined) {
                throw new RequiredError('networkId','Required parameter networkId was null or undefined when calling networkingProjectNetworkServiceGet.');
            }
            // verify required parameter 'serviceId' is not null or undefined
            if (serviceId === null || serviceId === undefined) {
                throw new RequiredError('serviceId','Required parameter serviceId was null or undefined when calling networkingProjectNetworkServiceGet.');
            }
            const localVarPath = `/networking/{locationId}/project/{projectId}/network/{networkId}/service/{serviceId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"networkId"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List networking/network.service
         * @summary List networking/network.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} networkId Network Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetworkServiceList: async (projectId: string, locationId: string, networkId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling networkingProjectNetworkServiceList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling networkingProjectNetworkServiceList.');
            }
            // verify required parameter 'networkId' is not null or undefined
            if (networkId === null || networkId === undefined) {
                throw new RequiredError('networkId','Required parameter networkId was null or undefined when calling networkingProjectNetworkServiceList.');
            }
            const localVarPath = `/networking/{locationId}/project/{projectId}/network/{networkId}/service`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"networkId"}}`, encodeURIComponent(String(networkId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create networking/network.tag
         * @summary Create networking/network.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} networkId Network Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetworkTagCreate: async (projectId: string, locationId: string, networkId: string, tag: Tag, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling networkingProjectNetworkTagCreate.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling networkingProjectNetworkTagCreate.');
            }
            // verify required parameter 'networkId' is not null or undefined
            if (networkId === null || networkId === undefined) {
                throw new RequiredError('networkId','Required parameter networkId was null or undefined when calling networkingProjectNetworkTagCreate.');
            }
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling networkingProjectNetworkTagCreate.');
            }
            const localVarPath = `/networking/{locationId}/project/{projectId}/network/{networkId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"networkId"}}`, encodeURIComponent(String(networkId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof tag !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(tag !== undefined ? tag : {}) : (tag || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete networking/network.tag
         * @summary Delete networking/network.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} networkId Network Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetworkTagDelete: async (projectId: string, locationId: string, networkId: string, tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling networkingProjectNetworkTagDelete.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling networkingProjectNetworkTagDelete.');
            }
            // verify required parameter 'networkId' is not null or undefined
            if (networkId === null || networkId === undefined) {
                throw new RequiredError('networkId','Required parameter networkId was null or undefined when calling networkingProjectNetworkTagDelete.');
            }
            // verify required parameter 'tagId' is not null or undefined
            if (tagId === null || tagId === undefined) {
                throw new RequiredError('tagId','Required parameter tagId was null or undefined when calling networkingProjectNetworkTagDelete.');
            }
            const localVarPath = `/networking/{locationId}/project/{projectId}/network/{networkId}/tag/{tagId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"networkId"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get networking/network.tag
         * @summary Get networking/network.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} networkId Network Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetworkTagGet: async (projectId: string, locationId: string, networkId: string, tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling networkingProjectNetworkTagGet.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling networkingProjectNetworkTagGet.');
            }
            // verify required parameter 'networkId' is not null or undefined
            if (networkId === null || networkId === undefined) {
                throw new RequiredError('networkId','Required parameter networkId was null or undefined when calling networkingProjectNetworkTagGet.');
            }
            // verify required parameter 'tagId' is not null or undefined
            if (tagId === null || tagId === undefined) {
                throw new RequiredError('tagId','Required parameter tagId was null or undefined when calling networkingProjectNetworkTagGet.');
            }
            const localVarPath = `/networking/{locationId}/project/{projectId}/network/{networkId}/tag/{tagId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"networkId"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List networking/network.tag
         * @summary List networking/network.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} networkId Network Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetworkTagList: async (projectId: string, locationId: string, networkId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling networkingProjectNetworkTagList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling networkingProjectNetworkTagList.');
            }
            // verify required parameter 'networkId' is not null or undefined
            if (networkId === null || networkId === undefined) {
                throw new RequiredError('networkId','Required parameter networkId was null or undefined when calling networkingProjectNetworkTagList.');
            }
            const localVarPath = `/networking/{locationId}/project/{projectId}/network/{networkId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"networkId"}}`, encodeURIComponent(String(networkId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replace networking/network.tag
         * @summary Replace networking/network.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} networkId Network Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetworkTagPut: async (projectId: string, locationId: string, networkId: string, tag: Array<Tag>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling networkingProjectNetworkTagPut.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling networkingProjectNetworkTagPut.');
            }
            // verify required parameter 'networkId' is not null or undefined
            if (networkId === null || networkId === undefined) {
                throw new RequiredError('networkId','Required parameter networkId was null or undefined when calling networkingProjectNetworkTagPut.');
            }
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling networkingProjectNetworkTagPut.');
            }
            const localVarPath = `/networking/{locationId}/project/{projectId}/network/{networkId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"networkId"}}`, encodeURIComponent(String(networkId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof tag !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(tag !== undefined ? tag : {}) : (tag || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns modified network
         * @summary Update networking/network
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} networkId Network Id
         * @param {NetworkingProjectNetworkUpdate} networkingProjectNetworkUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetworkUpdate: async (projectId: string, locationId: string, networkId: string, networkingProjectNetworkUpdate: NetworkingProjectNetworkUpdate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling networkingProjectNetworkUpdate.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling networkingProjectNetworkUpdate.');
            }
            // verify required parameter 'networkId' is not null or undefined
            if (networkId === null || networkId === undefined) {
                throw new RequiredError('networkId','Required parameter networkId was null or undefined when calling networkingProjectNetworkUpdate.');
            }
            // verify required parameter 'networkingProjectNetworkUpdate' is not null or undefined
            if (networkingProjectNetworkUpdate === null || networkingProjectNetworkUpdate === undefined) {
                throw new RequiredError('networkingProjectNetworkUpdate','Required parameter networkingProjectNetworkUpdate was null or undefined when calling networkingProjectNetworkUpdate.');
            }
            const localVarPath = `/networking/{locationId}/project/{projectId}/network/{networkId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"networkId"}}`, encodeURIComponent(String(networkId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof networkingProjectNetworkUpdate !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(networkingProjectNetworkUpdate !== undefined ? networkingProjectNetworkUpdate : {}) : (networkingProjectNetworkUpdate || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NetworkingProjectNetworkApi - functional programming interface
 * @export
 */
export const NetworkingProjectNetworkApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create network
         * @summary Create networking/network
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {NetworkingProjectNetworkCreate} networkingProjectNetworkCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectNetworkCreate(projectId: string, locationId: string, networkingProjectNetworkCreate: NetworkingProjectNetworkCreate, xIdempotencyKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Network>> {
            const localVarAxiosArgs = await NetworkingProjectNetworkApiAxiosParamCreator(configuration).networkingProjectNetworkCreate(projectId, locationId, networkingProjectNetworkCreate, xIdempotencyKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete network
         * @summary Delete networking/network
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} networkId Network Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectNetworkDelete(projectId: string, locationId: string, networkId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await NetworkingProjectNetworkApiAxiosParamCreator(configuration).networkingProjectNetworkDelete(projectId, locationId, networkId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get networking/network.event
         * @summary Get networking/network.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} networkId Network Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectNetworkEventGet(projectId: string, locationId: string, networkId: string, eventId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>> {
            const localVarAxiosArgs = await NetworkingProjectNetworkApiAxiosParamCreator(configuration).networkingProjectNetworkEventGet(projectId, locationId, networkId, eventId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List networking/network.event
         * @summary List networking/network.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} networkId Network Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectNetworkEventList(projectId: string, locationId: string, networkId: string, $limit?: number, $skip?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Event>>> {
            const localVarAxiosArgs = await NetworkingProjectNetworkApiAxiosParamCreator(configuration).networkingProjectNetworkEventList(projectId, locationId, networkId, $limit, $skip, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a single network
         * @summary Get networking/network
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} networkId Network Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectNetworkGet(projectId: string, locationId: string, networkId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Network>> {
            const localVarAxiosArgs = await NetworkingProjectNetworkApiAxiosParamCreator(configuration).networkingProjectNetworkGet(projectId, locationId, networkId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List network
         * @summary List networking/network
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [name] Filter by name
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectNetworkList(projectId: string, locationId: string, name?: string, tagValue?: string, tagKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Network>>> {
            const localVarAxiosArgs = await NetworkingProjectNetworkApiAxiosParamCreator(configuration).networkingProjectNetworkList(projectId, locationId, name, tagValue, tagKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get networking/network.service
         * @summary Get networking/network.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} networkId Network Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectNetworkServiceGet(projectId: string, locationId: string, networkId: string, serviceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceService>> {
            const localVarAxiosArgs = await NetworkingProjectNetworkApiAxiosParamCreator(configuration).networkingProjectNetworkServiceGet(projectId, locationId, networkId, serviceId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List networking/network.service
         * @summary List networking/network.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} networkId Network Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectNetworkServiceList(projectId: string, locationId: string, networkId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResourceService>>> {
            const localVarAxiosArgs = await NetworkingProjectNetworkApiAxiosParamCreator(configuration).networkingProjectNetworkServiceList(projectId, locationId, networkId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create networking/network.tag
         * @summary Create networking/network.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} networkId Network Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectNetworkTagCreate(projectId: string, locationId: string, networkId: string, tag: Tag, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await NetworkingProjectNetworkApiAxiosParamCreator(configuration).networkingProjectNetworkTagCreate(projectId, locationId, networkId, tag, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete networking/network.tag
         * @summary Delete networking/network.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} networkId Network Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectNetworkTagDelete(projectId: string, locationId: string, networkId: string, tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await NetworkingProjectNetworkApiAxiosParamCreator(configuration).networkingProjectNetworkTagDelete(projectId, locationId, networkId, tagId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get networking/network.tag
         * @summary Get networking/network.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} networkId Network Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectNetworkTagGet(projectId: string, locationId: string, networkId: string, tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await NetworkingProjectNetworkApiAxiosParamCreator(configuration).networkingProjectNetworkTagGet(projectId, locationId, networkId, tagId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List networking/network.tag
         * @summary List networking/network.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} networkId Network Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectNetworkTagList(projectId: string, locationId: string, networkId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await NetworkingProjectNetworkApiAxiosParamCreator(configuration).networkingProjectNetworkTagList(projectId, locationId, networkId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Replace networking/network.tag
         * @summary Replace networking/network.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} networkId Network Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectNetworkTagPut(projectId: string, locationId: string, networkId: string, tag: Array<Tag>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await NetworkingProjectNetworkApiAxiosParamCreator(configuration).networkingProjectNetworkTagPut(projectId, locationId, networkId, tag, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns modified network
         * @summary Update networking/network
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} networkId Network Id
         * @param {NetworkingProjectNetworkUpdate} networkingProjectNetworkUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectNetworkUpdate(projectId: string, locationId: string, networkId: string, networkingProjectNetworkUpdate: NetworkingProjectNetworkUpdate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Network>> {
            const localVarAxiosArgs = await NetworkingProjectNetworkApiAxiosParamCreator(configuration).networkingProjectNetworkUpdate(projectId, locationId, networkId, networkingProjectNetworkUpdate, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * NetworkingProjectNetworkApi - factory interface
 * @export
 */
export const NetworkingProjectNetworkApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Create network
         * @summary Create networking/network
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {NetworkingProjectNetworkCreate} networkingProjectNetworkCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetworkCreate(projectId: string, locationId: string, networkingProjectNetworkCreate: NetworkingProjectNetworkCreate, xIdempotencyKey?: string, options?: any): AxiosPromise<Network> {
            return NetworkingProjectNetworkApiFp(configuration).networkingProjectNetworkCreate(projectId, locationId, networkingProjectNetworkCreate, xIdempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete network
         * @summary Delete networking/network
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} networkId Network Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetworkDelete(projectId: string, locationId: string, networkId: string, options?: any): AxiosPromise<void> {
            return NetworkingProjectNetworkApiFp(configuration).networkingProjectNetworkDelete(projectId, locationId, networkId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get networking/network.event
         * @summary Get networking/network.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} networkId Network Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetworkEventGet(projectId: string, locationId: string, networkId: string, eventId: string, options?: any): AxiosPromise<Event> {
            return NetworkingProjectNetworkApiFp(configuration).networkingProjectNetworkEventGet(projectId, locationId, networkId, eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * List networking/network.event
         * @summary List networking/network.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} networkId Network Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetworkEventList(projectId: string, locationId: string, networkId: string, $limit?: number, $skip?: number, options?: any): AxiosPromise<Array<Event>> {
            return NetworkingProjectNetworkApiFp(configuration).networkingProjectNetworkEventList(projectId, locationId, networkId, $limit, $skip, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single network
         * @summary Get networking/network
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} networkId Network Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetworkGet(projectId: string, locationId: string, networkId: string, options?: any): AxiosPromise<Network> {
            return NetworkingProjectNetworkApiFp(configuration).networkingProjectNetworkGet(projectId, locationId, networkId, options).then((request) => request(axios, basePath));
        },
        /**
         * List network
         * @summary List networking/network
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [name] Filter by name
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetworkList(projectId: string, locationId: string, name?: string, tagValue?: string, tagKey?: string, options?: any): AxiosPromise<Array<Network>> {
            return NetworkingProjectNetworkApiFp(configuration).networkingProjectNetworkList(projectId, locationId, name, tagValue, tagKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get networking/network.service
         * @summary Get networking/network.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} networkId Network Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetworkServiceGet(projectId: string, locationId: string, networkId: string, serviceId: string, options?: any): AxiosPromise<ResourceService> {
            return NetworkingProjectNetworkApiFp(configuration).networkingProjectNetworkServiceGet(projectId, locationId, networkId, serviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * List networking/network.service
         * @summary List networking/network.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} networkId Network Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetworkServiceList(projectId: string, locationId: string, networkId: string, options?: any): AxiosPromise<Array<ResourceService>> {
            return NetworkingProjectNetworkApiFp(configuration).networkingProjectNetworkServiceList(projectId, locationId, networkId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create networking/network.tag
         * @summary Create networking/network.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} networkId Network Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetworkTagCreate(projectId: string, locationId: string, networkId: string, tag: Tag, options?: any): AxiosPromise<Tag> {
            return NetworkingProjectNetworkApiFp(configuration).networkingProjectNetworkTagCreate(projectId, locationId, networkId, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete networking/network.tag
         * @summary Delete networking/network.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} networkId Network Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetworkTagDelete(projectId: string, locationId: string, networkId: string, tagId: string, options?: any): AxiosPromise<void> {
            return NetworkingProjectNetworkApiFp(configuration).networkingProjectNetworkTagDelete(projectId, locationId, networkId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get networking/network.tag
         * @summary Get networking/network.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} networkId Network Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetworkTagGet(projectId: string, locationId: string, networkId: string, tagId: string, options?: any): AxiosPromise<Tag> {
            return NetworkingProjectNetworkApiFp(configuration).networkingProjectNetworkTagGet(projectId, locationId, networkId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * List networking/network.tag
         * @summary List networking/network.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} networkId Network Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetworkTagList(projectId: string, locationId: string, networkId: string, options?: any): AxiosPromise<Array<Tag>> {
            return NetworkingProjectNetworkApiFp(configuration).networkingProjectNetworkTagList(projectId, locationId, networkId, options).then((request) => request(axios, basePath));
        },
        /**
         * Replace networking/network.tag
         * @summary Replace networking/network.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} networkId Network Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetworkTagPut(projectId: string, locationId: string, networkId: string, tag: Array<Tag>, options?: any): AxiosPromise<Array<Tag>> {
            return NetworkingProjectNetworkApiFp(configuration).networkingProjectNetworkTagPut(projectId, locationId, networkId, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns modified network
         * @summary Update networking/network
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} networkId Network Id
         * @param {NetworkingProjectNetworkUpdate} networkingProjectNetworkUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetworkUpdate(projectId: string, locationId: string, networkId: string, networkingProjectNetworkUpdate: NetworkingProjectNetworkUpdate, options?: any): AxiosPromise<Network> {
            return NetworkingProjectNetworkApiFp(configuration).networkingProjectNetworkUpdate(projectId, locationId, networkId, networkingProjectNetworkUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NetworkingProjectNetworkApi - object-oriented interface
 * @export
 * @class NetworkingProjectNetworkApi
 * @extends {BaseAPI}
 */
export class NetworkingProjectNetworkApi extends BaseAPI {
    /**
     * Create network
     * @summary Create networking/network
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {NetworkingProjectNetworkCreate} networkingProjectNetworkCreate 
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectNetworkApi
     */
    public networkingProjectNetworkCreate(projectId: string, locationId: string, networkingProjectNetworkCreate: NetworkingProjectNetworkCreate, xIdempotencyKey?: string, options?: any) {
        return NetworkingProjectNetworkApiFp(this.configuration).networkingProjectNetworkCreate(projectId, locationId, networkingProjectNetworkCreate, xIdempotencyKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete network
     * @summary Delete networking/network
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} networkId Network Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectNetworkApi
     */
    public networkingProjectNetworkDelete(projectId: string, locationId: string, networkId: string, options?: any) {
        return NetworkingProjectNetworkApiFp(this.configuration).networkingProjectNetworkDelete(projectId, locationId, networkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get networking/network.event
     * @summary Get networking/network.event
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} networkId Network Id
     * @param {string} eventId eventId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectNetworkApi
     */
    public networkingProjectNetworkEventGet(projectId: string, locationId: string, networkId: string, eventId: string, options?: any) {
        return NetworkingProjectNetworkApiFp(this.configuration).networkingProjectNetworkEventGet(projectId, locationId, networkId, eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List networking/network.event
     * @summary List networking/network.event
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} networkId Network Id
     * @param {number} [$limit] $limit
     * @param {number} [$skip] $skip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectNetworkApi
     */
    public networkingProjectNetworkEventList(projectId: string, locationId: string, networkId: string, $limit?: number, $skip?: number, options?: any) {
        return NetworkingProjectNetworkApiFp(this.configuration).networkingProjectNetworkEventList(projectId, locationId, networkId, $limit, $skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single network
     * @summary Get networking/network
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} networkId Network Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectNetworkApi
     */
    public networkingProjectNetworkGet(projectId: string, locationId: string, networkId: string, options?: any) {
        return NetworkingProjectNetworkApiFp(this.configuration).networkingProjectNetworkGet(projectId, locationId, networkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List network
     * @summary List networking/network
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} [name] Filter by name
     * @param {string} [tagValue] Filter by tag.value
     * @param {string} [tagKey] Filter by tag.key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectNetworkApi
     */
    public networkingProjectNetworkList(projectId: string, locationId: string, name?: string, tagValue?: string, tagKey?: string, options?: any) {
        return NetworkingProjectNetworkApiFp(this.configuration).networkingProjectNetworkList(projectId, locationId, name, tagValue, tagKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get networking/network.service
     * @summary Get networking/network.service
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} networkId Network Id
     * @param {string} serviceId serviceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectNetworkApi
     */
    public networkingProjectNetworkServiceGet(projectId: string, locationId: string, networkId: string, serviceId: string, options?: any) {
        return NetworkingProjectNetworkApiFp(this.configuration).networkingProjectNetworkServiceGet(projectId, locationId, networkId, serviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List networking/network.service
     * @summary List networking/network.service
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} networkId Network Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectNetworkApi
     */
    public networkingProjectNetworkServiceList(projectId: string, locationId: string, networkId: string, options?: any) {
        return NetworkingProjectNetworkApiFp(this.configuration).networkingProjectNetworkServiceList(projectId, locationId, networkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create networking/network.tag
     * @summary Create networking/network.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} networkId Network Id
     * @param {Tag} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectNetworkApi
     */
    public networkingProjectNetworkTagCreate(projectId: string, locationId: string, networkId: string, tag: Tag, options?: any) {
        return NetworkingProjectNetworkApiFp(this.configuration).networkingProjectNetworkTagCreate(projectId, locationId, networkId, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete networking/network.tag
     * @summary Delete networking/network.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} networkId Network Id
     * @param {string} tagId tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectNetworkApi
     */
    public networkingProjectNetworkTagDelete(projectId: string, locationId: string, networkId: string, tagId: string, options?: any) {
        return NetworkingProjectNetworkApiFp(this.configuration).networkingProjectNetworkTagDelete(projectId, locationId, networkId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get networking/network.tag
     * @summary Get networking/network.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} networkId Network Id
     * @param {string} tagId tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectNetworkApi
     */
    public networkingProjectNetworkTagGet(projectId: string, locationId: string, networkId: string, tagId: string, options?: any) {
        return NetworkingProjectNetworkApiFp(this.configuration).networkingProjectNetworkTagGet(projectId, locationId, networkId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List networking/network.tag
     * @summary List networking/network.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} networkId Network Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectNetworkApi
     */
    public networkingProjectNetworkTagList(projectId: string, locationId: string, networkId: string, options?: any) {
        return NetworkingProjectNetworkApiFp(this.configuration).networkingProjectNetworkTagList(projectId, locationId, networkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replace networking/network.tag
     * @summary Replace networking/network.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} networkId Network Id
     * @param {Array<Tag>} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectNetworkApi
     */
    public networkingProjectNetworkTagPut(projectId: string, locationId: string, networkId: string, tag: Array<Tag>, options?: any) {
        return NetworkingProjectNetworkApiFp(this.configuration).networkingProjectNetworkTagPut(projectId, locationId, networkId, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns modified network
     * @summary Update networking/network
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} networkId Network Id
     * @param {NetworkingProjectNetworkUpdate} networkingProjectNetworkUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectNetworkApi
     */
    public networkingProjectNetworkUpdate(projectId: string, locationId: string, networkId: string, networkingProjectNetworkUpdate: NetworkingProjectNetworkUpdate, options?: any) {
        return NetworkingProjectNetworkApiFp(this.configuration).networkingProjectNetworkUpdate(projectId, locationId, networkId, networkingProjectNetworkUpdate, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * ProviderProjectAgentApi - axios parameter creator
 * @export
 */
export const ProviderProjectAgentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create agent
         * @summary Create provider/agent
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {ProviderProjectAgentCreate} providerProjectAgentCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentCreate: async (projectId: string, locationId: string, providerProjectAgentCreate: ProviderProjectAgentCreate, xIdempotencyKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling providerProjectAgentCreate.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling providerProjectAgentCreate.');
            }
            // verify required parameter 'providerProjectAgentCreate' is not null or undefined
            if (providerProjectAgentCreate === null || providerProjectAgentCreate === undefined) {
                throw new RequiredError('providerProjectAgentCreate','Required parameter providerProjectAgentCreate was null or undefined when calling providerProjectAgentCreate.');
            }
            const localVarPath = `/provider/{locationId}/project/{projectId}/agent`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof providerProjectAgentCreate !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(providerProjectAgentCreate !== undefined ? providerProjectAgentCreate : {}) : (providerProjectAgentCreate || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create provider/agent.credential
         * @summary Create provider/agent.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {AgentCredential} agentCredential 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentCredentialCreate: async (projectId: string, locationId: string, agentId: string, agentCredential: AgentCredential, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling providerProjectAgentCredentialCreate.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling providerProjectAgentCredentialCreate.');
            }
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new RequiredError('agentId','Required parameter agentId was null or undefined when calling providerProjectAgentCredentialCreate.');
            }
            // verify required parameter 'agentCredential' is not null or undefined
            if (agentCredential === null || agentCredential === undefined) {
                throw new RequiredError('agentCredential','Required parameter agentCredential was null or undefined when calling providerProjectAgentCredentialCreate.');
            }
            const localVarPath = `/provider/{locationId}/project/{projectId}/agent/{agentId}/credential`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"agentId"}}`, encodeURIComponent(String(agentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof agentCredential !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(agentCredential !== undefined ? agentCredential : {}) : (agentCredential || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete provider/agent.credential
         * @summary Delete provider/agent.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {string} credentialId credentialId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentCredentialDelete: async (projectId: string, locationId: string, agentId: string, credentialId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling providerProjectAgentCredentialDelete.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling providerProjectAgentCredentialDelete.');
            }
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new RequiredError('agentId','Required parameter agentId was null or undefined when calling providerProjectAgentCredentialDelete.');
            }
            // verify required parameter 'credentialId' is not null or undefined
            if (credentialId === null || credentialId === undefined) {
                throw new RequiredError('credentialId','Required parameter credentialId was null or undefined when calling providerProjectAgentCredentialDelete.');
            }
            const localVarPath = `/provider/{locationId}/project/{projectId}/agent/{agentId}/credential/{credentialId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"agentId"}}`, encodeURIComponent(String(agentId)))
                .replace(`{${"credentialId"}}`, encodeURIComponent(String(credentialId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get provider/agent.credential
         * @summary Get provider/agent.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {string} credentialId credentialId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentCredentialGet: async (projectId: string, locationId: string, agentId: string, credentialId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling providerProjectAgentCredentialGet.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling providerProjectAgentCredentialGet.');
            }
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new RequiredError('agentId','Required parameter agentId was null or undefined when calling providerProjectAgentCredentialGet.');
            }
            // verify required parameter 'credentialId' is not null or undefined
            if (credentialId === null || credentialId === undefined) {
                throw new RequiredError('credentialId','Required parameter credentialId was null or undefined when calling providerProjectAgentCredentialGet.');
            }
            const localVarPath = `/provider/{locationId}/project/{projectId}/agent/{agentId}/credential/{credentialId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"agentId"}}`, encodeURIComponent(String(agentId)))
                .replace(`{${"credentialId"}}`, encodeURIComponent(String(credentialId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List provider/agent.credential
         * @summary List provider/agent.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentCredentialList: async (projectId: string, locationId: string, agentId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling providerProjectAgentCredentialList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling providerProjectAgentCredentialList.');
            }
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new RequiredError('agentId','Required parameter agentId was null or undefined when calling providerProjectAgentCredentialList.');
            }
            const localVarPath = `/provider/{locationId}/project/{projectId}/agent/{agentId}/credential`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"agentId"}}`, encodeURIComponent(String(agentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update provider/agent.credential
         * @summary Update provider/agent.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {string} credentialId credentialId
         * @param {ProviderProjectAgentCredentialPatch} providerProjectAgentCredentialPatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentCredentialPatch: async (projectId: string, locationId: string, agentId: string, credentialId: string, providerProjectAgentCredentialPatch: ProviderProjectAgentCredentialPatch, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling providerProjectAgentCredentialPatch.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling providerProjectAgentCredentialPatch.');
            }
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new RequiredError('agentId','Required parameter agentId was null or undefined when calling providerProjectAgentCredentialPatch.');
            }
            // verify required parameter 'credentialId' is not null or undefined
            if (credentialId === null || credentialId === undefined) {
                throw new RequiredError('credentialId','Required parameter credentialId was null or undefined when calling providerProjectAgentCredentialPatch.');
            }
            // verify required parameter 'providerProjectAgentCredentialPatch' is not null or undefined
            if (providerProjectAgentCredentialPatch === null || providerProjectAgentCredentialPatch === undefined) {
                throw new RequiredError('providerProjectAgentCredentialPatch','Required parameter providerProjectAgentCredentialPatch was null or undefined when calling providerProjectAgentCredentialPatch.');
            }
            const localVarPath = `/provider/{locationId}/project/{projectId}/agent/{agentId}/credential/{credentialId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"agentId"}}`, encodeURIComponent(String(agentId)))
                .replace(`{${"credentialId"}}`, encodeURIComponent(String(credentialId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof providerProjectAgentCredentialPatch !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(providerProjectAgentCredentialPatch !== undefined ? providerProjectAgentCredentialPatch : {}) : (providerProjectAgentCredentialPatch || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete agent
         * @summary Delete provider/agent
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentDelete: async (projectId: string, locationId: string, agentId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling providerProjectAgentDelete.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling providerProjectAgentDelete.');
            }
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new RequiredError('agentId','Required parameter agentId was null or undefined when calling providerProjectAgentDelete.');
            }
            const localVarPath = `/provider/{locationId}/project/{projectId}/agent/{agentId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"agentId"}}`, encodeURIComponent(String(agentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create provider/agent.enabledService
         * @summary Create provider/agent.enabledService
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {EnabledService} enabledService 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentEnabledServiceCreate: async (projectId: string, locationId: string, agentId: string, enabledService: EnabledService, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling providerProjectAgentEnabledServiceCreate.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling providerProjectAgentEnabledServiceCreate.');
            }
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new RequiredError('agentId','Required parameter agentId was null or undefined when calling providerProjectAgentEnabledServiceCreate.');
            }
            // verify required parameter 'enabledService' is not null or undefined
            if (enabledService === null || enabledService === undefined) {
                throw new RequiredError('enabledService','Required parameter enabledService was null or undefined when calling providerProjectAgentEnabledServiceCreate.');
            }
            const localVarPath = `/provider/{locationId}/project/{projectId}/agent/{agentId}/enabledService`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"agentId"}}`, encodeURIComponent(String(agentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof enabledService !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(enabledService !== undefined ? enabledService : {}) : (enabledService || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete provider/agent.enabledService
         * @summary Delete provider/agent.enabledService
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {string} enabledServiceId enabledServiceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentEnabledServiceDelete: async (projectId: string, locationId: string, agentId: string, enabledServiceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling providerProjectAgentEnabledServiceDelete.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling providerProjectAgentEnabledServiceDelete.');
            }
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new RequiredError('agentId','Required parameter agentId was null or undefined when calling providerProjectAgentEnabledServiceDelete.');
            }
            // verify required parameter 'enabledServiceId' is not null or undefined
            if (enabledServiceId === null || enabledServiceId === undefined) {
                throw new RequiredError('enabledServiceId','Required parameter enabledServiceId was null or undefined when calling providerProjectAgentEnabledServiceDelete.');
            }
            const localVarPath = `/provider/{locationId}/project/{projectId}/agent/{agentId}/enabledService/{enabledServiceId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"agentId"}}`, encodeURIComponent(String(agentId)))
                .replace(`{${"enabledServiceId"}}`, encodeURIComponent(String(enabledServiceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get provider/agent.enabledService
         * @summary Get provider/agent.enabledService
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {string} enabledServiceId enabledServiceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentEnabledServiceGet: async (projectId: string, locationId: string, agentId: string, enabledServiceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling providerProjectAgentEnabledServiceGet.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling providerProjectAgentEnabledServiceGet.');
            }
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new RequiredError('agentId','Required parameter agentId was null or undefined when calling providerProjectAgentEnabledServiceGet.');
            }
            // verify required parameter 'enabledServiceId' is not null or undefined
            if (enabledServiceId === null || enabledServiceId === undefined) {
                throw new RequiredError('enabledServiceId','Required parameter enabledServiceId was null or undefined when calling providerProjectAgentEnabledServiceGet.');
            }
            const localVarPath = `/provider/{locationId}/project/{projectId}/agent/{agentId}/enabledService/{enabledServiceId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"agentId"}}`, encodeURIComponent(String(agentId)))
                .replace(`{${"enabledServiceId"}}`, encodeURIComponent(String(enabledServiceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List provider/agent.enabledService
         * @summary List provider/agent.enabledService
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentEnabledServiceList: async (projectId: string, locationId: string, agentId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling providerProjectAgentEnabledServiceList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling providerProjectAgentEnabledServiceList.');
            }
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new RequiredError('agentId','Required parameter agentId was null or undefined when calling providerProjectAgentEnabledServiceList.');
            }
            const localVarPath = `/provider/{locationId}/project/{projectId}/agent/{agentId}/enabledService`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"agentId"}}`, encodeURIComponent(String(agentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get provider/agent.event
         * @summary Get provider/agent.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentEventGet: async (projectId: string, locationId: string, agentId: string, eventId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling providerProjectAgentEventGet.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling providerProjectAgentEventGet.');
            }
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new RequiredError('agentId','Required parameter agentId was null or undefined when calling providerProjectAgentEventGet.');
            }
            // verify required parameter 'eventId' is not null or undefined
            if (eventId === null || eventId === undefined) {
                throw new RequiredError('eventId','Required parameter eventId was null or undefined when calling providerProjectAgentEventGet.');
            }
            const localVarPath = `/provider/{locationId}/project/{projectId}/agent/{agentId}/event/{eventId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"agentId"}}`, encodeURIComponent(String(agentId)))
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List provider/agent.event
         * @summary List provider/agent.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentEventList: async (projectId: string, locationId: string, agentId: string, $limit?: number, $skip?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling providerProjectAgentEventList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling providerProjectAgentEventList.');
            }
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new RequiredError('agentId','Required parameter agentId was null or undefined when calling providerProjectAgentEventList.');
            }
            const localVarPath = `/provider/{locationId}/project/{projectId}/agent/{agentId}/event`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"agentId"}}`, encodeURIComponent(String(agentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if ($limit !== undefined) {
                localVarQueryParameter['$limit'] = $limit;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single agent
         * @summary Get provider/agent
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentGet: async (projectId: string, locationId: string, agentId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling providerProjectAgentGet.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling providerProjectAgentGet.');
            }
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new RequiredError('agentId','Required parameter agentId was null or undefined when calling providerProjectAgentGet.');
            }
            const localVarPath = `/provider/{locationId}/project/{projectId}/agent/{agentId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"agentId"}}`, encodeURIComponent(String(agentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * action inspect
         * @summary Inspect provider/agent
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentInspect: async (projectId: string, locationId: string, agentId: string, xIdempotencyKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling providerProjectAgentInspect.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling providerProjectAgentInspect.');
            }
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new RequiredError('agentId','Required parameter agentId was null or undefined when calling providerProjectAgentInspect.');
            }
            const localVarPath = `/provider/{locationId}/project/{projectId}/agent/{agentId}/actions/inspect`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"agentId"}}`, encodeURIComponent(String(agentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List agent
         * @summary List provider/agent
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [name] Filter by name
         * @param {string} [enabledServices] Filter by enabledServices
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentList: async (projectId: string, locationId: string, name?: string, enabledServices?: string, tagValue?: string, tagKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling providerProjectAgentList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling providerProjectAgentList.');
            }
            const localVarPath = `/provider/{locationId}/project/{projectId}/agent`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (enabledServices !== undefined) {
                localVarQueryParameter['enabledServices'] = enabledServices;
            }

            if (tagValue !== undefined) {
                localVarQueryParameter['tag.value'] = tagValue;
            }

            if (tagKey !== undefined) {
                localVarQueryParameter['tag.key'] = tagKey;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get provider/agent.metric
         * @summary Get provider/agent.metric
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {string} metricId metricId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentMetricGet: async (projectId: string, locationId: string, agentId: string, metricId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling providerProjectAgentMetricGet.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling providerProjectAgentMetricGet.');
            }
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new RequiredError('agentId','Required parameter agentId was null or undefined when calling providerProjectAgentMetricGet.');
            }
            // verify required parameter 'metricId' is not null or undefined
            if (metricId === null || metricId === undefined) {
                throw new RequiredError('metricId','Required parameter metricId was null or undefined when calling providerProjectAgentMetricGet.');
            }
            const localVarPath = `/provider/{locationId}/project/{projectId}/agent/{agentId}/metric/{metricId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"agentId"}}`, encodeURIComponent(String(agentId)))
                .replace(`{${"metricId"}}`, encodeURIComponent(String(metricId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List provider/agent.metric
         * @summary List provider/agent.metric
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentMetricList: async (projectId: string, locationId: string, agentId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling providerProjectAgentMetricList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling providerProjectAgentMetricList.');
            }
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new RequiredError('agentId','Required parameter agentId was null or undefined when calling providerProjectAgentMetricList.');
            }
            const localVarPath = `/provider/{locationId}/project/{projectId}/agent/{agentId}/metric`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"agentId"}}`, encodeURIComponent(String(agentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List provider/agent.point
         * @summary List provider/agent.point
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {string} metricId metricId
         * @param {string} [interval] interval
         * @param {string} [timespan] timespan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentMetricPointList: async (projectId: string, locationId: string, agentId: string, metricId: string, interval?: string, timespan?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling providerProjectAgentMetricPointList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling providerProjectAgentMetricPointList.');
            }
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new RequiredError('agentId','Required parameter agentId was null or undefined when calling providerProjectAgentMetricPointList.');
            }
            // verify required parameter 'metricId' is not null or undefined
            if (metricId === null || metricId === undefined) {
                throw new RequiredError('metricId','Required parameter metricId was null or undefined when calling providerProjectAgentMetricPointList.');
            }
            const localVarPath = `/provider/{locationId}/project/{projectId}/agent/{agentId}/metric/{metricId}/point`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"agentId"}}`, encodeURIComponent(String(agentId)))
                .replace(`{${"metricId"}}`, encodeURIComponent(String(metricId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (timespan !== undefined) {
                localVarQueryParameter['timespan'] = timespan;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List provider/agent.event
         * @summary List provider/agent.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {string} resourceId resourceId
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentResourceEventList: async (projectId: string, locationId: string, agentId: string, resourceId: string, $limit?: number, $skip?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling providerProjectAgentResourceEventList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling providerProjectAgentResourceEventList.');
            }
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new RequiredError('agentId','Required parameter agentId was null or undefined when calling providerProjectAgentResourceEventList.');
            }
            // verify required parameter 'resourceId' is not null or undefined
            if (resourceId === null || resourceId === undefined) {
                throw new RequiredError('resourceId','Required parameter resourceId was null or undefined when calling providerProjectAgentResourceEventList.');
            }
            const localVarPath = `/provider/{locationId}/project/{projectId}/agent/{agentId}/resource/{resourceId}/event`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"agentId"}}`, encodeURIComponent(String(agentId)))
                .replace(`{${"resourceId"}}`, encodeURIComponent(String(resourceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if ($limit !== undefined) {
                localVarQueryParameter['$limit'] = $limit;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get provider/agent.resource
         * @summary Get provider/agent.resource
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {string} resourceId resourceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentResourceGet: async (projectId: string, locationId: string, agentId: string, resourceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling providerProjectAgentResourceGet.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling providerProjectAgentResourceGet.');
            }
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new RequiredError('agentId','Required parameter agentId was null or undefined when calling providerProjectAgentResourceGet.');
            }
            // verify required parameter 'resourceId' is not null or undefined
            if (resourceId === null || resourceId === undefined) {
                throw new RequiredError('resourceId','Required parameter resourceId was null or undefined when calling providerProjectAgentResourceGet.');
            }
            const localVarPath = `/provider/{locationId}/project/{projectId}/agent/{agentId}/resource/{resourceId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"agentId"}}`, encodeURIComponent(String(agentId)))
                .replace(`{${"resourceId"}}`, encodeURIComponent(String(resourceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * action inspect
         * @summary Inspect provider/agent.resource
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {string} resourceId resourceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentResourceInspect: async (projectId: string, locationId: string, agentId: string, resourceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling providerProjectAgentResourceInspect.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling providerProjectAgentResourceInspect.');
            }
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new RequiredError('agentId','Required parameter agentId was null or undefined when calling providerProjectAgentResourceInspect.');
            }
            // verify required parameter 'resourceId' is not null or undefined
            if (resourceId === null || resourceId === undefined) {
                throw new RequiredError('resourceId','Required parameter resourceId was null or undefined when calling providerProjectAgentResourceInspect.');
            }
            const localVarPath = `/provider/{locationId}/project/{projectId}/agent/{agentId}/resource/{resourceId}/actions/inspect`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"agentId"}}`, encodeURIComponent(String(agentId)))
                .replace(`{${"resourceId"}}`, encodeURIComponent(String(resourceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List provider/agent.resource
         * @summary List provider/agent.resource
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentResourceList: async (projectId: string, locationId: string, agentId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling providerProjectAgentResourceList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling providerProjectAgentResourceList.');
            }
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new RequiredError('agentId','Required parameter agentId was null or undefined when calling providerProjectAgentResourceList.');
            }
            const localVarPath = `/provider/{locationId}/project/{projectId}/agent/{agentId}/resource`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"agentId"}}`, encodeURIComponent(String(agentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * action recreate
         * @summary Recreate provider/agent.resource
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {string} resourceId resourceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentResourceRecreate: async (projectId: string, locationId: string, agentId: string, resourceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling providerProjectAgentResourceRecreate.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling providerProjectAgentResourceRecreate.');
            }
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new RequiredError('agentId','Required parameter agentId was null or undefined when calling providerProjectAgentResourceRecreate.');
            }
            // verify required parameter 'resourceId' is not null or undefined
            if (resourceId === null || resourceId === undefined) {
                throw new RequiredError('resourceId','Required parameter resourceId was null or undefined when calling providerProjectAgentResourceRecreate.');
            }
            const localVarPath = `/provider/{locationId}/project/{projectId}/agent/{agentId}/resource/{resourceId}/actions/recreate`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"agentId"}}`, encodeURIComponent(String(agentId)))
                .replace(`{${"resourceId"}}`, encodeURIComponent(String(resourceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get provider/agent.service
         * @summary Get provider/agent.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentServiceGet: async (projectId: string, locationId: string, agentId: string, serviceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling providerProjectAgentServiceGet.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling providerProjectAgentServiceGet.');
            }
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new RequiredError('agentId','Required parameter agentId was null or undefined when calling providerProjectAgentServiceGet.');
            }
            // verify required parameter 'serviceId' is not null or undefined
            if (serviceId === null || serviceId === undefined) {
                throw new RequiredError('serviceId','Required parameter serviceId was null or undefined when calling providerProjectAgentServiceGet.');
            }
            const localVarPath = `/provider/{locationId}/project/{projectId}/agent/{agentId}/service/{serviceId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"agentId"}}`, encodeURIComponent(String(agentId)))
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List provider/agent.service
         * @summary List provider/agent.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentServiceList: async (projectId: string, locationId: string, agentId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling providerProjectAgentServiceList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling providerProjectAgentServiceList.');
            }
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new RequiredError('agentId','Required parameter agentId was null or undefined when calling providerProjectAgentServiceList.');
            }
            const localVarPath = `/provider/{locationId}/project/{projectId}/agent/{agentId}/service`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"agentId"}}`, encodeURIComponent(String(agentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * action start
         * @summary Start provider/agent
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentStart: async (projectId: string, locationId: string, agentId: string, xIdempotencyKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling providerProjectAgentStart.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling providerProjectAgentStart.');
            }
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new RequiredError('agentId','Required parameter agentId was null or undefined when calling providerProjectAgentStart.');
            }
            const localVarPath = `/provider/{locationId}/project/{projectId}/agent/{agentId}/actions/start`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"agentId"}}`, encodeURIComponent(String(agentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * action suspend
         * @summary Suspend provider/agent
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentSuspend: async (projectId: string, locationId: string, agentId: string, xIdempotencyKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling providerProjectAgentSuspend.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling providerProjectAgentSuspend.');
            }
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new RequiredError('agentId','Required parameter agentId was null or undefined when calling providerProjectAgentSuspend.');
            }
            const localVarPath = `/provider/{locationId}/project/{projectId}/agent/{agentId}/actions/suspend`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"agentId"}}`, encodeURIComponent(String(agentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create provider/agent.tag
         * @summary Create provider/agent.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentTagCreate: async (projectId: string, locationId: string, agentId: string, tag: Tag, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling providerProjectAgentTagCreate.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling providerProjectAgentTagCreate.');
            }
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new RequiredError('agentId','Required parameter agentId was null or undefined when calling providerProjectAgentTagCreate.');
            }
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling providerProjectAgentTagCreate.');
            }
            const localVarPath = `/provider/{locationId}/project/{projectId}/agent/{agentId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"agentId"}}`, encodeURIComponent(String(agentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof tag !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(tag !== undefined ? tag : {}) : (tag || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete provider/agent.tag
         * @summary Delete provider/agent.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentTagDelete: async (projectId: string, locationId: string, agentId: string, tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling providerProjectAgentTagDelete.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling providerProjectAgentTagDelete.');
            }
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new RequiredError('agentId','Required parameter agentId was null or undefined when calling providerProjectAgentTagDelete.');
            }
            // verify required parameter 'tagId' is not null or undefined
            if (tagId === null || tagId === undefined) {
                throw new RequiredError('tagId','Required parameter tagId was null or undefined when calling providerProjectAgentTagDelete.');
            }
            const localVarPath = `/provider/{locationId}/project/{projectId}/agent/{agentId}/tag/{tagId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"agentId"}}`, encodeURIComponent(String(agentId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get provider/agent.tag
         * @summary Get provider/agent.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentTagGet: async (projectId: string, locationId: string, agentId: string, tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling providerProjectAgentTagGet.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling providerProjectAgentTagGet.');
            }
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new RequiredError('agentId','Required parameter agentId was null or undefined when calling providerProjectAgentTagGet.');
            }
            // verify required parameter 'tagId' is not null or undefined
            if (tagId === null || tagId === undefined) {
                throw new RequiredError('tagId','Required parameter tagId was null or undefined when calling providerProjectAgentTagGet.');
            }
            const localVarPath = `/provider/{locationId}/project/{projectId}/agent/{agentId}/tag/{tagId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"agentId"}}`, encodeURIComponent(String(agentId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List provider/agent.tag
         * @summary List provider/agent.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentTagList: async (projectId: string, locationId: string, agentId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling providerProjectAgentTagList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling providerProjectAgentTagList.');
            }
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new RequiredError('agentId','Required parameter agentId was null or undefined when calling providerProjectAgentTagList.');
            }
            const localVarPath = `/provider/{locationId}/project/{projectId}/agent/{agentId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"agentId"}}`, encodeURIComponent(String(agentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replace provider/agent.tag
         * @summary Replace provider/agent.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentTagPut: async (projectId: string, locationId: string, agentId: string, tag: Array<Tag>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling providerProjectAgentTagPut.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling providerProjectAgentTagPut.');
            }
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new RequiredError('agentId','Required parameter agentId was null or undefined when calling providerProjectAgentTagPut.');
            }
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling providerProjectAgentTagPut.');
            }
            const localVarPath = `/provider/{locationId}/project/{projectId}/agent/{agentId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"agentId"}}`, encodeURIComponent(String(agentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof tag !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(tag !== undefined ? tag : {}) : (tag || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * action transfer
         * @summary Transfer provider/agent
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {ProviderProjectAgentTransfer} providerProjectAgentTransfer 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentTransfer: async (projectId: string, locationId: string, agentId: string, providerProjectAgentTransfer: ProviderProjectAgentTransfer, xIdempotencyKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling providerProjectAgentTransfer.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling providerProjectAgentTransfer.');
            }
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new RequiredError('agentId','Required parameter agentId was null or undefined when calling providerProjectAgentTransfer.');
            }
            // verify required parameter 'providerProjectAgentTransfer' is not null or undefined
            if (providerProjectAgentTransfer === null || providerProjectAgentTransfer === undefined) {
                throw new RequiredError('providerProjectAgentTransfer','Required parameter providerProjectAgentTransfer was null or undefined when calling providerProjectAgentTransfer.');
            }
            const localVarPath = `/provider/{locationId}/project/{projectId}/agent/{agentId}/actions/transfer`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"agentId"}}`, encodeURIComponent(String(agentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof providerProjectAgentTransfer !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(providerProjectAgentTransfer !== undefined ? providerProjectAgentTransfer : {}) : (providerProjectAgentTransfer || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns modified agent
         * @summary Update provider/agent
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {ProviderProjectAgentUpdate} providerProjectAgentUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentUpdate: async (projectId: string, locationId: string, agentId: string, providerProjectAgentUpdate: ProviderProjectAgentUpdate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling providerProjectAgentUpdate.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling providerProjectAgentUpdate.');
            }
            // verify required parameter 'agentId' is not null or undefined
            if (agentId === null || agentId === undefined) {
                throw new RequiredError('agentId','Required parameter agentId was null or undefined when calling providerProjectAgentUpdate.');
            }
            // verify required parameter 'providerProjectAgentUpdate' is not null or undefined
            if (providerProjectAgentUpdate === null || providerProjectAgentUpdate === undefined) {
                throw new RequiredError('providerProjectAgentUpdate','Required parameter providerProjectAgentUpdate was null or undefined when calling providerProjectAgentUpdate.');
            }
            const localVarPath = `/provider/{locationId}/project/{projectId}/agent/{agentId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"agentId"}}`, encodeURIComponent(String(agentId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof providerProjectAgentUpdate !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(providerProjectAgentUpdate !== undefined ? providerProjectAgentUpdate : {}) : (providerProjectAgentUpdate || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProviderProjectAgentApi - functional programming interface
 * @export
 */
export const ProviderProjectAgentApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create agent
         * @summary Create provider/agent
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {ProviderProjectAgentCreate} providerProjectAgentCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async providerProjectAgentCreate(projectId: string, locationId: string, providerProjectAgentCreate: ProviderProjectAgentCreate, xIdempotencyKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Agent>> {
            const localVarAxiosArgs = await ProviderProjectAgentApiAxiosParamCreator(configuration).providerProjectAgentCreate(projectId, locationId, providerProjectAgentCreate, xIdempotencyKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create provider/agent.credential
         * @summary Create provider/agent.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {AgentCredential} agentCredential 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async providerProjectAgentCredentialCreate(projectId: string, locationId: string, agentId: string, agentCredential: AgentCredential, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AgentCredential>> {
            const localVarAxiosArgs = await ProviderProjectAgentApiAxiosParamCreator(configuration).providerProjectAgentCredentialCreate(projectId, locationId, agentId, agentCredential, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete provider/agent.credential
         * @summary Delete provider/agent.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {string} credentialId credentialId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async providerProjectAgentCredentialDelete(projectId: string, locationId: string, agentId: string, credentialId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Agent>> {
            const localVarAxiosArgs = await ProviderProjectAgentApiAxiosParamCreator(configuration).providerProjectAgentCredentialDelete(projectId, locationId, agentId, credentialId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get provider/agent.credential
         * @summary Get provider/agent.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {string} credentialId credentialId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async providerProjectAgentCredentialGet(projectId: string, locationId: string, agentId: string, credentialId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AgentCredential>> {
            const localVarAxiosArgs = await ProviderProjectAgentApiAxiosParamCreator(configuration).providerProjectAgentCredentialGet(projectId, locationId, agentId, credentialId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List provider/agent.credential
         * @summary List provider/agent.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async providerProjectAgentCredentialList(projectId: string, locationId: string, agentId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AgentCredential>>> {
            const localVarAxiosArgs = await ProviderProjectAgentApiAxiosParamCreator(configuration).providerProjectAgentCredentialList(projectId, locationId, agentId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update provider/agent.credential
         * @summary Update provider/agent.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {string} credentialId credentialId
         * @param {ProviderProjectAgentCredentialPatch} providerProjectAgentCredentialPatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async providerProjectAgentCredentialPatch(projectId: string, locationId: string, agentId: string, credentialId: string, providerProjectAgentCredentialPatch: ProviderProjectAgentCredentialPatch, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AgentCredential>> {
            const localVarAxiosArgs = await ProviderProjectAgentApiAxiosParamCreator(configuration).providerProjectAgentCredentialPatch(projectId, locationId, agentId, credentialId, providerProjectAgentCredentialPatch, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete agent
         * @summary Delete provider/agent
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async providerProjectAgentDelete(projectId: string, locationId: string, agentId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ProviderProjectAgentApiAxiosParamCreator(configuration).providerProjectAgentDelete(projectId, locationId, agentId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create provider/agent.enabledService
         * @summary Create provider/agent.enabledService
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {EnabledService} enabledService 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async providerProjectAgentEnabledServiceCreate(projectId: string, locationId: string, agentId: string, enabledService: EnabledService, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnabledService>> {
            const localVarAxiosArgs = await ProviderProjectAgentApiAxiosParamCreator(configuration).providerProjectAgentEnabledServiceCreate(projectId, locationId, agentId, enabledService, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete provider/agent.enabledService
         * @summary Delete provider/agent.enabledService
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {string} enabledServiceId enabledServiceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async providerProjectAgentEnabledServiceDelete(projectId: string, locationId: string, agentId: string, enabledServiceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Agent>> {
            const localVarAxiosArgs = await ProviderProjectAgentApiAxiosParamCreator(configuration).providerProjectAgentEnabledServiceDelete(projectId, locationId, agentId, enabledServiceId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get provider/agent.enabledService
         * @summary Get provider/agent.enabledService
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {string} enabledServiceId enabledServiceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async providerProjectAgentEnabledServiceGet(projectId: string, locationId: string, agentId: string, enabledServiceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnabledService>> {
            const localVarAxiosArgs = await ProviderProjectAgentApiAxiosParamCreator(configuration).providerProjectAgentEnabledServiceGet(projectId, locationId, agentId, enabledServiceId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List provider/agent.enabledService
         * @summary List provider/agent.enabledService
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async providerProjectAgentEnabledServiceList(projectId: string, locationId: string, agentId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EnabledService>>> {
            const localVarAxiosArgs = await ProviderProjectAgentApiAxiosParamCreator(configuration).providerProjectAgentEnabledServiceList(projectId, locationId, agentId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get provider/agent.event
         * @summary Get provider/agent.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async providerProjectAgentEventGet(projectId: string, locationId: string, agentId: string, eventId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>> {
            const localVarAxiosArgs = await ProviderProjectAgentApiAxiosParamCreator(configuration).providerProjectAgentEventGet(projectId, locationId, agentId, eventId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List provider/agent.event
         * @summary List provider/agent.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async providerProjectAgentEventList(projectId: string, locationId: string, agentId: string, $limit?: number, $skip?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Event>>> {
            const localVarAxiosArgs = await ProviderProjectAgentApiAxiosParamCreator(configuration).providerProjectAgentEventList(projectId, locationId, agentId, $limit, $skip, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a single agent
         * @summary Get provider/agent
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async providerProjectAgentGet(projectId: string, locationId: string, agentId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Agent>> {
            const localVarAxiosArgs = await ProviderProjectAgentApiAxiosParamCreator(configuration).providerProjectAgentGet(projectId, locationId, agentId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * action inspect
         * @summary Inspect provider/agent
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async providerProjectAgentInspect(projectId: string, locationId: string, agentId: string, xIdempotencyKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Agent>> {
            const localVarAxiosArgs = await ProviderProjectAgentApiAxiosParamCreator(configuration).providerProjectAgentInspect(projectId, locationId, agentId, xIdempotencyKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List agent
         * @summary List provider/agent
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [name] Filter by name
         * @param {string} [enabledServices] Filter by enabledServices
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async providerProjectAgentList(projectId: string, locationId: string, name?: string, enabledServices?: string, tagValue?: string, tagKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Agent>>> {
            const localVarAxiosArgs = await ProviderProjectAgentApiAxiosParamCreator(configuration).providerProjectAgentList(projectId, locationId, name, enabledServices, tagValue, tagKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get provider/agent.metric
         * @summary Get provider/agent.metric
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {string} metricId metricId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async providerProjectAgentMetricGet(projectId: string, locationId: string, agentId: string, metricId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Metric>> {
            const localVarAxiosArgs = await ProviderProjectAgentApiAxiosParamCreator(configuration).providerProjectAgentMetricGet(projectId, locationId, agentId, metricId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List provider/agent.metric
         * @summary List provider/agent.metric
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async providerProjectAgentMetricList(projectId: string, locationId: string, agentId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Metric>>> {
            const localVarAxiosArgs = await ProviderProjectAgentApiAxiosParamCreator(configuration).providerProjectAgentMetricList(projectId, locationId, agentId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List provider/agent.point
         * @summary List provider/agent.point
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {string} metricId metricId
         * @param {string} [interval] interval
         * @param {string} [timespan] timespan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async providerProjectAgentMetricPointList(projectId: string, locationId: string, agentId: string, metricId: string, interval?: string, timespan?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Point>>> {
            const localVarAxiosArgs = await ProviderProjectAgentApiAxiosParamCreator(configuration).providerProjectAgentMetricPointList(projectId, locationId, agentId, metricId, interval, timespan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List provider/agent.event
         * @summary List provider/agent.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {string} resourceId resourceId
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async providerProjectAgentResourceEventList(projectId: string, locationId: string, agentId: string, resourceId: string, $limit?: number, $skip?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProviderAgentResourceEvent>>> {
            const localVarAxiosArgs = await ProviderProjectAgentApiAxiosParamCreator(configuration).providerProjectAgentResourceEventList(projectId, locationId, agentId, resourceId, $limit, $skip, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get provider/agent.resource
         * @summary Get provider/agent.resource
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {string} resourceId resourceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async providerProjectAgentResourceGet(projectId: string, locationId: string, agentId: string, resourceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProviderAgentResource>> {
            const localVarAxiosArgs = await ProviderProjectAgentApiAxiosParamCreator(configuration).providerProjectAgentResourceGet(projectId, locationId, agentId, resourceId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * action inspect
         * @summary Inspect provider/agent.resource
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {string} resourceId resourceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async providerProjectAgentResourceInspect(projectId: string, locationId: string, agentId: string, resourceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await ProviderProjectAgentApiAxiosParamCreator(configuration).providerProjectAgentResourceInspect(projectId, locationId, agentId, resourceId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List provider/agent.resource
         * @summary List provider/agent.resource
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async providerProjectAgentResourceList(projectId: string, locationId: string, agentId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProviderAgentResource>>> {
            const localVarAxiosArgs = await ProviderProjectAgentApiAxiosParamCreator(configuration).providerProjectAgentResourceList(projectId, locationId, agentId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * action recreate
         * @summary Recreate provider/agent.resource
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {string} resourceId resourceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async providerProjectAgentResourceRecreate(projectId: string, locationId: string, agentId: string, resourceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProviderAgentResource>> {
            const localVarAxiosArgs = await ProviderProjectAgentApiAxiosParamCreator(configuration).providerProjectAgentResourceRecreate(projectId, locationId, agentId, resourceId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get provider/agent.service
         * @summary Get provider/agent.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async providerProjectAgentServiceGet(projectId: string, locationId: string, agentId: string, serviceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceService>> {
            const localVarAxiosArgs = await ProviderProjectAgentApiAxiosParamCreator(configuration).providerProjectAgentServiceGet(projectId, locationId, agentId, serviceId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List provider/agent.service
         * @summary List provider/agent.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async providerProjectAgentServiceList(projectId: string, locationId: string, agentId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResourceService>>> {
            const localVarAxiosArgs = await ProviderProjectAgentApiAxiosParamCreator(configuration).providerProjectAgentServiceList(projectId, locationId, agentId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * action start
         * @summary Start provider/agent
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async providerProjectAgentStart(projectId: string, locationId: string, agentId: string, xIdempotencyKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Agent>> {
            const localVarAxiosArgs = await ProviderProjectAgentApiAxiosParamCreator(configuration).providerProjectAgentStart(projectId, locationId, agentId, xIdempotencyKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * action suspend
         * @summary Suspend provider/agent
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async providerProjectAgentSuspend(projectId: string, locationId: string, agentId: string, xIdempotencyKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Agent>> {
            const localVarAxiosArgs = await ProviderProjectAgentApiAxiosParamCreator(configuration).providerProjectAgentSuspend(projectId, locationId, agentId, xIdempotencyKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create provider/agent.tag
         * @summary Create provider/agent.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async providerProjectAgentTagCreate(projectId: string, locationId: string, agentId: string, tag: Tag, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await ProviderProjectAgentApiAxiosParamCreator(configuration).providerProjectAgentTagCreate(projectId, locationId, agentId, tag, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete provider/agent.tag
         * @summary Delete provider/agent.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async providerProjectAgentTagDelete(projectId: string, locationId: string, agentId: string, tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await ProviderProjectAgentApiAxiosParamCreator(configuration).providerProjectAgentTagDelete(projectId, locationId, agentId, tagId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get provider/agent.tag
         * @summary Get provider/agent.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async providerProjectAgentTagGet(projectId: string, locationId: string, agentId: string, tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await ProviderProjectAgentApiAxiosParamCreator(configuration).providerProjectAgentTagGet(projectId, locationId, agentId, tagId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List provider/agent.tag
         * @summary List provider/agent.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async providerProjectAgentTagList(projectId: string, locationId: string, agentId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await ProviderProjectAgentApiAxiosParamCreator(configuration).providerProjectAgentTagList(projectId, locationId, agentId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Replace provider/agent.tag
         * @summary Replace provider/agent.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async providerProjectAgentTagPut(projectId: string, locationId: string, agentId: string, tag: Array<Tag>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await ProviderProjectAgentApiAxiosParamCreator(configuration).providerProjectAgentTagPut(projectId, locationId, agentId, tag, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * action transfer
         * @summary Transfer provider/agent
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {ProviderProjectAgentTransfer} providerProjectAgentTransfer 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async providerProjectAgentTransfer(projectId: string, locationId: string, agentId: string, providerProjectAgentTransfer: ProviderProjectAgentTransfer, xIdempotencyKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Agent>> {
            const localVarAxiosArgs = await ProviderProjectAgentApiAxiosParamCreator(configuration).providerProjectAgentTransfer(projectId, locationId, agentId, providerProjectAgentTransfer, xIdempotencyKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns modified agent
         * @summary Update provider/agent
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {ProviderProjectAgentUpdate} providerProjectAgentUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async providerProjectAgentUpdate(projectId: string, locationId: string, agentId: string, providerProjectAgentUpdate: ProviderProjectAgentUpdate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Agent>> {
            const localVarAxiosArgs = await ProviderProjectAgentApiAxiosParamCreator(configuration).providerProjectAgentUpdate(projectId, locationId, agentId, providerProjectAgentUpdate, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ProviderProjectAgentApi - factory interface
 * @export
 */
export const ProviderProjectAgentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Create agent
         * @summary Create provider/agent
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {ProviderProjectAgentCreate} providerProjectAgentCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentCreate(projectId: string, locationId: string, providerProjectAgentCreate: ProviderProjectAgentCreate, xIdempotencyKey?: string, options?: any): AxiosPromise<Agent> {
            return ProviderProjectAgentApiFp(configuration).providerProjectAgentCreate(projectId, locationId, providerProjectAgentCreate, xIdempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Create provider/agent.credential
         * @summary Create provider/agent.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {AgentCredential} agentCredential 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentCredentialCreate(projectId: string, locationId: string, agentId: string, agentCredential: AgentCredential, options?: any): AxiosPromise<AgentCredential> {
            return ProviderProjectAgentApiFp(configuration).providerProjectAgentCredentialCreate(projectId, locationId, agentId, agentCredential, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete provider/agent.credential
         * @summary Delete provider/agent.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {string} credentialId credentialId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentCredentialDelete(projectId: string, locationId: string, agentId: string, credentialId: string, options?: any): AxiosPromise<Agent> {
            return ProviderProjectAgentApiFp(configuration).providerProjectAgentCredentialDelete(projectId, locationId, agentId, credentialId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get provider/agent.credential
         * @summary Get provider/agent.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {string} credentialId credentialId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentCredentialGet(projectId: string, locationId: string, agentId: string, credentialId: string, options?: any): AxiosPromise<AgentCredential> {
            return ProviderProjectAgentApiFp(configuration).providerProjectAgentCredentialGet(projectId, locationId, agentId, credentialId, options).then((request) => request(axios, basePath));
        },
        /**
         * List provider/agent.credential
         * @summary List provider/agent.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentCredentialList(projectId: string, locationId: string, agentId: string, options?: any): AxiosPromise<Array<AgentCredential>> {
            return ProviderProjectAgentApiFp(configuration).providerProjectAgentCredentialList(projectId, locationId, agentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update provider/agent.credential
         * @summary Update provider/agent.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {string} credentialId credentialId
         * @param {ProviderProjectAgentCredentialPatch} providerProjectAgentCredentialPatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentCredentialPatch(projectId: string, locationId: string, agentId: string, credentialId: string, providerProjectAgentCredentialPatch: ProviderProjectAgentCredentialPatch, options?: any): AxiosPromise<AgentCredential> {
            return ProviderProjectAgentApiFp(configuration).providerProjectAgentCredentialPatch(projectId, locationId, agentId, credentialId, providerProjectAgentCredentialPatch, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete agent
         * @summary Delete provider/agent
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentDelete(projectId: string, locationId: string, agentId: string, options?: any): AxiosPromise<void> {
            return ProviderProjectAgentApiFp(configuration).providerProjectAgentDelete(projectId, locationId, agentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create provider/agent.enabledService
         * @summary Create provider/agent.enabledService
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {EnabledService} enabledService 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentEnabledServiceCreate(projectId: string, locationId: string, agentId: string, enabledService: EnabledService, options?: any): AxiosPromise<EnabledService> {
            return ProviderProjectAgentApiFp(configuration).providerProjectAgentEnabledServiceCreate(projectId, locationId, agentId, enabledService, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete provider/agent.enabledService
         * @summary Delete provider/agent.enabledService
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {string} enabledServiceId enabledServiceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentEnabledServiceDelete(projectId: string, locationId: string, agentId: string, enabledServiceId: string, options?: any): AxiosPromise<Agent> {
            return ProviderProjectAgentApiFp(configuration).providerProjectAgentEnabledServiceDelete(projectId, locationId, agentId, enabledServiceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get provider/agent.enabledService
         * @summary Get provider/agent.enabledService
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {string} enabledServiceId enabledServiceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentEnabledServiceGet(projectId: string, locationId: string, agentId: string, enabledServiceId: string, options?: any): AxiosPromise<EnabledService> {
            return ProviderProjectAgentApiFp(configuration).providerProjectAgentEnabledServiceGet(projectId, locationId, agentId, enabledServiceId, options).then((request) => request(axios, basePath));
        },
        /**
         * List provider/agent.enabledService
         * @summary List provider/agent.enabledService
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentEnabledServiceList(projectId: string, locationId: string, agentId: string, options?: any): AxiosPromise<Array<EnabledService>> {
            return ProviderProjectAgentApiFp(configuration).providerProjectAgentEnabledServiceList(projectId, locationId, agentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get provider/agent.event
         * @summary Get provider/agent.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentEventGet(projectId: string, locationId: string, agentId: string, eventId: string, options?: any): AxiosPromise<Event> {
            return ProviderProjectAgentApiFp(configuration).providerProjectAgentEventGet(projectId, locationId, agentId, eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * List provider/agent.event
         * @summary List provider/agent.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentEventList(projectId: string, locationId: string, agentId: string, $limit?: number, $skip?: number, options?: any): AxiosPromise<Array<Event>> {
            return ProviderProjectAgentApiFp(configuration).providerProjectAgentEventList(projectId, locationId, agentId, $limit, $skip, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single agent
         * @summary Get provider/agent
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentGet(projectId: string, locationId: string, agentId: string, options?: any): AxiosPromise<Agent> {
            return ProviderProjectAgentApiFp(configuration).providerProjectAgentGet(projectId, locationId, agentId, options).then((request) => request(axios, basePath));
        },
        /**
         * action inspect
         * @summary Inspect provider/agent
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentInspect(projectId: string, locationId: string, agentId: string, xIdempotencyKey?: string, options?: any): AxiosPromise<Agent> {
            return ProviderProjectAgentApiFp(configuration).providerProjectAgentInspect(projectId, locationId, agentId, xIdempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * List agent
         * @summary List provider/agent
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [name] Filter by name
         * @param {string} [enabledServices] Filter by enabledServices
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentList(projectId: string, locationId: string, name?: string, enabledServices?: string, tagValue?: string, tagKey?: string, options?: any): AxiosPromise<Array<Agent>> {
            return ProviderProjectAgentApiFp(configuration).providerProjectAgentList(projectId, locationId, name, enabledServices, tagValue, tagKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get provider/agent.metric
         * @summary Get provider/agent.metric
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {string} metricId metricId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentMetricGet(projectId: string, locationId: string, agentId: string, metricId: string, options?: any): AxiosPromise<Metric> {
            return ProviderProjectAgentApiFp(configuration).providerProjectAgentMetricGet(projectId, locationId, agentId, metricId, options).then((request) => request(axios, basePath));
        },
        /**
         * List provider/agent.metric
         * @summary List provider/agent.metric
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentMetricList(projectId: string, locationId: string, agentId: string, options?: any): AxiosPromise<Array<Metric>> {
            return ProviderProjectAgentApiFp(configuration).providerProjectAgentMetricList(projectId, locationId, agentId, options).then((request) => request(axios, basePath));
        },
        /**
         * List provider/agent.point
         * @summary List provider/agent.point
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {string} metricId metricId
         * @param {string} [interval] interval
         * @param {string} [timespan] timespan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentMetricPointList(projectId: string, locationId: string, agentId: string, metricId: string, interval?: string, timespan?: string, options?: any): AxiosPromise<Array<Point>> {
            return ProviderProjectAgentApiFp(configuration).providerProjectAgentMetricPointList(projectId, locationId, agentId, metricId, interval, timespan, options).then((request) => request(axios, basePath));
        },
        /**
         * List provider/agent.event
         * @summary List provider/agent.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {string} resourceId resourceId
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentResourceEventList(projectId: string, locationId: string, agentId: string, resourceId: string, $limit?: number, $skip?: number, options?: any): AxiosPromise<Array<ProviderAgentResourceEvent>> {
            return ProviderProjectAgentApiFp(configuration).providerProjectAgentResourceEventList(projectId, locationId, agentId, resourceId, $limit, $skip, options).then((request) => request(axios, basePath));
        },
        /**
         * Get provider/agent.resource
         * @summary Get provider/agent.resource
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {string} resourceId resourceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentResourceGet(projectId: string, locationId: string, agentId: string, resourceId: string, options?: any): AxiosPromise<ProviderAgentResource> {
            return ProviderProjectAgentApiFp(configuration).providerProjectAgentResourceGet(projectId, locationId, agentId, resourceId, options).then((request) => request(axios, basePath));
        },
        /**
         * action inspect
         * @summary Inspect provider/agent.resource
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {string} resourceId resourceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentResourceInspect(projectId: string, locationId: string, agentId: string, resourceId: string, options?: any): AxiosPromise<any> {
            return ProviderProjectAgentApiFp(configuration).providerProjectAgentResourceInspect(projectId, locationId, agentId, resourceId, options).then((request) => request(axios, basePath));
        },
        /**
         * List provider/agent.resource
         * @summary List provider/agent.resource
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentResourceList(projectId: string, locationId: string, agentId: string, options?: any): AxiosPromise<Array<ProviderAgentResource>> {
            return ProviderProjectAgentApiFp(configuration).providerProjectAgentResourceList(projectId, locationId, agentId, options).then((request) => request(axios, basePath));
        },
        /**
         * action recreate
         * @summary Recreate provider/agent.resource
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {string} resourceId resourceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentResourceRecreate(projectId: string, locationId: string, agentId: string, resourceId: string, options?: any): AxiosPromise<ProviderAgentResource> {
            return ProviderProjectAgentApiFp(configuration).providerProjectAgentResourceRecreate(projectId, locationId, agentId, resourceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get provider/agent.service
         * @summary Get provider/agent.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentServiceGet(projectId: string, locationId: string, agentId: string, serviceId: string, options?: any): AxiosPromise<ResourceService> {
            return ProviderProjectAgentApiFp(configuration).providerProjectAgentServiceGet(projectId, locationId, agentId, serviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * List provider/agent.service
         * @summary List provider/agent.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentServiceList(projectId: string, locationId: string, agentId: string, options?: any): AxiosPromise<Array<ResourceService>> {
            return ProviderProjectAgentApiFp(configuration).providerProjectAgentServiceList(projectId, locationId, agentId, options).then((request) => request(axios, basePath));
        },
        /**
         * action start
         * @summary Start provider/agent
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentStart(projectId: string, locationId: string, agentId: string, xIdempotencyKey?: string, options?: any): AxiosPromise<Agent> {
            return ProviderProjectAgentApiFp(configuration).providerProjectAgentStart(projectId, locationId, agentId, xIdempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * action suspend
         * @summary Suspend provider/agent
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentSuspend(projectId: string, locationId: string, agentId: string, xIdempotencyKey?: string, options?: any): AxiosPromise<Agent> {
            return ProviderProjectAgentApiFp(configuration).providerProjectAgentSuspend(projectId, locationId, agentId, xIdempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Create provider/agent.tag
         * @summary Create provider/agent.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentTagCreate(projectId: string, locationId: string, agentId: string, tag: Tag, options?: any): AxiosPromise<Tag> {
            return ProviderProjectAgentApiFp(configuration).providerProjectAgentTagCreate(projectId, locationId, agentId, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete provider/agent.tag
         * @summary Delete provider/agent.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentTagDelete(projectId: string, locationId: string, agentId: string, tagId: string, options?: any): AxiosPromise<void> {
            return ProviderProjectAgentApiFp(configuration).providerProjectAgentTagDelete(projectId, locationId, agentId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get provider/agent.tag
         * @summary Get provider/agent.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentTagGet(projectId: string, locationId: string, agentId: string, tagId: string, options?: any): AxiosPromise<Tag> {
            return ProviderProjectAgentApiFp(configuration).providerProjectAgentTagGet(projectId, locationId, agentId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * List provider/agent.tag
         * @summary List provider/agent.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentTagList(projectId: string, locationId: string, agentId: string, options?: any): AxiosPromise<Array<Tag>> {
            return ProviderProjectAgentApiFp(configuration).providerProjectAgentTagList(projectId, locationId, agentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Replace provider/agent.tag
         * @summary Replace provider/agent.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentTagPut(projectId: string, locationId: string, agentId: string, tag: Array<Tag>, options?: any): AxiosPromise<Array<Tag>> {
            return ProviderProjectAgentApiFp(configuration).providerProjectAgentTagPut(projectId, locationId, agentId, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * action transfer
         * @summary Transfer provider/agent
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {ProviderProjectAgentTransfer} providerProjectAgentTransfer 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentTransfer(projectId: string, locationId: string, agentId: string, providerProjectAgentTransfer: ProviderProjectAgentTransfer, xIdempotencyKey?: string, options?: any): AxiosPromise<Agent> {
            return ProviderProjectAgentApiFp(configuration).providerProjectAgentTransfer(projectId, locationId, agentId, providerProjectAgentTransfer, xIdempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns modified agent
         * @summary Update provider/agent
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {ProviderProjectAgentUpdate} providerProjectAgentUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentUpdate(projectId: string, locationId: string, agentId: string, providerProjectAgentUpdate: ProviderProjectAgentUpdate, options?: any): AxiosPromise<Agent> {
            return ProviderProjectAgentApiFp(configuration).providerProjectAgentUpdate(projectId, locationId, agentId, providerProjectAgentUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProviderProjectAgentApi - object-oriented interface
 * @export
 * @class ProviderProjectAgentApi
 * @extends {BaseAPI}
 */
export class ProviderProjectAgentApi extends BaseAPI {
    /**
     * Create agent
     * @summary Create provider/agent
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {ProviderProjectAgentCreate} providerProjectAgentCreate 
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderProjectAgentApi
     */
    public providerProjectAgentCreate(projectId: string, locationId: string, providerProjectAgentCreate: ProviderProjectAgentCreate, xIdempotencyKey?: string, options?: any) {
        return ProviderProjectAgentApiFp(this.configuration).providerProjectAgentCreate(projectId, locationId, providerProjectAgentCreate, xIdempotencyKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create provider/agent.credential
     * @summary Create provider/agent.credential
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} agentId Agent Id
     * @param {AgentCredential} agentCredential 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderProjectAgentApi
     */
    public providerProjectAgentCredentialCreate(projectId: string, locationId: string, agentId: string, agentCredential: AgentCredential, options?: any) {
        return ProviderProjectAgentApiFp(this.configuration).providerProjectAgentCredentialCreate(projectId, locationId, agentId, agentCredential, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete provider/agent.credential
     * @summary Delete provider/agent.credential
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} agentId Agent Id
     * @param {string} credentialId credentialId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderProjectAgentApi
     */
    public providerProjectAgentCredentialDelete(projectId: string, locationId: string, agentId: string, credentialId: string, options?: any) {
        return ProviderProjectAgentApiFp(this.configuration).providerProjectAgentCredentialDelete(projectId, locationId, agentId, credentialId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get provider/agent.credential
     * @summary Get provider/agent.credential
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} agentId Agent Id
     * @param {string} credentialId credentialId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderProjectAgentApi
     */
    public providerProjectAgentCredentialGet(projectId: string, locationId: string, agentId: string, credentialId: string, options?: any) {
        return ProviderProjectAgentApiFp(this.configuration).providerProjectAgentCredentialGet(projectId, locationId, agentId, credentialId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List provider/agent.credential
     * @summary List provider/agent.credential
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} agentId Agent Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderProjectAgentApi
     */
    public providerProjectAgentCredentialList(projectId: string, locationId: string, agentId: string, options?: any) {
        return ProviderProjectAgentApiFp(this.configuration).providerProjectAgentCredentialList(projectId, locationId, agentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update provider/agent.credential
     * @summary Update provider/agent.credential
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} agentId Agent Id
     * @param {string} credentialId credentialId
     * @param {ProviderProjectAgentCredentialPatch} providerProjectAgentCredentialPatch 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderProjectAgentApi
     */
    public providerProjectAgentCredentialPatch(projectId: string, locationId: string, agentId: string, credentialId: string, providerProjectAgentCredentialPatch: ProviderProjectAgentCredentialPatch, options?: any) {
        return ProviderProjectAgentApiFp(this.configuration).providerProjectAgentCredentialPatch(projectId, locationId, agentId, credentialId, providerProjectAgentCredentialPatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete agent
     * @summary Delete provider/agent
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} agentId Agent Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderProjectAgentApi
     */
    public providerProjectAgentDelete(projectId: string, locationId: string, agentId: string, options?: any) {
        return ProviderProjectAgentApiFp(this.configuration).providerProjectAgentDelete(projectId, locationId, agentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create provider/agent.enabledService
     * @summary Create provider/agent.enabledService
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} agentId Agent Id
     * @param {EnabledService} enabledService 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderProjectAgentApi
     */
    public providerProjectAgentEnabledServiceCreate(projectId: string, locationId: string, agentId: string, enabledService: EnabledService, options?: any) {
        return ProviderProjectAgentApiFp(this.configuration).providerProjectAgentEnabledServiceCreate(projectId, locationId, agentId, enabledService, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete provider/agent.enabledService
     * @summary Delete provider/agent.enabledService
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} agentId Agent Id
     * @param {string} enabledServiceId enabledServiceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderProjectAgentApi
     */
    public providerProjectAgentEnabledServiceDelete(projectId: string, locationId: string, agentId: string, enabledServiceId: string, options?: any) {
        return ProviderProjectAgentApiFp(this.configuration).providerProjectAgentEnabledServiceDelete(projectId, locationId, agentId, enabledServiceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get provider/agent.enabledService
     * @summary Get provider/agent.enabledService
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} agentId Agent Id
     * @param {string} enabledServiceId enabledServiceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderProjectAgentApi
     */
    public providerProjectAgentEnabledServiceGet(projectId: string, locationId: string, agentId: string, enabledServiceId: string, options?: any) {
        return ProviderProjectAgentApiFp(this.configuration).providerProjectAgentEnabledServiceGet(projectId, locationId, agentId, enabledServiceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List provider/agent.enabledService
     * @summary List provider/agent.enabledService
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} agentId Agent Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderProjectAgentApi
     */
    public providerProjectAgentEnabledServiceList(projectId: string, locationId: string, agentId: string, options?: any) {
        return ProviderProjectAgentApiFp(this.configuration).providerProjectAgentEnabledServiceList(projectId, locationId, agentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get provider/agent.event
     * @summary Get provider/agent.event
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} agentId Agent Id
     * @param {string} eventId eventId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderProjectAgentApi
     */
    public providerProjectAgentEventGet(projectId: string, locationId: string, agentId: string, eventId: string, options?: any) {
        return ProviderProjectAgentApiFp(this.configuration).providerProjectAgentEventGet(projectId, locationId, agentId, eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List provider/agent.event
     * @summary List provider/agent.event
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} agentId Agent Id
     * @param {number} [$limit] $limit
     * @param {number} [$skip] $skip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderProjectAgentApi
     */
    public providerProjectAgentEventList(projectId: string, locationId: string, agentId: string, $limit?: number, $skip?: number, options?: any) {
        return ProviderProjectAgentApiFp(this.configuration).providerProjectAgentEventList(projectId, locationId, agentId, $limit, $skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single agent
     * @summary Get provider/agent
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} agentId Agent Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderProjectAgentApi
     */
    public providerProjectAgentGet(projectId: string, locationId: string, agentId: string, options?: any) {
        return ProviderProjectAgentApiFp(this.configuration).providerProjectAgentGet(projectId, locationId, agentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * action inspect
     * @summary Inspect provider/agent
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} agentId Agent Id
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderProjectAgentApi
     */
    public providerProjectAgentInspect(projectId: string, locationId: string, agentId: string, xIdempotencyKey?: string, options?: any) {
        return ProviderProjectAgentApiFp(this.configuration).providerProjectAgentInspect(projectId, locationId, agentId, xIdempotencyKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List agent
     * @summary List provider/agent
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} [name] Filter by name
     * @param {string} [enabledServices] Filter by enabledServices
     * @param {string} [tagValue] Filter by tag.value
     * @param {string} [tagKey] Filter by tag.key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderProjectAgentApi
     */
    public providerProjectAgentList(projectId: string, locationId: string, name?: string, enabledServices?: string, tagValue?: string, tagKey?: string, options?: any) {
        return ProviderProjectAgentApiFp(this.configuration).providerProjectAgentList(projectId, locationId, name, enabledServices, tagValue, tagKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get provider/agent.metric
     * @summary Get provider/agent.metric
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} agentId Agent Id
     * @param {string} metricId metricId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderProjectAgentApi
     */
    public providerProjectAgentMetricGet(projectId: string, locationId: string, agentId: string, metricId: string, options?: any) {
        return ProviderProjectAgentApiFp(this.configuration).providerProjectAgentMetricGet(projectId, locationId, agentId, metricId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List provider/agent.metric
     * @summary List provider/agent.metric
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} agentId Agent Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderProjectAgentApi
     */
    public providerProjectAgentMetricList(projectId: string, locationId: string, agentId: string, options?: any) {
        return ProviderProjectAgentApiFp(this.configuration).providerProjectAgentMetricList(projectId, locationId, agentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List provider/agent.point
     * @summary List provider/agent.point
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} agentId Agent Id
     * @param {string} metricId metricId
     * @param {string} [interval] interval
     * @param {string} [timespan] timespan
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderProjectAgentApi
     */
    public providerProjectAgentMetricPointList(projectId: string, locationId: string, agentId: string, metricId: string, interval?: string, timespan?: string, options?: any) {
        return ProviderProjectAgentApiFp(this.configuration).providerProjectAgentMetricPointList(projectId, locationId, agentId, metricId, interval, timespan, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List provider/agent.event
     * @summary List provider/agent.event
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} agentId Agent Id
     * @param {string} resourceId resourceId
     * @param {number} [$limit] $limit
     * @param {number} [$skip] $skip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderProjectAgentApi
     */
    public providerProjectAgentResourceEventList(projectId: string, locationId: string, agentId: string, resourceId: string, $limit?: number, $skip?: number, options?: any) {
        return ProviderProjectAgentApiFp(this.configuration).providerProjectAgentResourceEventList(projectId, locationId, agentId, resourceId, $limit, $skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get provider/agent.resource
     * @summary Get provider/agent.resource
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} agentId Agent Id
     * @param {string} resourceId resourceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderProjectAgentApi
     */
    public providerProjectAgentResourceGet(projectId: string, locationId: string, agentId: string, resourceId: string, options?: any) {
        return ProviderProjectAgentApiFp(this.configuration).providerProjectAgentResourceGet(projectId, locationId, agentId, resourceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * action inspect
     * @summary Inspect provider/agent.resource
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} agentId Agent Id
     * @param {string} resourceId resourceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderProjectAgentApi
     */
    public providerProjectAgentResourceInspect(projectId: string, locationId: string, agentId: string, resourceId: string, options?: any) {
        return ProviderProjectAgentApiFp(this.configuration).providerProjectAgentResourceInspect(projectId, locationId, agentId, resourceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List provider/agent.resource
     * @summary List provider/agent.resource
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} agentId Agent Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderProjectAgentApi
     */
    public providerProjectAgentResourceList(projectId: string, locationId: string, agentId: string, options?: any) {
        return ProviderProjectAgentApiFp(this.configuration).providerProjectAgentResourceList(projectId, locationId, agentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * action recreate
     * @summary Recreate provider/agent.resource
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} agentId Agent Id
     * @param {string} resourceId resourceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderProjectAgentApi
     */
    public providerProjectAgentResourceRecreate(projectId: string, locationId: string, agentId: string, resourceId: string, options?: any) {
        return ProviderProjectAgentApiFp(this.configuration).providerProjectAgentResourceRecreate(projectId, locationId, agentId, resourceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get provider/agent.service
     * @summary Get provider/agent.service
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} agentId Agent Id
     * @param {string} serviceId serviceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderProjectAgentApi
     */
    public providerProjectAgentServiceGet(projectId: string, locationId: string, agentId: string, serviceId: string, options?: any) {
        return ProviderProjectAgentApiFp(this.configuration).providerProjectAgentServiceGet(projectId, locationId, agentId, serviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List provider/agent.service
     * @summary List provider/agent.service
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} agentId Agent Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderProjectAgentApi
     */
    public providerProjectAgentServiceList(projectId: string, locationId: string, agentId: string, options?: any) {
        return ProviderProjectAgentApiFp(this.configuration).providerProjectAgentServiceList(projectId, locationId, agentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * action start
     * @summary Start provider/agent
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} agentId Agent Id
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderProjectAgentApi
     */
    public providerProjectAgentStart(projectId: string, locationId: string, agentId: string, xIdempotencyKey?: string, options?: any) {
        return ProviderProjectAgentApiFp(this.configuration).providerProjectAgentStart(projectId, locationId, agentId, xIdempotencyKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * action suspend
     * @summary Suspend provider/agent
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} agentId Agent Id
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderProjectAgentApi
     */
    public providerProjectAgentSuspend(projectId: string, locationId: string, agentId: string, xIdempotencyKey?: string, options?: any) {
        return ProviderProjectAgentApiFp(this.configuration).providerProjectAgentSuspend(projectId, locationId, agentId, xIdempotencyKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create provider/agent.tag
     * @summary Create provider/agent.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} agentId Agent Id
     * @param {Tag} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderProjectAgentApi
     */
    public providerProjectAgentTagCreate(projectId: string, locationId: string, agentId: string, tag: Tag, options?: any) {
        return ProviderProjectAgentApiFp(this.configuration).providerProjectAgentTagCreate(projectId, locationId, agentId, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete provider/agent.tag
     * @summary Delete provider/agent.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} agentId Agent Id
     * @param {string} tagId tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderProjectAgentApi
     */
    public providerProjectAgentTagDelete(projectId: string, locationId: string, agentId: string, tagId: string, options?: any) {
        return ProviderProjectAgentApiFp(this.configuration).providerProjectAgentTagDelete(projectId, locationId, agentId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get provider/agent.tag
     * @summary Get provider/agent.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} agentId Agent Id
     * @param {string} tagId tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderProjectAgentApi
     */
    public providerProjectAgentTagGet(projectId: string, locationId: string, agentId: string, tagId: string, options?: any) {
        return ProviderProjectAgentApiFp(this.configuration).providerProjectAgentTagGet(projectId, locationId, agentId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List provider/agent.tag
     * @summary List provider/agent.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} agentId Agent Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderProjectAgentApi
     */
    public providerProjectAgentTagList(projectId: string, locationId: string, agentId: string, options?: any) {
        return ProviderProjectAgentApiFp(this.configuration).providerProjectAgentTagList(projectId, locationId, agentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replace provider/agent.tag
     * @summary Replace provider/agent.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} agentId Agent Id
     * @param {Array<Tag>} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderProjectAgentApi
     */
    public providerProjectAgentTagPut(projectId: string, locationId: string, agentId: string, tag: Array<Tag>, options?: any) {
        return ProviderProjectAgentApiFp(this.configuration).providerProjectAgentTagPut(projectId, locationId, agentId, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * action transfer
     * @summary Transfer provider/agent
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} agentId Agent Id
     * @param {ProviderProjectAgentTransfer} providerProjectAgentTransfer 
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderProjectAgentApi
     */
    public providerProjectAgentTransfer(projectId: string, locationId: string, agentId: string, providerProjectAgentTransfer: ProviderProjectAgentTransfer, xIdempotencyKey?: string, options?: any) {
        return ProviderProjectAgentApiFp(this.configuration).providerProjectAgentTransfer(projectId, locationId, agentId, providerProjectAgentTransfer, xIdempotencyKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns modified agent
     * @summary Update provider/agent
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} agentId Agent Id
     * @param {ProviderProjectAgentUpdate} providerProjectAgentUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderProjectAgentApi
     */
    public providerProjectAgentUpdate(projectId: string, locationId: string, agentId: string, providerProjectAgentUpdate: ProviderProjectAgentUpdate, options?: any) {
        return ProviderProjectAgentApiFp(this.configuration).providerProjectAgentUpdate(projectId, locationId, agentId, providerProjectAgentUpdate, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * RecoveryProjectBackupApi - axios parameter creator
 * @export
 */
export const RecoveryProjectBackupApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create backup
         * @summary Create recovery/backup
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {RecoveryProjectBackupCreate} recoveryProjectBackupCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoveryProjectBackupCreate: async (projectId: string, locationId: string, recoveryProjectBackupCreate: RecoveryProjectBackupCreate, xIdempotencyKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling recoveryProjectBackupCreate.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling recoveryProjectBackupCreate.');
            }
            // verify required parameter 'recoveryProjectBackupCreate' is not null or undefined
            if (recoveryProjectBackupCreate === null || recoveryProjectBackupCreate === undefined) {
                throw new RequiredError('recoveryProjectBackupCreate','Required parameter recoveryProjectBackupCreate was null or undefined when calling recoveryProjectBackupCreate.');
            }
            const localVarPath = `/recovery/{locationId}/project/{projectId}/backup`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof recoveryProjectBackupCreate !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(recoveryProjectBackupCreate !== undefined ? recoveryProjectBackupCreate : {}) : (recoveryProjectBackupCreate || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete backup
         * @summary Delete recovery/backup
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} backupId Backup Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoveryProjectBackupDelete: async (projectId: string, locationId: string, backupId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling recoveryProjectBackupDelete.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling recoveryProjectBackupDelete.');
            }
            // verify required parameter 'backupId' is not null or undefined
            if (backupId === null || backupId === undefined) {
                throw new RequiredError('backupId','Required parameter backupId was null or undefined when calling recoveryProjectBackupDelete.');
            }
            const localVarPath = `/recovery/{locationId}/project/{projectId}/backup/{backupId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"backupId"}}`, encodeURIComponent(String(backupId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get recovery/backup.event
         * @summary Get recovery/backup.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} backupId Backup Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoveryProjectBackupEventGet: async (projectId: string, locationId: string, backupId: string, eventId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling recoveryProjectBackupEventGet.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling recoveryProjectBackupEventGet.');
            }
            // verify required parameter 'backupId' is not null or undefined
            if (backupId === null || backupId === undefined) {
                throw new RequiredError('backupId','Required parameter backupId was null or undefined when calling recoveryProjectBackupEventGet.');
            }
            // verify required parameter 'eventId' is not null or undefined
            if (eventId === null || eventId === undefined) {
                throw new RequiredError('eventId','Required parameter eventId was null or undefined when calling recoveryProjectBackupEventGet.');
            }
            const localVarPath = `/recovery/{locationId}/project/{projectId}/backup/{backupId}/event/{eventId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"backupId"}}`, encodeURIComponent(String(backupId)))
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List recovery/backup.event
         * @summary List recovery/backup.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} backupId Backup Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoveryProjectBackupEventList: async (projectId: string, locationId: string, backupId: string, $limit?: number, $skip?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling recoveryProjectBackupEventList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling recoveryProjectBackupEventList.');
            }
            // verify required parameter 'backupId' is not null or undefined
            if (backupId === null || backupId === undefined) {
                throw new RequiredError('backupId','Required parameter backupId was null or undefined when calling recoveryProjectBackupEventList.');
            }
            const localVarPath = `/recovery/{locationId}/project/{projectId}/backup/{backupId}/event`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"backupId"}}`, encodeURIComponent(String(backupId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if ($limit !== undefined) {
                localVarQueryParameter['$limit'] = $limit;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * action export
         * @summary Export recovery/backup
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} backupId Backup Id
         * @param {RecoveryProjectBackupExport} recoveryProjectBackupExport 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoveryProjectBackupExport: async (projectId: string, locationId: string, backupId: string, recoveryProjectBackupExport: RecoveryProjectBackupExport, xIdempotencyKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling recoveryProjectBackupExport.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling recoveryProjectBackupExport.');
            }
            // verify required parameter 'backupId' is not null or undefined
            if (backupId === null || backupId === undefined) {
                throw new RequiredError('backupId','Required parameter backupId was null or undefined when calling recoveryProjectBackupExport.');
            }
            // verify required parameter 'recoveryProjectBackupExport' is not null or undefined
            if (recoveryProjectBackupExport === null || recoveryProjectBackupExport === undefined) {
                throw new RequiredError('recoveryProjectBackupExport','Required parameter recoveryProjectBackupExport was null or undefined when calling recoveryProjectBackupExport.');
            }
            const localVarPath = `/recovery/{locationId}/project/{projectId}/backup/{backupId}/actions/export`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"backupId"}}`, encodeURIComponent(String(backupId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof recoveryProjectBackupExport !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(recoveryProjectBackupExport !== undefined ? recoveryProjectBackupExport : {}) : (recoveryProjectBackupExport || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single backup
         * @summary Get recovery/backup
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} backupId Backup Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoveryProjectBackupGet: async (projectId: string, locationId: string, backupId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling recoveryProjectBackupGet.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling recoveryProjectBackupGet.');
            }
            // verify required parameter 'backupId' is not null or undefined
            if (backupId === null || backupId === undefined) {
                throw new RequiredError('backupId','Required parameter backupId was null or undefined when calling recoveryProjectBackupGet.');
            }
            const localVarPath = `/recovery/{locationId}/project/{projectId}/backup/{backupId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"backupId"}}`, encodeURIComponent(String(backupId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List backup
         * @summary List recovery/backup
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [name] Filter by name
         * @param {string} [source] Filter by source
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoveryProjectBackupList: async (projectId: string, locationId: string, name?: string, source?: string, tagValue?: string, tagKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling recoveryProjectBackupList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling recoveryProjectBackupList.');
            }
            const localVarPath = `/recovery/{locationId}/project/{projectId}/backup`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (source !== undefined) {
                localVarQueryParameter['source'] = source;
            }

            if (tagValue !== undefined) {
                localVarQueryParameter['tag.value'] = tagValue;
            }

            if (tagKey !== undefined) {
                localVarQueryParameter['tag.key'] = tagKey;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get recovery/backup.metric
         * @summary Get recovery/backup.metric
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} backupId Backup Id
         * @param {string} metricId metricId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoveryProjectBackupMetricGet: async (projectId: string, locationId: string, backupId: string, metricId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling recoveryProjectBackupMetricGet.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling recoveryProjectBackupMetricGet.');
            }
            // verify required parameter 'backupId' is not null or undefined
            if (backupId === null || backupId === undefined) {
                throw new RequiredError('backupId','Required parameter backupId was null or undefined when calling recoveryProjectBackupMetricGet.');
            }
            // verify required parameter 'metricId' is not null or undefined
            if (metricId === null || metricId === undefined) {
                throw new RequiredError('metricId','Required parameter metricId was null or undefined when calling recoveryProjectBackupMetricGet.');
            }
            const localVarPath = `/recovery/{locationId}/project/{projectId}/backup/{backupId}/metric/{metricId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"backupId"}}`, encodeURIComponent(String(backupId)))
                .replace(`{${"metricId"}}`, encodeURIComponent(String(metricId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List recovery/backup.metric
         * @summary List recovery/backup.metric
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} backupId Backup Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoveryProjectBackupMetricList: async (projectId: string, locationId: string, backupId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling recoveryProjectBackupMetricList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling recoveryProjectBackupMetricList.');
            }
            // verify required parameter 'backupId' is not null or undefined
            if (backupId === null || backupId === undefined) {
                throw new RequiredError('backupId','Required parameter backupId was null or undefined when calling recoveryProjectBackupMetricList.');
            }
            const localVarPath = `/recovery/{locationId}/project/{projectId}/backup/{backupId}/metric`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"backupId"}}`, encodeURIComponent(String(backupId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List recovery/backup.point
         * @summary List recovery/backup.point
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} backupId Backup Id
         * @param {string} metricId metricId
         * @param {string} [interval] interval
         * @param {string} [timespan] timespan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoveryProjectBackupMetricPointList: async (projectId: string, locationId: string, backupId: string, metricId: string, interval?: string, timespan?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling recoveryProjectBackupMetricPointList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling recoveryProjectBackupMetricPointList.');
            }
            // verify required parameter 'backupId' is not null or undefined
            if (backupId === null || backupId === undefined) {
                throw new RequiredError('backupId','Required parameter backupId was null or undefined when calling recoveryProjectBackupMetricPointList.');
            }
            // verify required parameter 'metricId' is not null or undefined
            if (metricId === null || metricId === undefined) {
                throw new RequiredError('metricId','Required parameter metricId was null or undefined when calling recoveryProjectBackupMetricPointList.');
            }
            const localVarPath = `/recovery/{locationId}/project/{projectId}/backup/{backupId}/metric/{metricId}/point`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"backupId"}}`, encodeURIComponent(String(backupId)))
                .replace(`{${"metricId"}}`, encodeURIComponent(String(metricId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (timespan !== undefined) {
                localVarQueryParameter['timespan'] = timespan;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get recovery/backup.service
         * @summary Get recovery/backup.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} backupId Backup Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoveryProjectBackupServiceGet: async (projectId: string, locationId: string, backupId: string, serviceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling recoveryProjectBackupServiceGet.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling recoveryProjectBackupServiceGet.');
            }
            // verify required parameter 'backupId' is not null or undefined
            if (backupId === null || backupId === undefined) {
                throw new RequiredError('backupId','Required parameter backupId was null or undefined when calling recoveryProjectBackupServiceGet.');
            }
            // verify required parameter 'serviceId' is not null or undefined
            if (serviceId === null || serviceId === undefined) {
                throw new RequiredError('serviceId','Required parameter serviceId was null or undefined when calling recoveryProjectBackupServiceGet.');
            }
            const localVarPath = `/recovery/{locationId}/project/{projectId}/backup/{backupId}/service/{serviceId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"backupId"}}`, encodeURIComponent(String(backupId)))
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List recovery/backup.service
         * @summary List recovery/backup.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} backupId Backup Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoveryProjectBackupServiceList: async (projectId: string, locationId: string, backupId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling recoveryProjectBackupServiceList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling recoveryProjectBackupServiceList.');
            }
            // verify required parameter 'backupId' is not null or undefined
            if (backupId === null || backupId === undefined) {
                throw new RequiredError('backupId','Required parameter backupId was null or undefined when calling recoveryProjectBackupServiceList.');
            }
            const localVarPath = `/recovery/{locationId}/project/{projectId}/backup/{backupId}/service`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"backupId"}}`, encodeURIComponent(String(backupId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create recovery/backup.tag
         * @summary Create recovery/backup.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} backupId Backup Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoveryProjectBackupTagCreate: async (projectId: string, locationId: string, backupId: string, tag: Tag, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling recoveryProjectBackupTagCreate.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling recoveryProjectBackupTagCreate.');
            }
            // verify required parameter 'backupId' is not null or undefined
            if (backupId === null || backupId === undefined) {
                throw new RequiredError('backupId','Required parameter backupId was null or undefined when calling recoveryProjectBackupTagCreate.');
            }
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling recoveryProjectBackupTagCreate.');
            }
            const localVarPath = `/recovery/{locationId}/project/{projectId}/backup/{backupId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"backupId"}}`, encodeURIComponent(String(backupId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof tag !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(tag !== undefined ? tag : {}) : (tag || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete recovery/backup.tag
         * @summary Delete recovery/backup.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} backupId Backup Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoveryProjectBackupTagDelete: async (projectId: string, locationId: string, backupId: string, tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling recoveryProjectBackupTagDelete.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling recoveryProjectBackupTagDelete.');
            }
            // verify required parameter 'backupId' is not null or undefined
            if (backupId === null || backupId === undefined) {
                throw new RequiredError('backupId','Required parameter backupId was null or undefined when calling recoveryProjectBackupTagDelete.');
            }
            // verify required parameter 'tagId' is not null or undefined
            if (tagId === null || tagId === undefined) {
                throw new RequiredError('tagId','Required parameter tagId was null or undefined when calling recoveryProjectBackupTagDelete.');
            }
            const localVarPath = `/recovery/{locationId}/project/{projectId}/backup/{backupId}/tag/{tagId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"backupId"}}`, encodeURIComponent(String(backupId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get recovery/backup.tag
         * @summary Get recovery/backup.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} backupId Backup Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoveryProjectBackupTagGet: async (projectId: string, locationId: string, backupId: string, tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling recoveryProjectBackupTagGet.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling recoveryProjectBackupTagGet.');
            }
            // verify required parameter 'backupId' is not null or undefined
            if (backupId === null || backupId === undefined) {
                throw new RequiredError('backupId','Required parameter backupId was null or undefined when calling recoveryProjectBackupTagGet.');
            }
            // verify required parameter 'tagId' is not null or undefined
            if (tagId === null || tagId === undefined) {
                throw new RequiredError('tagId','Required parameter tagId was null or undefined when calling recoveryProjectBackupTagGet.');
            }
            const localVarPath = `/recovery/{locationId}/project/{projectId}/backup/{backupId}/tag/{tagId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"backupId"}}`, encodeURIComponent(String(backupId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List recovery/backup.tag
         * @summary List recovery/backup.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} backupId Backup Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoveryProjectBackupTagList: async (projectId: string, locationId: string, backupId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling recoveryProjectBackupTagList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling recoveryProjectBackupTagList.');
            }
            // verify required parameter 'backupId' is not null or undefined
            if (backupId === null || backupId === undefined) {
                throw new RequiredError('backupId','Required parameter backupId was null or undefined when calling recoveryProjectBackupTagList.');
            }
            const localVarPath = `/recovery/{locationId}/project/{projectId}/backup/{backupId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"backupId"}}`, encodeURIComponent(String(backupId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replace recovery/backup.tag
         * @summary Replace recovery/backup.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} backupId Backup Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoveryProjectBackupTagPut: async (projectId: string, locationId: string, backupId: string, tag: Array<Tag>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling recoveryProjectBackupTagPut.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling recoveryProjectBackupTagPut.');
            }
            // verify required parameter 'backupId' is not null or undefined
            if (backupId === null || backupId === undefined) {
                throw new RequiredError('backupId','Required parameter backupId was null or undefined when calling recoveryProjectBackupTagPut.');
            }
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling recoveryProjectBackupTagPut.');
            }
            const localVarPath = `/recovery/{locationId}/project/{projectId}/backup/{backupId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"backupId"}}`, encodeURIComponent(String(backupId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof tag !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(tag !== undefined ? tag : {}) : (tag || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns modified backup
         * @summary Update recovery/backup
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} backupId Backup Id
         * @param {RecoveryProjectBackupUpdate} recoveryProjectBackupUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoveryProjectBackupUpdate: async (projectId: string, locationId: string, backupId: string, recoveryProjectBackupUpdate: RecoveryProjectBackupUpdate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling recoveryProjectBackupUpdate.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling recoveryProjectBackupUpdate.');
            }
            // verify required parameter 'backupId' is not null or undefined
            if (backupId === null || backupId === undefined) {
                throw new RequiredError('backupId','Required parameter backupId was null or undefined when calling recoveryProjectBackupUpdate.');
            }
            // verify required parameter 'recoveryProjectBackupUpdate' is not null or undefined
            if (recoveryProjectBackupUpdate === null || recoveryProjectBackupUpdate === undefined) {
                throw new RequiredError('recoveryProjectBackupUpdate','Required parameter recoveryProjectBackupUpdate was null or undefined when calling recoveryProjectBackupUpdate.');
            }
            const localVarPath = `/recovery/{locationId}/project/{projectId}/backup/{backupId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"backupId"}}`, encodeURIComponent(String(backupId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof recoveryProjectBackupUpdate !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(recoveryProjectBackupUpdate !== undefined ? recoveryProjectBackupUpdate : {}) : (recoveryProjectBackupUpdate || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RecoveryProjectBackupApi - functional programming interface
 * @export
 */
export const RecoveryProjectBackupApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create backup
         * @summary Create recovery/backup
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {RecoveryProjectBackupCreate} recoveryProjectBackupCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recoveryProjectBackupCreate(projectId: string, locationId: string, recoveryProjectBackupCreate: RecoveryProjectBackupCreate, xIdempotencyKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Backup>> {
            const localVarAxiosArgs = await RecoveryProjectBackupApiAxiosParamCreator(configuration).recoveryProjectBackupCreate(projectId, locationId, recoveryProjectBackupCreate, xIdempotencyKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete backup
         * @summary Delete recovery/backup
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} backupId Backup Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recoveryProjectBackupDelete(projectId: string, locationId: string, backupId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await RecoveryProjectBackupApiAxiosParamCreator(configuration).recoveryProjectBackupDelete(projectId, locationId, backupId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get recovery/backup.event
         * @summary Get recovery/backup.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} backupId Backup Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recoveryProjectBackupEventGet(projectId: string, locationId: string, backupId: string, eventId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>> {
            const localVarAxiosArgs = await RecoveryProjectBackupApiAxiosParamCreator(configuration).recoveryProjectBackupEventGet(projectId, locationId, backupId, eventId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List recovery/backup.event
         * @summary List recovery/backup.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} backupId Backup Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recoveryProjectBackupEventList(projectId: string, locationId: string, backupId: string, $limit?: number, $skip?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Event>>> {
            const localVarAxiosArgs = await RecoveryProjectBackupApiAxiosParamCreator(configuration).recoveryProjectBackupEventList(projectId, locationId, backupId, $limit, $skip, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * action export
         * @summary Export recovery/backup
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} backupId Backup Id
         * @param {RecoveryProjectBackupExport} recoveryProjectBackupExport 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recoveryProjectBackupExport(projectId: string, locationId: string, backupId: string, recoveryProjectBackupExport: RecoveryProjectBackupExport, xIdempotencyKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Backup>> {
            const localVarAxiosArgs = await RecoveryProjectBackupApiAxiosParamCreator(configuration).recoveryProjectBackupExport(projectId, locationId, backupId, recoveryProjectBackupExport, xIdempotencyKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a single backup
         * @summary Get recovery/backup
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} backupId Backup Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recoveryProjectBackupGet(projectId: string, locationId: string, backupId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Backup>> {
            const localVarAxiosArgs = await RecoveryProjectBackupApiAxiosParamCreator(configuration).recoveryProjectBackupGet(projectId, locationId, backupId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List backup
         * @summary List recovery/backup
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [name] Filter by name
         * @param {string} [source] Filter by source
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recoveryProjectBackupList(projectId: string, locationId: string, name?: string, source?: string, tagValue?: string, tagKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Backup>>> {
            const localVarAxiosArgs = await RecoveryProjectBackupApiAxiosParamCreator(configuration).recoveryProjectBackupList(projectId, locationId, name, source, tagValue, tagKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get recovery/backup.metric
         * @summary Get recovery/backup.metric
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} backupId Backup Id
         * @param {string} metricId metricId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recoveryProjectBackupMetricGet(projectId: string, locationId: string, backupId: string, metricId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Metric>> {
            const localVarAxiosArgs = await RecoveryProjectBackupApiAxiosParamCreator(configuration).recoveryProjectBackupMetricGet(projectId, locationId, backupId, metricId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List recovery/backup.metric
         * @summary List recovery/backup.metric
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} backupId Backup Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recoveryProjectBackupMetricList(projectId: string, locationId: string, backupId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Metric>>> {
            const localVarAxiosArgs = await RecoveryProjectBackupApiAxiosParamCreator(configuration).recoveryProjectBackupMetricList(projectId, locationId, backupId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List recovery/backup.point
         * @summary List recovery/backup.point
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} backupId Backup Id
         * @param {string} metricId metricId
         * @param {string} [interval] interval
         * @param {string} [timespan] timespan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recoveryProjectBackupMetricPointList(projectId: string, locationId: string, backupId: string, metricId: string, interval?: string, timespan?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Point>>> {
            const localVarAxiosArgs = await RecoveryProjectBackupApiAxiosParamCreator(configuration).recoveryProjectBackupMetricPointList(projectId, locationId, backupId, metricId, interval, timespan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get recovery/backup.service
         * @summary Get recovery/backup.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} backupId Backup Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recoveryProjectBackupServiceGet(projectId: string, locationId: string, backupId: string, serviceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceService>> {
            const localVarAxiosArgs = await RecoveryProjectBackupApiAxiosParamCreator(configuration).recoveryProjectBackupServiceGet(projectId, locationId, backupId, serviceId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List recovery/backup.service
         * @summary List recovery/backup.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} backupId Backup Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recoveryProjectBackupServiceList(projectId: string, locationId: string, backupId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResourceService>>> {
            const localVarAxiosArgs = await RecoveryProjectBackupApiAxiosParamCreator(configuration).recoveryProjectBackupServiceList(projectId, locationId, backupId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create recovery/backup.tag
         * @summary Create recovery/backup.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} backupId Backup Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recoveryProjectBackupTagCreate(projectId: string, locationId: string, backupId: string, tag: Tag, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await RecoveryProjectBackupApiAxiosParamCreator(configuration).recoveryProjectBackupTagCreate(projectId, locationId, backupId, tag, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete recovery/backup.tag
         * @summary Delete recovery/backup.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} backupId Backup Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recoveryProjectBackupTagDelete(projectId: string, locationId: string, backupId: string, tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await RecoveryProjectBackupApiAxiosParamCreator(configuration).recoveryProjectBackupTagDelete(projectId, locationId, backupId, tagId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get recovery/backup.tag
         * @summary Get recovery/backup.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} backupId Backup Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recoveryProjectBackupTagGet(projectId: string, locationId: string, backupId: string, tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await RecoveryProjectBackupApiAxiosParamCreator(configuration).recoveryProjectBackupTagGet(projectId, locationId, backupId, tagId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List recovery/backup.tag
         * @summary List recovery/backup.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} backupId Backup Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recoveryProjectBackupTagList(projectId: string, locationId: string, backupId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await RecoveryProjectBackupApiAxiosParamCreator(configuration).recoveryProjectBackupTagList(projectId, locationId, backupId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Replace recovery/backup.tag
         * @summary Replace recovery/backup.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} backupId Backup Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recoveryProjectBackupTagPut(projectId: string, locationId: string, backupId: string, tag: Array<Tag>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await RecoveryProjectBackupApiAxiosParamCreator(configuration).recoveryProjectBackupTagPut(projectId, locationId, backupId, tag, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns modified backup
         * @summary Update recovery/backup
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} backupId Backup Id
         * @param {RecoveryProjectBackupUpdate} recoveryProjectBackupUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recoveryProjectBackupUpdate(projectId: string, locationId: string, backupId: string, recoveryProjectBackupUpdate: RecoveryProjectBackupUpdate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Backup>> {
            const localVarAxiosArgs = await RecoveryProjectBackupApiAxiosParamCreator(configuration).recoveryProjectBackupUpdate(projectId, locationId, backupId, recoveryProjectBackupUpdate, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * RecoveryProjectBackupApi - factory interface
 * @export
 */
export const RecoveryProjectBackupApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Create backup
         * @summary Create recovery/backup
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {RecoveryProjectBackupCreate} recoveryProjectBackupCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoveryProjectBackupCreate(projectId: string, locationId: string, recoveryProjectBackupCreate: RecoveryProjectBackupCreate, xIdempotencyKey?: string, options?: any): AxiosPromise<Backup> {
            return RecoveryProjectBackupApiFp(configuration).recoveryProjectBackupCreate(projectId, locationId, recoveryProjectBackupCreate, xIdempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete backup
         * @summary Delete recovery/backup
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} backupId Backup Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoveryProjectBackupDelete(projectId: string, locationId: string, backupId: string, options?: any): AxiosPromise<void> {
            return RecoveryProjectBackupApiFp(configuration).recoveryProjectBackupDelete(projectId, locationId, backupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get recovery/backup.event
         * @summary Get recovery/backup.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} backupId Backup Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoveryProjectBackupEventGet(projectId: string, locationId: string, backupId: string, eventId: string, options?: any): AxiosPromise<Event> {
            return RecoveryProjectBackupApiFp(configuration).recoveryProjectBackupEventGet(projectId, locationId, backupId, eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * List recovery/backup.event
         * @summary List recovery/backup.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} backupId Backup Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoveryProjectBackupEventList(projectId: string, locationId: string, backupId: string, $limit?: number, $skip?: number, options?: any): AxiosPromise<Array<Event>> {
            return RecoveryProjectBackupApiFp(configuration).recoveryProjectBackupEventList(projectId, locationId, backupId, $limit, $skip, options).then((request) => request(axios, basePath));
        },
        /**
         * action export
         * @summary Export recovery/backup
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} backupId Backup Id
         * @param {RecoveryProjectBackupExport} recoveryProjectBackupExport 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoveryProjectBackupExport(projectId: string, locationId: string, backupId: string, recoveryProjectBackupExport: RecoveryProjectBackupExport, xIdempotencyKey?: string, options?: any): AxiosPromise<Backup> {
            return RecoveryProjectBackupApiFp(configuration).recoveryProjectBackupExport(projectId, locationId, backupId, recoveryProjectBackupExport, xIdempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single backup
         * @summary Get recovery/backup
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} backupId Backup Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoveryProjectBackupGet(projectId: string, locationId: string, backupId: string, options?: any): AxiosPromise<Backup> {
            return RecoveryProjectBackupApiFp(configuration).recoveryProjectBackupGet(projectId, locationId, backupId, options).then((request) => request(axios, basePath));
        },
        /**
         * List backup
         * @summary List recovery/backup
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [name] Filter by name
         * @param {string} [source] Filter by source
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoveryProjectBackupList(projectId: string, locationId: string, name?: string, source?: string, tagValue?: string, tagKey?: string, options?: any): AxiosPromise<Array<Backup>> {
            return RecoveryProjectBackupApiFp(configuration).recoveryProjectBackupList(projectId, locationId, name, source, tagValue, tagKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get recovery/backup.metric
         * @summary Get recovery/backup.metric
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} backupId Backup Id
         * @param {string} metricId metricId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoveryProjectBackupMetricGet(projectId: string, locationId: string, backupId: string, metricId: string, options?: any): AxiosPromise<Metric> {
            return RecoveryProjectBackupApiFp(configuration).recoveryProjectBackupMetricGet(projectId, locationId, backupId, metricId, options).then((request) => request(axios, basePath));
        },
        /**
         * List recovery/backup.metric
         * @summary List recovery/backup.metric
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} backupId Backup Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoveryProjectBackupMetricList(projectId: string, locationId: string, backupId: string, options?: any): AxiosPromise<Array<Metric>> {
            return RecoveryProjectBackupApiFp(configuration).recoveryProjectBackupMetricList(projectId, locationId, backupId, options).then((request) => request(axios, basePath));
        },
        /**
         * List recovery/backup.point
         * @summary List recovery/backup.point
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} backupId Backup Id
         * @param {string} metricId metricId
         * @param {string} [interval] interval
         * @param {string} [timespan] timespan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoveryProjectBackupMetricPointList(projectId: string, locationId: string, backupId: string, metricId: string, interval?: string, timespan?: string, options?: any): AxiosPromise<Array<Point>> {
            return RecoveryProjectBackupApiFp(configuration).recoveryProjectBackupMetricPointList(projectId, locationId, backupId, metricId, interval, timespan, options).then((request) => request(axios, basePath));
        },
        /**
         * Get recovery/backup.service
         * @summary Get recovery/backup.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} backupId Backup Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoveryProjectBackupServiceGet(projectId: string, locationId: string, backupId: string, serviceId: string, options?: any): AxiosPromise<ResourceService> {
            return RecoveryProjectBackupApiFp(configuration).recoveryProjectBackupServiceGet(projectId, locationId, backupId, serviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * List recovery/backup.service
         * @summary List recovery/backup.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} backupId Backup Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoveryProjectBackupServiceList(projectId: string, locationId: string, backupId: string, options?: any): AxiosPromise<Array<ResourceService>> {
            return RecoveryProjectBackupApiFp(configuration).recoveryProjectBackupServiceList(projectId, locationId, backupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create recovery/backup.tag
         * @summary Create recovery/backup.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} backupId Backup Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoveryProjectBackupTagCreate(projectId: string, locationId: string, backupId: string, tag: Tag, options?: any): AxiosPromise<Tag> {
            return RecoveryProjectBackupApiFp(configuration).recoveryProjectBackupTagCreate(projectId, locationId, backupId, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete recovery/backup.tag
         * @summary Delete recovery/backup.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} backupId Backup Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoveryProjectBackupTagDelete(projectId: string, locationId: string, backupId: string, tagId: string, options?: any): AxiosPromise<void> {
            return RecoveryProjectBackupApiFp(configuration).recoveryProjectBackupTagDelete(projectId, locationId, backupId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get recovery/backup.tag
         * @summary Get recovery/backup.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} backupId Backup Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoveryProjectBackupTagGet(projectId: string, locationId: string, backupId: string, tagId: string, options?: any): AxiosPromise<Tag> {
            return RecoveryProjectBackupApiFp(configuration).recoveryProjectBackupTagGet(projectId, locationId, backupId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * List recovery/backup.tag
         * @summary List recovery/backup.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} backupId Backup Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoveryProjectBackupTagList(projectId: string, locationId: string, backupId: string, options?: any): AxiosPromise<Array<Tag>> {
            return RecoveryProjectBackupApiFp(configuration).recoveryProjectBackupTagList(projectId, locationId, backupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Replace recovery/backup.tag
         * @summary Replace recovery/backup.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} backupId Backup Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoveryProjectBackupTagPut(projectId: string, locationId: string, backupId: string, tag: Array<Tag>, options?: any): AxiosPromise<Array<Tag>> {
            return RecoveryProjectBackupApiFp(configuration).recoveryProjectBackupTagPut(projectId, locationId, backupId, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns modified backup
         * @summary Update recovery/backup
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} backupId Backup Id
         * @param {RecoveryProjectBackupUpdate} recoveryProjectBackupUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoveryProjectBackupUpdate(projectId: string, locationId: string, backupId: string, recoveryProjectBackupUpdate: RecoveryProjectBackupUpdate, options?: any): AxiosPromise<Backup> {
            return RecoveryProjectBackupApiFp(configuration).recoveryProjectBackupUpdate(projectId, locationId, backupId, recoveryProjectBackupUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RecoveryProjectBackupApi - object-oriented interface
 * @export
 * @class RecoveryProjectBackupApi
 * @extends {BaseAPI}
 */
export class RecoveryProjectBackupApi extends BaseAPI {
    /**
     * Create backup
     * @summary Create recovery/backup
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {RecoveryProjectBackupCreate} recoveryProjectBackupCreate 
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecoveryProjectBackupApi
     */
    public recoveryProjectBackupCreate(projectId: string, locationId: string, recoveryProjectBackupCreate: RecoveryProjectBackupCreate, xIdempotencyKey?: string, options?: any) {
        return RecoveryProjectBackupApiFp(this.configuration).recoveryProjectBackupCreate(projectId, locationId, recoveryProjectBackupCreate, xIdempotencyKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete backup
     * @summary Delete recovery/backup
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} backupId Backup Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecoveryProjectBackupApi
     */
    public recoveryProjectBackupDelete(projectId: string, locationId: string, backupId: string, options?: any) {
        return RecoveryProjectBackupApiFp(this.configuration).recoveryProjectBackupDelete(projectId, locationId, backupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get recovery/backup.event
     * @summary Get recovery/backup.event
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} backupId Backup Id
     * @param {string} eventId eventId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecoveryProjectBackupApi
     */
    public recoveryProjectBackupEventGet(projectId: string, locationId: string, backupId: string, eventId: string, options?: any) {
        return RecoveryProjectBackupApiFp(this.configuration).recoveryProjectBackupEventGet(projectId, locationId, backupId, eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List recovery/backup.event
     * @summary List recovery/backup.event
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} backupId Backup Id
     * @param {number} [$limit] $limit
     * @param {number} [$skip] $skip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecoveryProjectBackupApi
     */
    public recoveryProjectBackupEventList(projectId: string, locationId: string, backupId: string, $limit?: number, $skip?: number, options?: any) {
        return RecoveryProjectBackupApiFp(this.configuration).recoveryProjectBackupEventList(projectId, locationId, backupId, $limit, $skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * action export
     * @summary Export recovery/backup
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} backupId Backup Id
     * @param {RecoveryProjectBackupExport} recoveryProjectBackupExport 
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecoveryProjectBackupApi
     */
    public recoveryProjectBackupExport(projectId: string, locationId: string, backupId: string, recoveryProjectBackupExport: RecoveryProjectBackupExport, xIdempotencyKey?: string, options?: any) {
        return RecoveryProjectBackupApiFp(this.configuration).recoveryProjectBackupExport(projectId, locationId, backupId, recoveryProjectBackupExport, xIdempotencyKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single backup
     * @summary Get recovery/backup
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} backupId Backup Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecoveryProjectBackupApi
     */
    public recoveryProjectBackupGet(projectId: string, locationId: string, backupId: string, options?: any) {
        return RecoveryProjectBackupApiFp(this.configuration).recoveryProjectBackupGet(projectId, locationId, backupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List backup
     * @summary List recovery/backup
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} [name] Filter by name
     * @param {string} [source] Filter by source
     * @param {string} [tagValue] Filter by tag.value
     * @param {string} [tagKey] Filter by tag.key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecoveryProjectBackupApi
     */
    public recoveryProjectBackupList(projectId: string, locationId: string, name?: string, source?: string, tagValue?: string, tagKey?: string, options?: any) {
        return RecoveryProjectBackupApiFp(this.configuration).recoveryProjectBackupList(projectId, locationId, name, source, tagValue, tagKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get recovery/backup.metric
     * @summary Get recovery/backup.metric
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} backupId Backup Id
     * @param {string} metricId metricId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecoveryProjectBackupApi
     */
    public recoveryProjectBackupMetricGet(projectId: string, locationId: string, backupId: string, metricId: string, options?: any) {
        return RecoveryProjectBackupApiFp(this.configuration).recoveryProjectBackupMetricGet(projectId, locationId, backupId, metricId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List recovery/backup.metric
     * @summary List recovery/backup.metric
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} backupId Backup Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecoveryProjectBackupApi
     */
    public recoveryProjectBackupMetricList(projectId: string, locationId: string, backupId: string, options?: any) {
        return RecoveryProjectBackupApiFp(this.configuration).recoveryProjectBackupMetricList(projectId, locationId, backupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List recovery/backup.point
     * @summary List recovery/backup.point
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} backupId Backup Id
     * @param {string} metricId metricId
     * @param {string} [interval] interval
     * @param {string} [timespan] timespan
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecoveryProjectBackupApi
     */
    public recoveryProjectBackupMetricPointList(projectId: string, locationId: string, backupId: string, metricId: string, interval?: string, timespan?: string, options?: any) {
        return RecoveryProjectBackupApiFp(this.configuration).recoveryProjectBackupMetricPointList(projectId, locationId, backupId, metricId, interval, timespan, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get recovery/backup.service
     * @summary Get recovery/backup.service
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} backupId Backup Id
     * @param {string} serviceId serviceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecoveryProjectBackupApi
     */
    public recoveryProjectBackupServiceGet(projectId: string, locationId: string, backupId: string, serviceId: string, options?: any) {
        return RecoveryProjectBackupApiFp(this.configuration).recoveryProjectBackupServiceGet(projectId, locationId, backupId, serviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List recovery/backup.service
     * @summary List recovery/backup.service
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} backupId Backup Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecoveryProjectBackupApi
     */
    public recoveryProjectBackupServiceList(projectId: string, locationId: string, backupId: string, options?: any) {
        return RecoveryProjectBackupApiFp(this.configuration).recoveryProjectBackupServiceList(projectId, locationId, backupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create recovery/backup.tag
     * @summary Create recovery/backup.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} backupId Backup Id
     * @param {Tag} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecoveryProjectBackupApi
     */
    public recoveryProjectBackupTagCreate(projectId: string, locationId: string, backupId: string, tag: Tag, options?: any) {
        return RecoveryProjectBackupApiFp(this.configuration).recoveryProjectBackupTagCreate(projectId, locationId, backupId, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete recovery/backup.tag
     * @summary Delete recovery/backup.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} backupId Backup Id
     * @param {string} tagId tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecoveryProjectBackupApi
     */
    public recoveryProjectBackupTagDelete(projectId: string, locationId: string, backupId: string, tagId: string, options?: any) {
        return RecoveryProjectBackupApiFp(this.configuration).recoveryProjectBackupTagDelete(projectId, locationId, backupId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get recovery/backup.tag
     * @summary Get recovery/backup.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} backupId Backup Id
     * @param {string} tagId tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecoveryProjectBackupApi
     */
    public recoveryProjectBackupTagGet(projectId: string, locationId: string, backupId: string, tagId: string, options?: any) {
        return RecoveryProjectBackupApiFp(this.configuration).recoveryProjectBackupTagGet(projectId, locationId, backupId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List recovery/backup.tag
     * @summary List recovery/backup.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} backupId Backup Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecoveryProjectBackupApi
     */
    public recoveryProjectBackupTagList(projectId: string, locationId: string, backupId: string, options?: any) {
        return RecoveryProjectBackupApiFp(this.configuration).recoveryProjectBackupTagList(projectId, locationId, backupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replace recovery/backup.tag
     * @summary Replace recovery/backup.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} backupId Backup Id
     * @param {Array<Tag>} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecoveryProjectBackupApi
     */
    public recoveryProjectBackupTagPut(projectId: string, locationId: string, backupId: string, tag: Array<Tag>, options?: any) {
        return RecoveryProjectBackupApiFp(this.configuration).recoveryProjectBackupTagPut(projectId, locationId, backupId, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns modified backup
     * @summary Update recovery/backup
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} backupId Backup Id
     * @param {RecoveryProjectBackupUpdate} recoveryProjectBackupUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecoveryProjectBackupApi
     */
    public recoveryProjectBackupUpdate(projectId: string, locationId: string, backupId: string, recoveryProjectBackupUpdate: RecoveryProjectBackupUpdate, options?: any) {
        return RecoveryProjectBackupApiFp(this.configuration).recoveryProjectBackupUpdate(projectId, locationId, backupId, recoveryProjectBackupUpdate, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * StorageProjectBucketApi - axios parameter creator
 * @export
 */
export const StorageProjectBucketApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a single bucket
         * @summary Get storage/bucket
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} bucketId Bucket Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectBucketGet: async (projectId: string, locationId: string, bucketId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling storageProjectBucketGet.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling storageProjectBucketGet.');
            }
            // verify required parameter 'bucketId' is not null or undefined
            if (bucketId === null || bucketId === undefined) {
                throw new RequiredError('bucketId','Required parameter bucketId was null or undefined when calling storageProjectBucketGet.');
            }
            const localVarPath = `/storage/{locationId}/project/{projectId}/bucket/{bucketId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"bucketId"}}`, encodeURIComponent(String(bucketId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List bucket
         * @summary List storage/bucket
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectBucketList: async (projectId: string, locationId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling storageProjectBucketList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling storageProjectBucketList.');
            }
            const localVarPath = `/storage/{locationId}/project/{projectId}/bucket`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete storage/bucket.object
         * @summary Delete storage/bucket.object
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} bucketId Bucket Id
         * @param {string} objectId objectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectBucketObjectDelete: async (projectId: string, locationId: string, bucketId: string, objectId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling storageProjectBucketObjectDelete.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling storageProjectBucketObjectDelete.');
            }
            // verify required parameter 'bucketId' is not null or undefined
            if (bucketId === null || bucketId === undefined) {
                throw new RequiredError('bucketId','Required parameter bucketId was null or undefined when calling storageProjectBucketObjectDelete.');
            }
            // verify required parameter 'objectId' is not null or undefined
            if (objectId === null || objectId === undefined) {
                throw new RequiredError('objectId','Required parameter objectId was null or undefined when calling storageProjectBucketObjectDelete.');
            }
            const localVarPath = `/storage/{locationId}/project/{projectId}/bucket/{bucketId}/object/{objectId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"bucketId"}}`, encodeURIComponent(String(bucketId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * action download
         * @summary Download storage/bucket.object
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} bucketId Bucket Id
         * @param {string} objectId objectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectBucketObjectDownload: async (projectId: string, locationId: string, bucketId: string, objectId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling storageProjectBucketObjectDownload.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling storageProjectBucketObjectDownload.');
            }
            // verify required parameter 'bucketId' is not null or undefined
            if (bucketId === null || bucketId === undefined) {
                throw new RequiredError('bucketId','Required parameter bucketId was null or undefined when calling storageProjectBucketObjectDownload.');
            }
            // verify required parameter 'objectId' is not null or undefined
            if (objectId === null || objectId === undefined) {
                throw new RequiredError('objectId','Required parameter objectId was null or undefined when calling storageProjectBucketObjectDownload.');
            }
            const localVarPath = `/storage/{locationId}/project/{projectId}/bucket/{bucketId}/object/{objectId}/actions/download`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"bucketId"}}`, encodeURIComponent(String(bucketId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get storage/bucket.object
         * @summary Get storage/bucket.object
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} bucketId Bucket Id
         * @param {string} objectId objectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectBucketObjectGet: async (projectId: string, locationId: string, bucketId: string, objectId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling storageProjectBucketObjectGet.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling storageProjectBucketObjectGet.');
            }
            // verify required parameter 'bucketId' is not null or undefined
            if (bucketId === null || bucketId === undefined) {
                throw new RequiredError('bucketId','Required parameter bucketId was null or undefined when calling storageProjectBucketObjectGet.');
            }
            // verify required parameter 'objectId' is not null or undefined
            if (objectId === null || objectId === undefined) {
                throw new RequiredError('objectId','Required parameter objectId was null or undefined when calling storageProjectBucketObjectGet.');
            }
            const localVarPath = `/storage/{locationId}/project/{projectId}/bucket/{bucketId}/object/{objectId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"bucketId"}}`, encodeURIComponent(String(bucketId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List storage/bucket.object
         * @summary List storage/bucket.object
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} bucketId Bucket Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectBucketObjectList: async (projectId: string, locationId: string, bucketId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling storageProjectBucketObjectList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling storageProjectBucketObjectList.');
            }
            // verify required parameter 'bucketId' is not null or undefined
            if (bucketId === null || bucketId === undefined) {
                throw new RequiredError('bucketId','Required parameter bucketId was null or undefined when calling storageProjectBucketObjectList.');
            }
            const localVarPath = `/storage/{locationId}/project/{projectId}/bucket/{bucketId}/object`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"bucketId"}}`, encodeURIComponent(String(bucketId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * action upload
         * @summary Upload storage/bucket
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} bucketId Bucket Id
         * @param {StorageProjectBucketUpload} storageProjectBucketUpload 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectBucketUpload: async (projectId: string, locationId: string, bucketId: string, storageProjectBucketUpload: StorageProjectBucketUpload, xIdempotencyKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling storageProjectBucketUpload.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling storageProjectBucketUpload.');
            }
            // verify required parameter 'bucketId' is not null or undefined
            if (bucketId === null || bucketId === undefined) {
                throw new RequiredError('bucketId','Required parameter bucketId was null or undefined when calling storageProjectBucketUpload.');
            }
            // verify required parameter 'storageProjectBucketUpload' is not null or undefined
            if (storageProjectBucketUpload === null || storageProjectBucketUpload === undefined) {
                throw new RequiredError('storageProjectBucketUpload','Required parameter storageProjectBucketUpload was null or undefined when calling storageProjectBucketUpload.');
            }
            const localVarPath = `/storage/{locationId}/project/{projectId}/bucket/{bucketId}/actions/upload`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"bucketId"}}`, encodeURIComponent(String(bucketId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof storageProjectBucketUpload !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(storageProjectBucketUpload !== undefined ? storageProjectBucketUpload : {}) : (storageProjectBucketUpload || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StorageProjectBucketApi - functional programming interface
 * @export
 */
export const StorageProjectBucketApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Returns a single bucket
         * @summary Get storage/bucket
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} bucketId Bucket Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectBucketGet(projectId: string, locationId: string, bucketId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Bucket>> {
            const localVarAxiosArgs = await StorageProjectBucketApiAxiosParamCreator(configuration).storageProjectBucketGet(projectId, locationId, bucketId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List bucket
         * @summary List storage/bucket
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectBucketList(projectId: string, locationId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Bucket>>> {
            const localVarAxiosArgs = await StorageProjectBucketApiAxiosParamCreator(configuration).storageProjectBucketList(projectId, locationId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete storage/bucket.object
         * @summary Delete storage/bucket.object
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} bucketId Bucket Id
         * @param {string} objectId objectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectBucketObjectDelete(projectId: string, locationId: string, bucketId: string, objectId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await StorageProjectBucketApiAxiosParamCreator(configuration).storageProjectBucketObjectDelete(projectId, locationId, bucketId, objectId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * action download
         * @summary Download storage/bucket.object
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} bucketId Bucket Id
         * @param {string} objectId objectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectBucketObjectDownload(projectId: string, locationId: string, bucketId: string, objectId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await StorageProjectBucketApiAxiosParamCreator(configuration).storageProjectBucketObjectDownload(projectId, locationId, bucketId, objectId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get storage/bucket.object
         * @summary Get storage/bucket.object
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} bucketId Bucket Id
         * @param {string} objectId objectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectBucketObjectGet(projectId: string, locationId: string, bucketId: string, objectId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StorageObject>> {
            const localVarAxiosArgs = await StorageProjectBucketApiAxiosParamCreator(configuration).storageProjectBucketObjectGet(projectId, locationId, bucketId, objectId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List storage/bucket.object
         * @summary List storage/bucket.object
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} bucketId Bucket Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectBucketObjectList(projectId: string, locationId: string, bucketId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<StorageObject>>> {
            const localVarAxiosArgs = await StorageProjectBucketApiAxiosParamCreator(configuration).storageProjectBucketObjectList(projectId, locationId, bucketId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * action upload
         * @summary Upload storage/bucket
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} bucketId Bucket Id
         * @param {StorageProjectBucketUpload} storageProjectBucketUpload 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectBucketUpload(projectId: string, locationId: string, bucketId: string, storageProjectBucketUpload: StorageProjectBucketUpload, xIdempotencyKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Bucket>> {
            const localVarAxiosArgs = await StorageProjectBucketApiAxiosParamCreator(configuration).storageProjectBucketUpload(projectId, locationId, bucketId, storageProjectBucketUpload, xIdempotencyKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * StorageProjectBucketApi - factory interface
 * @export
 */
export const StorageProjectBucketApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Returns a single bucket
         * @summary Get storage/bucket
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} bucketId Bucket Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectBucketGet(projectId: string, locationId: string, bucketId: string, options?: any): AxiosPromise<Bucket> {
            return StorageProjectBucketApiFp(configuration).storageProjectBucketGet(projectId, locationId, bucketId, options).then((request) => request(axios, basePath));
        },
        /**
         * List bucket
         * @summary List storage/bucket
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectBucketList(projectId: string, locationId: string, options?: any): AxiosPromise<Array<Bucket>> {
            return StorageProjectBucketApiFp(configuration).storageProjectBucketList(projectId, locationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete storage/bucket.object
         * @summary Delete storage/bucket.object
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} bucketId Bucket Id
         * @param {string} objectId objectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectBucketObjectDelete(projectId: string, locationId: string, bucketId: string, objectId: string, options?: any): AxiosPromise<void> {
            return StorageProjectBucketApiFp(configuration).storageProjectBucketObjectDelete(projectId, locationId, bucketId, objectId, options).then((request) => request(axios, basePath));
        },
        /**
         * action download
         * @summary Download storage/bucket.object
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} bucketId Bucket Id
         * @param {string} objectId objectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectBucketObjectDownload(projectId: string, locationId: string, bucketId: string, objectId: string, options?: any): AxiosPromise<void> {
            return StorageProjectBucketApiFp(configuration).storageProjectBucketObjectDownload(projectId, locationId, bucketId, objectId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get storage/bucket.object
         * @summary Get storage/bucket.object
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} bucketId Bucket Id
         * @param {string} objectId objectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectBucketObjectGet(projectId: string, locationId: string, bucketId: string, objectId: string, options?: any): AxiosPromise<StorageObject> {
            return StorageProjectBucketApiFp(configuration).storageProjectBucketObjectGet(projectId, locationId, bucketId, objectId, options).then((request) => request(axios, basePath));
        },
        /**
         * List storage/bucket.object
         * @summary List storage/bucket.object
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} bucketId Bucket Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectBucketObjectList(projectId: string, locationId: string, bucketId: string, options?: any): AxiosPromise<Array<StorageObject>> {
            return StorageProjectBucketApiFp(configuration).storageProjectBucketObjectList(projectId, locationId, bucketId, options).then((request) => request(axios, basePath));
        },
        /**
         * action upload
         * @summary Upload storage/bucket
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} bucketId Bucket Id
         * @param {StorageProjectBucketUpload} storageProjectBucketUpload 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectBucketUpload(projectId: string, locationId: string, bucketId: string, storageProjectBucketUpload: StorageProjectBucketUpload, xIdempotencyKey?: string, options?: any): AxiosPromise<Bucket> {
            return StorageProjectBucketApiFp(configuration).storageProjectBucketUpload(projectId, locationId, bucketId, storageProjectBucketUpload, xIdempotencyKey, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StorageProjectBucketApi - object-oriented interface
 * @export
 * @class StorageProjectBucketApi
 * @extends {BaseAPI}
 */
export class StorageProjectBucketApi extends BaseAPI {
    /**
     * Returns a single bucket
     * @summary Get storage/bucket
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} bucketId Bucket Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectBucketApi
     */
    public storageProjectBucketGet(projectId: string, locationId: string, bucketId: string, options?: any) {
        return StorageProjectBucketApiFp(this.configuration).storageProjectBucketGet(projectId, locationId, bucketId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List bucket
     * @summary List storage/bucket
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectBucketApi
     */
    public storageProjectBucketList(projectId: string, locationId: string, options?: any) {
        return StorageProjectBucketApiFp(this.configuration).storageProjectBucketList(projectId, locationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete storage/bucket.object
     * @summary Delete storage/bucket.object
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} bucketId Bucket Id
     * @param {string} objectId objectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectBucketApi
     */
    public storageProjectBucketObjectDelete(projectId: string, locationId: string, bucketId: string, objectId: string, options?: any) {
        return StorageProjectBucketApiFp(this.configuration).storageProjectBucketObjectDelete(projectId, locationId, bucketId, objectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * action download
     * @summary Download storage/bucket.object
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} bucketId Bucket Id
     * @param {string} objectId objectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectBucketApi
     */
    public storageProjectBucketObjectDownload(projectId: string, locationId: string, bucketId: string, objectId: string, options?: any) {
        return StorageProjectBucketApiFp(this.configuration).storageProjectBucketObjectDownload(projectId, locationId, bucketId, objectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get storage/bucket.object
     * @summary Get storage/bucket.object
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} bucketId Bucket Id
     * @param {string} objectId objectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectBucketApi
     */
    public storageProjectBucketObjectGet(projectId: string, locationId: string, bucketId: string, objectId: string, options?: any) {
        return StorageProjectBucketApiFp(this.configuration).storageProjectBucketObjectGet(projectId, locationId, bucketId, objectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List storage/bucket.object
     * @summary List storage/bucket.object
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} bucketId Bucket Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectBucketApi
     */
    public storageProjectBucketObjectList(projectId: string, locationId: string, bucketId: string, options?: any) {
        return StorageProjectBucketApiFp(this.configuration).storageProjectBucketObjectList(projectId, locationId, bucketId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * action upload
     * @summary Upload storage/bucket
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} bucketId Bucket Id
     * @param {StorageProjectBucketUpload} storageProjectBucketUpload 
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectBucketApi
     */
    public storageProjectBucketUpload(projectId: string, locationId: string, bucketId: string, storageProjectBucketUpload: StorageProjectBucketUpload, xIdempotencyKey?: string, options?: any) {
        return StorageProjectBucketApiFp(this.configuration).storageProjectBucketUpload(projectId, locationId, bucketId, storageProjectBucketUpload, xIdempotencyKey, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * StorageProjectDiskApi - axios parameter creator
 * @export
 */
export const StorageProjectDiskApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create disk
         * @summary Create storage/disk
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {StorageProjectDiskCreate} storageProjectDiskCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectDiskCreate: async (projectId: string, locationId: string, storageProjectDiskCreate: StorageProjectDiskCreate, xIdempotencyKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling storageProjectDiskCreate.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling storageProjectDiskCreate.');
            }
            // verify required parameter 'storageProjectDiskCreate' is not null or undefined
            if (storageProjectDiskCreate === null || storageProjectDiskCreate === undefined) {
                throw new RequiredError('storageProjectDiskCreate','Required parameter storageProjectDiskCreate was null or undefined when calling storageProjectDiskCreate.');
            }
            const localVarPath = `/storage/{locationId}/project/{projectId}/disk`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof storageProjectDiskCreate !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(storageProjectDiskCreate !== undefined ? storageProjectDiskCreate : {}) : (storageProjectDiskCreate || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete disk
         * @summary Delete storage/disk
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectDiskDelete: async (projectId: string, locationId: string, diskId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling storageProjectDiskDelete.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling storageProjectDiskDelete.');
            }
            // verify required parameter 'diskId' is not null or undefined
            if (diskId === null || diskId === undefined) {
                throw new RequiredError('diskId','Required parameter diskId was null or undefined when calling storageProjectDiskDelete.');
            }
            const localVarPath = `/storage/{locationId}/project/{projectId}/disk/{diskId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"diskId"}}`, encodeURIComponent(String(diskId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * action detach
         * @summary Detach storage/disk
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectDiskDetach: async (projectId: string, locationId: string, diskId: string, xIdempotencyKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling storageProjectDiskDetach.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling storageProjectDiskDetach.');
            }
            // verify required parameter 'diskId' is not null or undefined
            if (diskId === null || diskId === undefined) {
                throw new RequiredError('diskId','Required parameter diskId was null or undefined when calling storageProjectDiskDetach.');
            }
            const localVarPath = `/storage/{locationId}/project/{projectId}/disk/{diskId}/actions/detach`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"diskId"}}`, encodeURIComponent(String(diskId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * action download
         * @summary Download storage/disk
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectDiskDownload: async (projectId: string, locationId: string, diskId: string, xIdempotencyKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling storageProjectDiskDownload.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling storageProjectDiskDownload.');
            }
            // verify required parameter 'diskId' is not null or undefined
            if (diskId === null || diskId === undefined) {
                throw new RequiredError('diskId','Required parameter diskId was null or undefined when calling storageProjectDiskDownload.');
            }
            const localVarPath = `/storage/{locationId}/project/{projectId}/disk/{diskId}/actions/download`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"diskId"}}`, encodeURIComponent(String(diskId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get storage/disk.event
         * @summary Get storage/disk.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectDiskEventGet: async (projectId: string, locationId: string, diskId: string, eventId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling storageProjectDiskEventGet.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling storageProjectDiskEventGet.');
            }
            // verify required parameter 'diskId' is not null or undefined
            if (diskId === null || diskId === undefined) {
                throw new RequiredError('diskId','Required parameter diskId was null or undefined when calling storageProjectDiskEventGet.');
            }
            // verify required parameter 'eventId' is not null or undefined
            if (eventId === null || eventId === undefined) {
                throw new RequiredError('eventId','Required parameter eventId was null or undefined when calling storageProjectDiskEventGet.');
            }
            const localVarPath = `/storage/{locationId}/project/{projectId}/disk/{diskId}/event/{eventId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"diskId"}}`, encodeURIComponent(String(diskId)))
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List storage/disk.event
         * @summary List storage/disk.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectDiskEventList: async (projectId: string, locationId: string, diskId: string, $limit?: number, $skip?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling storageProjectDiskEventList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling storageProjectDiskEventList.');
            }
            // verify required parameter 'diskId' is not null or undefined
            if (diskId === null || diskId === undefined) {
                throw new RequiredError('diskId','Required parameter diskId was null or undefined when calling storageProjectDiskEventList.');
            }
            const localVarPath = `/storage/{locationId}/project/{projectId}/disk/{diskId}/event`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"diskId"}}`, encodeURIComponent(String(diskId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if ($limit !== undefined) {
                localVarQueryParameter['$limit'] = $limit;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single disk
         * @summary Get storage/disk
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectDiskGet: async (projectId: string, locationId: string, diskId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling storageProjectDiskGet.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling storageProjectDiskGet.');
            }
            // verify required parameter 'diskId' is not null or undefined
            if (diskId === null || diskId === undefined) {
                throw new RequiredError('diskId','Required parameter diskId was null or undefined when calling storageProjectDiskGet.');
            }
            const localVarPath = `/storage/{locationId}/project/{projectId}/disk/{diskId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"diskId"}}`, encodeURIComponent(String(diskId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List disk
         * @summary List storage/disk
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [name] Filter by name
         * @param {string} [vm] Filter by vm
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectDiskList: async (projectId: string, locationId: string, name?: string, vm?: string, tagValue?: string, tagKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling storageProjectDiskList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling storageProjectDiskList.');
            }
            const localVarPath = `/storage/{locationId}/project/{projectId}/disk`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (vm !== undefined) {
                localVarQueryParameter['vm'] = vm;
            }

            if (tagValue !== undefined) {
                localVarQueryParameter['tag.value'] = tagValue;
            }

            if (tagKey !== undefined) {
                localVarQueryParameter['tag.key'] = tagKey;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get storage/disk.metric
         * @summary Get storage/disk.metric
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {string} metricId metricId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectDiskMetricGet: async (projectId: string, locationId: string, diskId: string, metricId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling storageProjectDiskMetricGet.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling storageProjectDiskMetricGet.');
            }
            // verify required parameter 'diskId' is not null or undefined
            if (diskId === null || diskId === undefined) {
                throw new RequiredError('diskId','Required parameter diskId was null or undefined when calling storageProjectDiskMetricGet.');
            }
            // verify required parameter 'metricId' is not null or undefined
            if (metricId === null || metricId === undefined) {
                throw new RequiredError('metricId','Required parameter metricId was null or undefined when calling storageProjectDiskMetricGet.');
            }
            const localVarPath = `/storage/{locationId}/project/{projectId}/disk/{diskId}/metric/{metricId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"diskId"}}`, encodeURIComponent(String(diskId)))
                .replace(`{${"metricId"}}`, encodeURIComponent(String(metricId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List storage/disk.metric
         * @summary List storage/disk.metric
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectDiskMetricList: async (projectId: string, locationId: string, diskId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling storageProjectDiskMetricList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling storageProjectDiskMetricList.');
            }
            // verify required parameter 'diskId' is not null or undefined
            if (diskId === null || diskId === undefined) {
                throw new RequiredError('diskId','Required parameter diskId was null or undefined when calling storageProjectDiskMetricList.');
            }
            const localVarPath = `/storage/{locationId}/project/{projectId}/disk/{diskId}/metric`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"diskId"}}`, encodeURIComponent(String(diskId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List storage/disk.point
         * @summary List storage/disk.point
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {string} metricId metricId
         * @param {string} [interval] interval
         * @param {string} [timespan] timespan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectDiskMetricPointList: async (projectId: string, locationId: string, diskId: string, metricId: string, interval?: string, timespan?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling storageProjectDiskMetricPointList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling storageProjectDiskMetricPointList.');
            }
            // verify required parameter 'diskId' is not null or undefined
            if (diskId === null || diskId === undefined) {
                throw new RequiredError('diskId','Required parameter diskId was null or undefined when calling storageProjectDiskMetricPointList.');
            }
            // verify required parameter 'metricId' is not null or undefined
            if (metricId === null || metricId === undefined) {
                throw new RequiredError('metricId','Required parameter metricId was null or undefined when calling storageProjectDiskMetricPointList.');
            }
            const localVarPath = `/storage/{locationId}/project/{projectId}/disk/{diskId}/metric/{metricId}/point`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"diskId"}}`, encodeURIComponent(String(diskId)))
                .replace(`{${"metricId"}}`, encodeURIComponent(String(metricId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (timespan !== undefined) {
                localVarQueryParameter['timespan'] = timespan;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * action resize
         * @summary Resize storage/disk
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {StorageProjectDiskResize} storageProjectDiskResize 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectDiskResize: async (projectId: string, locationId: string, diskId: string, storageProjectDiskResize: StorageProjectDiskResize, xIdempotencyKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling storageProjectDiskResize.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling storageProjectDiskResize.');
            }
            // verify required parameter 'diskId' is not null or undefined
            if (diskId === null || diskId === undefined) {
                throw new RequiredError('diskId','Required parameter diskId was null or undefined when calling storageProjectDiskResize.');
            }
            // verify required parameter 'storageProjectDiskResize' is not null or undefined
            if (storageProjectDiskResize === null || storageProjectDiskResize === undefined) {
                throw new RequiredError('storageProjectDiskResize','Required parameter storageProjectDiskResize was null or undefined when calling storageProjectDiskResize.');
            }
            const localVarPath = `/storage/{locationId}/project/{projectId}/disk/{diskId}/actions/resize`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"diskId"}}`, encodeURIComponent(String(diskId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof storageProjectDiskResize !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(storageProjectDiskResize !== undefined ? storageProjectDiskResize : {}) : (storageProjectDiskResize || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get storage/disk.service
         * @summary Get storage/disk.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectDiskServiceGet: async (projectId: string, locationId: string, diskId: string, serviceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling storageProjectDiskServiceGet.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling storageProjectDiskServiceGet.');
            }
            // verify required parameter 'diskId' is not null or undefined
            if (diskId === null || diskId === undefined) {
                throw new RequiredError('diskId','Required parameter diskId was null or undefined when calling storageProjectDiskServiceGet.');
            }
            // verify required parameter 'serviceId' is not null or undefined
            if (serviceId === null || serviceId === undefined) {
                throw new RequiredError('serviceId','Required parameter serviceId was null or undefined when calling storageProjectDiskServiceGet.');
            }
            const localVarPath = `/storage/{locationId}/project/{projectId}/disk/{diskId}/service/{serviceId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"diskId"}}`, encodeURIComponent(String(diskId)))
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List storage/disk.service
         * @summary List storage/disk.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectDiskServiceList: async (projectId: string, locationId: string, diskId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling storageProjectDiskServiceList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling storageProjectDiskServiceList.');
            }
            // verify required parameter 'diskId' is not null or undefined
            if (diskId === null || diskId === undefined) {
                throw new RequiredError('diskId','Required parameter diskId was null or undefined when calling storageProjectDiskServiceList.');
            }
            const localVarPath = `/storage/{locationId}/project/{projectId}/disk/{diskId}/service`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"diskId"}}`, encodeURIComponent(String(diskId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create storage/disk.tag
         * @summary Create storage/disk.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectDiskTagCreate: async (projectId: string, locationId: string, diskId: string, tag: Tag, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling storageProjectDiskTagCreate.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling storageProjectDiskTagCreate.');
            }
            // verify required parameter 'diskId' is not null or undefined
            if (diskId === null || diskId === undefined) {
                throw new RequiredError('diskId','Required parameter diskId was null or undefined when calling storageProjectDiskTagCreate.');
            }
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling storageProjectDiskTagCreate.');
            }
            const localVarPath = `/storage/{locationId}/project/{projectId}/disk/{diskId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"diskId"}}`, encodeURIComponent(String(diskId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof tag !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(tag !== undefined ? tag : {}) : (tag || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete storage/disk.tag
         * @summary Delete storage/disk.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectDiskTagDelete: async (projectId: string, locationId: string, diskId: string, tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling storageProjectDiskTagDelete.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling storageProjectDiskTagDelete.');
            }
            // verify required parameter 'diskId' is not null or undefined
            if (diskId === null || diskId === undefined) {
                throw new RequiredError('diskId','Required parameter diskId was null or undefined when calling storageProjectDiskTagDelete.');
            }
            // verify required parameter 'tagId' is not null or undefined
            if (tagId === null || tagId === undefined) {
                throw new RequiredError('tagId','Required parameter tagId was null or undefined when calling storageProjectDiskTagDelete.');
            }
            const localVarPath = `/storage/{locationId}/project/{projectId}/disk/{diskId}/tag/{tagId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"diskId"}}`, encodeURIComponent(String(diskId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get storage/disk.tag
         * @summary Get storage/disk.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectDiskTagGet: async (projectId: string, locationId: string, diskId: string, tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling storageProjectDiskTagGet.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling storageProjectDiskTagGet.');
            }
            // verify required parameter 'diskId' is not null or undefined
            if (diskId === null || diskId === undefined) {
                throw new RequiredError('diskId','Required parameter diskId was null or undefined when calling storageProjectDiskTagGet.');
            }
            // verify required parameter 'tagId' is not null or undefined
            if (tagId === null || tagId === undefined) {
                throw new RequiredError('tagId','Required parameter tagId was null or undefined when calling storageProjectDiskTagGet.');
            }
            const localVarPath = `/storage/{locationId}/project/{projectId}/disk/{diskId}/tag/{tagId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"diskId"}}`, encodeURIComponent(String(diskId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List storage/disk.tag
         * @summary List storage/disk.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectDiskTagList: async (projectId: string, locationId: string, diskId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling storageProjectDiskTagList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling storageProjectDiskTagList.');
            }
            // verify required parameter 'diskId' is not null or undefined
            if (diskId === null || diskId === undefined) {
                throw new RequiredError('diskId','Required parameter diskId was null or undefined when calling storageProjectDiskTagList.');
            }
            const localVarPath = `/storage/{locationId}/project/{projectId}/disk/{diskId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"diskId"}}`, encodeURIComponent(String(diskId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replace storage/disk.tag
         * @summary Replace storage/disk.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectDiskTagPut: async (projectId: string, locationId: string, diskId: string, tag: Array<Tag>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling storageProjectDiskTagPut.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling storageProjectDiskTagPut.');
            }
            // verify required parameter 'diskId' is not null or undefined
            if (diskId === null || diskId === undefined) {
                throw new RequiredError('diskId','Required parameter diskId was null or undefined when calling storageProjectDiskTagPut.');
            }
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling storageProjectDiskTagPut.');
            }
            const localVarPath = `/storage/{locationId}/project/{projectId}/disk/{diskId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"diskId"}}`, encodeURIComponent(String(diskId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof tag !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(tag !== undefined ? tag : {}) : (tag || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * action transfer
         * @summary Transfer storage/disk
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {StorageProjectDiskTransfer} storageProjectDiskTransfer 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectDiskTransfer: async (projectId: string, locationId: string, diskId: string, storageProjectDiskTransfer: StorageProjectDiskTransfer, xIdempotencyKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling storageProjectDiskTransfer.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling storageProjectDiskTransfer.');
            }
            // verify required parameter 'diskId' is not null or undefined
            if (diskId === null || diskId === undefined) {
                throw new RequiredError('diskId','Required parameter diskId was null or undefined when calling storageProjectDiskTransfer.');
            }
            // verify required parameter 'storageProjectDiskTransfer' is not null or undefined
            if (storageProjectDiskTransfer === null || storageProjectDiskTransfer === undefined) {
                throw new RequiredError('storageProjectDiskTransfer','Required parameter storageProjectDiskTransfer was null or undefined when calling storageProjectDiskTransfer.');
            }
            const localVarPath = `/storage/{locationId}/project/{projectId}/disk/{diskId}/actions/transfer`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"diskId"}}`, encodeURIComponent(String(diskId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof storageProjectDiskTransfer !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(storageProjectDiskTransfer !== undefined ? storageProjectDiskTransfer : {}) : (storageProjectDiskTransfer || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns modified disk
         * @summary Update storage/disk
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {StorageProjectDiskUpdate} storageProjectDiskUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectDiskUpdate: async (projectId: string, locationId: string, diskId: string, storageProjectDiskUpdate: StorageProjectDiskUpdate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling storageProjectDiskUpdate.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling storageProjectDiskUpdate.');
            }
            // verify required parameter 'diskId' is not null or undefined
            if (diskId === null || diskId === undefined) {
                throw new RequiredError('diskId','Required parameter diskId was null or undefined when calling storageProjectDiskUpdate.');
            }
            // verify required parameter 'storageProjectDiskUpdate' is not null or undefined
            if (storageProjectDiskUpdate === null || storageProjectDiskUpdate === undefined) {
                throw new RequiredError('storageProjectDiskUpdate','Required parameter storageProjectDiskUpdate was null or undefined when calling storageProjectDiskUpdate.');
            }
            const localVarPath = `/storage/{locationId}/project/{projectId}/disk/{diskId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"diskId"}}`, encodeURIComponent(String(diskId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof storageProjectDiskUpdate !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(storageProjectDiskUpdate !== undefined ? storageProjectDiskUpdate : {}) : (storageProjectDiskUpdate || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StorageProjectDiskApi - functional programming interface
 * @export
 */
export const StorageProjectDiskApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create disk
         * @summary Create storage/disk
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {StorageProjectDiskCreate} storageProjectDiskCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectDiskCreate(projectId: string, locationId: string, storageProjectDiskCreate: StorageProjectDiskCreate, xIdempotencyKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Disk>> {
            const localVarAxiosArgs = await StorageProjectDiskApiAxiosParamCreator(configuration).storageProjectDiskCreate(projectId, locationId, storageProjectDiskCreate, xIdempotencyKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete disk
         * @summary Delete storage/disk
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectDiskDelete(projectId: string, locationId: string, diskId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await StorageProjectDiskApiAxiosParamCreator(configuration).storageProjectDiskDelete(projectId, locationId, diskId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * action detach
         * @summary Detach storage/disk
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectDiskDetach(projectId: string, locationId: string, diskId: string, xIdempotencyKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Disk>> {
            const localVarAxiosArgs = await StorageProjectDiskApiAxiosParamCreator(configuration).storageProjectDiskDetach(projectId, locationId, diskId, xIdempotencyKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * action download
         * @summary Download storage/disk
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectDiskDownload(projectId: string, locationId: string, diskId: string, xIdempotencyKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await StorageProjectDiskApiAxiosParamCreator(configuration).storageProjectDiskDownload(projectId, locationId, diskId, xIdempotencyKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get storage/disk.event
         * @summary Get storage/disk.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectDiskEventGet(projectId: string, locationId: string, diskId: string, eventId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>> {
            const localVarAxiosArgs = await StorageProjectDiskApiAxiosParamCreator(configuration).storageProjectDiskEventGet(projectId, locationId, diskId, eventId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List storage/disk.event
         * @summary List storage/disk.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectDiskEventList(projectId: string, locationId: string, diskId: string, $limit?: number, $skip?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Event>>> {
            const localVarAxiosArgs = await StorageProjectDiskApiAxiosParamCreator(configuration).storageProjectDiskEventList(projectId, locationId, diskId, $limit, $skip, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a single disk
         * @summary Get storage/disk
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectDiskGet(projectId: string, locationId: string, diskId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Disk>> {
            const localVarAxiosArgs = await StorageProjectDiskApiAxiosParamCreator(configuration).storageProjectDiskGet(projectId, locationId, diskId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List disk
         * @summary List storage/disk
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [name] Filter by name
         * @param {string} [vm] Filter by vm
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectDiskList(projectId: string, locationId: string, name?: string, vm?: string, tagValue?: string, tagKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Disk>>> {
            const localVarAxiosArgs = await StorageProjectDiskApiAxiosParamCreator(configuration).storageProjectDiskList(projectId, locationId, name, vm, tagValue, tagKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get storage/disk.metric
         * @summary Get storage/disk.metric
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {string} metricId metricId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectDiskMetricGet(projectId: string, locationId: string, diskId: string, metricId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Metric>> {
            const localVarAxiosArgs = await StorageProjectDiskApiAxiosParamCreator(configuration).storageProjectDiskMetricGet(projectId, locationId, diskId, metricId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List storage/disk.metric
         * @summary List storage/disk.metric
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectDiskMetricList(projectId: string, locationId: string, diskId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Metric>>> {
            const localVarAxiosArgs = await StorageProjectDiskApiAxiosParamCreator(configuration).storageProjectDiskMetricList(projectId, locationId, diskId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List storage/disk.point
         * @summary List storage/disk.point
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {string} metricId metricId
         * @param {string} [interval] interval
         * @param {string} [timespan] timespan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectDiskMetricPointList(projectId: string, locationId: string, diskId: string, metricId: string, interval?: string, timespan?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Point>>> {
            const localVarAxiosArgs = await StorageProjectDiskApiAxiosParamCreator(configuration).storageProjectDiskMetricPointList(projectId, locationId, diskId, metricId, interval, timespan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * action resize
         * @summary Resize storage/disk
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {StorageProjectDiskResize} storageProjectDiskResize 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectDiskResize(projectId: string, locationId: string, diskId: string, storageProjectDiskResize: StorageProjectDiskResize, xIdempotencyKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Disk>> {
            const localVarAxiosArgs = await StorageProjectDiskApiAxiosParamCreator(configuration).storageProjectDiskResize(projectId, locationId, diskId, storageProjectDiskResize, xIdempotencyKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get storage/disk.service
         * @summary Get storage/disk.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectDiskServiceGet(projectId: string, locationId: string, diskId: string, serviceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceService>> {
            const localVarAxiosArgs = await StorageProjectDiskApiAxiosParamCreator(configuration).storageProjectDiskServiceGet(projectId, locationId, diskId, serviceId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List storage/disk.service
         * @summary List storage/disk.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectDiskServiceList(projectId: string, locationId: string, diskId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResourceService>>> {
            const localVarAxiosArgs = await StorageProjectDiskApiAxiosParamCreator(configuration).storageProjectDiskServiceList(projectId, locationId, diskId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create storage/disk.tag
         * @summary Create storage/disk.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectDiskTagCreate(projectId: string, locationId: string, diskId: string, tag: Tag, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await StorageProjectDiskApiAxiosParamCreator(configuration).storageProjectDiskTagCreate(projectId, locationId, diskId, tag, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete storage/disk.tag
         * @summary Delete storage/disk.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectDiskTagDelete(projectId: string, locationId: string, diskId: string, tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await StorageProjectDiskApiAxiosParamCreator(configuration).storageProjectDiskTagDelete(projectId, locationId, diskId, tagId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get storage/disk.tag
         * @summary Get storage/disk.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectDiskTagGet(projectId: string, locationId: string, diskId: string, tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await StorageProjectDiskApiAxiosParamCreator(configuration).storageProjectDiskTagGet(projectId, locationId, diskId, tagId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List storage/disk.tag
         * @summary List storage/disk.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectDiskTagList(projectId: string, locationId: string, diskId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await StorageProjectDiskApiAxiosParamCreator(configuration).storageProjectDiskTagList(projectId, locationId, diskId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Replace storage/disk.tag
         * @summary Replace storage/disk.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectDiskTagPut(projectId: string, locationId: string, diskId: string, tag: Array<Tag>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await StorageProjectDiskApiAxiosParamCreator(configuration).storageProjectDiskTagPut(projectId, locationId, diskId, tag, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * action transfer
         * @summary Transfer storage/disk
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {StorageProjectDiskTransfer} storageProjectDiskTransfer 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectDiskTransfer(projectId: string, locationId: string, diskId: string, storageProjectDiskTransfer: StorageProjectDiskTransfer, xIdempotencyKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Disk>> {
            const localVarAxiosArgs = await StorageProjectDiskApiAxiosParamCreator(configuration).storageProjectDiskTransfer(projectId, locationId, diskId, storageProjectDiskTransfer, xIdempotencyKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns modified disk
         * @summary Update storage/disk
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {StorageProjectDiskUpdate} storageProjectDiskUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectDiskUpdate(projectId: string, locationId: string, diskId: string, storageProjectDiskUpdate: StorageProjectDiskUpdate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Disk>> {
            const localVarAxiosArgs = await StorageProjectDiskApiAxiosParamCreator(configuration).storageProjectDiskUpdate(projectId, locationId, diskId, storageProjectDiskUpdate, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * StorageProjectDiskApi - factory interface
 * @export
 */
export const StorageProjectDiskApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Create disk
         * @summary Create storage/disk
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {StorageProjectDiskCreate} storageProjectDiskCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectDiskCreate(projectId: string, locationId: string, storageProjectDiskCreate: StorageProjectDiskCreate, xIdempotencyKey?: string, options?: any): AxiosPromise<Disk> {
            return StorageProjectDiskApiFp(configuration).storageProjectDiskCreate(projectId, locationId, storageProjectDiskCreate, xIdempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete disk
         * @summary Delete storage/disk
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectDiskDelete(projectId: string, locationId: string, diskId: string, options?: any): AxiosPromise<void> {
            return StorageProjectDiskApiFp(configuration).storageProjectDiskDelete(projectId, locationId, diskId, options).then((request) => request(axios, basePath));
        },
        /**
         * action detach
         * @summary Detach storage/disk
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectDiskDetach(projectId: string, locationId: string, diskId: string, xIdempotencyKey?: string, options?: any): AxiosPromise<Disk> {
            return StorageProjectDiskApiFp(configuration).storageProjectDiskDetach(projectId, locationId, diskId, xIdempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * action download
         * @summary Download storage/disk
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectDiskDownload(projectId: string, locationId: string, diskId: string, xIdempotencyKey?: string, options?: any): AxiosPromise<void> {
            return StorageProjectDiskApiFp(configuration).storageProjectDiskDownload(projectId, locationId, diskId, xIdempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get storage/disk.event
         * @summary Get storage/disk.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectDiskEventGet(projectId: string, locationId: string, diskId: string, eventId: string, options?: any): AxiosPromise<Event> {
            return StorageProjectDiskApiFp(configuration).storageProjectDiskEventGet(projectId, locationId, diskId, eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * List storage/disk.event
         * @summary List storage/disk.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectDiskEventList(projectId: string, locationId: string, diskId: string, $limit?: number, $skip?: number, options?: any): AxiosPromise<Array<Event>> {
            return StorageProjectDiskApiFp(configuration).storageProjectDiskEventList(projectId, locationId, diskId, $limit, $skip, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single disk
         * @summary Get storage/disk
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectDiskGet(projectId: string, locationId: string, diskId: string, options?: any): AxiosPromise<Disk> {
            return StorageProjectDiskApiFp(configuration).storageProjectDiskGet(projectId, locationId, diskId, options).then((request) => request(axios, basePath));
        },
        /**
         * List disk
         * @summary List storage/disk
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [name] Filter by name
         * @param {string} [vm] Filter by vm
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectDiskList(projectId: string, locationId: string, name?: string, vm?: string, tagValue?: string, tagKey?: string, options?: any): AxiosPromise<Array<Disk>> {
            return StorageProjectDiskApiFp(configuration).storageProjectDiskList(projectId, locationId, name, vm, tagValue, tagKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get storage/disk.metric
         * @summary Get storage/disk.metric
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {string} metricId metricId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectDiskMetricGet(projectId: string, locationId: string, diskId: string, metricId: string, options?: any): AxiosPromise<Metric> {
            return StorageProjectDiskApiFp(configuration).storageProjectDiskMetricGet(projectId, locationId, diskId, metricId, options).then((request) => request(axios, basePath));
        },
        /**
         * List storage/disk.metric
         * @summary List storage/disk.metric
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectDiskMetricList(projectId: string, locationId: string, diskId: string, options?: any): AxiosPromise<Array<Metric>> {
            return StorageProjectDiskApiFp(configuration).storageProjectDiskMetricList(projectId, locationId, diskId, options).then((request) => request(axios, basePath));
        },
        /**
         * List storage/disk.point
         * @summary List storage/disk.point
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {string} metricId metricId
         * @param {string} [interval] interval
         * @param {string} [timespan] timespan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectDiskMetricPointList(projectId: string, locationId: string, diskId: string, metricId: string, interval?: string, timespan?: string, options?: any): AxiosPromise<Array<Point>> {
            return StorageProjectDiskApiFp(configuration).storageProjectDiskMetricPointList(projectId, locationId, diskId, metricId, interval, timespan, options).then((request) => request(axios, basePath));
        },
        /**
         * action resize
         * @summary Resize storage/disk
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {StorageProjectDiskResize} storageProjectDiskResize 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectDiskResize(projectId: string, locationId: string, diskId: string, storageProjectDiskResize: StorageProjectDiskResize, xIdempotencyKey?: string, options?: any): AxiosPromise<Disk> {
            return StorageProjectDiskApiFp(configuration).storageProjectDiskResize(projectId, locationId, diskId, storageProjectDiskResize, xIdempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get storage/disk.service
         * @summary Get storage/disk.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectDiskServiceGet(projectId: string, locationId: string, diskId: string, serviceId: string, options?: any): AxiosPromise<ResourceService> {
            return StorageProjectDiskApiFp(configuration).storageProjectDiskServiceGet(projectId, locationId, diskId, serviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * List storage/disk.service
         * @summary List storage/disk.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectDiskServiceList(projectId: string, locationId: string, diskId: string, options?: any): AxiosPromise<Array<ResourceService>> {
            return StorageProjectDiskApiFp(configuration).storageProjectDiskServiceList(projectId, locationId, diskId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create storage/disk.tag
         * @summary Create storage/disk.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectDiskTagCreate(projectId: string, locationId: string, diskId: string, tag: Tag, options?: any): AxiosPromise<Tag> {
            return StorageProjectDiskApiFp(configuration).storageProjectDiskTagCreate(projectId, locationId, diskId, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete storage/disk.tag
         * @summary Delete storage/disk.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectDiskTagDelete(projectId: string, locationId: string, diskId: string, tagId: string, options?: any): AxiosPromise<void> {
            return StorageProjectDiskApiFp(configuration).storageProjectDiskTagDelete(projectId, locationId, diskId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get storage/disk.tag
         * @summary Get storage/disk.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectDiskTagGet(projectId: string, locationId: string, diskId: string, tagId: string, options?: any): AxiosPromise<Tag> {
            return StorageProjectDiskApiFp(configuration).storageProjectDiskTagGet(projectId, locationId, diskId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * List storage/disk.tag
         * @summary List storage/disk.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectDiskTagList(projectId: string, locationId: string, diskId: string, options?: any): AxiosPromise<Array<Tag>> {
            return StorageProjectDiskApiFp(configuration).storageProjectDiskTagList(projectId, locationId, diskId, options).then((request) => request(axios, basePath));
        },
        /**
         * Replace storage/disk.tag
         * @summary Replace storage/disk.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectDiskTagPut(projectId: string, locationId: string, diskId: string, tag: Array<Tag>, options?: any): AxiosPromise<Array<Tag>> {
            return StorageProjectDiskApiFp(configuration).storageProjectDiskTagPut(projectId, locationId, diskId, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * action transfer
         * @summary Transfer storage/disk
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {StorageProjectDiskTransfer} storageProjectDiskTransfer 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectDiskTransfer(projectId: string, locationId: string, diskId: string, storageProjectDiskTransfer: StorageProjectDiskTransfer, xIdempotencyKey?: string, options?: any): AxiosPromise<Disk> {
            return StorageProjectDiskApiFp(configuration).storageProjectDiskTransfer(projectId, locationId, diskId, storageProjectDiskTransfer, xIdempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns modified disk
         * @summary Update storage/disk
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {StorageProjectDiskUpdate} storageProjectDiskUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectDiskUpdate(projectId: string, locationId: string, diskId: string, storageProjectDiskUpdate: StorageProjectDiskUpdate, options?: any): AxiosPromise<Disk> {
            return StorageProjectDiskApiFp(configuration).storageProjectDiskUpdate(projectId, locationId, diskId, storageProjectDiskUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StorageProjectDiskApi - object-oriented interface
 * @export
 * @class StorageProjectDiskApi
 * @extends {BaseAPI}
 */
export class StorageProjectDiskApi extends BaseAPI {
    /**
     * Create disk
     * @summary Create storage/disk
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {StorageProjectDiskCreate} storageProjectDiskCreate 
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectDiskApi
     */
    public storageProjectDiskCreate(projectId: string, locationId: string, storageProjectDiskCreate: StorageProjectDiskCreate, xIdempotencyKey?: string, options?: any) {
        return StorageProjectDiskApiFp(this.configuration).storageProjectDiskCreate(projectId, locationId, storageProjectDiskCreate, xIdempotencyKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete disk
     * @summary Delete storage/disk
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} diskId Disk Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectDiskApi
     */
    public storageProjectDiskDelete(projectId: string, locationId: string, diskId: string, options?: any) {
        return StorageProjectDiskApiFp(this.configuration).storageProjectDiskDelete(projectId, locationId, diskId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * action detach
     * @summary Detach storage/disk
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} diskId Disk Id
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectDiskApi
     */
    public storageProjectDiskDetach(projectId: string, locationId: string, diskId: string, xIdempotencyKey?: string, options?: any) {
        return StorageProjectDiskApiFp(this.configuration).storageProjectDiskDetach(projectId, locationId, diskId, xIdempotencyKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * action download
     * @summary Download storage/disk
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} diskId Disk Id
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectDiskApi
     */
    public storageProjectDiskDownload(projectId: string, locationId: string, diskId: string, xIdempotencyKey?: string, options?: any) {
        return StorageProjectDiskApiFp(this.configuration).storageProjectDiskDownload(projectId, locationId, diskId, xIdempotencyKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get storage/disk.event
     * @summary Get storage/disk.event
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} diskId Disk Id
     * @param {string} eventId eventId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectDiskApi
     */
    public storageProjectDiskEventGet(projectId: string, locationId: string, diskId: string, eventId: string, options?: any) {
        return StorageProjectDiskApiFp(this.configuration).storageProjectDiskEventGet(projectId, locationId, diskId, eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List storage/disk.event
     * @summary List storage/disk.event
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} diskId Disk Id
     * @param {number} [$limit] $limit
     * @param {number} [$skip] $skip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectDiskApi
     */
    public storageProjectDiskEventList(projectId: string, locationId: string, diskId: string, $limit?: number, $skip?: number, options?: any) {
        return StorageProjectDiskApiFp(this.configuration).storageProjectDiskEventList(projectId, locationId, diskId, $limit, $skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single disk
     * @summary Get storage/disk
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} diskId Disk Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectDiskApi
     */
    public storageProjectDiskGet(projectId: string, locationId: string, diskId: string, options?: any) {
        return StorageProjectDiskApiFp(this.configuration).storageProjectDiskGet(projectId, locationId, diskId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List disk
     * @summary List storage/disk
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} [name] Filter by name
     * @param {string} [vm] Filter by vm
     * @param {string} [tagValue] Filter by tag.value
     * @param {string} [tagKey] Filter by tag.key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectDiskApi
     */
    public storageProjectDiskList(projectId: string, locationId: string, name?: string, vm?: string, tagValue?: string, tagKey?: string, options?: any) {
        return StorageProjectDiskApiFp(this.configuration).storageProjectDiskList(projectId, locationId, name, vm, tagValue, tagKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get storage/disk.metric
     * @summary Get storage/disk.metric
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} diskId Disk Id
     * @param {string} metricId metricId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectDiskApi
     */
    public storageProjectDiskMetricGet(projectId: string, locationId: string, diskId: string, metricId: string, options?: any) {
        return StorageProjectDiskApiFp(this.configuration).storageProjectDiskMetricGet(projectId, locationId, diskId, metricId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List storage/disk.metric
     * @summary List storage/disk.metric
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} diskId Disk Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectDiskApi
     */
    public storageProjectDiskMetricList(projectId: string, locationId: string, diskId: string, options?: any) {
        return StorageProjectDiskApiFp(this.configuration).storageProjectDiskMetricList(projectId, locationId, diskId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List storage/disk.point
     * @summary List storage/disk.point
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} diskId Disk Id
     * @param {string} metricId metricId
     * @param {string} [interval] interval
     * @param {string} [timespan] timespan
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectDiskApi
     */
    public storageProjectDiskMetricPointList(projectId: string, locationId: string, diskId: string, metricId: string, interval?: string, timespan?: string, options?: any) {
        return StorageProjectDiskApiFp(this.configuration).storageProjectDiskMetricPointList(projectId, locationId, diskId, metricId, interval, timespan, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * action resize
     * @summary Resize storage/disk
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} diskId Disk Id
     * @param {StorageProjectDiskResize} storageProjectDiskResize 
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectDiskApi
     */
    public storageProjectDiskResize(projectId: string, locationId: string, diskId: string, storageProjectDiskResize: StorageProjectDiskResize, xIdempotencyKey?: string, options?: any) {
        return StorageProjectDiskApiFp(this.configuration).storageProjectDiskResize(projectId, locationId, diskId, storageProjectDiskResize, xIdempotencyKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get storage/disk.service
     * @summary Get storage/disk.service
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} diskId Disk Id
     * @param {string} serviceId serviceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectDiskApi
     */
    public storageProjectDiskServiceGet(projectId: string, locationId: string, diskId: string, serviceId: string, options?: any) {
        return StorageProjectDiskApiFp(this.configuration).storageProjectDiskServiceGet(projectId, locationId, diskId, serviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List storage/disk.service
     * @summary List storage/disk.service
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} diskId Disk Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectDiskApi
     */
    public storageProjectDiskServiceList(projectId: string, locationId: string, diskId: string, options?: any) {
        return StorageProjectDiskApiFp(this.configuration).storageProjectDiskServiceList(projectId, locationId, diskId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create storage/disk.tag
     * @summary Create storage/disk.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} diskId Disk Id
     * @param {Tag} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectDiskApi
     */
    public storageProjectDiskTagCreate(projectId: string, locationId: string, diskId: string, tag: Tag, options?: any) {
        return StorageProjectDiskApiFp(this.configuration).storageProjectDiskTagCreate(projectId, locationId, diskId, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete storage/disk.tag
     * @summary Delete storage/disk.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} diskId Disk Id
     * @param {string} tagId tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectDiskApi
     */
    public storageProjectDiskTagDelete(projectId: string, locationId: string, diskId: string, tagId: string, options?: any) {
        return StorageProjectDiskApiFp(this.configuration).storageProjectDiskTagDelete(projectId, locationId, diskId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get storage/disk.tag
     * @summary Get storage/disk.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} diskId Disk Id
     * @param {string} tagId tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectDiskApi
     */
    public storageProjectDiskTagGet(projectId: string, locationId: string, diskId: string, tagId: string, options?: any) {
        return StorageProjectDiskApiFp(this.configuration).storageProjectDiskTagGet(projectId, locationId, diskId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List storage/disk.tag
     * @summary List storage/disk.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} diskId Disk Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectDiskApi
     */
    public storageProjectDiskTagList(projectId: string, locationId: string, diskId: string, options?: any) {
        return StorageProjectDiskApiFp(this.configuration).storageProjectDiskTagList(projectId, locationId, diskId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replace storage/disk.tag
     * @summary Replace storage/disk.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} diskId Disk Id
     * @param {Array<Tag>} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectDiskApi
     */
    public storageProjectDiskTagPut(projectId: string, locationId: string, diskId: string, tag: Array<Tag>, options?: any) {
        return StorageProjectDiskApiFp(this.configuration).storageProjectDiskTagPut(projectId, locationId, diskId, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * action transfer
     * @summary Transfer storage/disk
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} diskId Disk Id
     * @param {StorageProjectDiskTransfer} storageProjectDiskTransfer 
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectDiskApi
     */
    public storageProjectDiskTransfer(projectId: string, locationId: string, diskId: string, storageProjectDiskTransfer: StorageProjectDiskTransfer, xIdempotencyKey?: string, options?: any) {
        return StorageProjectDiskApiFp(this.configuration).storageProjectDiskTransfer(projectId, locationId, diskId, storageProjectDiskTransfer, xIdempotencyKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns modified disk
     * @summary Update storage/disk
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} diskId Disk Id
     * @param {StorageProjectDiskUpdate} storageProjectDiskUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectDiskApi
     */
    public storageProjectDiskUpdate(projectId: string, locationId: string, diskId: string, storageProjectDiskUpdate: StorageProjectDiskUpdate, options?: any) {
        return StorageProjectDiskApiFp(this.configuration).storageProjectDiskUpdate(projectId, locationId, diskId, storageProjectDiskUpdate, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * StorageProjectImageApi - axios parameter creator
 * @export
 */
export const StorageProjectImageApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create image
         * @summary Create storage/image
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {StorageProjectImageCreate} storageProjectImageCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectImageCreate: async (projectId: string, locationId: string, storageProjectImageCreate: StorageProjectImageCreate, xIdempotencyKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling storageProjectImageCreate.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling storageProjectImageCreate.');
            }
            // verify required parameter 'storageProjectImageCreate' is not null or undefined
            if (storageProjectImageCreate === null || storageProjectImageCreate === undefined) {
                throw new RequiredError('storageProjectImageCreate','Required parameter storageProjectImageCreate was null or undefined when calling storageProjectImageCreate.');
            }
            const localVarPath = `/storage/{locationId}/project/{projectId}/image`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof storageProjectImageCreate !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(storageProjectImageCreate !== undefined ? storageProjectImageCreate : {}) : (storageProjectImageCreate || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete image
         * @summary Delete storage/image
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} imageId Image Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectImageDelete: async (projectId: string, locationId: string, imageId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling storageProjectImageDelete.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling storageProjectImageDelete.');
            }
            // verify required parameter 'imageId' is not null or undefined
            if (imageId === null || imageId === undefined) {
                throw new RequiredError('imageId','Required parameter imageId was null or undefined when calling storageProjectImageDelete.');
            }
            const localVarPath = `/storage/{locationId}/project/{projectId}/image/{imageId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"imageId"}}`, encodeURIComponent(String(imageId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List storage/image.disk
         * @summary List storage/image.disk
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} imageId Image Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectImageDiskList: async (projectId: string, locationId: string, imageId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling storageProjectImageDiskList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling storageProjectImageDiskList.');
            }
            // verify required parameter 'imageId' is not null or undefined
            if (imageId === null || imageId === undefined) {
                throw new RequiredError('imageId','Required parameter imageId was null or undefined when calling storageProjectImageDiskList.');
            }
            const localVarPath = `/storage/{locationId}/project/{projectId}/image/{imageId}/disk`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"imageId"}}`, encodeURIComponent(String(imageId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get storage/image.event
         * @summary Get storage/image.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} imageId Image Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectImageEventGet: async (projectId: string, locationId: string, imageId: string, eventId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling storageProjectImageEventGet.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling storageProjectImageEventGet.');
            }
            // verify required parameter 'imageId' is not null or undefined
            if (imageId === null || imageId === undefined) {
                throw new RequiredError('imageId','Required parameter imageId was null or undefined when calling storageProjectImageEventGet.');
            }
            // verify required parameter 'eventId' is not null or undefined
            if (eventId === null || eventId === undefined) {
                throw new RequiredError('eventId','Required parameter eventId was null or undefined when calling storageProjectImageEventGet.');
            }
            const localVarPath = `/storage/{locationId}/project/{projectId}/image/{imageId}/event/{eventId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"imageId"}}`, encodeURIComponent(String(imageId)))
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List storage/image.event
         * @summary List storage/image.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} imageId Image Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectImageEventList: async (projectId: string, locationId: string, imageId: string, $limit?: number, $skip?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling storageProjectImageEventList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling storageProjectImageEventList.');
            }
            // verify required parameter 'imageId' is not null or undefined
            if (imageId === null || imageId === undefined) {
                throw new RequiredError('imageId','Required parameter imageId was null or undefined when calling storageProjectImageEventList.');
            }
            const localVarPath = `/storage/{locationId}/project/{projectId}/image/{imageId}/event`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"imageId"}}`, encodeURIComponent(String(imageId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if ($limit !== undefined) {
                localVarQueryParameter['$limit'] = $limit;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single image
         * @summary Get storage/image
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} imageId Image Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectImageGet: async (projectId: string, locationId: string, imageId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling storageProjectImageGet.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling storageProjectImageGet.');
            }
            // verify required parameter 'imageId' is not null or undefined
            if (imageId === null || imageId === undefined) {
                throw new RequiredError('imageId','Required parameter imageId was null or undefined when calling storageProjectImageGet.');
            }
            const localVarPath = `/storage/{locationId}/project/{projectId}/image/{imageId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"imageId"}}`, encodeURIComponent(String(imageId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List image
         * @summary List storage/image
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [name] Filter by name
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectImageList: async (projectId: string, locationId: string, name?: string, tagValue?: string, tagKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling storageProjectImageList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling storageProjectImageList.');
            }
            const localVarPath = `/storage/{locationId}/project/{projectId}/image`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (tagValue !== undefined) {
                localVarQueryParameter['tag.value'] = tagValue;
            }

            if (tagKey !== undefined) {
                localVarQueryParameter['tag.key'] = tagKey;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get storage/image.service
         * @summary Get storage/image.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} imageId Image Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectImageServiceGet: async (projectId: string, locationId: string, imageId: string, serviceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling storageProjectImageServiceGet.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling storageProjectImageServiceGet.');
            }
            // verify required parameter 'imageId' is not null or undefined
            if (imageId === null || imageId === undefined) {
                throw new RequiredError('imageId','Required parameter imageId was null or undefined when calling storageProjectImageServiceGet.');
            }
            // verify required parameter 'serviceId' is not null or undefined
            if (serviceId === null || serviceId === undefined) {
                throw new RequiredError('serviceId','Required parameter serviceId was null or undefined when calling storageProjectImageServiceGet.');
            }
            const localVarPath = `/storage/{locationId}/project/{projectId}/image/{imageId}/service/{serviceId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"imageId"}}`, encodeURIComponent(String(imageId)))
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List storage/image.service
         * @summary List storage/image.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} imageId Image Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectImageServiceList: async (projectId: string, locationId: string, imageId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling storageProjectImageServiceList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling storageProjectImageServiceList.');
            }
            // verify required parameter 'imageId' is not null or undefined
            if (imageId === null || imageId === undefined) {
                throw new RequiredError('imageId','Required parameter imageId was null or undefined when calling storageProjectImageServiceList.');
            }
            const localVarPath = `/storage/{locationId}/project/{projectId}/image/{imageId}/service`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"imageId"}}`, encodeURIComponent(String(imageId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create storage/image.tag
         * @summary Create storage/image.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} imageId Image Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectImageTagCreate: async (projectId: string, locationId: string, imageId: string, tag: Tag, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling storageProjectImageTagCreate.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling storageProjectImageTagCreate.');
            }
            // verify required parameter 'imageId' is not null or undefined
            if (imageId === null || imageId === undefined) {
                throw new RequiredError('imageId','Required parameter imageId was null or undefined when calling storageProjectImageTagCreate.');
            }
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling storageProjectImageTagCreate.');
            }
            const localVarPath = `/storage/{locationId}/project/{projectId}/image/{imageId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"imageId"}}`, encodeURIComponent(String(imageId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof tag !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(tag !== undefined ? tag : {}) : (tag || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete storage/image.tag
         * @summary Delete storage/image.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} imageId Image Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectImageTagDelete: async (projectId: string, locationId: string, imageId: string, tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling storageProjectImageTagDelete.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling storageProjectImageTagDelete.');
            }
            // verify required parameter 'imageId' is not null or undefined
            if (imageId === null || imageId === undefined) {
                throw new RequiredError('imageId','Required parameter imageId was null or undefined when calling storageProjectImageTagDelete.');
            }
            // verify required parameter 'tagId' is not null or undefined
            if (tagId === null || tagId === undefined) {
                throw new RequiredError('tagId','Required parameter tagId was null or undefined when calling storageProjectImageTagDelete.');
            }
            const localVarPath = `/storage/{locationId}/project/{projectId}/image/{imageId}/tag/{tagId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"imageId"}}`, encodeURIComponent(String(imageId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get storage/image.tag
         * @summary Get storage/image.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} imageId Image Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectImageTagGet: async (projectId: string, locationId: string, imageId: string, tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling storageProjectImageTagGet.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling storageProjectImageTagGet.');
            }
            // verify required parameter 'imageId' is not null or undefined
            if (imageId === null || imageId === undefined) {
                throw new RequiredError('imageId','Required parameter imageId was null or undefined when calling storageProjectImageTagGet.');
            }
            // verify required parameter 'tagId' is not null or undefined
            if (tagId === null || tagId === undefined) {
                throw new RequiredError('tagId','Required parameter tagId was null or undefined when calling storageProjectImageTagGet.');
            }
            const localVarPath = `/storage/{locationId}/project/{projectId}/image/{imageId}/tag/{tagId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"imageId"}}`, encodeURIComponent(String(imageId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List storage/image.tag
         * @summary List storage/image.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} imageId Image Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectImageTagList: async (projectId: string, locationId: string, imageId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling storageProjectImageTagList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling storageProjectImageTagList.');
            }
            // verify required parameter 'imageId' is not null or undefined
            if (imageId === null || imageId === undefined) {
                throw new RequiredError('imageId','Required parameter imageId was null or undefined when calling storageProjectImageTagList.');
            }
            const localVarPath = `/storage/{locationId}/project/{projectId}/image/{imageId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"imageId"}}`, encodeURIComponent(String(imageId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replace storage/image.tag
         * @summary Replace storage/image.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} imageId Image Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectImageTagPut: async (projectId: string, locationId: string, imageId: string, tag: Array<Tag>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling storageProjectImageTagPut.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling storageProjectImageTagPut.');
            }
            // verify required parameter 'imageId' is not null or undefined
            if (imageId === null || imageId === undefined) {
                throw new RequiredError('imageId','Required parameter imageId was null or undefined when calling storageProjectImageTagPut.');
            }
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling storageProjectImageTagPut.');
            }
            const localVarPath = `/storage/{locationId}/project/{projectId}/image/{imageId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"imageId"}}`, encodeURIComponent(String(imageId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof tag !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(tag !== undefined ? tag : {}) : (tag || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * action transfer
         * @summary Transfer storage/image
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} imageId Image Id
         * @param {StorageProjectImageTransfer} storageProjectImageTransfer 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectImageTransfer: async (projectId: string, locationId: string, imageId: string, storageProjectImageTransfer: StorageProjectImageTransfer, xIdempotencyKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling storageProjectImageTransfer.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling storageProjectImageTransfer.');
            }
            // verify required parameter 'imageId' is not null or undefined
            if (imageId === null || imageId === undefined) {
                throw new RequiredError('imageId','Required parameter imageId was null or undefined when calling storageProjectImageTransfer.');
            }
            // verify required parameter 'storageProjectImageTransfer' is not null or undefined
            if (storageProjectImageTransfer === null || storageProjectImageTransfer === undefined) {
                throw new RequiredError('storageProjectImageTransfer','Required parameter storageProjectImageTransfer was null or undefined when calling storageProjectImageTransfer.');
            }
            const localVarPath = `/storage/{locationId}/project/{projectId}/image/{imageId}/actions/transfer`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"imageId"}}`, encodeURIComponent(String(imageId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof storageProjectImageTransfer !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(storageProjectImageTransfer !== undefined ? storageProjectImageTransfer : {}) : (storageProjectImageTransfer || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns modified image
         * @summary Update storage/image
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} imageId Image Id
         * @param {StorageProjectImageUpdate} storageProjectImageUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectImageUpdate: async (projectId: string, locationId: string, imageId: string, storageProjectImageUpdate: StorageProjectImageUpdate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling storageProjectImageUpdate.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling storageProjectImageUpdate.');
            }
            // verify required parameter 'imageId' is not null or undefined
            if (imageId === null || imageId === undefined) {
                throw new RequiredError('imageId','Required parameter imageId was null or undefined when calling storageProjectImageUpdate.');
            }
            // verify required parameter 'storageProjectImageUpdate' is not null or undefined
            if (storageProjectImageUpdate === null || storageProjectImageUpdate === undefined) {
                throw new RequiredError('storageProjectImageUpdate','Required parameter storageProjectImageUpdate was null or undefined when calling storageProjectImageUpdate.');
            }
            const localVarPath = `/storage/{locationId}/project/{projectId}/image/{imageId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"imageId"}}`, encodeURIComponent(String(imageId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof storageProjectImageUpdate !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(storageProjectImageUpdate !== undefined ? storageProjectImageUpdate : {}) : (storageProjectImageUpdate || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StorageProjectImageApi - functional programming interface
 * @export
 */
export const StorageProjectImageApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create image
         * @summary Create storage/image
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {StorageProjectImageCreate} storageProjectImageCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectImageCreate(projectId: string, locationId: string, storageProjectImageCreate: StorageProjectImageCreate, xIdempotencyKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Image>> {
            const localVarAxiosArgs = await StorageProjectImageApiAxiosParamCreator(configuration).storageProjectImageCreate(projectId, locationId, storageProjectImageCreate, xIdempotencyKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete image
         * @summary Delete storage/image
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} imageId Image Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectImageDelete(projectId: string, locationId: string, imageId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await StorageProjectImageApiAxiosParamCreator(configuration).storageProjectImageDelete(projectId, locationId, imageId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List storage/image.disk
         * @summary List storage/image.disk
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} imageId Image Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectImageDiskList(projectId: string, locationId: string, imageId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Disk>>> {
            const localVarAxiosArgs = await StorageProjectImageApiAxiosParamCreator(configuration).storageProjectImageDiskList(projectId, locationId, imageId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get storage/image.event
         * @summary Get storage/image.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} imageId Image Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectImageEventGet(projectId: string, locationId: string, imageId: string, eventId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>> {
            const localVarAxiosArgs = await StorageProjectImageApiAxiosParamCreator(configuration).storageProjectImageEventGet(projectId, locationId, imageId, eventId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List storage/image.event
         * @summary List storage/image.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} imageId Image Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectImageEventList(projectId: string, locationId: string, imageId: string, $limit?: number, $skip?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Event>>> {
            const localVarAxiosArgs = await StorageProjectImageApiAxiosParamCreator(configuration).storageProjectImageEventList(projectId, locationId, imageId, $limit, $skip, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a single image
         * @summary Get storage/image
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} imageId Image Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectImageGet(projectId: string, locationId: string, imageId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Image>> {
            const localVarAxiosArgs = await StorageProjectImageApiAxiosParamCreator(configuration).storageProjectImageGet(projectId, locationId, imageId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List image
         * @summary List storage/image
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [name] Filter by name
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectImageList(projectId: string, locationId: string, name?: string, tagValue?: string, tagKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Image>>> {
            const localVarAxiosArgs = await StorageProjectImageApiAxiosParamCreator(configuration).storageProjectImageList(projectId, locationId, name, tagValue, tagKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get storage/image.service
         * @summary Get storage/image.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} imageId Image Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectImageServiceGet(projectId: string, locationId: string, imageId: string, serviceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceService>> {
            const localVarAxiosArgs = await StorageProjectImageApiAxiosParamCreator(configuration).storageProjectImageServiceGet(projectId, locationId, imageId, serviceId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List storage/image.service
         * @summary List storage/image.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} imageId Image Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectImageServiceList(projectId: string, locationId: string, imageId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResourceService>>> {
            const localVarAxiosArgs = await StorageProjectImageApiAxiosParamCreator(configuration).storageProjectImageServiceList(projectId, locationId, imageId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create storage/image.tag
         * @summary Create storage/image.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} imageId Image Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectImageTagCreate(projectId: string, locationId: string, imageId: string, tag: Tag, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await StorageProjectImageApiAxiosParamCreator(configuration).storageProjectImageTagCreate(projectId, locationId, imageId, tag, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete storage/image.tag
         * @summary Delete storage/image.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} imageId Image Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectImageTagDelete(projectId: string, locationId: string, imageId: string, tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await StorageProjectImageApiAxiosParamCreator(configuration).storageProjectImageTagDelete(projectId, locationId, imageId, tagId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get storage/image.tag
         * @summary Get storage/image.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} imageId Image Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectImageTagGet(projectId: string, locationId: string, imageId: string, tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await StorageProjectImageApiAxiosParamCreator(configuration).storageProjectImageTagGet(projectId, locationId, imageId, tagId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List storage/image.tag
         * @summary List storage/image.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} imageId Image Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectImageTagList(projectId: string, locationId: string, imageId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await StorageProjectImageApiAxiosParamCreator(configuration).storageProjectImageTagList(projectId, locationId, imageId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Replace storage/image.tag
         * @summary Replace storage/image.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} imageId Image Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectImageTagPut(projectId: string, locationId: string, imageId: string, tag: Array<Tag>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await StorageProjectImageApiAxiosParamCreator(configuration).storageProjectImageTagPut(projectId, locationId, imageId, tag, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * action transfer
         * @summary Transfer storage/image
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} imageId Image Id
         * @param {StorageProjectImageTransfer} storageProjectImageTransfer 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectImageTransfer(projectId: string, locationId: string, imageId: string, storageProjectImageTransfer: StorageProjectImageTransfer, xIdempotencyKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Image>> {
            const localVarAxiosArgs = await StorageProjectImageApiAxiosParamCreator(configuration).storageProjectImageTransfer(projectId, locationId, imageId, storageProjectImageTransfer, xIdempotencyKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns modified image
         * @summary Update storage/image
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} imageId Image Id
         * @param {StorageProjectImageUpdate} storageProjectImageUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectImageUpdate(projectId: string, locationId: string, imageId: string, storageProjectImageUpdate: StorageProjectImageUpdate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Image>> {
            const localVarAxiosArgs = await StorageProjectImageApiAxiosParamCreator(configuration).storageProjectImageUpdate(projectId, locationId, imageId, storageProjectImageUpdate, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * StorageProjectImageApi - factory interface
 * @export
 */
export const StorageProjectImageApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Create image
         * @summary Create storage/image
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {StorageProjectImageCreate} storageProjectImageCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectImageCreate(projectId: string, locationId: string, storageProjectImageCreate: StorageProjectImageCreate, xIdempotencyKey?: string, options?: any): AxiosPromise<Image> {
            return StorageProjectImageApiFp(configuration).storageProjectImageCreate(projectId, locationId, storageProjectImageCreate, xIdempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete image
         * @summary Delete storage/image
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} imageId Image Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectImageDelete(projectId: string, locationId: string, imageId: string, options?: any): AxiosPromise<void> {
            return StorageProjectImageApiFp(configuration).storageProjectImageDelete(projectId, locationId, imageId, options).then((request) => request(axios, basePath));
        },
        /**
         * List storage/image.disk
         * @summary List storage/image.disk
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} imageId Image Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectImageDiskList(projectId: string, locationId: string, imageId: string, options?: any): AxiosPromise<Array<Disk>> {
            return StorageProjectImageApiFp(configuration).storageProjectImageDiskList(projectId, locationId, imageId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get storage/image.event
         * @summary Get storage/image.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} imageId Image Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectImageEventGet(projectId: string, locationId: string, imageId: string, eventId: string, options?: any): AxiosPromise<Event> {
            return StorageProjectImageApiFp(configuration).storageProjectImageEventGet(projectId, locationId, imageId, eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * List storage/image.event
         * @summary List storage/image.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} imageId Image Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectImageEventList(projectId: string, locationId: string, imageId: string, $limit?: number, $skip?: number, options?: any): AxiosPromise<Array<Event>> {
            return StorageProjectImageApiFp(configuration).storageProjectImageEventList(projectId, locationId, imageId, $limit, $skip, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single image
         * @summary Get storage/image
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} imageId Image Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectImageGet(projectId: string, locationId: string, imageId: string, options?: any): AxiosPromise<Image> {
            return StorageProjectImageApiFp(configuration).storageProjectImageGet(projectId, locationId, imageId, options).then((request) => request(axios, basePath));
        },
        /**
         * List image
         * @summary List storage/image
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [name] Filter by name
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectImageList(projectId: string, locationId: string, name?: string, tagValue?: string, tagKey?: string, options?: any): AxiosPromise<Array<Image>> {
            return StorageProjectImageApiFp(configuration).storageProjectImageList(projectId, locationId, name, tagValue, tagKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get storage/image.service
         * @summary Get storage/image.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} imageId Image Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectImageServiceGet(projectId: string, locationId: string, imageId: string, serviceId: string, options?: any): AxiosPromise<ResourceService> {
            return StorageProjectImageApiFp(configuration).storageProjectImageServiceGet(projectId, locationId, imageId, serviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * List storage/image.service
         * @summary List storage/image.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} imageId Image Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectImageServiceList(projectId: string, locationId: string, imageId: string, options?: any): AxiosPromise<Array<ResourceService>> {
            return StorageProjectImageApiFp(configuration).storageProjectImageServiceList(projectId, locationId, imageId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create storage/image.tag
         * @summary Create storage/image.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} imageId Image Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectImageTagCreate(projectId: string, locationId: string, imageId: string, tag: Tag, options?: any): AxiosPromise<Tag> {
            return StorageProjectImageApiFp(configuration).storageProjectImageTagCreate(projectId, locationId, imageId, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete storage/image.tag
         * @summary Delete storage/image.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} imageId Image Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectImageTagDelete(projectId: string, locationId: string, imageId: string, tagId: string, options?: any): AxiosPromise<void> {
            return StorageProjectImageApiFp(configuration).storageProjectImageTagDelete(projectId, locationId, imageId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get storage/image.tag
         * @summary Get storage/image.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} imageId Image Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectImageTagGet(projectId: string, locationId: string, imageId: string, tagId: string, options?: any): AxiosPromise<Tag> {
            return StorageProjectImageApiFp(configuration).storageProjectImageTagGet(projectId, locationId, imageId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * List storage/image.tag
         * @summary List storage/image.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} imageId Image Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectImageTagList(projectId: string, locationId: string, imageId: string, options?: any): AxiosPromise<Array<Tag>> {
            return StorageProjectImageApiFp(configuration).storageProjectImageTagList(projectId, locationId, imageId, options).then((request) => request(axios, basePath));
        },
        /**
         * Replace storage/image.tag
         * @summary Replace storage/image.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} imageId Image Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectImageTagPut(projectId: string, locationId: string, imageId: string, tag: Array<Tag>, options?: any): AxiosPromise<Array<Tag>> {
            return StorageProjectImageApiFp(configuration).storageProjectImageTagPut(projectId, locationId, imageId, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * action transfer
         * @summary Transfer storage/image
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} imageId Image Id
         * @param {StorageProjectImageTransfer} storageProjectImageTransfer 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectImageTransfer(projectId: string, locationId: string, imageId: string, storageProjectImageTransfer: StorageProjectImageTransfer, xIdempotencyKey?: string, options?: any): AxiosPromise<Image> {
            return StorageProjectImageApiFp(configuration).storageProjectImageTransfer(projectId, locationId, imageId, storageProjectImageTransfer, xIdempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns modified image
         * @summary Update storage/image
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} imageId Image Id
         * @param {StorageProjectImageUpdate} storageProjectImageUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectImageUpdate(projectId: string, locationId: string, imageId: string, storageProjectImageUpdate: StorageProjectImageUpdate, options?: any): AxiosPromise<Image> {
            return StorageProjectImageApiFp(configuration).storageProjectImageUpdate(projectId, locationId, imageId, storageProjectImageUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StorageProjectImageApi - object-oriented interface
 * @export
 * @class StorageProjectImageApi
 * @extends {BaseAPI}
 */
export class StorageProjectImageApi extends BaseAPI {
    /**
     * Create image
     * @summary Create storage/image
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {StorageProjectImageCreate} storageProjectImageCreate 
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectImageApi
     */
    public storageProjectImageCreate(projectId: string, locationId: string, storageProjectImageCreate: StorageProjectImageCreate, xIdempotencyKey?: string, options?: any) {
        return StorageProjectImageApiFp(this.configuration).storageProjectImageCreate(projectId, locationId, storageProjectImageCreate, xIdempotencyKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete image
     * @summary Delete storage/image
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} imageId Image Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectImageApi
     */
    public storageProjectImageDelete(projectId: string, locationId: string, imageId: string, options?: any) {
        return StorageProjectImageApiFp(this.configuration).storageProjectImageDelete(projectId, locationId, imageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List storage/image.disk
     * @summary List storage/image.disk
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} imageId Image Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectImageApi
     */
    public storageProjectImageDiskList(projectId: string, locationId: string, imageId: string, options?: any) {
        return StorageProjectImageApiFp(this.configuration).storageProjectImageDiskList(projectId, locationId, imageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get storage/image.event
     * @summary Get storage/image.event
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} imageId Image Id
     * @param {string} eventId eventId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectImageApi
     */
    public storageProjectImageEventGet(projectId: string, locationId: string, imageId: string, eventId: string, options?: any) {
        return StorageProjectImageApiFp(this.configuration).storageProjectImageEventGet(projectId, locationId, imageId, eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List storage/image.event
     * @summary List storage/image.event
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} imageId Image Id
     * @param {number} [$limit] $limit
     * @param {number} [$skip] $skip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectImageApi
     */
    public storageProjectImageEventList(projectId: string, locationId: string, imageId: string, $limit?: number, $skip?: number, options?: any) {
        return StorageProjectImageApiFp(this.configuration).storageProjectImageEventList(projectId, locationId, imageId, $limit, $skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single image
     * @summary Get storage/image
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} imageId Image Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectImageApi
     */
    public storageProjectImageGet(projectId: string, locationId: string, imageId: string, options?: any) {
        return StorageProjectImageApiFp(this.configuration).storageProjectImageGet(projectId, locationId, imageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List image
     * @summary List storage/image
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} [name] Filter by name
     * @param {string} [tagValue] Filter by tag.value
     * @param {string} [tagKey] Filter by tag.key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectImageApi
     */
    public storageProjectImageList(projectId: string, locationId: string, name?: string, tagValue?: string, tagKey?: string, options?: any) {
        return StorageProjectImageApiFp(this.configuration).storageProjectImageList(projectId, locationId, name, tagValue, tagKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get storage/image.service
     * @summary Get storage/image.service
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} imageId Image Id
     * @param {string} serviceId serviceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectImageApi
     */
    public storageProjectImageServiceGet(projectId: string, locationId: string, imageId: string, serviceId: string, options?: any) {
        return StorageProjectImageApiFp(this.configuration).storageProjectImageServiceGet(projectId, locationId, imageId, serviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List storage/image.service
     * @summary List storage/image.service
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} imageId Image Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectImageApi
     */
    public storageProjectImageServiceList(projectId: string, locationId: string, imageId: string, options?: any) {
        return StorageProjectImageApiFp(this.configuration).storageProjectImageServiceList(projectId, locationId, imageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create storage/image.tag
     * @summary Create storage/image.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} imageId Image Id
     * @param {Tag} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectImageApi
     */
    public storageProjectImageTagCreate(projectId: string, locationId: string, imageId: string, tag: Tag, options?: any) {
        return StorageProjectImageApiFp(this.configuration).storageProjectImageTagCreate(projectId, locationId, imageId, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete storage/image.tag
     * @summary Delete storage/image.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} imageId Image Id
     * @param {string} tagId tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectImageApi
     */
    public storageProjectImageTagDelete(projectId: string, locationId: string, imageId: string, tagId: string, options?: any) {
        return StorageProjectImageApiFp(this.configuration).storageProjectImageTagDelete(projectId, locationId, imageId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get storage/image.tag
     * @summary Get storage/image.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} imageId Image Id
     * @param {string} tagId tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectImageApi
     */
    public storageProjectImageTagGet(projectId: string, locationId: string, imageId: string, tagId: string, options?: any) {
        return StorageProjectImageApiFp(this.configuration).storageProjectImageTagGet(projectId, locationId, imageId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List storage/image.tag
     * @summary List storage/image.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} imageId Image Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectImageApi
     */
    public storageProjectImageTagList(projectId: string, locationId: string, imageId: string, options?: any) {
        return StorageProjectImageApiFp(this.configuration).storageProjectImageTagList(projectId, locationId, imageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replace storage/image.tag
     * @summary Replace storage/image.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} imageId Image Id
     * @param {Array<Tag>} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectImageApi
     */
    public storageProjectImageTagPut(projectId: string, locationId: string, imageId: string, tag: Array<Tag>, options?: any) {
        return StorageProjectImageApiFp(this.configuration).storageProjectImageTagPut(projectId, locationId, imageId, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * action transfer
     * @summary Transfer storage/image
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} imageId Image Id
     * @param {StorageProjectImageTransfer} storageProjectImageTransfer 
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectImageApi
     */
    public storageProjectImageTransfer(projectId: string, locationId: string, imageId: string, storageProjectImageTransfer: StorageProjectImageTransfer, xIdempotencyKey?: string, options?: any) {
        return StorageProjectImageApiFp(this.configuration).storageProjectImageTransfer(projectId, locationId, imageId, storageProjectImageTransfer, xIdempotencyKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns modified image
     * @summary Update storage/image
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} imageId Image Id
     * @param {StorageProjectImageUpdate} storageProjectImageUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectImageApi
     */
    public storageProjectImageUpdate(projectId: string, locationId: string, imageId: string, storageProjectImageUpdate: StorageProjectImageUpdate, options?: any) {
        return StorageProjectImageApiFp(this.configuration).storageProjectImageUpdate(projectId, locationId, imageId, storageProjectImageUpdate, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * StorageProjectIsoApi - axios parameter creator
 * @export
 */
export const StorageProjectIsoApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create iso
         * @summary Create storage/iso
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {StorageProjectIsoCreate} storageProjectIsoCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectIsoCreate: async (projectId: string, locationId: string, storageProjectIsoCreate: StorageProjectIsoCreate, xIdempotencyKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling storageProjectIsoCreate.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling storageProjectIsoCreate.');
            }
            // verify required parameter 'storageProjectIsoCreate' is not null or undefined
            if (storageProjectIsoCreate === null || storageProjectIsoCreate === undefined) {
                throw new RequiredError('storageProjectIsoCreate','Required parameter storageProjectIsoCreate was null or undefined when calling storageProjectIsoCreate.');
            }
            const localVarPath = `/storage/{locationId}/project/{projectId}/iso`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof storageProjectIsoCreate !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(storageProjectIsoCreate !== undefined ? storageProjectIsoCreate : {}) : (storageProjectIsoCreate || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete iso
         * @summary Delete storage/iso
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} isoId Iso Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectIsoDelete: async (projectId: string, locationId: string, isoId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling storageProjectIsoDelete.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling storageProjectIsoDelete.');
            }
            // verify required parameter 'isoId' is not null or undefined
            if (isoId === null || isoId === undefined) {
                throw new RequiredError('isoId','Required parameter isoId was null or undefined when calling storageProjectIsoDelete.');
            }
            const localVarPath = `/storage/{locationId}/project/{projectId}/iso/{isoId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"isoId"}}`, encodeURIComponent(String(isoId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * action detach
         * @summary Detach storage/iso
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} isoId Iso Id
         * @param {StorageProjectIsoDetach} storageProjectIsoDetach 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectIsoDetach: async (projectId: string, locationId: string, isoId: string, storageProjectIsoDetach: StorageProjectIsoDetach, xIdempotencyKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling storageProjectIsoDetach.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling storageProjectIsoDetach.');
            }
            // verify required parameter 'isoId' is not null or undefined
            if (isoId === null || isoId === undefined) {
                throw new RequiredError('isoId','Required parameter isoId was null or undefined when calling storageProjectIsoDetach.');
            }
            // verify required parameter 'storageProjectIsoDetach' is not null or undefined
            if (storageProjectIsoDetach === null || storageProjectIsoDetach === undefined) {
                throw new RequiredError('storageProjectIsoDetach','Required parameter storageProjectIsoDetach was null or undefined when calling storageProjectIsoDetach.');
            }
            const localVarPath = `/storage/{locationId}/project/{projectId}/iso/{isoId}/actions/detach`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"isoId"}}`, encodeURIComponent(String(isoId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof storageProjectIsoDetach !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(storageProjectIsoDetach !== undefined ? storageProjectIsoDetach : {}) : (storageProjectIsoDetach || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get storage/iso.event
         * @summary Get storage/iso.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} isoId Iso Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectIsoEventGet: async (projectId: string, locationId: string, isoId: string, eventId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling storageProjectIsoEventGet.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling storageProjectIsoEventGet.');
            }
            // verify required parameter 'isoId' is not null or undefined
            if (isoId === null || isoId === undefined) {
                throw new RequiredError('isoId','Required parameter isoId was null or undefined when calling storageProjectIsoEventGet.');
            }
            // verify required parameter 'eventId' is not null or undefined
            if (eventId === null || eventId === undefined) {
                throw new RequiredError('eventId','Required parameter eventId was null or undefined when calling storageProjectIsoEventGet.');
            }
            const localVarPath = `/storage/{locationId}/project/{projectId}/iso/{isoId}/event/{eventId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"isoId"}}`, encodeURIComponent(String(isoId)))
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List storage/iso.event
         * @summary List storage/iso.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} isoId Iso Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectIsoEventList: async (projectId: string, locationId: string, isoId: string, $limit?: number, $skip?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling storageProjectIsoEventList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling storageProjectIsoEventList.');
            }
            // verify required parameter 'isoId' is not null or undefined
            if (isoId === null || isoId === undefined) {
                throw new RequiredError('isoId','Required parameter isoId was null or undefined when calling storageProjectIsoEventList.');
            }
            const localVarPath = `/storage/{locationId}/project/{projectId}/iso/{isoId}/event`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"isoId"}}`, encodeURIComponent(String(isoId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if ($limit !== undefined) {
                localVarQueryParameter['$limit'] = $limit;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single iso
         * @summary Get storage/iso
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} isoId Iso Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectIsoGet: async (projectId: string, locationId: string, isoId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling storageProjectIsoGet.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling storageProjectIsoGet.');
            }
            // verify required parameter 'isoId' is not null or undefined
            if (isoId === null || isoId === undefined) {
                throw new RequiredError('isoId','Required parameter isoId was null or undefined when calling storageProjectIsoGet.');
            }
            const localVarPath = `/storage/{locationId}/project/{projectId}/iso/{isoId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"isoId"}}`, encodeURIComponent(String(isoId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List iso
         * @summary List storage/iso
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [name] Filter by name
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectIsoList: async (projectId: string, locationId: string, name?: string, tagValue?: string, tagKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling storageProjectIsoList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling storageProjectIsoList.');
            }
            const localVarPath = `/storage/{locationId}/project/{projectId}/iso`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (tagValue !== undefined) {
                localVarQueryParameter['tag.value'] = tagValue;
            }

            if (tagKey !== undefined) {
                localVarQueryParameter['tag.key'] = tagKey;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get storage/iso.service
         * @summary Get storage/iso.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} isoId Iso Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectIsoServiceGet: async (projectId: string, locationId: string, isoId: string, serviceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling storageProjectIsoServiceGet.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling storageProjectIsoServiceGet.');
            }
            // verify required parameter 'isoId' is not null or undefined
            if (isoId === null || isoId === undefined) {
                throw new RequiredError('isoId','Required parameter isoId was null or undefined when calling storageProjectIsoServiceGet.');
            }
            // verify required parameter 'serviceId' is not null or undefined
            if (serviceId === null || serviceId === undefined) {
                throw new RequiredError('serviceId','Required parameter serviceId was null or undefined when calling storageProjectIsoServiceGet.');
            }
            const localVarPath = `/storage/{locationId}/project/{projectId}/iso/{isoId}/service/{serviceId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"isoId"}}`, encodeURIComponent(String(isoId)))
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List storage/iso.service
         * @summary List storage/iso.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} isoId Iso Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectIsoServiceList: async (projectId: string, locationId: string, isoId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling storageProjectIsoServiceList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling storageProjectIsoServiceList.');
            }
            // verify required parameter 'isoId' is not null or undefined
            if (isoId === null || isoId === undefined) {
                throw new RequiredError('isoId','Required parameter isoId was null or undefined when calling storageProjectIsoServiceList.');
            }
            const localVarPath = `/storage/{locationId}/project/{projectId}/iso/{isoId}/service`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"isoId"}}`, encodeURIComponent(String(isoId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create storage/iso.tag
         * @summary Create storage/iso.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} isoId Iso Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectIsoTagCreate: async (projectId: string, locationId: string, isoId: string, tag: Tag, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling storageProjectIsoTagCreate.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling storageProjectIsoTagCreate.');
            }
            // verify required parameter 'isoId' is not null or undefined
            if (isoId === null || isoId === undefined) {
                throw new RequiredError('isoId','Required parameter isoId was null or undefined when calling storageProjectIsoTagCreate.');
            }
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling storageProjectIsoTagCreate.');
            }
            const localVarPath = `/storage/{locationId}/project/{projectId}/iso/{isoId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"isoId"}}`, encodeURIComponent(String(isoId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof tag !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(tag !== undefined ? tag : {}) : (tag || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete storage/iso.tag
         * @summary Delete storage/iso.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} isoId Iso Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectIsoTagDelete: async (projectId: string, locationId: string, isoId: string, tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling storageProjectIsoTagDelete.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling storageProjectIsoTagDelete.');
            }
            // verify required parameter 'isoId' is not null or undefined
            if (isoId === null || isoId === undefined) {
                throw new RequiredError('isoId','Required parameter isoId was null or undefined when calling storageProjectIsoTagDelete.');
            }
            // verify required parameter 'tagId' is not null or undefined
            if (tagId === null || tagId === undefined) {
                throw new RequiredError('tagId','Required parameter tagId was null or undefined when calling storageProjectIsoTagDelete.');
            }
            const localVarPath = `/storage/{locationId}/project/{projectId}/iso/{isoId}/tag/{tagId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"isoId"}}`, encodeURIComponent(String(isoId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get storage/iso.tag
         * @summary Get storage/iso.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} isoId Iso Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectIsoTagGet: async (projectId: string, locationId: string, isoId: string, tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling storageProjectIsoTagGet.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling storageProjectIsoTagGet.');
            }
            // verify required parameter 'isoId' is not null or undefined
            if (isoId === null || isoId === undefined) {
                throw new RequiredError('isoId','Required parameter isoId was null or undefined when calling storageProjectIsoTagGet.');
            }
            // verify required parameter 'tagId' is not null or undefined
            if (tagId === null || tagId === undefined) {
                throw new RequiredError('tagId','Required parameter tagId was null or undefined when calling storageProjectIsoTagGet.');
            }
            const localVarPath = `/storage/{locationId}/project/{projectId}/iso/{isoId}/tag/{tagId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"isoId"}}`, encodeURIComponent(String(isoId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List storage/iso.tag
         * @summary List storage/iso.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} isoId Iso Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectIsoTagList: async (projectId: string, locationId: string, isoId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling storageProjectIsoTagList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling storageProjectIsoTagList.');
            }
            // verify required parameter 'isoId' is not null or undefined
            if (isoId === null || isoId === undefined) {
                throw new RequiredError('isoId','Required parameter isoId was null or undefined when calling storageProjectIsoTagList.');
            }
            const localVarPath = `/storage/{locationId}/project/{projectId}/iso/{isoId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"isoId"}}`, encodeURIComponent(String(isoId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replace storage/iso.tag
         * @summary Replace storage/iso.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} isoId Iso Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectIsoTagPut: async (projectId: string, locationId: string, isoId: string, tag: Array<Tag>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling storageProjectIsoTagPut.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling storageProjectIsoTagPut.');
            }
            // verify required parameter 'isoId' is not null or undefined
            if (isoId === null || isoId === undefined) {
                throw new RequiredError('isoId','Required parameter isoId was null or undefined when calling storageProjectIsoTagPut.');
            }
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling storageProjectIsoTagPut.');
            }
            const localVarPath = `/storage/{locationId}/project/{projectId}/iso/{isoId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"isoId"}}`, encodeURIComponent(String(isoId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof tag !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(tag !== undefined ? tag : {}) : (tag || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * action transfer
         * @summary Transfer storage/iso
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} isoId Iso Id
         * @param {StorageProjectIsoTransfer} storageProjectIsoTransfer 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectIsoTransfer: async (projectId: string, locationId: string, isoId: string, storageProjectIsoTransfer: StorageProjectIsoTransfer, xIdempotencyKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling storageProjectIsoTransfer.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling storageProjectIsoTransfer.');
            }
            // verify required parameter 'isoId' is not null or undefined
            if (isoId === null || isoId === undefined) {
                throw new RequiredError('isoId','Required parameter isoId was null or undefined when calling storageProjectIsoTransfer.');
            }
            // verify required parameter 'storageProjectIsoTransfer' is not null or undefined
            if (storageProjectIsoTransfer === null || storageProjectIsoTransfer === undefined) {
                throw new RequiredError('storageProjectIsoTransfer','Required parameter storageProjectIsoTransfer was null or undefined when calling storageProjectIsoTransfer.');
            }
            const localVarPath = `/storage/{locationId}/project/{projectId}/iso/{isoId}/actions/transfer`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"isoId"}}`, encodeURIComponent(String(isoId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof storageProjectIsoTransfer !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(storageProjectIsoTransfer !== undefined ? storageProjectIsoTransfer : {}) : (storageProjectIsoTransfer || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns modified iso
         * @summary Update storage/iso
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} isoId Iso Id
         * @param {StorageProjectIsoUpdate} storageProjectIsoUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectIsoUpdate: async (projectId: string, locationId: string, isoId: string, storageProjectIsoUpdate: StorageProjectIsoUpdate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling storageProjectIsoUpdate.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling storageProjectIsoUpdate.');
            }
            // verify required parameter 'isoId' is not null or undefined
            if (isoId === null || isoId === undefined) {
                throw new RequiredError('isoId','Required parameter isoId was null or undefined when calling storageProjectIsoUpdate.');
            }
            // verify required parameter 'storageProjectIsoUpdate' is not null or undefined
            if (storageProjectIsoUpdate === null || storageProjectIsoUpdate === undefined) {
                throw new RequiredError('storageProjectIsoUpdate','Required parameter storageProjectIsoUpdate was null or undefined when calling storageProjectIsoUpdate.');
            }
            const localVarPath = `/storage/{locationId}/project/{projectId}/iso/{isoId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"isoId"}}`, encodeURIComponent(String(isoId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof storageProjectIsoUpdate !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(storageProjectIsoUpdate !== undefined ? storageProjectIsoUpdate : {}) : (storageProjectIsoUpdate || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StorageProjectIsoApi - functional programming interface
 * @export
 */
export const StorageProjectIsoApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Create iso
         * @summary Create storage/iso
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {StorageProjectIsoCreate} storageProjectIsoCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectIsoCreate(projectId: string, locationId: string, storageProjectIsoCreate: StorageProjectIsoCreate, xIdempotencyKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Iso>> {
            const localVarAxiosArgs = await StorageProjectIsoApiAxiosParamCreator(configuration).storageProjectIsoCreate(projectId, locationId, storageProjectIsoCreate, xIdempotencyKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete iso
         * @summary Delete storage/iso
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} isoId Iso Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectIsoDelete(projectId: string, locationId: string, isoId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await StorageProjectIsoApiAxiosParamCreator(configuration).storageProjectIsoDelete(projectId, locationId, isoId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * action detach
         * @summary Detach storage/iso
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} isoId Iso Id
         * @param {StorageProjectIsoDetach} storageProjectIsoDetach 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectIsoDetach(projectId: string, locationId: string, isoId: string, storageProjectIsoDetach: StorageProjectIsoDetach, xIdempotencyKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Iso>> {
            const localVarAxiosArgs = await StorageProjectIsoApiAxiosParamCreator(configuration).storageProjectIsoDetach(projectId, locationId, isoId, storageProjectIsoDetach, xIdempotencyKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get storage/iso.event
         * @summary Get storage/iso.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} isoId Iso Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectIsoEventGet(projectId: string, locationId: string, isoId: string, eventId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>> {
            const localVarAxiosArgs = await StorageProjectIsoApiAxiosParamCreator(configuration).storageProjectIsoEventGet(projectId, locationId, isoId, eventId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List storage/iso.event
         * @summary List storage/iso.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} isoId Iso Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectIsoEventList(projectId: string, locationId: string, isoId: string, $limit?: number, $skip?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Event>>> {
            const localVarAxiosArgs = await StorageProjectIsoApiAxiosParamCreator(configuration).storageProjectIsoEventList(projectId, locationId, isoId, $limit, $skip, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a single iso
         * @summary Get storage/iso
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} isoId Iso Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectIsoGet(projectId: string, locationId: string, isoId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Iso>> {
            const localVarAxiosArgs = await StorageProjectIsoApiAxiosParamCreator(configuration).storageProjectIsoGet(projectId, locationId, isoId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List iso
         * @summary List storage/iso
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [name] Filter by name
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectIsoList(projectId: string, locationId: string, name?: string, tagValue?: string, tagKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Iso>>> {
            const localVarAxiosArgs = await StorageProjectIsoApiAxiosParamCreator(configuration).storageProjectIsoList(projectId, locationId, name, tagValue, tagKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get storage/iso.service
         * @summary Get storage/iso.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} isoId Iso Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectIsoServiceGet(projectId: string, locationId: string, isoId: string, serviceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceService>> {
            const localVarAxiosArgs = await StorageProjectIsoApiAxiosParamCreator(configuration).storageProjectIsoServiceGet(projectId, locationId, isoId, serviceId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List storage/iso.service
         * @summary List storage/iso.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} isoId Iso Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectIsoServiceList(projectId: string, locationId: string, isoId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResourceService>>> {
            const localVarAxiosArgs = await StorageProjectIsoApiAxiosParamCreator(configuration).storageProjectIsoServiceList(projectId, locationId, isoId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create storage/iso.tag
         * @summary Create storage/iso.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} isoId Iso Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectIsoTagCreate(projectId: string, locationId: string, isoId: string, tag: Tag, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await StorageProjectIsoApiAxiosParamCreator(configuration).storageProjectIsoTagCreate(projectId, locationId, isoId, tag, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete storage/iso.tag
         * @summary Delete storage/iso.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} isoId Iso Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectIsoTagDelete(projectId: string, locationId: string, isoId: string, tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await StorageProjectIsoApiAxiosParamCreator(configuration).storageProjectIsoTagDelete(projectId, locationId, isoId, tagId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get storage/iso.tag
         * @summary Get storage/iso.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} isoId Iso Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectIsoTagGet(projectId: string, locationId: string, isoId: string, tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await StorageProjectIsoApiAxiosParamCreator(configuration).storageProjectIsoTagGet(projectId, locationId, isoId, tagId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List storage/iso.tag
         * @summary List storage/iso.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} isoId Iso Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectIsoTagList(projectId: string, locationId: string, isoId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await StorageProjectIsoApiAxiosParamCreator(configuration).storageProjectIsoTagList(projectId, locationId, isoId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Replace storage/iso.tag
         * @summary Replace storage/iso.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} isoId Iso Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectIsoTagPut(projectId: string, locationId: string, isoId: string, tag: Array<Tag>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await StorageProjectIsoApiAxiosParamCreator(configuration).storageProjectIsoTagPut(projectId, locationId, isoId, tag, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * action transfer
         * @summary Transfer storage/iso
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} isoId Iso Id
         * @param {StorageProjectIsoTransfer} storageProjectIsoTransfer 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectIsoTransfer(projectId: string, locationId: string, isoId: string, storageProjectIsoTransfer: StorageProjectIsoTransfer, xIdempotencyKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Iso>> {
            const localVarAxiosArgs = await StorageProjectIsoApiAxiosParamCreator(configuration).storageProjectIsoTransfer(projectId, locationId, isoId, storageProjectIsoTransfer, xIdempotencyKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns modified iso
         * @summary Update storage/iso
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} isoId Iso Id
         * @param {StorageProjectIsoUpdate} storageProjectIsoUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectIsoUpdate(projectId: string, locationId: string, isoId: string, storageProjectIsoUpdate: StorageProjectIsoUpdate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Iso>> {
            const localVarAxiosArgs = await StorageProjectIsoApiAxiosParamCreator(configuration).storageProjectIsoUpdate(projectId, locationId, isoId, storageProjectIsoUpdate, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * StorageProjectIsoApi - factory interface
 * @export
 */
export const StorageProjectIsoApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Create iso
         * @summary Create storage/iso
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {StorageProjectIsoCreate} storageProjectIsoCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectIsoCreate(projectId: string, locationId: string, storageProjectIsoCreate: StorageProjectIsoCreate, xIdempotencyKey?: string, options?: any): AxiosPromise<Iso> {
            return StorageProjectIsoApiFp(configuration).storageProjectIsoCreate(projectId, locationId, storageProjectIsoCreate, xIdempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete iso
         * @summary Delete storage/iso
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} isoId Iso Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectIsoDelete(projectId: string, locationId: string, isoId: string, options?: any): AxiosPromise<void> {
            return StorageProjectIsoApiFp(configuration).storageProjectIsoDelete(projectId, locationId, isoId, options).then((request) => request(axios, basePath));
        },
        /**
         * action detach
         * @summary Detach storage/iso
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} isoId Iso Id
         * @param {StorageProjectIsoDetach} storageProjectIsoDetach 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectIsoDetach(projectId: string, locationId: string, isoId: string, storageProjectIsoDetach: StorageProjectIsoDetach, xIdempotencyKey?: string, options?: any): AxiosPromise<Iso> {
            return StorageProjectIsoApiFp(configuration).storageProjectIsoDetach(projectId, locationId, isoId, storageProjectIsoDetach, xIdempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get storage/iso.event
         * @summary Get storage/iso.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} isoId Iso Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectIsoEventGet(projectId: string, locationId: string, isoId: string, eventId: string, options?: any): AxiosPromise<Event> {
            return StorageProjectIsoApiFp(configuration).storageProjectIsoEventGet(projectId, locationId, isoId, eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * List storage/iso.event
         * @summary List storage/iso.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} isoId Iso Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectIsoEventList(projectId: string, locationId: string, isoId: string, $limit?: number, $skip?: number, options?: any): AxiosPromise<Array<Event>> {
            return StorageProjectIsoApiFp(configuration).storageProjectIsoEventList(projectId, locationId, isoId, $limit, $skip, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single iso
         * @summary Get storage/iso
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} isoId Iso Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectIsoGet(projectId: string, locationId: string, isoId: string, options?: any): AxiosPromise<Iso> {
            return StorageProjectIsoApiFp(configuration).storageProjectIsoGet(projectId, locationId, isoId, options).then((request) => request(axios, basePath));
        },
        /**
         * List iso
         * @summary List storage/iso
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [name] Filter by name
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectIsoList(projectId: string, locationId: string, name?: string, tagValue?: string, tagKey?: string, options?: any): AxiosPromise<Array<Iso>> {
            return StorageProjectIsoApiFp(configuration).storageProjectIsoList(projectId, locationId, name, tagValue, tagKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get storage/iso.service
         * @summary Get storage/iso.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} isoId Iso Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectIsoServiceGet(projectId: string, locationId: string, isoId: string, serviceId: string, options?: any): AxiosPromise<ResourceService> {
            return StorageProjectIsoApiFp(configuration).storageProjectIsoServiceGet(projectId, locationId, isoId, serviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * List storage/iso.service
         * @summary List storage/iso.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} isoId Iso Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectIsoServiceList(projectId: string, locationId: string, isoId: string, options?: any): AxiosPromise<Array<ResourceService>> {
            return StorageProjectIsoApiFp(configuration).storageProjectIsoServiceList(projectId, locationId, isoId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create storage/iso.tag
         * @summary Create storage/iso.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} isoId Iso Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectIsoTagCreate(projectId: string, locationId: string, isoId: string, tag: Tag, options?: any): AxiosPromise<Tag> {
            return StorageProjectIsoApiFp(configuration).storageProjectIsoTagCreate(projectId, locationId, isoId, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete storage/iso.tag
         * @summary Delete storage/iso.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} isoId Iso Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectIsoTagDelete(projectId: string, locationId: string, isoId: string, tagId: string, options?: any): AxiosPromise<void> {
            return StorageProjectIsoApiFp(configuration).storageProjectIsoTagDelete(projectId, locationId, isoId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get storage/iso.tag
         * @summary Get storage/iso.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} isoId Iso Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectIsoTagGet(projectId: string, locationId: string, isoId: string, tagId: string, options?: any): AxiosPromise<Tag> {
            return StorageProjectIsoApiFp(configuration).storageProjectIsoTagGet(projectId, locationId, isoId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * List storage/iso.tag
         * @summary List storage/iso.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} isoId Iso Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectIsoTagList(projectId: string, locationId: string, isoId: string, options?: any): AxiosPromise<Array<Tag>> {
            return StorageProjectIsoApiFp(configuration).storageProjectIsoTagList(projectId, locationId, isoId, options).then((request) => request(axios, basePath));
        },
        /**
         * Replace storage/iso.tag
         * @summary Replace storage/iso.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} isoId Iso Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectIsoTagPut(projectId: string, locationId: string, isoId: string, tag: Array<Tag>, options?: any): AxiosPromise<Array<Tag>> {
            return StorageProjectIsoApiFp(configuration).storageProjectIsoTagPut(projectId, locationId, isoId, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * action transfer
         * @summary Transfer storage/iso
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} isoId Iso Id
         * @param {StorageProjectIsoTransfer} storageProjectIsoTransfer 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectIsoTransfer(projectId: string, locationId: string, isoId: string, storageProjectIsoTransfer: StorageProjectIsoTransfer, xIdempotencyKey?: string, options?: any): AxiosPromise<Iso> {
            return StorageProjectIsoApiFp(configuration).storageProjectIsoTransfer(projectId, locationId, isoId, storageProjectIsoTransfer, xIdempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns modified iso
         * @summary Update storage/iso
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} isoId Iso Id
         * @param {StorageProjectIsoUpdate} storageProjectIsoUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectIsoUpdate(projectId: string, locationId: string, isoId: string, storageProjectIsoUpdate: StorageProjectIsoUpdate, options?: any): AxiosPromise<Iso> {
            return StorageProjectIsoApiFp(configuration).storageProjectIsoUpdate(projectId, locationId, isoId, storageProjectIsoUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StorageProjectIsoApi - object-oriented interface
 * @export
 * @class StorageProjectIsoApi
 * @extends {BaseAPI}
 */
export class StorageProjectIsoApi extends BaseAPI {
    /**
     * Create iso
     * @summary Create storage/iso
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {StorageProjectIsoCreate} storageProjectIsoCreate 
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectIsoApi
     */
    public storageProjectIsoCreate(projectId: string, locationId: string, storageProjectIsoCreate: StorageProjectIsoCreate, xIdempotencyKey?: string, options?: any) {
        return StorageProjectIsoApiFp(this.configuration).storageProjectIsoCreate(projectId, locationId, storageProjectIsoCreate, xIdempotencyKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete iso
     * @summary Delete storage/iso
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} isoId Iso Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectIsoApi
     */
    public storageProjectIsoDelete(projectId: string, locationId: string, isoId: string, options?: any) {
        return StorageProjectIsoApiFp(this.configuration).storageProjectIsoDelete(projectId, locationId, isoId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * action detach
     * @summary Detach storage/iso
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} isoId Iso Id
     * @param {StorageProjectIsoDetach} storageProjectIsoDetach 
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectIsoApi
     */
    public storageProjectIsoDetach(projectId: string, locationId: string, isoId: string, storageProjectIsoDetach: StorageProjectIsoDetach, xIdempotencyKey?: string, options?: any) {
        return StorageProjectIsoApiFp(this.configuration).storageProjectIsoDetach(projectId, locationId, isoId, storageProjectIsoDetach, xIdempotencyKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get storage/iso.event
     * @summary Get storage/iso.event
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} isoId Iso Id
     * @param {string} eventId eventId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectIsoApi
     */
    public storageProjectIsoEventGet(projectId: string, locationId: string, isoId: string, eventId: string, options?: any) {
        return StorageProjectIsoApiFp(this.configuration).storageProjectIsoEventGet(projectId, locationId, isoId, eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List storage/iso.event
     * @summary List storage/iso.event
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} isoId Iso Id
     * @param {number} [$limit] $limit
     * @param {number} [$skip] $skip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectIsoApi
     */
    public storageProjectIsoEventList(projectId: string, locationId: string, isoId: string, $limit?: number, $skip?: number, options?: any) {
        return StorageProjectIsoApiFp(this.configuration).storageProjectIsoEventList(projectId, locationId, isoId, $limit, $skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single iso
     * @summary Get storage/iso
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} isoId Iso Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectIsoApi
     */
    public storageProjectIsoGet(projectId: string, locationId: string, isoId: string, options?: any) {
        return StorageProjectIsoApiFp(this.configuration).storageProjectIsoGet(projectId, locationId, isoId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List iso
     * @summary List storage/iso
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} [name] Filter by name
     * @param {string} [tagValue] Filter by tag.value
     * @param {string} [tagKey] Filter by tag.key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectIsoApi
     */
    public storageProjectIsoList(projectId: string, locationId: string, name?: string, tagValue?: string, tagKey?: string, options?: any) {
        return StorageProjectIsoApiFp(this.configuration).storageProjectIsoList(projectId, locationId, name, tagValue, tagKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get storage/iso.service
     * @summary Get storage/iso.service
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} isoId Iso Id
     * @param {string} serviceId serviceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectIsoApi
     */
    public storageProjectIsoServiceGet(projectId: string, locationId: string, isoId: string, serviceId: string, options?: any) {
        return StorageProjectIsoApiFp(this.configuration).storageProjectIsoServiceGet(projectId, locationId, isoId, serviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List storage/iso.service
     * @summary List storage/iso.service
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} isoId Iso Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectIsoApi
     */
    public storageProjectIsoServiceList(projectId: string, locationId: string, isoId: string, options?: any) {
        return StorageProjectIsoApiFp(this.configuration).storageProjectIsoServiceList(projectId, locationId, isoId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create storage/iso.tag
     * @summary Create storage/iso.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} isoId Iso Id
     * @param {Tag} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectIsoApi
     */
    public storageProjectIsoTagCreate(projectId: string, locationId: string, isoId: string, tag: Tag, options?: any) {
        return StorageProjectIsoApiFp(this.configuration).storageProjectIsoTagCreate(projectId, locationId, isoId, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete storage/iso.tag
     * @summary Delete storage/iso.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} isoId Iso Id
     * @param {string} tagId tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectIsoApi
     */
    public storageProjectIsoTagDelete(projectId: string, locationId: string, isoId: string, tagId: string, options?: any) {
        return StorageProjectIsoApiFp(this.configuration).storageProjectIsoTagDelete(projectId, locationId, isoId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get storage/iso.tag
     * @summary Get storage/iso.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} isoId Iso Id
     * @param {string} tagId tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectIsoApi
     */
    public storageProjectIsoTagGet(projectId: string, locationId: string, isoId: string, tagId: string, options?: any) {
        return StorageProjectIsoApiFp(this.configuration).storageProjectIsoTagGet(projectId, locationId, isoId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List storage/iso.tag
     * @summary List storage/iso.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} isoId Iso Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectIsoApi
     */
    public storageProjectIsoTagList(projectId: string, locationId: string, isoId: string, options?: any) {
        return StorageProjectIsoApiFp(this.configuration).storageProjectIsoTagList(projectId, locationId, isoId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replace storage/iso.tag
     * @summary Replace storage/iso.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} isoId Iso Id
     * @param {Array<Tag>} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectIsoApi
     */
    public storageProjectIsoTagPut(projectId: string, locationId: string, isoId: string, tag: Array<Tag>, options?: any) {
        return StorageProjectIsoApiFp(this.configuration).storageProjectIsoTagPut(projectId, locationId, isoId, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * action transfer
     * @summary Transfer storage/iso
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} isoId Iso Id
     * @param {StorageProjectIsoTransfer} storageProjectIsoTransfer 
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectIsoApi
     */
    public storageProjectIsoTransfer(projectId: string, locationId: string, isoId: string, storageProjectIsoTransfer: StorageProjectIsoTransfer, xIdempotencyKey?: string, options?: any) {
        return StorageProjectIsoApiFp(this.configuration).storageProjectIsoTransfer(projectId, locationId, isoId, storageProjectIsoTransfer, xIdempotencyKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns modified iso
     * @summary Update storage/iso
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} isoId Iso Id
     * @param {StorageProjectIsoUpdate} storageProjectIsoUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectIsoApi
     */
    public storageProjectIsoUpdate(projectId: string, locationId: string, isoId: string, storageProjectIsoUpdate: StorageProjectIsoUpdate, options?: any) {
        return StorageProjectIsoApiFp(this.configuration).storageProjectIsoUpdate(projectId, locationId, isoId, storageProjectIsoUpdate, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * StorageProjectVaultApi - axios parameter creator
 * @export
 */
export const StorageProjectVaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get storage/vault.connect
         * @summary Get storage/vault.connect
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {string} connectId connectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultConnectGet: async (projectId: string, locationId: string, vaultId: string, connectId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling storageProjectVaultConnectGet.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling storageProjectVaultConnectGet.');
            }
            // verify required parameter 'vaultId' is not null or undefined
            if (vaultId === null || vaultId === undefined) {
                throw new RequiredError('vaultId','Required parameter vaultId was null or undefined when calling storageProjectVaultConnectGet.');
            }
            // verify required parameter 'connectId' is not null or undefined
            if (connectId === null || connectId === undefined) {
                throw new RequiredError('connectId','Required parameter connectId was null or undefined when calling storageProjectVaultConnectGet.');
            }
            const localVarPath = `/storage/{locationId}/project/{projectId}/vault/{vaultId}/connect/{connectId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"vaultId"}}`, encodeURIComponent(String(vaultId)))
                .replace(`{${"connectId"}}`, encodeURIComponent(String(connectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List storage/vault.connect
         * @summary List storage/vault.connect
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultConnectList: async (projectId: string, locationId: string, vaultId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling storageProjectVaultConnectList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling storageProjectVaultConnectList.');
            }
            // verify required parameter 'vaultId' is not null or undefined
            if (vaultId === null || vaultId === undefined) {
                throw new RequiredError('vaultId','Required parameter vaultId was null or undefined when calling storageProjectVaultConnectList.');
            }
            const localVarPath = `/storage/{locationId}/project/{projectId}/vault/{vaultId}/connect`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"vaultId"}}`, encodeURIComponent(String(vaultId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create vault
         * @summary Create storage/vault
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {StorageProjectVaultCreate} storageProjectVaultCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultCreate: async (projectId: string, locationId: string, storageProjectVaultCreate: StorageProjectVaultCreate, xIdempotencyKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling storageProjectVaultCreate.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling storageProjectVaultCreate.');
            }
            // verify required parameter 'storageProjectVaultCreate' is not null or undefined
            if (storageProjectVaultCreate === null || storageProjectVaultCreate === undefined) {
                throw new RequiredError('storageProjectVaultCreate','Required parameter storageProjectVaultCreate was null or undefined when calling storageProjectVaultCreate.');
            }
            const localVarPath = `/storage/{locationId}/project/{projectId}/vault`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof storageProjectVaultCreate !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(storageProjectVaultCreate !== undefined ? storageProjectVaultCreate : {}) : (storageProjectVaultCreate || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create storage/vault.credential
         * @summary Create storage/vault.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {VaultCredential} vaultCredential 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultCredentialCreate: async (projectId: string, locationId: string, vaultId: string, vaultCredential: VaultCredential, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling storageProjectVaultCredentialCreate.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling storageProjectVaultCredentialCreate.');
            }
            // verify required parameter 'vaultId' is not null or undefined
            if (vaultId === null || vaultId === undefined) {
                throw new RequiredError('vaultId','Required parameter vaultId was null or undefined when calling storageProjectVaultCredentialCreate.');
            }
            // verify required parameter 'vaultCredential' is not null or undefined
            if (vaultCredential === null || vaultCredential === undefined) {
                throw new RequiredError('vaultCredential','Required parameter vaultCredential was null or undefined when calling storageProjectVaultCredentialCreate.');
            }
            const localVarPath = `/storage/{locationId}/project/{projectId}/vault/{vaultId}/credential`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"vaultId"}}`, encodeURIComponent(String(vaultId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof vaultCredential !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(vaultCredential !== undefined ? vaultCredential : {}) : (vaultCredential || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete storage/vault.credential
         * @summary Delete storage/vault.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {string} credentialId credentialId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultCredentialDelete: async (projectId: string, locationId: string, vaultId: string, credentialId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling storageProjectVaultCredentialDelete.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling storageProjectVaultCredentialDelete.');
            }
            // verify required parameter 'vaultId' is not null or undefined
            if (vaultId === null || vaultId === undefined) {
                throw new RequiredError('vaultId','Required parameter vaultId was null or undefined when calling storageProjectVaultCredentialDelete.');
            }
            // verify required parameter 'credentialId' is not null or undefined
            if (credentialId === null || credentialId === undefined) {
                throw new RequiredError('credentialId','Required parameter credentialId was null or undefined when calling storageProjectVaultCredentialDelete.');
            }
            const localVarPath = `/storage/{locationId}/project/{projectId}/vault/{vaultId}/credential/{credentialId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"vaultId"}}`, encodeURIComponent(String(vaultId)))
                .replace(`{${"credentialId"}}`, encodeURIComponent(String(credentialId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get storage/vault.credential
         * @summary Get storage/vault.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {string} credentialId credentialId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultCredentialGet: async (projectId: string, locationId: string, vaultId: string, credentialId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling storageProjectVaultCredentialGet.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling storageProjectVaultCredentialGet.');
            }
            // verify required parameter 'vaultId' is not null or undefined
            if (vaultId === null || vaultId === undefined) {
                throw new RequiredError('vaultId','Required parameter vaultId was null or undefined when calling storageProjectVaultCredentialGet.');
            }
            // verify required parameter 'credentialId' is not null or undefined
            if (credentialId === null || credentialId === undefined) {
                throw new RequiredError('credentialId','Required parameter credentialId was null or undefined when calling storageProjectVaultCredentialGet.');
            }
            const localVarPath = `/storage/{locationId}/project/{projectId}/vault/{vaultId}/credential/{credentialId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"vaultId"}}`, encodeURIComponent(String(vaultId)))
                .replace(`{${"credentialId"}}`, encodeURIComponent(String(credentialId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List storage/vault.credential
         * @summary List storage/vault.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultCredentialList: async (projectId: string, locationId: string, vaultId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling storageProjectVaultCredentialList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling storageProjectVaultCredentialList.');
            }
            // verify required parameter 'vaultId' is not null or undefined
            if (vaultId === null || vaultId === undefined) {
                throw new RequiredError('vaultId','Required parameter vaultId was null or undefined when calling storageProjectVaultCredentialList.');
            }
            const localVarPath = `/storage/{locationId}/project/{projectId}/vault/{vaultId}/credential`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"vaultId"}}`, encodeURIComponent(String(vaultId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update storage/vault.credential
         * @summary Update storage/vault.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {string} credentialId credentialId
         * @param {StorageProjectVaultCredentialPatch} storageProjectVaultCredentialPatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultCredentialPatch: async (projectId: string, locationId: string, vaultId: string, credentialId: string, storageProjectVaultCredentialPatch: StorageProjectVaultCredentialPatch, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling storageProjectVaultCredentialPatch.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling storageProjectVaultCredentialPatch.');
            }
            // verify required parameter 'vaultId' is not null or undefined
            if (vaultId === null || vaultId === undefined) {
                throw new RequiredError('vaultId','Required parameter vaultId was null or undefined when calling storageProjectVaultCredentialPatch.');
            }
            // verify required parameter 'credentialId' is not null or undefined
            if (credentialId === null || credentialId === undefined) {
                throw new RequiredError('credentialId','Required parameter credentialId was null or undefined when calling storageProjectVaultCredentialPatch.');
            }
            // verify required parameter 'storageProjectVaultCredentialPatch' is not null or undefined
            if (storageProjectVaultCredentialPatch === null || storageProjectVaultCredentialPatch === undefined) {
                throw new RequiredError('storageProjectVaultCredentialPatch','Required parameter storageProjectVaultCredentialPatch was null or undefined when calling storageProjectVaultCredentialPatch.');
            }
            const localVarPath = `/storage/{locationId}/project/{projectId}/vault/{vaultId}/credential/{credentialId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"vaultId"}}`, encodeURIComponent(String(vaultId)))
                .replace(`{${"credentialId"}}`, encodeURIComponent(String(credentialId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof storageProjectVaultCredentialPatch !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(storageProjectVaultCredentialPatch !== undefined ? storageProjectVaultCredentialPatch : {}) : (storageProjectVaultCredentialPatch || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete vault
         * @summary Delete storage/vault
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {StorageProjectVaultDelete} storageProjectVaultDelete 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultDelete: async (projectId: string, locationId: string, vaultId: string, storageProjectVaultDelete: StorageProjectVaultDelete, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling storageProjectVaultDelete.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling storageProjectVaultDelete.');
            }
            // verify required parameter 'vaultId' is not null or undefined
            if (vaultId === null || vaultId === undefined) {
                throw new RequiredError('vaultId','Required parameter vaultId was null or undefined when calling storageProjectVaultDelete.');
            }
            // verify required parameter 'storageProjectVaultDelete' is not null or undefined
            if (storageProjectVaultDelete === null || storageProjectVaultDelete === undefined) {
                throw new RequiredError('storageProjectVaultDelete','Required parameter storageProjectVaultDelete was null or undefined when calling storageProjectVaultDelete.');
            }
            const localVarPath = `/storage/{locationId}/project/{projectId}/vault/{vaultId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"vaultId"}}`, encodeURIComponent(String(vaultId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof storageProjectVaultDelete !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(storageProjectVaultDelete !== undefined ? storageProjectVaultDelete : {}) : (storageProjectVaultDelete || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get storage/vault.event
         * @summary Get storage/vault.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultEventGet: async (projectId: string, locationId: string, vaultId: string, eventId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling storageProjectVaultEventGet.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling storageProjectVaultEventGet.');
            }
            // verify required parameter 'vaultId' is not null or undefined
            if (vaultId === null || vaultId === undefined) {
                throw new RequiredError('vaultId','Required parameter vaultId was null or undefined when calling storageProjectVaultEventGet.');
            }
            // verify required parameter 'eventId' is not null or undefined
            if (eventId === null || eventId === undefined) {
                throw new RequiredError('eventId','Required parameter eventId was null or undefined when calling storageProjectVaultEventGet.');
            }
            const localVarPath = `/storage/{locationId}/project/{projectId}/vault/{vaultId}/event/{eventId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"vaultId"}}`, encodeURIComponent(String(vaultId)))
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List storage/vault.event
         * @summary List storage/vault.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultEventList: async (projectId: string, locationId: string, vaultId: string, $limit?: number, $skip?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling storageProjectVaultEventList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling storageProjectVaultEventList.');
            }
            // verify required parameter 'vaultId' is not null or undefined
            if (vaultId === null || vaultId === undefined) {
                throw new RequiredError('vaultId','Required parameter vaultId was null or undefined when calling storageProjectVaultEventList.');
            }
            const localVarPath = `/storage/{locationId}/project/{projectId}/vault/{vaultId}/event`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"vaultId"}}`, encodeURIComponent(String(vaultId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if ($limit !== undefined) {
                localVarQueryParameter['$limit'] = $limit;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single vault
         * @summary Get storage/vault
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultGet: async (projectId: string, locationId: string, vaultId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling storageProjectVaultGet.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling storageProjectVaultGet.');
            }
            // verify required parameter 'vaultId' is not null or undefined
            if (vaultId === null || vaultId === undefined) {
                throw new RequiredError('vaultId','Required parameter vaultId was null or undefined when calling storageProjectVaultGet.');
            }
            const localVarPath = `/storage/{locationId}/project/{projectId}/vault/{vaultId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"vaultId"}}`, encodeURIComponent(String(vaultId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List vault
         * @summary List storage/vault
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [name] Filter by name
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultList: async (projectId: string, locationId: string, name?: string, tagValue?: string, tagKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling storageProjectVaultList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling storageProjectVaultList.');
            }
            const localVarPath = `/storage/{locationId}/project/{projectId}/vault`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (tagValue !== undefined) {
                localVarQueryParameter['tag.value'] = tagValue;
            }

            if (tagKey !== undefined) {
                localVarQueryParameter['tag.key'] = tagKey;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * action resize
         * @summary Resize storage/vault
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {StorageProjectVaultResize} storageProjectVaultResize 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultResize: async (projectId: string, locationId: string, vaultId: string, storageProjectVaultResize: StorageProjectVaultResize, xIdempotencyKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling storageProjectVaultResize.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling storageProjectVaultResize.');
            }
            // verify required parameter 'vaultId' is not null or undefined
            if (vaultId === null || vaultId === undefined) {
                throw new RequiredError('vaultId','Required parameter vaultId was null or undefined when calling storageProjectVaultResize.');
            }
            // verify required parameter 'storageProjectVaultResize' is not null or undefined
            if (storageProjectVaultResize === null || storageProjectVaultResize === undefined) {
                throw new RequiredError('storageProjectVaultResize','Required parameter storageProjectVaultResize was null or undefined when calling storageProjectVaultResize.');
            }
            const localVarPath = `/storage/{locationId}/project/{projectId}/vault/{vaultId}/actions/resize`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"vaultId"}}`, encodeURIComponent(String(vaultId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof storageProjectVaultResize !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(storageProjectVaultResize !== undefined ? storageProjectVaultResize : {}) : (storageProjectVaultResize || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get storage/vault.service
         * @summary Get storage/vault.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultServiceGet: async (projectId: string, locationId: string, vaultId: string, serviceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling storageProjectVaultServiceGet.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling storageProjectVaultServiceGet.');
            }
            // verify required parameter 'vaultId' is not null or undefined
            if (vaultId === null || vaultId === undefined) {
                throw new RequiredError('vaultId','Required parameter vaultId was null or undefined when calling storageProjectVaultServiceGet.');
            }
            // verify required parameter 'serviceId' is not null or undefined
            if (serviceId === null || serviceId === undefined) {
                throw new RequiredError('serviceId','Required parameter serviceId was null or undefined when calling storageProjectVaultServiceGet.');
            }
            const localVarPath = `/storage/{locationId}/project/{projectId}/vault/{vaultId}/service/{serviceId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"vaultId"}}`, encodeURIComponent(String(vaultId)))
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List storage/vault.service
         * @summary List storage/vault.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultServiceList: async (projectId: string, locationId: string, vaultId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling storageProjectVaultServiceList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling storageProjectVaultServiceList.');
            }
            // verify required parameter 'vaultId' is not null or undefined
            if (vaultId === null || vaultId === undefined) {
                throw new RequiredError('vaultId','Required parameter vaultId was null or undefined when calling storageProjectVaultServiceList.');
            }
            const localVarPath = `/storage/{locationId}/project/{projectId}/vault/{vaultId}/service`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"vaultId"}}`, encodeURIComponent(String(vaultId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create storage/vault.snapshot
         * @summary Create storage/vault.snapshot
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {StorageProjectVaultSnapshotCreate} storageProjectVaultSnapshotCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultSnapshotCreate: async (projectId: string, locationId: string, vaultId: string, storageProjectVaultSnapshotCreate: StorageProjectVaultSnapshotCreate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling storageProjectVaultSnapshotCreate.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling storageProjectVaultSnapshotCreate.');
            }
            // verify required parameter 'vaultId' is not null or undefined
            if (vaultId === null || vaultId === undefined) {
                throw new RequiredError('vaultId','Required parameter vaultId was null or undefined when calling storageProjectVaultSnapshotCreate.');
            }
            // verify required parameter 'storageProjectVaultSnapshotCreate' is not null or undefined
            if (storageProjectVaultSnapshotCreate === null || storageProjectVaultSnapshotCreate === undefined) {
                throw new RequiredError('storageProjectVaultSnapshotCreate','Required parameter storageProjectVaultSnapshotCreate was null or undefined when calling storageProjectVaultSnapshotCreate.');
            }
            const localVarPath = `/storage/{locationId}/project/{projectId}/vault/{vaultId}/snapshot`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"vaultId"}}`, encodeURIComponent(String(vaultId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof storageProjectVaultSnapshotCreate !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(storageProjectVaultSnapshotCreate !== undefined ? storageProjectVaultSnapshotCreate : {}) : (storageProjectVaultSnapshotCreate || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete storage/vault.snapshot
         * @summary Delete storage/vault.snapshot
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {string} snapshotId snapshotId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultSnapshotDelete: async (projectId: string, locationId: string, vaultId: string, snapshotId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling storageProjectVaultSnapshotDelete.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling storageProjectVaultSnapshotDelete.');
            }
            // verify required parameter 'vaultId' is not null or undefined
            if (vaultId === null || vaultId === undefined) {
                throw new RequiredError('vaultId','Required parameter vaultId was null or undefined when calling storageProjectVaultSnapshotDelete.');
            }
            // verify required parameter 'snapshotId' is not null or undefined
            if (snapshotId === null || snapshotId === undefined) {
                throw new RequiredError('snapshotId','Required parameter snapshotId was null or undefined when calling storageProjectVaultSnapshotDelete.');
            }
            const localVarPath = `/storage/{locationId}/project/{projectId}/vault/{vaultId}/snapshot/{snapshotId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"vaultId"}}`, encodeURIComponent(String(vaultId)))
                .replace(`{${"snapshotId"}}`, encodeURIComponent(String(snapshotId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get storage/vault.snapshot
         * @summary Get storage/vault.snapshot
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {string} snapshotId snapshotId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultSnapshotGet: async (projectId: string, locationId: string, vaultId: string, snapshotId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling storageProjectVaultSnapshotGet.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling storageProjectVaultSnapshotGet.');
            }
            // verify required parameter 'vaultId' is not null or undefined
            if (vaultId === null || vaultId === undefined) {
                throw new RequiredError('vaultId','Required parameter vaultId was null or undefined when calling storageProjectVaultSnapshotGet.');
            }
            // verify required parameter 'snapshotId' is not null or undefined
            if (snapshotId === null || snapshotId === undefined) {
                throw new RequiredError('snapshotId','Required parameter snapshotId was null or undefined when calling storageProjectVaultSnapshotGet.');
            }
            const localVarPath = `/storage/{locationId}/project/{projectId}/vault/{vaultId}/snapshot/{snapshotId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"vaultId"}}`, encodeURIComponent(String(vaultId)))
                .replace(`{${"snapshotId"}}`, encodeURIComponent(String(snapshotId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List storage/vault.snapshot
         * @summary List storage/vault.snapshot
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultSnapshotList: async (projectId: string, locationId: string, vaultId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling storageProjectVaultSnapshotList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling storageProjectVaultSnapshotList.');
            }
            // verify required parameter 'vaultId' is not null or undefined
            if (vaultId === null || vaultId === undefined) {
                throw new RequiredError('vaultId','Required parameter vaultId was null or undefined when calling storageProjectVaultSnapshotList.');
            }
            const localVarPath = `/storage/{locationId}/project/{projectId}/vault/{vaultId}/snapshot`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"vaultId"}}`, encodeURIComponent(String(vaultId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * action start
         * @summary Start storage/vault
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultStart: async (projectId: string, locationId: string, vaultId: string, xIdempotencyKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling storageProjectVaultStart.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling storageProjectVaultStart.');
            }
            // verify required parameter 'vaultId' is not null or undefined
            if (vaultId === null || vaultId === undefined) {
                throw new RequiredError('vaultId','Required parameter vaultId was null or undefined when calling storageProjectVaultStart.');
            }
            const localVarPath = `/storage/{locationId}/project/{projectId}/vault/{vaultId}/actions/start`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"vaultId"}}`, encodeURIComponent(String(vaultId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * action stop
         * @summary Stop storage/vault
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultStop: async (projectId: string, locationId: string, vaultId: string, xIdempotencyKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling storageProjectVaultStop.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling storageProjectVaultStop.');
            }
            // verify required parameter 'vaultId' is not null or undefined
            if (vaultId === null || vaultId === undefined) {
                throw new RequiredError('vaultId','Required parameter vaultId was null or undefined when calling storageProjectVaultStop.');
            }
            const localVarPath = `/storage/{locationId}/project/{projectId}/vault/{vaultId}/actions/stop`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"vaultId"}}`, encodeURIComponent(String(vaultId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create storage/vault.tag
         * @summary Create storage/vault.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultTagCreate: async (projectId: string, locationId: string, vaultId: string, tag: Tag, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling storageProjectVaultTagCreate.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling storageProjectVaultTagCreate.');
            }
            // verify required parameter 'vaultId' is not null or undefined
            if (vaultId === null || vaultId === undefined) {
                throw new RequiredError('vaultId','Required parameter vaultId was null or undefined when calling storageProjectVaultTagCreate.');
            }
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling storageProjectVaultTagCreate.');
            }
            const localVarPath = `/storage/{locationId}/project/{projectId}/vault/{vaultId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"vaultId"}}`, encodeURIComponent(String(vaultId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof tag !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(tag !== undefined ? tag : {}) : (tag || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete storage/vault.tag
         * @summary Delete storage/vault.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultTagDelete: async (projectId: string, locationId: string, vaultId: string, tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling storageProjectVaultTagDelete.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling storageProjectVaultTagDelete.');
            }
            // verify required parameter 'vaultId' is not null or undefined
            if (vaultId === null || vaultId === undefined) {
                throw new RequiredError('vaultId','Required parameter vaultId was null or undefined when calling storageProjectVaultTagDelete.');
            }
            // verify required parameter 'tagId' is not null or undefined
            if (tagId === null || tagId === undefined) {
                throw new RequiredError('tagId','Required parameter tagId was null or undefined when calling storageProjectVaultTagDelete.');
            }
            const localVarPath = `/storage/{locationId}/project/{projectId}/vault/{vaultId}/tag/{tagId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"vaultId"}}`, encodeURIComponent(String(vaultId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get storage/vault.tag
         * @summary Get storage/vault.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultTagGet: async (projectId: string, locationId: string, vaultId: string, tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling storageProjectVaultTagGet.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling storageProjectVaultTagGet.');
            }
            // verify required parameter 'vaultId' is not null or undefined
            if (vaultId === null || vaultId === undefined) {
                throw new RequiredError('vaultId','Required parameter vaultId was null or undefined when calling storageProjectVaultTagGet.');
            }
            // verify required parameter 'tagId' is not null or undefined
            if (tagId === null || tagId === undefined) {
                throw new RequiredError('tagId','Required parameter tagId was null or undefined when calling storageProjectVaultTagGet.');
            }
            const localVarPath = `/storage/{locationId}/project/{projectId}/vault/{vaultId}/tag/{tagId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"vaultId"}}`, encodeURIComponent(String(vaultId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List storage/vault.tag
         * @summary List storage/vault.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultTagList: async (projectId: string, locationId: string, vaultId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling storageProjectVaultTagList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling storageProjectVaultTagList.');
            }
            // verify required parameter 'vaultId' is not null or undefined
            if (vaultId === null || vaultId === undefined) {
                throw new RequiredError('vaultId','Required parameter vaultId was null or undefined when calling storageProjectVaultTagList.');
            }
            const localVarPath = `/storage/{locationId}/project/{projectId}/vault/{vaultId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"vaultId"}}`, encodeURIComponent(String(vaultId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replace storage/vault.tag
         * @summary Replace storage/vault.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultTagPut: async (projectId: string, locationId: string, vaultId: string, tag: Array<Tag>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling storageProjectVaultTagPut.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling storageProjectVaultTagPut.');
            }
            // verify required parameter 'vaultId' is not null or undefined
            if (vaultId === null || vaultId === undefined) {
                throw new RequiredError('vaultId','Required parameter vaultId was null or undefined when calling storageProjectVaultTagPut.');
            }
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling storageProjectVaultTagPut.');
            }
            const localVarPath = `/storage/{locationId}/project/{projectId}/vault/{vaultId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"vaultId"}}`, encodeURIComponent(String(vaultId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof tag !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(tag !== undefined ? tag : {}) : (tag || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns modified vault
         * @summary Update storage/vault
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {StorageProjectVaultUpdate} storageProjectVaultUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultUpdate: async (projectId: string, locationId: string, vaultId: string, storageProjectVaultUpdate: StorageProjectVaultUpdate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling storageProjectVaultUpdate.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling storageProjectVaultUpdate.');
            }
            // verify required parameter 'vaultId' is not null or undefined
            if (vaultId === null || vaultId === undefined) {
                throw new RequiredError('vaultId','Required parameter vaultId was null or undefined when calling storageProjectVaultUpdate.');
            }
            // verify required parameter 'storageProjectVaultUpdate' is not null or undefined
            if (storageProjectVaultUpdate === null || storageProjectVaultUpdate === undefined) {
                throw new RequiredError('storageProjectVaultUpdate','Required parameter storageProjectVaultUpdate was null or undefined when calling storageProjectVaultUpdate.');
            }
            const localVarPath = `/storage/{locationId}/project/{projectId}/vault/{vaultId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"vaultId"}}`, encodeURIComponent(String(vaultId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof storageProjectVaultUpdate !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(storageProjectVaultUpdate !== undefined ? storageProjectVaultUpdate : {}) : (storageProjectVaultUpdate || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StorageProjectVaultApi - functional programming interface
 * @export
 */
export const StorageProjectVaultApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get storage/vault.connect
         * @summary Get storage/vault.connect
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {string} connectId connectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectVaultConnectGet(projectId: string, locationId: string, vaultId: string, connectId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceConnect>> {
            const localVarAxiosArgs = await StorageProjectVaultApiAxiosParamCreator(configuration).storageProjectVaultConnectGet(projectId, locationId, vaultId, connectId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List storage/vault.connect
         * @summary List storage/vault.connect
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectVaultConnectList(projectId: string, locationId: string, vaultId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResourceConnect>>> {
            const localVarAxiosArgs = await StorageProjectVaultApiAxiosParamCreator(configuration).storageProjectVaultConnectList(projectId, locationId, vaultId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create vault
         * @summary Create storage/vault
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {StorageProjectVaultCreate} storageProjectVaultCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectVaultCreate(projectId: string, locationId: string, storageProjectVaultCreate: StorageProjectVaultCreate, xIdempotencyKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Vault>> {
            const localVarAxiosArgs = await StorageProjectVaultApiAxiosParamCreator(configuration).storageProjectVaultCreate(projectId, locationId, storageProjectVaultCreate, xIdempotencyKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create storage/vault.credential
         * @summary Create storage/vault.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {VaultCredential} vaultCredential 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectVaultCredentialCreate(projectId: string, locationId: string, vaultId: string, vaultCredential: VaultCredential, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VaultCredential>> {
            const localVarAxiosArgs = await StorageProjectVaultApiAxiosParamCreator(configuration).storageProjectVaultCredentialCreate(projectId, locationId, vaultId, vaultCredential, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete storage/vault.credential
         * @summary Delete storage/vault.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {string} credentialId credentialId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectVaultCredentialDelete(projectId: string, locationId: string, vaultId: string, credentialId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Vault>> {
            const localVarAxiosArgs = await StorageProjectVaultApiAxiosParamCreator(configuration).storageProjectVaultCredentialDelete(projectId, locationId, vaultId, credentialId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get storage/vault.credential
         * @summary Get storage/vault.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {string} credentialId credentialId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectVaultCredentialGet(projectId: string, locationId: string, vaultId: string, credentialId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VaultCredential>> {
            const localVarAxiosArgs = await StorageProjectVaultApiAxiosParamCreator(configuration).storageProjectVaultCredentialGet(projectId, locationId, vaultId, credentialId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List storage/vault.credential
         * @summary List storage/vault.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectVaultCredentialList(projectId: string, locationId: string, vaultId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<VaultCredential>>> {
            const localVarAxiosArgs = await StorageProjectVaultApiAxiosParamCreator(configuration).storageProjectVaultCredentialList(projectId, locationId, vaultId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update storage/vault.credential
         * @summary Update storage/vault.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {string} credentialId credentialId
         * @param {StorageProjectVaultCredentialPatch} storageProjectVaultCredentialPatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectVaultCredentialPatch(projectId: string, locationId: string, vaultId: string, credentialId: string, storageProjectVaultCredentialPatch: StorageProjectVaultCredentialPatch, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VaultCredential>> {
            const localVarAxiosArgs = await StorageProjectVaultApiAxiosParamCreator(configuration).storageProjectVaultCredentialPatch(projectId, locationId, vaultId, credentialId, storageProjectVaultCredentialPatch, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete vault
         * @summary Delete storage/vault
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {StorageProjectVaultDelete} storageProjectVaultDelete 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectVaultDelete(projectId: string, locationId: string, vaultId: string, storageProjectVaultDelete: StorageProjectVaultDelete, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await StorageProjectVaultApiAxiosParamCreator(configuration).storageProjectVaultDelete(projectId, locationId, vaultId, storageProjectVaultDelete, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get storage/vault.event
         * @summary Get storage/vault.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectVaultEventGet(projectId: string, locationId: string, vaultId: string, eventId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>> {
            const localVarAxiosArgs = await StorageProjectVaultApiAxiosParamCreator(configuration).storageProjectVaultEventGet(projectId, locationId, vaultId, eventId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List storage/vault.event
         * @summary List storage/vault.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectVaultEventList(projectId: string, locationId: string, vaultId: string, $limit?: number, $skip?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Event>>> {
            const localVarAxiosArgs = await StorageProjectVaultApiAxiosParamCreator(configuration).storageProjectVaultEventList(projectId, locationId, vaultId, $limit, $skip, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a single vault
         * @summary Get storage/vault
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectVaultGet(projectId: string, locationId: string, vaultId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Vault>> {
            const localVarAxiosArgs = await StorageProjectVaultApiAxiosParamCreator(configuration).storageProjectVaultGet(projectId, locationId, vaultId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List vault
         * @summary List storage/vault
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [name] Filter by name
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectVaultList(projectId: string, locationId: string, name?: string, tagValue?: string, tagKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Vault>>> {
            const localVarAxiosArgs = await StorageProjectVaultApiAxiosParamCreator(configuration).storageProjectVaultList(projectId, locationId, name, tagValue, tagKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * action resize
         * @summary Resize storage/vault
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {StorageProjectVaultResize} storageProjectVaultResize 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectVaultResize(projectId: string, locationId: string, vaultId: string, storageProjectVaultResize: StorageProjectVaultResize, xIdempotencyKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Vault>> {
            const localVarAxiosArgs = await StorageProjectVaultApiAxiosParamCreator(configuration).storageProjectVaultResize(projectId, locationId, vaultId, storageProjectVaultResize, xIdempotencyKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get storage/vault.service
         * @summary Get storage/vault.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectVaultServiceGet(projectId: string, locationId: string, vaultId: string, serviceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceService>> {
            const localVarAxiosArgs = await StorageProjectVaultApiAxiosParamCreator(configuration).storageProjectVaultServiceGet(projectId, locationId, vaultId, serviceId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List storage/vault.service
         * @summary List storage/vault.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectVaultServiceList(projectId: string, locationId: string, vaultId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResourceService>>> {
            const localVarAxiosArgs = await StorageProjectVaultApiAxiosParamCreator(configuration).storageProjectVaultServiceList(projectId, locationId, vaultId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create storage/vault.snapshot
         * @summary Create storage/vault.snapshot
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {StorageProjectVaultSnapshotCreate} storageProjectVaultSnapshotCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectVaultSnapshotCreate(projectId: string, locationId: string, vaultId: string, storageProjectVaultSnapshotCreate: StorageProjectVaultSnapshotCreate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StorageSnapshot>> {
            const localVarAxiosArgs = await StorageProjectVaultApiAxiosParamCreator(configuration).storageProjectVaultSnapshotCreate(projectId, locationId, vaultId, storageProjectVaultSnapshotCreate, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete storage/vault.snapshot
         * @summary Delete storage/vault.snapshot
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {string} snapshotId snapshotId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectVaultSnapshotDelete(projectId: string, locationId: string, vaultId: string, snapshotId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StorageSnapshot>> {
            const localVarAxiosArgs = await StorageProjectVaultApiAxiosParamCreator(configuration).storageProjectVaultSnapshotDelete(projectId, locationId, vaultId, snapshotId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get storage/vault.snapshot
         * @summary Get storage/vault.snapshot
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {string} snapshotId snapshotId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectVaultSnapshotGet(projectId: string, locationId: string, vaultId: string, snapshotId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StorageSnapshot>> {
            const localVarAxiosArgs = await StorageProjectVaultApiAxiosParamCreator(configuration).storageProjectVaultSnapshotGet(projectId, locationId, vaultId, snapshotId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List storage/vault.snapshot
         * @summary List storage/vault.snapshot
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectVaultSnapshotList(projectId: string, locationId: string, vaultId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<StorageSnapshot>>> {
            const localVarAxiosArgs = await StorageProjectVaultApiAxiosParamCreator(configuration).storageProjectVaultSnapshotList(projectId, locationId, vaultId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * action start
         * @summary Start storage/vault
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectVaultStart(projectId: string, locationId: string, vaultId: string, xIdempotencyKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Vault>> {
            const localVarAxiosArgs = await StorageProjectVaultApiAxiosParamCreator(configuration).storageProjectVaultStart(projectId, locationId, vaultId, xIdempotencyKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * action stop
         * @summary Stop storage/vault
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectVaultStop(projectId: string, locationId: string, vaultId: string, xIdempotencyKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Vault>> {
            const localVarAxiosArgs = await StorageProjectVaultApiAxiosParamCreator(configuration).storageProjectVaultStop(projectId, locationId, vaultId, xIdempotencyKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create storage/vault.tag
         * @summary Create storage/vault.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectVaultTagCreate(projectId: string, locationId: string, vaultId: string, tag: Tag, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await StorageProjectVaultApiAxiosParamCreator(configuration).storageProjectVaultTagCreate(projectId, locationId, vaultId, tag, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete storage/vault.tag
         * @summary Delete storage/vault.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectVaultTagDelete(projectId: string, locationId: string, vaultId: string, tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await StorageProjectVaultApiAxiosParamCreator(configuration).storageProjectVaultTagDelete(projectId, locationId, vaultId, tagId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get storage/vault.tag
         * @summary Get storage/vault.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectVaultTagGet(projectId: string, locationId: string, vaultId: string, tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await StorageProjectVaultApiAxiosParamCreator(configuration).storageProjectVaultTagGet(projectId, locationId, vaultId, tagId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List storage/vault.tag
         * @summary List storage/vault.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectVaultTagList(projectId: string, locationId: string, vaultId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await StorageProjectVaultApiAxiosParamCreator(configuration).storageProjectVaultTagList(projectId, locationId, vaultId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Replace storage/vault.tag
         * @summary Replace storage/vault.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectVaultTagPut(projectId: string, locationId: string, vaultId: string, tag: Array<Tag>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await StorageProjectVaultApiAxiosParamCreator(configuration).storageProjectVaultTagPut(projectId, locationId, vaultId, tag, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns modified vault
         * @summary Update storage/vault
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {StorageProjectVaultUpdate} storageProjectVaultUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectVaultUpdate(projectId: string, locationId: string, vaultId: string, storageProjectVaultUpdate: StorageProjectVaultUpdate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Vault>> {
            const localVarAxiosArgs = await StorageProjectVaultApiAxiosParamCreator(configuration).storageProjectVaultUpdate(projectId, locationId, vaultId, storageProjectVaultUpdate, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * StorageProjectVaultApi - factory interface
 * @export
 */
export const StorageProjectVaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Get storage/vault.connect
         * @summary Get storage/vault.connect
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {string} connectId connectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultConnectGet(projectId: string, locationId: string, vaultId: string, connectId: string, options?: any): AxiosPromise<ResourceConnect> {
            return StorageProjectVaultApiFp(configuration).storageProjectVaultConnectGet(projectId, locationId, vaultId, connectId, options).then((request) => request(axios, basePath));
        },
        /**
         * List storage/vault.connect
         * @summary List storage/vault.connect
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultConnectList(projectId: string, locationId: string, vaultId: string, options?: any): AxiosPromise<Array<ResourceConnect>> {
            return StorageProjectVaultApiFp(configuration).storageProjectVaultConnectList(projectId, locationId, vaultId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create vault
         * @summary Create storage/vault
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {StorageProjectVaultCreate} storageProjectVaultCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultCreate(projectId: string, locationId: string, storageProjectVaultCreate: StorageProjectVaultCreate, xIdempotencyKey?: string, options?: any): AxiosPromise<Vault> {
            return StorageProjectVaultApiFp(configuration).storageProjectVaultCreate(projectId, locationId, storageProjectVaultCreate, xIdempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Create storage/vault.credential
         * @summary Create storage/vault.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {VaultCredential} vaultCredential 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultCredentialCreate(projectId: string, locationId: string, vaultId: string, vaultCredential: VaultCredential, options?: any): AxiosPromise<VaultCredential> {
            return StorageProjectVaultApiFp(configuration).storageProjectVaultCredentialCreate(projectId, locationId, vaultId, vaultCredential, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete storage/vault.credential
         * @summary Delete storage/vault.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {string} credentialId credentialId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultCredentialDelete(projectId: string, locationId: string, vaultId: string, credentialId: string, options?: any): AxiosPromise<Vault> {
            return StorageProjectVaultApiFp(configuration).storageProjectVaultCredentialDelete(projectId, locationId, vaultId, credentialId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get storage/vault.credential
         * @summary Get storage/vault.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {string} credentialId credentialId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultCredentialGet(projectId: string, locationId: string, vaultId: string, credentialId: string, options?: any): AxiosPromise<VaultCredential> {
            return StorageProjectVaultApiFp(configuration).storageProjectVaultCredentialGet(projectId, locationId, vaultId, credentialId, options).then((request) => request(axios, basePath));
        },
        /**
         * List storage/vault.credential
         * @summary List storage/vault.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultCredentialList(projectId: string, locationId: string, vaultId: string, options?: any): AxiosPromise<Array<VaultCredential>> {
            return StorageProjectVaultApiFp(configuration).storageProjectVaultCredentialList(projectId, locationId, vaultId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update storage/vault.credential
         * @summary Update storage/vault.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {string} credentialId credentialId
         * @param {StorageProjectVaultCredentialPatch} storageProjectVaultCredentialPatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultCredentialPatch(projectId: string, locationId: string, vaultId: string, credentialId: string, storageProjectVaultCredentialPatch: StorageProjectVaultCredentialPatch, options?: any): AxiosPromise<VaultCredential> {
            return StorageProjectVaultApiFp(configuration).storageProjectVaultCredentialPatch(projectId, locationId, vaultId, credentialId, storageProjectVaultCredentialPatch, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete vault
         * @summary Delete storage/vault
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {StorageProjectVaultDelete} storageProjectVaultDelete 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultDelete(projectId: string, locationId: string, vaultId: string, storageProjectVaultDelete: StorageProjectVaultDelete, options?: any): AxiosPromise<void> {
            return StorageProjectVaultApiFp(configuration).storageProjectVaultDelete(projectId, locationId, vaultId, storageProjectVaultDelete, options).then((request) => request(axios, basePath));
        },
        /**
         * Get storage/vault.event
         * @summary Get storage/vault.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultEventGet(projectId: string, locationId: string, vaultId: string, eventId: string, options?: any): AxiosPromise<Event> {
            return StorageProjectVaultApiFp(configuration).storageProjectVaultEventGet(projectId, locationId, vaultId, eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * List storage/vault.event
         * @summary List storage/vault.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultEventList(projectId: string, locationId: string, vaultId: string, $limit?: number, $skip?: number, options?: any): AxiosPromise<Array<Event>> {
            return StorageProjectVaultApiFp(configuration).storageProjectVaultEventList(projectId, locationId, vaultId, $limit, $skip, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single vault
         * @summary Get storage/vault
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultGet(projectId: string, locationId: string, vaultId: string, options?: any): AxiosPromise<Vault> {
            return StorageProjectVaultApiFp(configuration).storageProjectVaultGet(projectId, locationId, vaultId, options).then((request) => request(axios, basePath));
        },
        /**
         * List vault
         * @summary List storage/vault
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [name] Filter by name
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultList(projectId: string, locationId: string, name?: string, tagValue?: string, tagKey?: string, options?: any): AxiosPromise<Array<Vault>> {
            return StorageProjectVaultApiFp(configuration).storageProjectVaultList(projectId, locationId, name, tagValue, tagKey, options).then((request) => request(axios, basePath));
        },
        /**
         * action resize
         * @summary Resize storage/vault
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {StorageProjectVaultResize} storageProjectVaultResize 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultResize(projectId: string, locationId: string, vaultId: string, storageProjectVaultResize: StorageProjectVaultResize, xIdempotencyKey?: string, options?: any): AxiosPromise<Vault> {
            return StorageProjectVaultApiFp(configuration).storageProjectVaultResize(projectId, locationId, vaultId, storageProjectVaultResize, xIdempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get storage/vault.service
         * @summary Get storage/vault.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultServiceGet(projectId: string, locationId: string, vaultId: string, serviceId: string, options?: any): AxiosPromise<ResourceService> {
            return StorageProjectVaultApiFp(configuration).storageProjectVaultServiceGet(projectId, locationId, vaultId, serviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * List storage/vault.service
         * @summary List storage/vault.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultServiceList(projectId: string, locationId: string, vaultId: string, options?: any): AxiosPromise<Array<ResourceService>> {
            return StorageProjectVaultApiFp(configuration).storageProjectVaultServiceList(projectId, locationId, vaultId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create storage/vault.snapshot
         * @summary Create storage/vault.snapshot
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {StorageProjectVaultSnapshotCreate} storageProjectVaultSnapshotCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultSnapshotCreate(projectId: string, locationId: string, vaultId: string, storageProjectVaultSnapshotCreate: StorageProjectVaultSnapshotCreate, options?: any): AxiosPromise<StorageSnapshot> {
            return StorageProjectVaultApiFp(configuration).storageProjectVaultSnapshotCreate(projectId, locationId, vaultId, storageProjectVaultSnapshotCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete storage/vault.snapshot
         * @summary Delete storage/vault.snapshot
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {string} snapshotId snapshotId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultSnapshotDelete(projectId: string, locationId: string, vaultId: string, snapshotId: string, options?: any): AxiosPromise<StorageSnapshot> {
            return StorageProjectVaultApiFp(configuration).storageProjectVaultSnapshotDelete(projectId, locationId, vaultId, snapshotId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get storage/vault.snapshot
         * @summary Get storage/vault.snapshot
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {string} snapshotId snapshotId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultSnapshotGet(projectId: string, locationId: string, vaultId: string, snapshotId: string, options?: any): AxiosPromise<StorageSnapshot> {
            return StorageProjectVaultApiFp(configuration).storageProjectVaultSnapshotGet(projectId, locationId, vaultId, snapshotId, options).then((request) => request(axios, basePath));
        },
        /**
         * List storage/vault.snapshot
         * @summary List storage/vault.snapshot
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultSnapshotList(projectId: string, locationId: string, vaultId: string, options?: any): AxiosPromise<Array<StorageSnapshot>> {
            return StorageProjectVaultApiFp(configuration).storageProjectVaultSnapshotList(projectId, locationId, vaultId, options).then((request) => request(axios, basePath));
        },
        /**
         * action start
         * @summary Start storage/vault
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultStart(projectId: string, locationId: string, vaultId: string, xIdempotencyKey?: string, options?: any): AxiosPromise<Vault> {
            return StorageProjectVaultApiFp(configuration).storageProjectVaultStart(projectId, locationId, vaultId, xIdempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * action stop
         * @summary Stop storage/vault
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultStop(projectId: string, locationId: string, vaultId: string, xIdempotencyKey?: string, options?: any): AxiosPromise<Vault> {
            return StorageProjectVaultApiFp(configuration).storageProjectVaultStop(projectId, locationId, vaultId, xIdempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Create storage/vault.tag
         * @summary Create storage/vault.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultTagCreate(projectId: string, locationId: string, vaultId: string, tag: Tag, options?: any): AxiosPromise<Tag> {
            return StorageProjectVaultApiFp(configuration).storageProjectVaultTagCreate(projectId, locationId, vaultId, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete storage/vault.tag
         * @summary Delete storage/vault.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultTagDelete(projectId: string, locationId: string, vaultId: string, tagId: string, options?: any): AxiosPromise<void> {
            return StorageProjectVaultApiFp(configuration).storageProjectVaultTagDelete(projectId, locationId, vaultId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get storage/vault.tag
         * @summary Get storage/vault.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultTagGet(projectId: string, locationId: string, vaultId: string, tagId: string, options?: any): AxiosPromise<Tag> {
            return StorageProjectVaultApiFp(configuration).storageProjectVaultTagGet(projectId, locationId, vaultId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * List storage/vault.tag
         * @summary List storage/vault.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultTagList(projectId: string, locationId: string, vaultId: string, options?: any): AxiosPromise<Array<Tag>> {
            return StorageProjectVaultApiFp(configuration).storageProjectVaultTagList(projectId, locationId, vaultId, options).then((request) => request(axios, basePath));
        },
        /**
         * Replace storage/vault.tag
         * @summary Replace storage/vault.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultTagPut(projectId: string, locationId: string, vaultId: string, tag: Array<Tag>, options?: any): AxiosPromise<Array<Tag>> {
            return StorageProjectVaultApiFp(configuration).storageProjectVaultTagPut(projectId, locationId, vaultId, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns modified vault
         * @summary Update storage/vault
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {StorageProjectVaultUpdate} storageProjectVaultUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultUpdate(projectId: string, locationId: string, vaultId: string, storageProjectVaultUpdate: StorageProjectVaultUpdate, options?: any): AxiosPromise<Vault> {
            return StorageProjectVaultApiFp(configuration).storageProjectVaultUpdate(projectId, locationId, vaultId, storageProjectVaultUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StorageProjectVaultApi - object-oriented interface
 * @export
 * @class StorageProjectVaultApi
 * @extends {BaseAPI}
 */
export class StorageProjectVaultApi extends BaseAPI {
    /**
     * Get storage/vault.connect
     * @summary Get storage/vault.connect
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} vaultId Vault Id
     * @param {string} connectId connectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectVaultApi
     */
    public storageProjectVaultConnectGet(projectId: string, locationId: string, vaultId: string, connectId: string, options?: any) {
        return StorageProjectVaultApiFp(this.configuration).storageProjectVaultConnectGet(projectId, locationId, vaultId, connectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List storage/vault.connect
     * @summary List storage/vault.connect
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} vaultId Vault Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectVaultApi
     */
    public storageProjectVaultConnectList(projectId: string, locationId: string, vaultId: string, options?: any) {
        return StorageProjectVaultApiFp(this.configuration).storageProjectVaultConnectList(projectId, locationId, vaultId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create vault
     * @summary Create storage/vault
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {StorageProjectVaultCreate} storageProjectVaultCreate 
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectVaultApi
     */
    public storageProjectVaultCreate(projectId: string, locationId: string, storageProjectVaultCreate: StorageProjectVaultCreate, xIdempotencyKey?: string, options?: any) {
        return StorageProjectVaultApiFp(this.configuration).storageProjectVaultCreate(projectId, locationId, storageProjectVaultCreate, xIdempotencyKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create storage/vault.credential
     * @summary Create storage/vault.credential
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} vaultId Vault Id
     * @param {VaultCredential} vaultCredential 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectVaultApi
     */
    public storageProjectVaultCredentialCreate(projectId: string, locationId: string, vaultId: string, vaultCredential: VaultCredential, options?: any) {
        return StorageProjectVaultApiFp(this.configuration).storageProjectVaultCredentialCreate(projectId, locationId, vaultId, vaultCredential, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete storage/vault.credential
     * @summary Delete storage/vault.credential
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} vaultId Vault Id
     * @param {string} credentialId credentialId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectVaultApi
     */
    public storageProjectVaultCredentialDelete(projectId: string, locationId: string, vaultId: string, credentialId: string, options?: any) {
        return StorageProjectVaultApiFp(this.configuration).storageProjectVaultCredentialDelete(projectId, locationId, vaultId, credentialId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get storage/vault.credential
     * @summary Get storage/vault.credential
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} vaultId Vault Id
     * @param {string} credentialId credentialId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectVaultApi
     */
    public storageProjectVaultCredentialGet(projectId: string, locationId: string, vaultId: string, credentialId: string, options?: any) {
        return StorageProjectVaultApiFp(this.configuration).storageProjectVaultCredentialGet(projectId, locationId, vaultId, credentialId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List storage/vault.credential
     * @summary List storage/vault.credential
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} vaultId Vault Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectVaultApi
     */
    public storageProjectVaultCredentialList(projectId: string, locationId: string, vaultId: string, options?: any) {
        return StorageProjectVaultApiFp(this.configuration).storageProjectVaultCredentialList(projectId, locationId, vaultId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update storage/vault.credential
     * @summary Update storage/vault.credential
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} vaultId Vault Id
     * @param {string} credentialId credentialId
     * @param {StorageProjectVaultCredentialPatch} storageProjectVaultCredentialPatch 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectVaultApi
     */
    public storageProjectVaultCredentialPatch(projectId: string, locationId: string, vaultId: string, credentialId: string, storageProjectVaultCredentialPatch: StorageProjectVaultCredentialPatch, options?: any) {
        return StorageProjectVaultApiFp(this.configuration).storageProjectVaultCredentialPatch(projectId, locationId, vaultId, credentialId, storageProjectVaultCredentialPatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete vault
     * @summary Delete storage/vault
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} vaultId Vault Id
     * @param {StorageProjectVaultDelete} storageProjectVaultDelete 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectVaultApi
     */
    public storageProjectVaultDelete(projectId: string, locationId: string, vaultId: string, storageProjectVaultDelete: StorageProjectVaultDelete, options?: any) {
        return StorageProjectVaultApiFp(this.configuration).storageProjectVaultDelete(projectId, locationId, vaultId, storageProjectVaultDelete, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get storage/vault.event
     * @summary Get storage/vault.event
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} vaultId Vault Id
     * @param {string} eventId eventId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectVaultApi
     */
    public storageProjectVaultEventGet(projectId: string, locationId: string, vaultId: string, eventId: string, options?: any) {
        return StorageProjectVaultApiFp(this.configuration).storageProjectVaultEventGet(projectId, locationId, vaultId, eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List storage/vault.event
     * @summary List storage/vault.event
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} vaultId Vault Id
     * @param {number} [$limit] $limit
     * @param {number} [$skip] $skip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectVaultApi
     */
    public storageProjectVaultEventList(projectId: string, locationId: string, vaultId: string, $limit?: number, $skip?: number, options?: any) {
        return StorageProjectVaultApiFp(this.configuration).storageProjectVaultEventList(projectId, locationId, vaultId, $limit, $skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single vault
     * @summary Get storage/vault
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} vaultId Vault Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectVaultApi
     */
    public storageProjectVaultGet(projectId: string, locationId: string, vaultId: string, options?: any) {
        return StorageProjectVaultApiFp(this.configuration).storageProjectVaultGet(projectId, locationId, vaultId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List vault
     * @summary List storage/vault
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} [name] Filter by name
     * @param {string} [tagValue] Filter by tag.value
     * @param {string} [tagKey] Filter by tag.key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectVaultApi
     */
    public storageProjectVaultList(projectId: string, locationId: string, name?: string, tagValue?: string, tagKey?: string, options?: any) {
        return StorageProjectVaultApiFp(this.configuration).storageProjectVaultList(projectId, locationId, name, tagValue, tagKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * action resize
     * @summary Resize storage/vault
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} vaultId Vault Id
     * @param {StorageProjectVaultResize} storageProjectVaultResize 
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectVaultApi
     */
    public storageProjectVaultResize(projectId: string, locationId: string, vaultId: string, storageProjectVaultResize: StorageProjectVaultResize, xIdempotencyKey?: string, options?: any) {
        return StorageProjectVaultApiFp(this.configuration).storageProjectVaultResize(projectId, locationId, vaultId, storageProjectVaultResize, xIdempotencyKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get storage/vault.service
     * @summary Get storage/vault.service
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} vaultId Vault Id
     * @param {string} serviceId serviceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectVaultApi
     */
    public storageProjectVaultServiceGet(projectId: string, locationId: string, vaultId: string, serviceId: string, options?: any) {
        return StorageProjectVaultApiFp(this.configuration).storageProjectVaultServiceGet(projectId, locationId, vaultId, serviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List storage/vault.service
     * @summary List storage/vault.service
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} vaultId Vault Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectVaultApi
     */
    public storageProjectVaultServiceList(projectId: string, locationId: string, vaultId: string, options?: any) {
        return StorageProjectVaultApiFp(this.configuration).storageProjectVaultServiceList(projectId, locationId, vaultId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create storage/vault.snapshot
     * @summary Create storage/vault.snapshot
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} vaultId Vault Id
     * @param {StorageProjectVaultSnapshotCreate} storageProjectVaultSnapshotCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectVaultApi
     */
    public storageProjectVaultSnapshotCreate(projectId: string, locationId: string, vaultId: string, storageProjectVaultSnapshotCreate: StorageProjectVaultSnapshotCreate, options?: any) {
        return StorageProjectVaultApiFp(this.configuration).storageProjectVaultSnapshotCreate(projectId, locationId, vaultId, storageProjectVaultSnapshotCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete storage/vault.snapshot
     * @summary Delete storage/vault.snapshot
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} vaultId Vault Id
     * @param {string} snapshotId snapshotId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectVaultApi
     */
    public storageProjectVaultSnapshotDelete(projectId: string, locationId: string, vaultId: string, snapshotId: string, options?: any) {
        return StorageProjectVaultApiFp(this.configuration).storageProjectVaultSnapshotDelete(projectId, locationId, vaultId, snapshotId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get storage/vault.snapshot
     * @summary Get storage/vault.snapshot
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} vaultId Vault Id
     * @param {string} snapshotId snapshotId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectVaultApi
     */
    public storageProjectVaultSnapshotGet(projectId: string, locationId: string, vaultId: string, snapshotId: string, options?: any) {
        return StorageProjectVaultApiFp(this.configuration).storageProjectVaultSnapshotGet(projectId, locationId, vaultId, snapshotId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List storage/vault.snapshot
     * @summary List storage/vault.snapshot
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} vaultId Vault Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectVaultApi
     */
    public storageProjectVaultSnapshotList(projectId: string, locationId: string, vaultId: string, options?: any) {
        return StorageProjectVaultApiFp(this.configuration).storageProjectVaultSnapshotList(projectId, locationId, vaultId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * action start
     * @summary Start storage/vault
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} vaultId Vault Id
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectVaultApi
     */
    public storageProjectVaultStart(projectId: string, locationId: string, vaultId: string, xIdempotencyKey?: string, options?: any) {
        return StorageProjectVaultApiFp(this.configuration).storageProjectVaultStart(projectId, locationId, vaultId, xIdempotencyKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * action stop
     * @summary Stop storage/vault
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} vaultId Vault Id
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectVaultApi
     */
    public storageProjectVaultStop(projectId: string, locationId: string, vaultId: string, xIdempotencyKey?: string, options?: any) {
        return StorageProjectVaultApiFp(this.configuration).storageProjectVaultStop(projectId, locationId, vaultId, xIdempotencyKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create storage/vault.tag
     * @summary Create storage/vault.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} vaultId Vault Id
     * @param {Tag} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectVaultApi
     */
    public storageProjectVaultTagCreate(projectId: string, locationId: string, vaultId: string, tag: Tag, options?: any) {
        return StorageProjectVaultApiFp(this.configuration).storageProjectVaultTagCreate(projectId, locationId, vaultId, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete storage/vault.tag
     * @summary Delete storage/vault.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} vaultId Vault Id
     * @param {string} tagId tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectVaultApi
     */
    public storageProjectVaultTagDelete(projectId: string, locationId: string, vaultId: string, tagId: string, options?: any) {
        return StorageProjectVaultApiFp(this.configuration).storageProjectVaultTagDelete(projectId, locationId, vaultId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get storage/vault.tag
     * @summary Get storage/vault.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} vaultId Vault Id
     * @param {string} tagId tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectVaultApi
     */
    public storageProjectVaultTagGet(projectId: string, locationId: string, vaultId: string, tagId: string, options?: any) {
        return StorageProjectVaultApiFp(this.configuration).storageProjectVaultTagGet(projectId, locationId, vaultId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List storage/vault.tag
     * @summary List storage/vault.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} vaultId Vault Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectVaultApi
     */
    public storageProjectVaultTagList(projectId: string, locationId: string, vaultId: string, options?: any) {
        return StorageProjectVaultApiFp(this.configuration).storageProjectVaultTagList(projectId, locationId, vaultId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replace storage/vault.tag
     * @summary Replace storage/vault.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} vaultId Vault Id
     * @param {Array<Tag>} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectVaultApi
     */
    public storageProjectVaultTagPut(projectId: string, locationId: string, vaultId: string, tag: Array<Tag>, options?: any) {
        return StorageProjectVaultApiFp(this.configuration).storageProjectVaultTagPut(projectId, locationId, vaultId, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns modified vault
     * @summary Update storage/vault
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} vaultId Vault Id
     * @param {StorageProjectVaultUpdate} storageProjectVaultUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectVaultApi
     */
    public storageProjectVaultUpdate(projectId: string, locationId: string, vaultId: string, storageProjectVaultUpdate: StorageProjectVaultUpdate, options?: any) {
        return StorageProjectVaultApiFp(this.configuration).storageProjectVaultUpdate(projectId, locationId, vaultId, storageProjectVaultUpdate, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * SupportProjectTicketApi - axios parameter creator
 * @export
 */
export const SupportProjectTicketApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * action close
         * @summary Close support/ticket
         * @param {string} projectId Project Id
         * @param {string} ticketId Ticket Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supportProjectTicketClose: async (projectId: string, ticketId: string, xIdempotencyKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling supportProjectTicketClose.');
            }
            // verify required parameter 'ticketId' is not null or undefined
            if (ticketId === null || ticketId === undefined) {
                throw new RequiredError('ticketId','Required parameter ticketId was null or undefined when calling supportProjectTicketClose.');
            }
            const localVarPath = `/support/project/{projectId}/ticket/{ticketId}/actions/close`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"ticketId"}}`, encodeURIComponent(String(ticketId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create ticket
         * @summary Create support/ticket
         * @param {string} projectId Project Id
         * @param {SupportProjectTicketCreate} supportProjectTicketCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supportProjectTicketCreate: async (projectId: string, supportProjectTicketCreate: SupportProjectTicketCreate, xIdempotencyKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling supportProjectTicketCreate.');
            }
            // verify required parameter 'supportProjectTicketCreate' is not null or undefined
            if (supportProjectTicketCreate === null || supportProjectTicketCreate === undefined) {
                throw new RequiredError('supportProjectTicketCreate','Required parameter supportProjectTicketCreate was null or undefined when calling supportProjectTicketCreate.');
            }
            const localVarPath = `/support/project/{projectId}/ticket`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof supportProjectTicketCreate !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(supportProjectTicketCreate !== undefined ? supportProjectTicketCreate : {}) : (supportProjectTicketCreate || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single ticket
         * @summary Get support/ticket
         * @param {string} projectId Project Id
         * @param {string} ticketId Ticket Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supportProjectTicketGet: async (projectId: string, ticketId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling supportProjectTicketGet.');
            }
            // verify required parameter 'ticketId' is not null or undefined
            if (ticketId === null || ticketId === undefined) {
                throw new RequiredError('ticketId','Required parameter ticketId was null or undefined when calling supportProjectTicketGet.');
            }
            const localVarPath = `/support/project/{projectId}/ticket/{ticketId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"ticketId"}}`, encodeURIComponent(String(ticketId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List ticket
         * @summary List support/ticket
         * @param {string} projectId Project Id
         * @param {string} [state] Filter by state
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supportProjectTicketList: async (projectId: string, state?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling supportProjectTicketList.');
            }
            const localVarPath = `/support/project/{projectId}/ticket`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create support/ticket.message
         * @summary Create support/ticket.message
         * @param {string} projectId Project Id
         * @param {string} ticketId Ticket Id
         * @param {SupportMessage} supportMessage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supportProjectTicketMessageCreate: async (projectId: string, ticketId: string, supportMessage: SupportMessage, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling supportProjectTicketMessageCreate.');
            }
            // verify required parameter 'ticketId' is not null or undefined
            if (ticketId === null || ticketId === undefined) {
                throw new RequiredError('ticketId','Required parameter ticketId was null or undefined when calling supportProjectTicketMessageCreate.');
            }
            // verify required parameter 'supportMessage' is not null or undefined
            if (supportMessage === null || supportMessage === undefined) {
                throw new RequiredError('supportMessage','Required parameter supportMessage was null or undefined when calling supportProjectTicketMessageCreate.');
            }
            const localVarPath = `/support/project/{projectId}/ticket/{ticketId}/message`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"ticketId"}}`, encodeURIComponent(String(ticketId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof supportMessage !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(supportMessage !== undefined ? supportMessage : {}) : (supportMessage || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get support/ticket.message
         * @summary Get support/ticket.message
         * @param {string} projectId Project Id
         * @param {string} ticketId Ticket Id
         * @param {string} messageId messageId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supportProjectTicketMessageGet: async (projectId: string, ticketId: string, messageId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling supportProjectTicketMessageGet.');
            }
            // verify required parameter 'ticketId' is not null or undefined
            if (ticketId === null || ticketId === undefined) {
                throw new RequiredError('ticketId','Required parameter ticketId was null or undefined when calling supportProjectTicketMessageGet.');
            }
            // verify required parameter 'messageId' is not null or undefined
            if (messageId === null || messageId === undefined) {
                throw new RequiredError('messageId','Required parameter messageId was null or undefined when calling supportProjectTicketMessageGet.');
            }
            const localVarPath = `/support/project/{projectId}/ticket/{ticketId}/message/{messageId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"ticketId"}}`, encodeURIComponent(String(ticketId)))
                .replace(`{${"messageId"}}`, encodeURIComponent(String(messageId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List support/ticket.message
         * @summary List support/ticket.message
         * @param {string} projectId Project Id
         * @param {string} ticketId Ticket Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supportProjectTicketMessageList: async (projectId: string, ticketId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling supportProjectTicketMessageList.');
            }
            // verify required parameter 'ticketId' is not null or undefined
            if (ticketId === null || ticketId === undefined) {
                throw new RequiredError('ticketId','Required parameter ticketId was null or undefined when calling supportProjectTicketMessageList.');
            }
            const localVarPath = `/support/project/{projectId}/ticket/{ticketId}/message`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"ticketId"}}`, encodeURIComponent(String(ticketId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SupportProjectTicketApi - functional programming interface
 * @export
 */
export const SupportProjectTicketApiFp = function(configuration?: Configuration) {
    return {
        /**
         * action close
         * @summary Close support/ticket
         * @param {string} projectId Project Id
         * @param {string} ticketId Ticket Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async supportProjectTicketClose(projectId: string, ticketId: string, xIdempotencyKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Ticket>> {
            const localVarAxiosArgs = await SupportProjectTicketApiAxiosParamCreator(configuration).supportProjectTicketClose(projectId, ticketId, xIdempotencyKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create ticket
         * @summary Create support/ticket
         * @param {string} projectId Project Id
         * @param {SupportProjectTicketCreate} supportProjectTicketCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async supportProjectTicketCreate(projectId: string, supportProjectTicketCreate: SupportProjectTicketCreate, xIdempotencyKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Ticket>> {
            const localVarAxiosArgs = await SupportProjectTicketApiAxiosParamCreator(configuration).supportProjectTicketCreate(projectId, supportProjectTicketCreate, xIdempotencyKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a single ticket
         * @summary Get support/ticket
         * @param {string} projectId Project Id
         * @param {string} ticketId Ticket Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async supportProjectTicketGet(projectId: string, ticketId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Ticket>> {
            const localVarAxiosArgs = await SupportProjectTicketApiAxiosParamCreator(configuration).supportProjectTicketGet(projectId, ticketId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List ticket
         * @summary List support/ticket
         * @param {string} projectId Project Id
         * @param {string} [state] Filter by state
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async supportProjectTicketList(projectId: string, state?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Ticket>>> {
            const localVarAxiosArgs = await SupportProjectTicketApiAxiosParamCreator(configuration).supportProjectTicketList(projectId, state, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create support/ticket.message
         * @summary Create support/ticket.message
         * @param {string} projectId Project Id
         * @param {string} ticketId Ticket Id
         * @param {SupportMessage} supportMessage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async supportProjectTicketMessageCreate(projectId: string, ticketId: string, supportMessage: SupportMessage, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupportMessage>> {
            const localVarAxiosArgs = await SupportProjectTicketApiAxiosParamCreator(configuration).supportProjectTicketMessageCreate(projectId, ticketId, supportMessage, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get support/ticket.message
         * @summary Get support/ticket.message
         * @param {string} projectId Project Id
         * @param {string} ticketId Ticket Id
         * @param {string} messageId messageId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async supportProjectTicketMessageGet(projectId: string, ticketId: string, messageId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupportMessage>> {
            const localVarAxiosArgs = await SupportProjectTicketApiAxiosParamCreator(configuration).supportProjectTicketMessageGet(projectId, ticketId, messageId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List support/ticket.message
         * @summary List support/ticket.message
         * @param {string} projectId Project Id
         * @param {string} ticketId Ticket Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async supportProjectTicketMessageList(projectId: string, ticketId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SupportMessage>>> {
            const localVarAxiosArgs = await SupportProjectTicketApiAxiosParamCreator(configuration).supportProjectTicketMessageList(projectId, ticketId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * SupportProjectTicketApi - factory interface
 * @export
 */
export const SupportProjectTicketApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * action close
         * @summary Close support/ticket
         * @param {string} projectId Project Id
         * @param {string} ticketId Ticket Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supportProjectTicketClose(projectId: string, ticketId: string, xIdempotencyKey?: string, options?: any): AxiosPromise<Ticket> {
            return SupportProjectTicketApiFp(configuration).supportProjectTicketClose(projectId, ticketId, xIdempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Create ticket
         * @summary Create support/ticket
         * @param {string} projectId Project Id
         * @param {SupportProjectTicketCreate} supportProjectTicketCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supportProjectTicketCreate(projectId: string, supportProjectTicketCreate: SupportProjectTicketCreate, xIdempotencyKey?: string, options?: any): AxiosPromise<Ticket> {
            return SupportProjectTicketApiFp(configuration).supportProjectTicketCreate(projectId, supportProjectTicketCreate, xIdempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single ticket
         * @summary Get support/ticket
         * @param {string} projectId Project Id
         * @param {string} ticketId Ticket Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supportProjectTicketGet(projectId: string, ticketId: string, options?: any): AxiosPromise<Ticket> {
            return SupportProjectTicketApiFp(configuration).supportProjectTicketGet(projectId, ticketId, options).then((request) => request(axios, basePath));
        },
        /**
         * List ticket
         * @summary List support/ticket
         * @param {string} projectId Project Id
         * @param {string} [state] Filter by state
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supportProjectTicketList(projectId: string, state?: string, options?: any): AxiosPromise<Array<Ticket>> {
            return SupportProjectTicketApiFp(configuration).supportProjectTicketList(projectId, state, options).then((request) => request(axios, basePath));
        },
        /**
         * Create support/ticket.message
         * @summary Create support/ticket.message
         * @param {string} projectId Project Id
         * @param {string} ticketId Ticket Id
         * @param {SupportMessage} supportMessage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supportProjectTicketMessageCreate(projectId: string, ticketId: string, supportMessage: SupportMessage, options?: any): AxiosPromise<SupportMessage> {
            return SupportProjectTicketApiFp(configuration).supportProjectTicketMessageCreate(projectId, ticketId, supportMessage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get support/ticket.message
         * @summary Get support/ticket.message
         * @param {string} projectId Project Id
         * @param {string} ticketId Ticket Id
         * @param {string} messageId messageId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supportProjectTicketMessageGet(projectId: string, ticketId: string, messageId: string, options?: any): AxiosPromise<SupportMessage> {
            return SupportProjectTicketApiFp(configuration).supportProjectTicketMessageGet(projectId, ticketId, messageId, options).then((request) => request(axios, basePath));
        },
        /**
         * List support/ticket.message
         * @summary List support/ticket.message
         * @param {string} projectId Project Id
         * @param {string} ticketId Ticket Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supportProjectTicketMessageList(projectId: string, ticketId: string, options?: any): AxiosPromise<Array<SupportMessage>> {
            return SupportProjectTicketApiFp(configuration).supportProjectTicketMessageList(projectId, ticketId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SupportProjectTicketApi - object-oriented interface
 * @export
 * @class SupportProjectTicketApi
 * @extends {BaseAPI}
 */
export class SupportProjectTicketApi extends BaseAPI {
    /**
     * action close
     * @summary Close support/ticket
     * @param {string} projectId Project Id
     * @param {string} ticketId Ticket Id
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SupportProjectTicketApi
     */
    public supportProjectTicketClose(projectId: string, ticketId: string, xIdempotencyKey?: string, options?: any) {
        return SupportProjectTicketApiFp(this.configuration).supportProjectTicketClose(projectId, ticketId, xIdempotencyKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create ticket
     * @summary Create support/ticket
     * @param {string} projectId Project Id
     * @param {SupportProjectTicketCreate} supportProjectTicketCreate 
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SupportProjectTicketApi
     */
    public supportProjectTicketCreate(projectId: string, supportProjectTicketCreate: SupportProjectTicketCreate, xIdempotencyKey?: string, options?: any) {
        return SupportProjectTicketApiFp(this.configuration).supportProjectTicketCreate(projectId, supportProjectTicketCreate, xIdempotencyKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single ticket
     * @summary Get support/ticket
     * @param {string} projectId Project Id
     * @param {string} ticketId Ticket Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SupportProjectTicketApi
     */
    public supportProjectTicketGet(projectId: string, ticketId: string, options?: any) {
        return SupportProjectTicketApiFp(this.configuration).supportProjectTicketGet(projectId, ticketId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List ticket
     * @summary List support/ticket
     * @param {string} projectId Project Id
     * @param {string} [state] Filter by state
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SupportProjectTicketApi
     */
    public supportProjectTicketList(projectId: string, state?: string, options?: any) {
        return SupportProjectTicketApiFp(this.configuration).supportProjectTicketList(projectId, state, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create support/ticket.message
     * @summary Create support/ticket.message
     * @param {string} projectId Project Id
     * @param {string} ticketId Ticket Id
     * @param {SupportMessage} supportMessage 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SupportProjectTicketApi
     */
    public supportProjectTicketMessageCreate(projectId: string, ticketId: string, supportMessage: SupportMessage, options?: any) {
        return SupportProjectTicketApiFp(this.configuration).supportProjectTicketMessageCreate(projectId, ticketId, supportMessage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get support/ticket.message
     * @summary Get support/ticket.message
     * @param {string} projectId Project Id
     * @param {string} ticketId Ticket Id
     * @param {string} messageId messageId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SupportProjectTicketApi
     */
    public supportProjectTicketMessageGet(projectId: string, ticketId: string, messageId: string, options?: any) {
        return SupportProjectTicketApiFp(this.configuration).supportProjectTicketMessageGet(projectId, ticketId, messageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List support/ticket.message
     * @summary List support/ticket.message
     * @param {string} projectId Project Id
     * @param {string} ticketId Ticket Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SupportProjectTicketApi
     */
    public supportProjectTicketMessageList(projectId: string, ticketId: string, options?: any) {
        return SupportProjectTicketApiFp(this.configuration).supportProjectTicketMessageList(projectId, ticketId, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * VmhostProjectInstanceApi - axios parameter creator
 * @export
 */
export const VmhostProjectInstanceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get vmhost/instance.event
         * @summary Get vmhost/instance.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vmhostProjectInstanceEventGet: async (projectId: string, locationId: string, instanceId: string, eventId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling vmhostProjectInstanceEventGet.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling vmhostProjectInstanceEventGet.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling vmhostProjectInstanceEventGet.');
            }
            // verify required parameter 'eventId' is not null or undefined
            if (eventId === null || eventId === undefined) {
                throw new RequiredError('eventId','Required parameter eventId was null or undefined when calling vmhostProjectInstanceEventGet.');
            }
            const localVarPath = `/vmhost/{locationId}/project/{projectId}/instance/{instanceId}/event/{eventId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List vmhost/instance.event
         * @summary List vmhost/instance.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vmhostProjectInstanceEventList: async (projectId: string, locationId: string, instanceId: string, $limit?: number, $skip?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling vmhostProjectInstanceEventList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling vmhostProjectInstanceEventList.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling vmhostProjectInstanceEventList.');
            }
            const localVarPath = `/vmhost/{locationId}/project/{projectId}/instance/{instanceId}/event`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if ($limit !== undefined) {
                localVarQueryParameter['$limit'] = $limit;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single instance
         * @summary Get vmhost/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vmhostProjectInstanceGet: async (projectId: string, locationId: string, instanceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling vmhostProjectInstanceGet.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling vmhostProjectInstanceGet.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling vmhostProjectInstanceGet.');
            }
            const localVarPath = `/vmhost/{locationId}/project/{projectId}/instance/{instanceId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List instance
         * @summary List vmhost/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [enabledServices] Filter by enabledServices
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vmhostProjectInstanceList: async (projectId: string, locationId: string, enabledServices?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling vmhostProjectInstanceList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling vmhostProjectInstanceList.');
            }
            const localVarPath = `/vmhost/{locationId}/project/{projectId}/instance`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (enabledServices !== undefined) {
                localVarQueryParameter['enabledServices'] = enabledServices;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get vmhost/instance.service
         * @summary Get vmhost/instance.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vmhostProjectInstanceServiceGet: async (projectId: string, locationId: string, instanceId: string, serviceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling vmhostProjectInstanceServiceGet.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling vmhostProjectInstanceServiceGet.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling vmhostProjectInstanceServiceGet.');
            }
            // verify required parameter 'serviceId' is not null or undefined
            if (serviceId === null || serviceId === undefined) {
                throw new RequiredError('serviceId','Required parameter serviceId was null or undefined when calling vmhostProjectInstanceServiceGet.');
            }
            const localVarPath = `/vmhost/{locationId}/project/{projectId}/instance/{instanceId}/service/{serviceId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List vmhost/instance.service
         * @summary List vmhost/instance.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vmhostProjectInstanceServiceList: async (projectId: string, locationId: string, instanceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling vmhostProjectInstanceServiceList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling vmhostProjectInstanceServiceList.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling vmhostProjectInstanceServiceList.');
            }
            const localVarPath = `/vmhost/{locationId}/project/{projectId}/instance/{instanceId}/service`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create vmhost/instance.tag
         * @summary Create vmhost/instance.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vmhostProjectInstanceTagCreate: async (projectId: string, locationId: string, instanceId: string, tag: Tag, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling vmhostProjectInstanceTagCreate.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling vmhostProjectInstanceTagCreate.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling vmhostProjectInstanceTagCreate.');
            }
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling vmhostProjectInstanceTagCreate.');
            }
            const localVarPath = `/vmhost/{locationId}/project/{projectId}/instance/{instanceId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof tag !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(tag !== undefined ? tag : {}) : (tag || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete vmhost/instance.tag
         * @summary Delete vmhost/instance.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vmhostProjectInstanceTagDelete: async (projectId: string, locationId: string, instanceId: string, tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling vmhostProjectInstanceTagDelete.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling vmhostProjectInstanceTagDelete.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling vmhostProjectInstanceTagDelete.');
            }
            // verify required parameter 'tagId' is not null or undefined
            if (tagId === null || tagId === undefined) {
                throw new RequiredError('tagId','Required parameter tagId was null or undefined when calling vmhostProjectInstanceTagDelete.');
            }
            const localVarPath = `/vmhost/{locationId}/project/{projectId}/instance/{instanceId}/tag/{tagId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get vmhost/instance.tag
         * @summary Get vmhost/instance.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vmhostProjectInstanceTagGet: async (projectId: string, locationId: string, instanceId: string, tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling vmhostProjectInstanceTagGet.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling vmhostProjectInstanceTagGet.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling vmhostProjectInstanceTagGet.');
            }
            // verify required parameter 'tagId' is not null or undefined
            if (tagId === null || tagId === undefined) {
                throw new RequiredError('tagId','Required parameter tagId was null or undefined when calling vmhostProjectInstanceTagGet.');
            }
            const localVarPath = `/vmhost/{locationId}/project/{projectId}/instance/{instanceId}/tag/{tagId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List vmhost/instance.tag
         * @summary List vmhost/instance.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vmhostProjectInstanceTagList: async (projectId: string, locationId: string, instanceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling vmhostProjectInstanceTagList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling vmhostProjectInstanceTagList.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling vmhostProjectInstanceTagList.');
            }
            const localVarPath = `/vmhost/{locationId}/project/{projectId}/instance/{instanceId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replace vmhost/instance.tag
         * @summary Replace vmhost/instance.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vmhostProjectInstanceTagPut: async (projectId: string, locationId: string, instanceId: string, tag: Array<Tag>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling vmhostProjectInstanceTagPut.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling vmhostProjectInstanceTagPut.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling vmhostProjectInstanceTagPut.');
            }
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling vmhostProjectInstanceTagPut.');
            }
            const localVarPath = `/vmhost/{locationId}/project/{projectId}/instance/{instanceId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof tag !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(tag !== undefined ? tag : {}) : (tag || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VmhostProjectInstanceApi - functional programming interface
 * @export
 */
export const VmhostProjectInstanceApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get vmhost/instance.event
         * @summary Get vmhost/instance.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vmhostProjectInstanceEventGet(projectId: string, locationId: string, instanceId: string, eventId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>> {
            const localVarAxiosArgs = await VmhostProjectInstanceApiAxiosParamCreator(configuration).vmhostProjectInstanceEventGet(projectId, locationId, instanceId, eventId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List vmhost/instance.event
         * @summary List vmhost/instance.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vmhostProjectInstanceEventList(projectId: string, locationId: string, instanceId: string, $limit?: number, $skip?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Event>>> {
            const localVarAxiosArgs = await VmhostProjectInstanceApiAxiosParamCreator(configuration).vmhostProjectInstanceEventList(projectId, locationId, instanceId, $limit, $skip, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a single instance
         * @summary Get vmhost/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vmhostProjectInstanceGet(projectId: string, locationId: string, instanceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Vmhost>> {
            const localVarAxiosArgs = await VmhostProjectInstanceApiAxiosParamCreator(configuration).vmhostProjectInstanceGet(projectId, locationId, instanceId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List instance
         * @summary List vmhost/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [enabledServices] Filter by enabledServices
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vmhostProjectInstanceList(projectId: string, locationId: string, enabledServices?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Vmhost>>> {
            const localVarAxiosArgs = await VmhostProjectInstanceApiAxiosParamCreator(configuration).vmhostProjectInstanceList(projectId, locationId, enabledServices, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get vmhost/instance.service
         * @summary Get vmhost/instance.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vmhostProjectInstanceServiceGet(projectId: string, locationId: string, instanceId: string, serviceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceService>> {
            const localVarAxiosArgs = await VmhostProjectInstanceApiAxiosParamCreator(configuration).vmhostProjectInstanceServiceGet(projectId, locationId, instanceId, serviceId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List vmhost/instance.service
         * @summary List vmhost/instance.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vmhostProjectInstanceServiceList(projectId: string, locationId: string, instanceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResourceService>>> {
            const localVarAxiosArgs = await VmhostProjectInstanceApiAxiosParamCreator(configuration).vmhostProjectInstanceServiceList(projectId, locationId, instanceId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create vmhost/instance.tag
         * @summary Create vmhost/instance.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vmhostProjectInstanceTagCreate(projectId: string, locationId: string, instanceId: string, tag: Tag, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await VmhostProjectInstanceApiAxiosParamCreator(configuration).vmhostProjectInstanceTagCreate(projectId, locationId, instanceId, tag, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete vmhost/instance.tag
         * @summary Delete vmhost/instance.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vmhostProjectInstanceTagDelete(projectId: string, locationId: string, instanceId: string, tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await VmhostProjectInstanceApiAxiosParamCreator(configuration).vmhostProjectInstanceTagDelete(projectId, locationId, instanceId, tagId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get vmhost/instance.tag
         * @summary Get vmhost/instance.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vmhostProjectInstanceTagGet(projectId: string, locationId: string, instanceId: string, tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await VmhostProjectInstanceApiAxiosParamCreator(configuration).vmhostProjectInstanceTagGet(projectId, locationId, instanceId, tagId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List vmhost/instance.tag
         * @summary List vmhost/instance.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vmhostProjectInstanceTagList(projectId: string, locationId: string, instanceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await VmhostProjectInstanceApiAxiosParamCreator(configuration).vmhostProjectInstanceTagList(projectId, locationId, instanceId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Replace vmhost/instance.tag
         * @summary Replace vmhost/instance.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vmhostProjectInstanceTagPut(projectId: string, locationId: string, instanceId: string, tag: Array<Tag>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await VmhostProjectInstanceApiAxiosParamCreator(configuration).vmhostProjectInstanceTagPut(projectId, locationId, instanceId, tag, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * VmhostProjectInstanceApi - factory interface
 * @export
 */
export const VmhostProjectInstanceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Get vmhost/instance.event
         * @summary Get vmhost/instance.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vmhostProjectInstanceEventGet(projectId: string, locationId: string, instanceId: string, eventId: string, options?: any): AxiosPromise<Event> {
            return VmhostProjectInstanceApiFp(configuration).vmhostProjectInstanceEventGet(projectId, locationId, instanceId, eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * List vmhost/instance.event
         * @summary List vmhost/instance.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vmhostProjectInstanceEventList(projectId: string, locationId: string, instanceId: string, $limit?: number, $skip?: number, options?: any): AxiosPromise<Array<Event>> {
            return VmhostProjectInstanceApiFp(configuration).vmhostProjectInstanceEventList(projectId, locationId, instanceId, $limit, $skip, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single instance
         * @summary Get vmhost/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vmhostProjectInstanceGet(projectId: string, locationId: string, instanceId: string, options?: any): AxiosPromise<Vmhost> {
            return VmhostProjectInstanceApiFp(configuration).vmhostProjectInstanceGet(projectId, locationId, instanceId, options).then((request) => request(axios, basePath));
        },
        /**
         * List instance
         * @summary List vmhost/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [enabledServices] Filter by enabledServices
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vmhostProjectInstanceList(projectId: string, locationId: string, enabledServices?: string, options?: any): AxiosPromise<Array<Vmhost>> {
            return VmhostProjectInstanceApiFp(configuration).vmhostProjectInstanceList(projectId, locationId, enabledServices, options).then((request) => request(axios, basePath));
        },
        /**
         * Get vmhost/instance.service
         * @summary Get vmhost/instance.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vmhostProjectInstanceServiceGet(projectId: string, locationId: string, instanceId: string, serviceId: string, options?: any): AxiosPromise<ResourceService> {
            return VmhostProjectInstanceApiFp(configuration).vmhostProjectInstanceServiceGet(projectId, locationId, instanceId, serviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * List vmhost/instance.service
         * @summary List vmhost/instance.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vmhostProjectInstanceServiceList(projectId: string, locationId: string, instanceId: string, options?: any): AxiosPromise<Array<ResourceService>> {
            return VmhostProjectInstanceApiFp(configuration).vmhostProjectInstanceServiceList(projectId, locationId, instanceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create vmhost/instance.tag
         * @summary Create vmhost/instance.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vmhostProjectInstanceTagCreate(projectId: string, locationId: string, instanceId: string, tag: Tag, options?: any): AxiosPromise<Tag> {
            return VmhostProjectInstanceApiFp(configuration).vmhostProjectInstanceTagCreate(projectId, locationId, instanceId, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete vmhost/instance.tag
         * @summary Delete vmhost/instance.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vmhostProjectInstanceTagDelete(projectId: string, locationId: string, instanceId: string, tagId: string, options?: any): AxiosPromise<void> {
            return VmhostProjectInstanceApiFp(configuration).vmhostProjectInstanceTagDelete(projectId, locationId, instanceId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get vmhost/instance.tag
         * @summary Get vmhost/instance.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vmhostProjectInstanceTagGet(projectId: string, locationId: string, instanceId: string, tagId: string, options?: any): AxiosPromise<Tag> {
            return VmhostProjectInstanceApiFp(configuration).vmhostProjectInstanceTagGet(projectId, locationId, instanceId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * List vmhost/instance.tag
         * @summary List vmhost/instance.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vmhostProjectInstanceTagList(projectId: string, locationId: string, instanceId: string, options?: any): AxiosPromise<Array<Tag>> {
            return VmhostProjectInstanceApiFp(configuration).vmhostProjectInstanceTagList(projectId, locationId, instanceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Replace vmhost/instance.tag
         * @summary Replace vmhost/instance.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vmhostProjectInstanceTagPut(projectId: string, locationId: string, instanceId: string, tag: Array<Tag>, options?: any): AxiosPromise<Array<Tag>> {
            return VmhostProjectInstanceApiFp(configuration).vmhostProjectInstanceTagPut(projectId, locationId, instanceId, tag, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VmhostProjectInstanceApi - object-oriented interface
 * @export
 * @class VmhostProjectInstanceApi
 * @extends {BaseAPI}
 */
export class VmhostProjectInstanceApi extends BaseAPI {
    /**
     * Get vmhost/instance.event
     * @summary Get vmhost/instance.event
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {string} eventId eventId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VmhostProjectInstanceApi
     */
    public vmhostProjectInstanceEventGet(projectId: string, locationId: string, instanceId: string, eventId: string, options?: any) {
        return VmhostProjectInstanceApiFp(this.configuration).vmhostProjectInstanceEventGet(projectId, locationId, instanceId, eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List vmhost/instance.event
     * @summary List vmhost/instance.event
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {number} [$limit] $limit
     * @param {number} [$skip] $skip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VmhostProjectInstanceApi
     */
    public vmhostProjectInstanceEventList(projectId: string, locationId: string, instanceId: string, $limit?: number, $skip?: number, options?: any) {
        return VmhostProjectInstanceApiFp(this.configuration).vmhostProjectInstanceEventList(projectId, locationId, instanceId, $limit, $skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single instance
     * @summary Get vmhost/instance
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VmhostProjectInstanceApi
     */
    public vmhostProjectInstanceGet(projectId: string, locationId: string, instanceId: string, options?: any) {
        return VmhostProjectInstanceApiFp(this.configuration).vmhostProjectInstanceGet(projectId, locationId, instanceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List instance
     * @summary List vmhost/instance
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} [enabledServices] Filter by enabledServices
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VmhostProjectInstanceApi
     */
    public vmhostProjectInstanceList(projectId: string, locationId: string, enabledServices?: string, options?: any) {
        return VmhostProjectInstanceApiFp(this.configuration).vmhostProjectInstanceList(projectId, locationId, enabledServices, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get vmhost/instance.service
     * @summary Get vmhost/instance.service
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {string} serviceId serviceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VmhostProjectInstanceApi
     */
    public vmhostProjectInstanceServiceGet(projectId: string, locationId: string, instanceId: string, serviceId: string, options?: any) {
        return VmhostProjectInstanceApiFp(this.configuration).vmhostProjectInstanceServiceGet(projectId, locationId, instanceId, serviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List vmhost/instance.service
     * @summary List vmhost/instance.service
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VmhostProjectInstanceApi
     */
    public vmhostProjectInstanceServiceList(projectId: string, locationId: string, instanceId: string, options?: any) {
        return VmhostProjectInstanceApiFp(this.configuration).vmhostProjectInstanceServiceList(projectId, locationId, instanceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create vmhost/instance.tag
     * @summary Create vmhost/instance.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {Tag} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VmhostProjectInstanceApi
     */
    public vmhostProjectInstanceTagCreate(projectId: string, locationId: string, instanceId: string, tag: Tag, options?: any) {
        return VmhostProjectInstanceApiFp(this.configuration).vmhostProjectInstanceTagCreate(projectId, locationId, instanceId, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete vmhost/instance.tag
     * @summary Delete vmhost/instance.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {string} tagId tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VmhostProjectInstanceApi
     */
    public vmhostProjectInstanceTagDelete(projectId: string, locationId: string, instanceId: string, tagId: string, options?: any) {
        return VmhostProjectInstanceApiFp(this.configuration).vmhostProjectInstanceTagDelete(projectId, locationId, instanceId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get vmhost/instance.tag
     * @summary Get vmhost/instance.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {string} tagId tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VmhostProjectInstanceApi
     */
    public vmhostProjectInstanceTagGet(projectId: string, locationId: string, instanceId: string, tagId: string, options?: any) {
        return VmhostProjectInstanceApiFp(this.configuration).vmhostProjectInstanceTagGet(projectId, locationId, instanceId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List vmhost/instance.tag
     * @summary List vmhost/instance.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VmhostProjectInstanceApi
     */
    public vmhostProjectInstanceTagList(projectId: string, locationId: string, instanceId: string, options?: any) {
        return VmhostProjectInstanceApiFp(this.configuration).vmhostProjectInstanceTagList(projectId, locationId, instanceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replace vmhost/instance.tag
     * @summary Replace vmhost/instance.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {Array<Tag>} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VmhostProjectInstanceApi
     */
    public vmhostProjectInstanceTagPut(projectId: string, locationId: string, instanceId: string, tag: Array<Tag>, options?: any) {
        return VmhostProjectInstanceApiFp(this.configuration).vmhostProjectInstanceTagPut(projectId, locationId, instanceId, tag, options).then((request) => request(this.axios, this.basePath));
    }

}


/**
 * WebsiteProjectInstanceApi - axios parameter creator
 * @export
 */
export const WebsiteProjectInstanceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get website/instance.connect
         * @summary Get website/instance.connect
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} connectId connectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceConnectGet: async (projectId: string, locationId: string, instanceId: string, connectId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling websiteProjectInstanceConnectGet.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling websiteProjectInstanceConnectGet.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling websiteProjectInstanceConnectGet.');
            }
            // verify required parameter 'connectId' is not null or undefined
            if (connectId === null || connectId === undefined) {
                throw new RequiredError('connectId','Required parameter connectId was null or undefined when calling websiteProjectInstanceConnectGet.');
            }
            const localVarPath = `/website/{locationId}/project/{projectId}/instance/{instanceId}/connect/{connectId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"connectId"}}`, encodeURIComponent(String(connectId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List website/instance.connect
         * @summary List website/instance.connect
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceConnectList: async (projectId: string, locationId: string, instanceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling websiteProjectInstanceConnectList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling websiteProjectInstanceConnectList.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling websiteProjectInstanceConnectList.');
            }
            const localVarPath = `/website/{locationId}/project/{projectId}/instance/{instanceId}/connect`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create instance
         * @summary Create website/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {WebsiteProjectInstanceCreate} websiteProjectInstanceCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceCreate: async (projectId: string, locationId: string, websiteProjectInstanceCreate: WebsiteProjectInstanceCreate, xIdempotencyKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling websiteProjectInstanceCreate.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling websiteProjectInstanceCreate.');
            }
            // verify required parameter 'websiteProjectInstanceCreate' is not null or undefined
            if (websiteProjectInstanceCreate === null || websiteProjectInstanceCreate === undefined) {
                throw new RequiredError('websiteProjectInstanceCreate','Required parameter websiteProjectInstanceCreate was null or undefined when calling websiteProjectInstanceCreate.');
            }
            const localVarPath = `/website/{locationId}/project/{projectId}/instance`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof websiteProjectInstanceCreate !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(websiteProjectInstanceCreate !== undefined ? websiteProjectInstanceCreate : {}) : (websiteProjectInstanceCreate || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create website/instance.credential
         * @summary Create website/instance.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {WebsiteCredential} websiteCredential 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceCredentialCreate: async (projectId: string, locationId: string, instanceId: string, websiteCredential: WebsiteCredential, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling websiteProjectInstanceCredentialCreate.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling websiteProjectInstanceCredentialCreate.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling websiteProjectInstanceCredentialCreate.');
            }
            // verify required parameter 'websiteCredential' is not null or undefined
            if (websiteCredential === null || websiteCredential === undefined) {
                throw new RequiredError('websiteCredential','Required parameter websiteCredential was null or undefined when calling websiteProjectInstanceCredentialCreate.');
            }
            const localVarPath = `/website/{locationId}/project/{projectId}/instance/{instanceId}/credential`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof websiteCredential !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(websiteCredential !== undefined ? websiteCredential : {}) : (websiteCredential || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete website/instance.credential
         * @summary Delete website/instance.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} credentialId credentialId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceCredentialDelete: async (projectId: string, locationId: string, instanceId: string, credentialId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling websiteProjectInstanceCredentialDelete.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling websiteProjectInstanceCredentialDelete.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling websiteProjectInstanceCredentialDelete.');
            }
            // verify required parameter 'credentialId' is not null or undefined
            if (credentialId === null || credentialId === undefined) {
                throw new RequiredError('credentialId','Required parameter credentialId was null or undefined when calling websiteProjectInstanceCredentialDelete.');
            }
            const localVarPath = `/website/{locationId}/project/{projectId}/instance/{instanceId}/credential/{credentialId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"credentialId"}}`, encodeURIComponent(String(credentialId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get website/instance.credential
         * @summary Get website/instance.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} credentialId credentialId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceCredentialGet: async (projectId: string, locationId: string, instanceId: string, credentialId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling websiteProjectInstanceCredentialGet.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling websiteProjectInstanceCredentialGet.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling websiteProjectInstanceCredentialGet.');
            }
            // verify required parameter 'credentialId' is not null or undefined
            if (credentialId === null || credentialId === undefined) {
                throw new RequiredError('credentialId','Required parameter credentialId was null or undefined when calling websiteProjectInstanceCredentialGet.');
            }
            const localVarPath = `/website/{locationId}/project/{projectId}/instance/{instanceId}/credential/{credentialId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"credentialId"}}`, encodeURIComponent(String(credentialId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List website/instance.credential
         * @summary List website/instance.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceCredentialList: async (projectId: string, locationId: string, instanceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling websiteProjectInstanceCredentialList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling websiteProjectInstanceCredentialList.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling websiteProjectInstanceCredentialList.');
            }
            const localVarPath = `/website/{locationId}/project/{projectId}/instance/{instanceId}/credential`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update website/instance.credential
         * @summary Update website/instance.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} credentialId credentialId
         * @param {WebsiteProjectInstanceCredentialPatch} websiteProjectInstanceCredentialPatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceCredentialPatch: async (projectId: string, locationId: string, instanceId: string, credentialId: string, websiteProjectInstanceCredentialPatch: WebsiteProjectInstanceCredentialPatch, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling websiteProjectInstanceCredentialPatch.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling websiteProjectInstanceCredentialPatch.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling websiteProjectInstanceCredentialPatch.');
            }
            // verify required parameter 'credentialId' is not null or undefined
            if (credentialId === null || credentialId === undefined) {
                throw new RequiredError('credentialId','Required parameter credentialId was null or undefined when calling websiteProjectInstanceCredentialPatch.');
            }
            // verify required parameter 'websiteProjectInstanceCredentialPatch' is not null or undefined
            if (websiteProjectInstanceCredentialPatch === null || websiteProjectInstanceCredentialPatch === undefined) {
                throw new RequiredError('websiteProjectInstanceCredentialPatch','Required parameter websiteProjectInstanceCredentialPatch was null or undefined when calling websiteProjectInstanceCredentialPatch.');
            }
            const localVarPath = `/website/{locationId}/project/{projectId}/instance/{instanceId}/credential/{credentialId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"credentialId"}}`, encodeURIComponent(String(credentialId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof websiteProjectInstanceCredentialPatch !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(websiteProjectInstanceCredentialPatch !== undefined ? websiteProjectInstanceCredentialPatch : {}) : (websiteProjectInstanceCredentialPatch || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete instance
         * @summary Delete website/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceDelete: async (projectId: string, locationId: string, instanceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling websiteProjectInstanceDelete.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling websiteProjectInstanceDelete.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling websiteProjectInstanceDelete.');
            }
            const localVarPath = `/website/{locationId}/project/{projectId}/instance/{instanceId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create website/instance.domain
         * @summary Create website/instance.domain
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {Domain} domain 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceDomainCreate: async (projectId: string, locationId: string, instanceId: string, domain: Domain, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling websiteProjectInstanceDomainCreate.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling websiteProjectInstanceDomainCreate.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling websiteProjectInstanceDomainCreate.');
            }
            // verify required parameter 'domain' is not null or undefined
            if (domain === null || domain === undefined) {
                throw new RequiredError('domain','Required parameter domain was null or undefined when calling websiteProjectInstanceDomainCreate.');
            }
            const localVarPath = `/website/{locationId}/project/{projectId}/instance/{instanceId}/domain`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof domain !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(domain !== undefined ? domain : {}) : (domain || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete website/instance.domain
         * @summary Delete website/instance.domain
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} domainId domainId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceDomainDelete: async (projectId: string, locationId: string, instanceId: string, domainId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling websiteProjectInstanceDomainDelete.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling websiteProjectInstanceDomainDelete.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling websiteProjectInstanceDomainDelete.');
            }
            // verify required parameter 'domainId' is not null or undefined
            if (domainId === null || domainId === undefined) {
                throw new RequiredError('domainId','Required parameter domainId was null or undefined when calling websiteProjectInstanceDomainDelete.');
            }
            const localVarPath = `/website/{locationId}/project/{projectId}/instance/{instanceId}/domain/{domainId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"domainId"}}`, encodeURIComponent(String(domainId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get website/instance.domain
         * @summary Get website/instance.domain
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} domainId domainId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceDomainGet: async (projectId: string, locationId: string, instanceId: string, domainId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling websiteProjectInstanceDomainGet.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling websiteProjectInstanceDomainGet.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling websiteProjectInstanceDomainGet.');
            }
            // verify required parameter 'domainId' is not null or undefined
            if (domainId === null || domainId === undefined) {
                throw new RequiredError('domainId','Required parameter domainId was null or undefined when calling websiteProjectInstanceDomainGet.');
            }
            const localVarPath = `/website/{locationId}/project/{projectId}/instance/{instanceId}/domain/{domainId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"domainId"}}`, encodeURIComponent(String(domainId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List website/instance.domain
         * @summary List website/instance.domain
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceDomainList: async (projectId: string, locationId: string, instanceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling websiteProjectInstanceDomainList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling websiteProjectInstanceDomainList.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling websiteProjectInstanceDomainList.');
            }
            const localVarPath = `/website/{locationId}/project/{projectId}/instance/{instanceId}/domain`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create website/instance.env
         * @summary Create website/instance.env
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {WebsiteEnv} websiteEnv 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceEnvCreate: async (projectId: string, locationId: string, instanceId: string, websiteEnv: WebsiteEnv, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling websiteProjectInstanceEnvCreate.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling websiteProjectInstanceEnvCreate.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling websiteProjectInstanceEnvCreate.');
            }
            // verify required parameter 'websiteEnv' is not null or undefined
            if (websiteEnv === null || websiteEnv === undefined) {
                throw new RequiredError('websiteEnv','Required parameter websiteEnv was null or undefined when calling websiteProjectInstanceEnvCreate.');
            }
            const localVarPath = `/website/{locationId}/project/{projectId}/instance/{instanceId}/env`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof websiteEnv !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(websiteEnv !== undefined ? websiteEnv : {}) : (websiteEnv || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete website/instance.env
         * @summary Delete website/instance.env
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} envId envId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceEnvDelete: async (projectId: string, locationId: string, instanceId: string, envId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling websiteProjectInstanceEnvDelete.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling websiteProjectInstanceEnvDelete.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling websiteProjectInstanceEnvDelete.');
            }
            // verify required parameter 'envId' is not null or undefined
            if (envId === null || envId === undefined) {
                throw new RequiredError('envId','Required parameter envId was null or undefined when calling websiteProjectInstanceEnvDelete.');
            }
            const localVarPath = `/website/{locationId}/project/{projectId}/instance/{instanceId}/env/{envId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get website/instance.env
         * @summary Get website/instance.env
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} envId envId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceEnvGet: async (projectId: string, locationId: string, instanceId: string, envId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling websiteProjectInstanceEnvGet.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling websiteProjectInstanceEnvGet.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling websiteProjectInstanceEnvGet.');
            }
            // verify required parameter 'envId' is not null or undefined
            if (envId === null || envId === undefined) {
                throw new RequiredError('envId','Required parameter envId was null or undefined when calling websiteProjectInstanceEnvGet.');
            }
            const localVarPath = `/website/{locationId}/project/{projectId}/instance/{instanceId}/env/{envId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List website/instance.env
         * @summary List website/instance.env
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceEnvList: async (projectId: string, locationId: string, instanceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling websiteProjectInstanceEnvList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling websiteProjectInstanceEnvList.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling websiteProjectInstanceEnvList.');
            }
            const localVarPath = `/website/{locationId}/project/{projectId}/instance/{instanceId}/env`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get website/instance.event
         * @summary Get website/instance.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceEventGet: async (projectId: string, locationId: string, instanceId: string, eventId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling websiteProjectInstanceEventGet.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling websiteProjectInstanceEventGet.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling websiteProjectInstanceEventGet.');
            }
            // verify required parameter 'eventId' is not null or undefined
            if (eventId === null || eventId === undefined) {
                throw new RequiredError('eventId','Required parameter eventId was null or undefined when calling websiteProjectInstanceEventGet.');
            }
            const localVarPath = `/website/{locationId}/project/{projectId}/instance/{instanceId}/event/{eventId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List website/instance.event
         * @summary List website/instance.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceEventList: async (projectId: string, locationId: string, instanceId: string, $limit?: number, $skip?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling websiteProjectInstanceEventList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling websiteProjectInstanceEventList.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling websiteProjectInstanceEventList.');
            }
            const localVarPath = `/website/{locationId}/project/{projectId}/instance/{instanceId}/event`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if ($limit !== undefined) {
                localVarQueryParameter['$limit'] = $limit;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single instance
         * @summary Get website/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceGet: async (projectId: string, locationId: string, instanceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling websiteProjectInstanceGet.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling websiteProjectInstanceGet.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling websiteProjectInstanceGet.');
            }
            const localVarPath = `/website/{locationId}/project/{projectId}/instance/{instanceId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create website/instance.link
         * @summary Create website/instance.link
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {WebsiteLink} websiteLink 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceLinkCreate: async (projectId: string, locationId: string, instanceId: string, websiteLink: WebsiteLink, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling websiteProjectInstanceLinkCreate.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling websiteProjectInstanceLinkCreate.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling websiteProjectInstanceLinkCreate.');
            }
            // verify required parameter 'websiteLink' is not null or undefined
            if (websiteLink === null || websiteLink === undefined) {
                throw new RequiredError('websiteLink','Required parameter websiteLink was null or undefined when calling websiteProjectInstanceLinkCreate.');
            }
            const localVarPath = `/website/{locationId}/project/{projectId}/instance/{instanceId}/link`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof websiteLink !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(websiteLink !== undefined ? websiteLink : {}) : (websiteLink || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete website/instance.link
         * @summary Delete website/instance.link
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} linkId linkId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceLinkDelete: async (projectId: string, locationId: string, instanceId: string, linkId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling websiteProjectInstanceLinkDelete.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling websiteProjectInstanceLinkDelete.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling websiteProjectInstanceLinkDelete.');
            }
            // verify required parameter 'linkId' is not null or undefined
            if (linkId === null || linkId === undefined) {
                throw new RequiredError('linkId','Required parameter linkId was null or undefined when calling websiteProjectInstanceLinkDelete.');
            }
            const localVarPath = `/website/{locationId}/project/{projectId}/instance/{instanceId}/link/{linkId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"linkId"}}`, encodeURIComponent(String(linkId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get website/instance.link
         * @summary Get website/instance.link
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} linkId linkId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceLinkGet: async (projectId: string, locationId: string, instanceId: string, linkId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling websiteProjectInstanceLinkGet.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling websiteProjectInstanceLinkGet.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling websiteProjectInstanceLinkGet.');
            }
            // verify required parameter 'linkId' is not null or undefined
            if (linkId === null || linkId === undefined) {
                throw new RequiredError('linkId','Required parameter linkId was null or undefined when calling websiteProjectInstanceLinkGet.');
            }
            const localVarPath = `/website/{locationId}/project/{projectId}/instance/{instanceId}/link/{linkId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"linkId"}}`, encodeURIComponent(String(linkId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List website/instance.link
         * @summary List website/instance.link
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceLinkList: async (projectId: string, locationId: string, instanceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling websiteProjectInstanceLinkList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling websiteProjectInstanceLinkList.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling websiteProjectInstanceLinkList.');
            }
            const localVarPath = `/website/{locationId}/project/{projectId}/instance/{instanceId}/link`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List instance
         * @summary List website/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [name] Filter by name
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceList: async (projectId: string, locationId: string, name?: string, tagValue?: string, tagKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling websiteProjectInstanceList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling websiteProjectInstanceList.');
            }
            const localVarPath = `/website/{locationId}/project/{projectId}/instance`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (tagValue !== undefined) {
                localVarQueryParameter['tag.value'] = tagValue;
            }

            if (tagKey !== undefined) {
                localVarQueryParameter['tag.key'] = tagKey;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get website/instance.log
         * @summary Get website/instance.log
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} logId logId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceLogGet: async (projectId: string, locationId: string, instanceId: string, logId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling websiteProjectInstanceLogGet.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling websiteProjectInstanceLogGet.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling websiteProjectInstanceLogGet.');
            }
            // verify required parameter 'logId' is not null or undefined
            if (logId === null || logId === undefined) {
                throw new RequiredError('logId','Required parameter logId was null or undefined when calling websiteProjectInstanceLogGet.');
            }
            const localVarPath = `/website/{locationId}/project/{projectId}/instance/{instanceId}/log/{logId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"logId"}}`, encodeURIComponent(String(logId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List website/instance.log
         * @summary List website/instance.log
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceLogList: async (projectId: string, locationId: string, instanceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling websiteProjectInstanceLogList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling websiteProjectInstanceLogList.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling websiteProjectInstanceLogList.');
            }
            const localVarPath = `/website/{locationId}/project/{projectId}/instance/{instanceId}/log`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * action read
         * @summary Read website/instance.log
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} logId logId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceLogRead: async (projectId: string, locationId: string, instanceId: string, logId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling websiteProjectInstanceLogRead.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling websiteProjectInstanceLogRead.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling websiteProjectInstanceLogRead.');
            }
            // verify required parameter 'logId' is not null or undefined
            if (logId === null || logId === undefined) {
                throw new RequiredError('logId','Required parameter logId was null or undefined when calling websiteProjectInstanceLogRead.');
            }
            const localVarPath = `/website/{locationId}/project/{projectId}/instance/{instanceId}/log/{logId}/actions/read`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"logId"}}`, encodeURIComponent(String(logId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get website/instance.metric
         * @summary Get website/instance.metric
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} metricId metricId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceMetricGet: async (projectId: string, locationId: string, instanceId: string, metricId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling websiteProjectInstanceMetricGet.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling websiteProjectInstanceMetricGet.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling websiteProjectInstanceMetricGet.');
            }
            // verify required parameter 'metricId' is not null or undefined
            if (metricId === null || metricId === undefined) {
                throw new RequiredError('metricId','Required parameter metricId was null or undefined when calling websiteProjectInstanceMetricGet.');
            }
            const localVarPath = `/website/{locationId}/project/{projectId}/instance/{instanceId}/metric/{metricId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"metricId"}}`, encodeURIComponent(String(metricId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List website/instance.metric
         * @summary List website/instance.metric
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceMetricList: async (projectId: string, locationId: string, instanceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling websiteProjectInstanceMetricList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling websiteProjectInstanceMetricList.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling websiteProjectInstanceMetricList.');
            }
            const localVarPath = `/website/{locationId}/project/{projectId}/instance/{instanceId}/metric`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List website/instance.point
         * @summary List website/instance.point
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} metricId metricId
         * @param {string} [interval] interval
         * @param {string} [timespan] timespan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceMetricPointList: async (projectId: string, locationId: string, instanceId: string, metricId: string, interval?: string, timespan?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling websiteProjectInstanceMetricPointList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling websiteProjectInstanceMetricPointList.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling websiteProjectInstanceMetricPointList.');
            }
            // verify required parameter 'metricId' is not null or undefined
            if (metricId === null || metricId === undefined) {
                throw new RequiredError('metricId','Required parameter metricId was null or undefined when calling websiteProjectInstanceMetricPointList.');
            }
            const localVarPath = `/website/{locationId}/project/{projectId}/instance/{instanceId}/metric/{metricId}/point`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"metricId"}}`, encodeURIComponent(String(metricId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (timespan !== undefined) {
                localVarQueryParameter['timespan'] = timespan;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * action restart
         * @summary Restart website/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceRestart: async (projectId: string, locationId: string, instanceId: string, xIdempotencyKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling websiteProjectInstanceRestart.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling websiteProjectInstanceRestart.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling websiteProjectInstanceRestart.');
            }
            const localVarPath = `/website/{locationId}/project/{projectId}/instance/{instanceId}/actions/restart`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get website/instance.service
         * @summary Get website/instance.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceServiceGet: async (projectId: string, locationId: string, instanceId: string, serviceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling websiteProjectInstanceServiceGet.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling websiteProjectInstanceServiceGet.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling websiteProjectInstanceServiceGet.');
            }
            // verify required parameter 'serviceId' is not null or undefined
            if (serviceId === null || serviceId === undefined) {
                throw new RequiredError('serviceId','Required parameter serviceId was null or undefined when calling websiteProjectInstanceServiceGet.');
            }
            const localVarPath = `/website/{locationId}/project/{projectId}/instance/{instanceId}/service/{serviceId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List website/instance.service
         * @summary List website/instance.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceServiceList: async (projectId: string, locationId: string, instanceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling websiteProjectInstanceServiceList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling websiteProjectInstanceServiceList.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling websiteProjectInstanceServiceList.');
            }
            const localVarPath = `/website/{locationId}/project/{projectId}/instance/{instanceId}/service`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create website/instance.sideapp
         * @summary Create website/instance.sideapp
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {WebsiteSideapp} websiteSideapp 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceSideappCreate: async (projectId: string, locationId: string, instanceId: string, websiteSideapp: WebsiteSideapp, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling websiteProjectInstanceSideappCreate.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling websiteProjectInstanceSideappCreate.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling websiteProjectInstanceSideappCreate.');
            }
            // verify required parameter 'websiteSideapp' is not null or undefined
            if (websiteSideapp === null || websiteSideapp === undefined) {
                throw new RequiredError('websiteSideapp','Required parameter websiteSideapp was null or undefined when calling websiteProjectInstanceSideappCreate.');
            }
            const localVarPath = `/website/{locationId}/project/{projectId}/instance/{instanceId}/sideapp`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof websiteSideapp !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(websiteSideapp !== undefined ? websiteSideapp : {}) : (websiteSideapp || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete website/instance.sideapp
         * @summary Delete website/instance.sideapp
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} sideappId sideappId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceSideappDelete: async (projectId: string, locationId: string, instanceId: string, sideappId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling websiteProjectInstanceSideappDelete.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling websiteProjectInstanceSideappDelete.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling websiteProjectInstanceSideappDelete.');
            }
            // verify required parameter 'sideappId' is not null or undefined
            if (sideappId === null || sideappId === undefined) {
                throw new RequiredError('sideappId','Required parameter sideappId was null or undefined when calling websiteProjectInstanceSideappDelete.');
            }
            const localVarPath = `/website/{locationId}/project/{projectId}/instance/{instanceId}/sideapp/{sideappId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"sideappId"}}`, encodeURIComponent(String(sideappId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get website/instance.sideapp
         * @summary Get website/instance.sideapp
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} sideappId sideappId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceSideappGet: async (projectId: string, locationId: string, instanceId: string, sideappId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling websiteProjectInstanceSideappGet.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling websiteProjectInstanceSideappGet.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling websiteProjectInstanceSideappGet.');
            }
            // verify required parameter 'sideappId' is not null or undefined
            if (sideappId === null || sideappId === undefined) {
                throw new RequiredError('sideappId','Required parameter sideappId was null or undefined when calling websiteProjectInstanceSideappGet.');
            }
            const localVarPath = `/website/{locationId}/project/{projectId}/instance/{instanceId}/sideapp/{sideappId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"sideappId"}}`, encodeURIComponent(String(sideappId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List website/instance.sideapp
         * @summary List website/instance.sideapp
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceSideappList: async (projectId: string, locationId: string, instanceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling websiteProjectInstanceSideappList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling websiteProjectInstanceSideappList.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling websiteProjectInstanceSideappList.');
            }
            const localVarPath = `/website/{locationId}/project/{projectId}/instance/{instanceId}/sideapp`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create website/instance.snapshot
         * @summary Create website/instance.snapshot
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {WebsiteSnapshot} websiteSnapshot 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceSnapshotCreate: async (projectId: string, locationId: string, instanceId: string, websiteSnapshot: WebsiteSnapshot, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling websiteProjectInstanceSnapshotCreate.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling websiteProjectInstanceSnapshotCreate.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling websiteProjectInstanceSnapshotCreate.');
            }
            // verify required parameter 'websiteSnapshot' is not null or undefined
            if (websiteSnapshot === null || websiteSnapshot === undefined) {
                throw new RequiredError('websiteSnapshot','Required parameter websiteSnapshot was null or undefined when calling websiteProjectInstanceSnapshotCreate.');
            }
            const localVarPath = `/website/{locationId}/project/{projectId}/instance/{instanceId}/snapshot`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof websiteSnapshot !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(websiteSnapshot !== undefined ? websiteSnapshot : {}) : (websiteSnapshot || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete website/instance.snapshot
         * @summary Delete website/instance.snapshot
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} snapshotId snapshotId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceSnapshotDelete: async (projectId: string, locationId: string, instanceId: string, snapshotId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling websiteProjectInstanceSnapshotDelete.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling websiteProjectInstanceSnapshotDelete.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling websiteProjectInstanceSnapshotDelete.');
            }
            // verify required parameter 'snapshotId' is not null or undefined
            if (snapshotId === null || snapshotId === undefined) {
                throw new RequiredError('snapshotId','Required parameter snapshotId was null or undefined when calling websiteProjectInstanceSnapshotDelete.');
            }
            const localVarPath = `/website/{locationId}/project/{projectId}/instance/{instanceId}/snapshot/{snapshotId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"snapshotId"}}`, encodeURIComponent(String(snapshotId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * action download
         * @summary Download website/instance.snapshot
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} snapshotId snapshotId
         * @param {WebsiteProjectInstanceSnapshotDownload} websiteProjectInstanceSnapshotDownload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceSnapshotDownload: async (projectId: string, locationId: string, instanceId: string, snapshotId: string, websiteProjectInstanceSnapshotDownload: WebsiteProjectInstanceSnapshotDownload, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling websiteProjectInstanceSnapshotDownload.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling websiteProjectInstanceSnapshotDownload.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling websiteProjectInstanceSnapshotDownload.');
            }
            // verify required parameter 'snapshotId' is not null or undefined
            if (snapshotId === null || snapshotId === undefined) {
                throw new RequiredError('snapshotId','Required parameter snapshotId was null or undefined when calling websiteProjectInstanceSnapshotDownload.');
            }
            // verify required parameter 'websiteProjectInstanceSnapshotDownload' is not null or undefined
            if (websiteProjectInstanceSnapshotDownload === null || websiteProjectInstanceSnapshotDownload === undefined) {
                throw new RequiredError('websiteProjectInstanceSnapshotDownload','Required parameter websiteProjectInstanceSnapshotDownload was null or undefined when calling websiteProjectInstanceSnapshotDownload.');
            }
            const localVarPath = `/website/{locationId}/project/{projectId}/instance/{instanceId}/snapshot/{snapshotId}/actions/download`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"snapshotId"}}`, encodeURIComponent(String(snapshotId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof websiteProjectInstanceSnapshotDownload !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(websiteProjectInstanceSnapshotDownload !== undefined ? websiteProjectInstanceSnapshotDownload : {}) : (websiteProjectInstanceSnapshotDownload || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get website/instance.snapshot
         * @summary Get website/instance.snapshot
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} snapshotId snapshotId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceSnapshotGet: async (projectId: string, locationId: string, instanceId: string, snapshotId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling websiteProjectInstanceSnapshotGet.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling websiteProjectInstanceSnapshotGet.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling websiteProjectInstanceSnapshotGet.');
            }
            // verify required parameter 'snapshotId' is not null or undefined
            if (snapshotId === null || snapshotId === undefined) {
                throw new RequiredError('snapshotId','Required parameter snapshotId was null or undefined when calling websiteProjectInstanceSnapshotGet.');
            }
            const localVarPath = `/website/{locationId}/project/{projectId}/instance/{instanceId}/snapshot/{snapshotId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"snapshotId"}}`, encodeURIComponent(String(snapshotId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List website/instance.snapshot
         * @summary List website/instance.snapshot
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceSnapshotList: async (projectId: string, locationId: string, instanceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling websiteProjectInstanceSnapshotList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling websiteProjectInstanceSnapshotList.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling websiteProjectInstanceSnapshotList.');
            }
            const localVarPath = `/website/{locationId}/project/{projectId}/instance/{instanceId}/snapshot`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * action start
         * @summary Start website/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceStart: async (projectId: string, locationId: string, instanceId: string, xIdempotencyKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling websiteProjectInstanceStart.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling websiteProjectInstanceStart.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling websiteProjectInstanceStart.');
            }
            const localVarPath = `/website/{locationId}/project/{projectId}/instance/{instanceId}/actions/start`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * action stop
         * @summary Stop website/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceStop: async (projectId: string, locationId: string, instanceId: string, xIdempotencyKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling websiteProjectInstanceStop.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling websiteProjectInstanceStop.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling websiteProjectInstanceStop.');
            }
            const localVarPath = `/website/{locationId}/project/{projectId}/instance/{instanceId}/actions/stop`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create website/instance.tag
         * @summary Create website/instance.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceTagCreate: async (projectId: string, locationId: string, instanceId: string, tag: Tag, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling websiteProjectInstanceTagCreate.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling websiteProjectInstanceTagCreate.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling websiteProjectInstanceTagCreate.');
            }
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling websiteProjectInstanceTagCreate.');
            }
            const localVarPath = `/website/{locationId}/project/{projectId}/instance/{instanceId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof tag !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(tag !== undefined ? tag : {}) : (tag || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete website/instance.tag
         * @summary Delete website/instance.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceTagDelete: async (projectId: string, locationId: string, instanceId: string, tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling websiteProjectInstanceTagDelete.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling websiteProjectInstanceTagDelete.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling websiteProjectInstanceTagDelete.');
            }
            // verify required parameter 'tagId' is not null or undefined
            if (tagId === null || tagId === undefined) {
                throw new RequiredError('tagId','Required parameter tagId was null or undefined when calling websiteProjectInstanceTagDelete.');
            }
            const localVarPath = `/website/{locationId}/project/{projectId}/instance/{instanceId}/tag/{tagId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get website/instance.tag
         * @summary Get website/instance.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceTagGet: async (projectId: string, locationId: string, instanceId: string, tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling websiteProjectInstanceTagGet.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling websiteProjectInstanceTagGet.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling websiteProjectInstanceTagGet.');
            }
            // verify required parameter 'tagId' is not null or undefined
            if (tagId === null || tagId === undefined) {
                throw new RequiredError('tagId','Required parameter tagId was null or undefined when calling websiteProjectInstanceTagGet.');
            }
            const localVarPath = `/website/{locationId}/project/{projectId}/instance/{instanceId}/tag/{tagId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List website/instance.tag
         * @summary List website/instance.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceTagList: async (projectId: string, locationId: string, instanceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling websiteProjectInstanceTagList.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling websiteProjectInstanceTagList.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling websiteProjectInstanceTagList.');
            }
            const localVarPath = `/website/{locationId}/project/{projectId}/instance/{instanceId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replace website/instance.tag
         * @summary Replace website/instance.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceTagPut: async (projectId: string, locationId: string, instanceId: string, tag: Array<Tag>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling websiteProjectInstanceTagPut.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling websiteProjectInstanceTagPut.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling websiteProjectInstanceTagPut.');
            }
            // verify required parameter 'tag' is not null or undefined
            if (tag === null || tag === undefined) {
                throw new RequiredError('tag','Required parameter tag was null or undefined when calling websiteProjectInstanceTagPut.');
            }
            const localVarPath = `/website/{locationId}/project/{projectId}/instance/{instanceId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof tag !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(tag !== undefined ? tag : {}) : (tag || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * action transfer
         * @summary Transfer website/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {WebsiteProjectInstanceTransfer} websiteProjectInstanceTransfer 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceTransfer: async (projectId: string, locationId: string, instanceId: string, websiteProjectInstanceTransfer: WebsiteProjectInstanceTransfer, xIdempotencyKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling websiteProjectInstanceTransfer.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling websiteProjectInstanceTransfer.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling websiteProjectInstanceTransfer.');
            }
            // verify required parameter 'websiteProjectInstanceTransfer' is not null or undefined
            if (websiteProjectInstanceTransfer === null || websiteProjectInstanceTransfer === undefined) {
                throw new RequiredError('websiteProjectInstanceTransfer','Required parameter websiteProjectInstanceTransfer was null or undefined when calling websiteProjectInstanceTransfer.');
            }
            const localVarPath = `/website/{locationId}/project/{projectId}/instance/{instanceId}/actions/transfer`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof websiteProjectInstanceTransfer !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(websiteProjectInstanceTransfer !== undefined ? websiteProjectInstanceTransfer : {}) : (websiteProjectInstanceTransfer || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns modified instance
         * @summary Update website/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {WebsiteProjectInstanceUpdate} websiteProjectInstanceUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceUpdate: async (projectId: string, locationId: string, instanceId: string, websiteProjectInstanceUpdate: WebsiteProjectInstanceUpdate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            if (projectId === null || projectId === undefined) {
                throw new RequiredError('projectId','Required parameter projectId was null or undefined when calling websiteProjectInstanceUpdate.');
            }
            // verify required parameter 'locationId' is not null or undefined
            if (locationId === null || locationId === undefined) {
                throw new RequiredError('locationId','Required parameter locationId was null or undefined when calling websiteProjectInstanceUpdate.');
            }
            // verify required parameter 'instanceId' is not null or undefined
            if (instanceId === null || instanceId === undefined) {
                throw new RequiredError('instanceId','Required parameter instanceId was null or undefined when calling websiteProjectInstanceUpdate.');
            }
            // verify required parameter 'websiteProjectInstanceUpdate' is not null or undefined
            if (websiteProjectInstanceUpdate === null || websiteProjectInstanceUpdate === undefined) {
                throw new RequiredError('websiteProjectInstanceUpdate','Required parameter websiteProjectInstanceUpdate was null or undefined when calling websiteProjectInstanceUpdate.');
            }
            const localVarPath = `/website/{locationId}/project/{projectId}/instance/{instanceId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            if (configuration && configuration.accessToken) {
                const accessToken = typeof configuration.accessToken === 'function'
                    ? configuration.accessToken()
                    : configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + accessToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = {...localVarUrlObj.query, ...localVarQueryParameter, ...options.query};
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            const needsSerialization = (typeof websiteProjectInstanceUpdate !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.data =  needsSerialization ? JSON.stringify(websiteProjectInstanceUpdate !== undefined ? websiteProjectInstanceUpdate : {}) : (websiteProjectInstanceUpdate || "");

            return {
                url: globalImportUrl.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WebsiteProjectInstanceApi - functional programming interface
 * @export
 */
export const WebsiteProjectInstanceApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get website/instance.connect
         * @summary Get website/instance.connect
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} connectId connectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websiteProjectInstanceConnectGet(projectId: string, locationId: string, instanceId: string, connectId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceConnect>> {
            const localVarAxiosArgs = await WebsiteProjectInstanceApiAxiosParamCreator(configuration).websiteProjectInstanceConnectGet(projectId, locationId, instanceId, connectId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List website/instance.connect
         * @summary List website/instance.connect
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websiteProjectInstanceConnectList(projectId: string, locationId: string, instanceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResourceConnect>>> {
            const localVarAxiosArgs = await WebsiteProjectInstanceApiAxiosParamCreator(configuration).websiteProjectInstanceConnectList(projectId, locationId, instanceId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create instance
         * @summary Create website/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {WebsiteProjectInstanceCreate} websiteProjectInstanceCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websiteProjectInstanceCreate(projectId: string, locationId: string, websiteProjectInstanceCreate: WebsiteProjectInstanceCreate, xIdempotencyKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Website>> {
            const localVarAxiosArgs = await WebsiteProjectInstanceApiAxiosParamCreator(configuration).websiteProjectInstanceCreate(projectId, locationId, websiteProjectInstanceCreate, xIdempotencyKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create website/instance.credential
         * @summary Create website/instance.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {WebsiteCredential} websiteCredential 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websiteProjectInstanceCredentialCreate(projectId: string, locationId: string, instanceId: string, websiteCredential: WebsiteCredential, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebsiteCredential>> {
            const localVarAxiosArgs = await WebsiteProjectInstanceApiAxiosParamCreator(configuration).websiteProjectInstanceCredentialCreate(projectId, locationId, instanceId, websiteCredential, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete website/instance.credential
         * @summary Delete website/instance.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} credentialId credentialId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websiteProjectInstanceCredentialDelete(projectId: string, locationId: string, instanceId: string, credentialId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Website>> {
            const localVarAxiosArgs = await WebsiteProjectInstanceApiAxiosParamCreator(configuration).websiteProjectInstanceCredentialDelete(projectId, locationId, instanceId, credentialId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get website/instance.credential
         * @summary Get website/instance.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} credentialId credentialId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websiteProjectInstanceCredentialGet(projectId: string, locationId: string, instanceId: string, credentialId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebsiteCredential>> {
            const localVarAxiosArgs = await WebsiteProjectInstanceApiAxiosParamCreator(configuration).websiteProjectInstanceCredentialGet(projectId, locationId, instanceId, credentialId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List website/instance.credential
         * @summary List website/instance.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websiteProjectInstanceCredentialList(projectId: string, locationId: string, instanceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WebsiteCredential>>> {
            const localVarAxiosArgs = await WebsiteProjectInstanceApiAxiosParamCreator(configuration).websiteProjectInstanceCredentialList(projectId, locationId, instanceId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Update website/instance.credential
         * @summary Update website/instance.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} credentialId credentialId
         * @param {WebsiteProjectInstanceCredentialPatch} websiteProjectInstanceCredentialPatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websiteProjectInstanceCredentialPatch(projectId: string, locationId: string, instanceId: string, credentialId: string, websiteProjectInstanceCredentialPatch: WebsiteProjectInstanceCredentialPatch, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebsiteCredential>> {
            const localVarAxiosArgs = await WebsiteProjectInstanceApiAxiosParamCreator(configuration).websiteProjectInstanceCredentialPatch(projectId, locationId, instanceId, credentialId, websiteProjectInstanceCredentialPatch, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete instance
         * @summary Delete website/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websiteProjectInstanceDelete(projectId: string, locationId: string, instanceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await WebsiteProjectInstanceApiAxiosParamCreator(configuration).websiteProjectInstanceDelete(projectId, locationId, instanceId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create website/instance.domain
         * @summary Create website/instance.domain
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {Domain} domain 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websiteProjectInstanceDomainCreate(projectId: string, locationId: string, instanceId: string, domain: Domain, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Domain>> {
            const localVarAxiosArgs = await WebsiteProjectInstanceApiAxiosParamCreator(configuration).websiteProjectInstanceDomainCreate(projectId, locationId, instanceId, domain, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete website/instance.domain
         * @summary Delete website/instance.domain
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} domainId domainId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websiteProjectInstanceDomainDelete(projectId: string, locationId: string, instanceId: string, domainId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await WebsiteProjectInstanceApiAxiosParamCreator(configuration).websiteProjectInstanceDomainDelete(projectId, locationId, instanceId, domainId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get website/instance.domain
         * @summary Get website/instance.domain
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} domainId domainId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websiteProjectInstanceDomainGet(projectId: string, locationId: string, instanceId: string, domainId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Domain>> {
            const localVarAxiosArgs = await WebsiteProjectInstanceApiAxiosParamCreator(configuration).websiteProjectInstanceDomainGet(projectId, locationId, instanceId, domainId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List website/instance.domain
         * @summary List website/instance.domain
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websiteProjectInstanceDomainList(projectId: string, locationId: string, instanceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Domain>>> {
            const localVarAxiosArgs = await WebsiteProjectInstanceApiAxiosParamCreator(configuration).websiteProjectInstanceDomainList(projectId, locationId, instanceId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create website/instance.env
         * @summary Create website/instance.env
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {WebsiteEnv} websiteEnv 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websiteProjectInstanceEnvCreate(projectId: string, locationId: string, instanceId: string, websiteEnv: WebsiteEnv, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebsiteEnv>> {
            const localVarAxiosArgs = await WebsiteProjectInstanceApiAxiosParamCreator(configuration).websiteProjectInstanceEnvCreate(projectId, locationId, instanceId, websiteEnv, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete website/instance.env
         * @summary Delete website/instance.env
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} envId envId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websiteProjectInstanceEnvDelete(projectId: string, locationId: string, instanceId: string, envId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await WebsiteProjectInstanceApiAxiosParamCreator(configuration).websiteProjectInstanceEnvDelete(projectId, locationId, instanceId, envId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get website/instance.env
         * @summary Get website/instance.env
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} envId envId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websiteProjectInstanceEnvGet(projectId: string, locationId: string, instanceId: string, envId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebsiteEnv>> {
            const localVarAxiosArgs = await WebsiteProjectInstanceApiAxiosParamCreator(configuration).websiteProjectInstanceEnvGet(projectId, locationId, instanceId, envId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List website/instance.env
         * @summary List website/instance.env
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websiteProjectInstanceEnvList(projectId: string, locationId: string, instanceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WebsiteEnv>>> {
            const localVarAxiosArgs = await WebsiteProjectInstanceApiAxiosParamCreator(configuration).websiteProjectInstanceEnvList(projectId, locationId, instanceId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get website/instance.event
         * @summary Get website/instance.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websiteProjectInstanceEventGet(projectId: string, locationId: string, instanceId: string, eventId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>> {
            const localVarAxiosArgs = await WebsiteProjectInstanceApiAxiosParamCreator(configuration).websiteProjectInstanceEventGet(projectId, locationId, instanceId, eventId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List website/instance.event
         * @summary List website/instance.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websiteProjectInstanceEventList(projectId: string, locationId: string, instanceId: string, $limit?: number, $skip?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Event>>> {
            const localVarAxiosArgs = await WebsiteProjectInstanceApiAxiosParamCreator(configuration).websiteProjectInstanceEventList(projectId, locationId, instanceId, $limit, $skip, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns a single instance
         * @summary Get website/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websiteProjectInstanceGet(projectId: string, locationId: string, instanceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Website>> {
            const localVarAxiosArgs = await WebsiteProjectInstanceApiAxiosParamCreator(configuration).websiteProjectInstanceGet(projectId, locationId, instanceId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create website/instance.link
         * @summary Create website/instance.link
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {WebsiteLink} websiteLink 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websiteProjectInstanceLinkCreate(projectId: string, locationId: string, instanceId: string, websiteLink: WebsiteLink, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebsiteLink>> {
            const localVarAxiosArgs = await WebsiteProjectInstanceApiAxiosParamCreator(configuration).websiteProjectInstanceLinkCreate(projectId, locationId, instanceId, websiteLink, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete website/instance.link
         * @summary Delete website/instance.link
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} linkId linkId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websiteProjectInstanceLinkDelete(projectId: string, locationId: string, instanceId: string, linkId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await WebsiteProjectInstanceApiAxiosParamCreator(configuration).websiteProjectInstanceLinkDelete(projectId, locationId, instanceId, linkId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get website/instance.link
         * @summary Get website/instance.link
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} linkId linkId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websiteProjectInstanceLinkGet(projectId: string, locationId: string, instanceId: string, linkId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebsiteLink>> {
            const localVarAxiosArgs = await WebsiteProjectInstanceApiAxiosParamCreator(configuration).websiteProjectInstanceLinkGet(projectId, locationId, instanceId, linkId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List website/instance.link
         * @summary List website/instance.link
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websiteProjectInstanceLinkList(projectId: string, locationId: string, instanceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WebsiteLink>>> {
            const localVarAxiosArgs = await WebsiteProjectInstanceApiAxiosParamCreator(configuration).websiteProjectInstanceLinkList(projectId, locationId, instanceId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List instance
         * @summary List website/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [name] Filter by name
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websiteProjectInstanceList(projectId: string, locationId: string, name?: string, tagValue?: string, tagKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Website>>> {
            const localVarAxiosArgs = await WebsiteProjectInstanceApiAxiosParamCreator(configuration).websiteProjectInstanceList(projectId, locationId, name, tagValue, tagKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get website/instance.log
         * @summary Get website/instance.log
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} logId logId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websiteProjectInstanceLogGet(projectId: string, locationId: string, instanceId: string, logId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Log>> {
            const localVarAxiosArgs = await WebsiteProjectInstanceApiAxiosParamCreator(configuration).websiteProjectInstanceLogGet(projectId, locationId, instanceId, logId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List website/instance.log
         * @summary List website/instance.log
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websiteProjectInstanceLogList(projectId: string, locationId: string, instanceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Log>>> {
            const localVarAxiosArgs = await WebsiteProjectInstanceApiAxiosParamCreator(configuration).websiteProjectInstanceLogList(projectId, locationId, instanceId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * action read
         * @summary Read website/instance.log
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} logId logId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websiteProjectInstanceLogRead(projectId: string, locationId: string, instanceId: string, logId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await WebsiteProjectInstanceApiAxiosParamCreator(configuration).websiteProjectInstanceLogRead(projectId, locationId, instanceId, logId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get website/instance.metric
         * @summary Get website/instance.metric
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} metricId metricId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websiteProjectInstanceMetricGet(projectId: string, locationId: string, instanceId: string, metricId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Metric>> {
            const localVarAxiosArgs = await WebsiteProjectInstanceApiAxiosParamCreator(configuration).websiteProjectInstanceMetricGet(projectId, locationId, instanceId, metricId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List website/instance.metric
         * @summary List website/instance.metric
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websiteProjectInstanceMetricList(projectId: string, locationId: string, instanceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Metric>>> {
            const localVarAxiosArgs = await WebsiteProjectInstanceApiAxiosParamCreator(configuration).websiteProjectInstanceMetricList(projectId, locationId, instanceId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List website/instance.point
         * @summary List website/instance.point
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} metricId metricId
         * @param {string} [interval] interval
         * @param {string} [timespan] timespan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websiteProjectInstanceMetricPointList(projectId: string, locationId: string, instanceId: string, metricId: string, interval?: string, timespan?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Point>>> {
            const localVarAxiosArgs = await WebsiteProjectInstanceApiAxiosParamCreator(configuration).websiteProjectInstanceMetricPointList(projectId, locationId, instanceId, metricId, interval, timespan, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * action restart
         * @summary Restart website/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websiteProjectInstanceRestart(projectId: string, locationId: string, instanceId: string, xIdempotencyKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Website>> {
            const localVarAxiosArgs = await WebsiteProjectInstanceApiAxiosParamCreator(configuration).websiteProjectInstanceRestart(projectId, locationId, instanceId, xIdempotencyKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get website/instance.service
         * @summary Get website/instance.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websiteProjectInstanceServiceGet(projectId: string, locationId: string, instanceId: string, serviceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceService>> {
            const localVarAxiosArgs = await WebsiteProjectInstanceApiAxiosParamCreator(configuration).websiteProjectInstanceServiceGet(projectId, locationId, instanceId, serviceId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List website/instance.service
         * @summary List website/instance.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websiteProjectInstanceServiceList(projectId: string, locationId: string, instanceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResourceService>>> {
            const localVarAxiosArgs = await WebsiteProjectInstanceApiAxiosParamCreator(configuration).websiteProjectInstanceServiceList(projectId, locationId, instanceId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create website/instance.sideapp
         * @summary Create website/instance.sideapp
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {WebsiteSideapp} websiteSideapp 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websiteProjectInstanceSideappCreate(projectId: string, locationId: string, instanceId: string, websiteSideapp: WebsiteSideapp, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebsiteSideapp>> {
            const localVarAxiosArgs = await WebsiteProjectInstanceApiAxiosParamCreator(configuration).websiteProjectInstanceSideappCreate(projectId, locationId, instanceId, websiteSideapp, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete website/instance.sideapp
         * @summary Delete website/instance.sideapp
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} sideappId sideappId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websiteProjectInstanceSideappDelete(projectId: string, locationId: string, instanceId: string, sideappId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await WebsiteProjectInstanceApiAxiosParamCreator(configuration).websiteProjectInstanceSideappDelete(projectId, locationId, instanceId, sideappId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get website/instance.sideapp
         * @summary Get website/instance.sideapp
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} sideappId sideappId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websiteProjectInstanceSideappGet(projectId: string, locationId: string, instanceId: string, sideappId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebsiteSideapp>> {
            const localVarAxiosArgs = await WebsiteProjectInstanceApiAxiosParamCreator(configuration).websiteProjectInstanceSideappGet(projectId, locationId, instanceId, sideappId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List website/instance.sideapp
         * @summary List website/instance.sideapp
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websiteProjectInstanceSideappList(projectId: string, locationId: string, instanceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WebsiteSideapp>>> {
            const localVarAxiosArgs = await WebsiteProjectInstanceApiAxiosParamCreator(configuration).websiteProjectInstanceSideappList(projectId, locationId, instanceId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create website/instance.snapshot
         * @summary Create website/instance.snapshot
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {WebsiteSnapshot} websiteSnapshot 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websiteProjectInstanceSnapshotCreate(projectId: string, locationId: string, instanceId: string, websiteSnapshot: WebsiteSnapshot, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebsiteSnapshot>> {
            const localVarAxiosArgs = await WebsiteProjectInstanceApiAxiosParamCreator(configuration).websiteProjectInstanceSnapshotCreate(projectId, locationId, instanceId, websiteSnapshot, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete website/instance.snapshot
         * @summary Delete website/instance.snapshot
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} snapshotId snapshotId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websiteProjectInstanceSnapshotDelete(projectId: string, locationId: string, instanceId: string, snapshotId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Website>> {
            const localVarAxiosArgs = await WebsiteProjectInstanceApiAxiosParamCreator(configuration).websiteProjectInstanceSnapshotDelete(projectId, locationId, instanceId, snapshotId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * action download
         * @summary Download website/instance.snapshot
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} snapshotId snapshotId
         * @param {WebsiteProjectInstanceSnapshotDownload} websiteProjectInstanceSnapshotDownload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websiteProjectInstanceSnapshotDownload(projectId: string, locationId: string, instanceId: string, snapshotId: string, websiteProjectInstanceSnapshotDownload: WebsiteProjectInstanceSnapshotDownload, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await WebsiteProjectInstanceApiAxiosParamCreator(configuration).websiteProjectInstanceSnapshotDownload(projectId, locationId, instanceId, snapshotId, websiteProjectInstanceSnapshotDownload, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get website/instance.snapshot
         * @summary Get website/instance.snapshot
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} snapshotId snapshotId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websiteProjectInstanceSnapshotGet(projectId: string, locationId: string, instanceId: string, snapshotId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebsiteSnapshot>> {
            const localVarAxiosArgs = await WebsiteProjectInstanceApiAxiosParamCreator(configuration).websiteProjectInstanceSnapshotGet(projectId, locationId, instanceId, snapshotId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List website/instance.snapshot
         * @summary List website/instance.snapshot
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websiteProjectInstanceSnapshotList(projectId: string, locationId: string, instanceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WebsiteSnapshot>>> {
            const localVarAxiosArgs = await WebsiteProjectInstanceApiAxiosParamCreator(configuration).websiteProjectInstanceSnapshotList(projectId, locationId, instanceId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * action start
         * @summary Start website/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websiteProjectInstanceStart(projectId: string, locationId: string, instanceId: string, xIdempotencyKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Website>> {
            const localVarAxiosArgs = await WebsiteProjectInstanceApiAxiosParamCreator(configuration).websiteProjectInstanceStart(projectId, locationId, instanceId, xIdempotencyKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * action stop
         * @summary Stop website/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websiteProjectInstanceStop(projectId: string, locationId: string, instanceId: string, xIdempotencyKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Website>> {
            const localVarAxiosArgs = await WebsiteProjectInstanceApiAxiosParamCreator(configuration).websiteProjectInstanceStop(projectId, locationId, instanceId, xIdempotencyKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Create website/instance.tag
         * @summary Create website/instance.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websiteProjectInstanceTagCreate(projectId: string, locationId: string, instanceId: string, tag: Tag, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await WebsiteProjectInstanceApiAxiosParamCreator(configuration).websiteProjectInstanceTagCreate(projectId, locationId, instanceId, tag, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Delete website/instance.tag
         * @summary Delete website/instance.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websiteProjectInstanceTagDelete(projectId: string, locationId: string, instanceId: string, tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await WebsiteProjectInstanceApiAxiosParamCreator(configuration).websiteProjectInstanceTagDelete(projectId, locationId, instanceId, tagId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Get website/instance.tag
         * @summary Get website/instance.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websiteProjectInstanceTagGet(projectId: string, locationId: string, instanceId: string, tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await WebsiteProjectInstanceApiAxiosParamCreator(configuration).websiteProjectInstanceTagGet(projectId, locationId, instanceId, tagId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * List website/instance.tag
         * @summary List website/instance.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websiteProjectInstanceTagList(projectId: string, locationId: string, instanceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await WebsiteProjectInstanceApiAxiosParamCreator(configuration).websiteProjectInstanceTagList(projectId, locationId, instanceId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Replace website/instance.tag
         * @summary Replace website/instance.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websiteProjectInstanceTagPut(projectId: string, locationId: string, instanceId: string, tag: Array<Tag>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await WebsiteProjectInstanceApiAxiosParamCreator(configuration).websiteProjectInstanceTagPut(projectId, locationId, instanceId, tag, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * action transfer
         * @summary Transfer website/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {WebsiteProjectInstanceTransfer} websiteProjectInstanceTransfer 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websiteProjectInstanceTransfer(projectId: string, locationId: string, instanceId: string, websiteProjectInstanceTransfer: WebsiteProjectInstanceTransfer, xIdempotencyKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Website>> {
            const localVarAxiosArgs = await WebsiteProjectInstanceApiAxiosParamCreator(configuration).websiteProjectInstanceTransfer(projectId, locationId, instanceId, websiteProjectInstanceTransfer, xIdempotencyKey, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Returns modified instance
         * @summary Update website/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {WebsiteProjectInstanceUpdate} websiteProjectInstanceUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websiteProjectInstanceUpdate(projectId: string, locationId: string, instanceId: string, websiteProjectInstanceUpdate: WebsiteProjectInstanceUpdate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Website>> {
            const localVarAxiosArgs = await WebsiteProjectInstanceApiAxiosParamCreator(configuration).websiteProjectInstanceUpdate(projectId, locationId, instanceId, websiteProjectInstanceUpdate, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * WebsiteProjectInstanceApi - factory interface
 * @export
 */
export const WebsiteProjectInstanceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Get website/instance.connect
         * @summary Get website/instance.connect
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} connectId connectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceConnectGet(projectId: string, locationId: string, instanceId: string, connectId: string, options?: any): AxiosPromise<ResourceConnect> {
            return WebsiteProjectInstanceApiFp(configuration).websiteProjectInstanceConnectGet(projectId, locationId, instanceId, connectId, options).then((request) => request(axios, basePath));
        },
        /**
         * List website/instance.connect
         * @summary List website/instance.connect
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceConnectList(projectId: string, locationId: string, instanceId: string, options?: any): AxiosPromise<Array<ResourceConnect>> {
            return WebsiteProjectInstanceApiFp(configuration).websiteProjectInstanceConnectList(projectId, locationId, instanceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create instance
         * @summary Create website/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {WebsiteProjectInstanceCreate} websiteProjectInstanceCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceCreate(projectId: string, locationId: string, websiteProjectInstanceCreate: WebsiteProjectInstanceCreate, xIdempotencyKey?: string, options?: any): AxiosPromise<Website> {
            return WebsiteProjectInstanceApiFp(configuration).websiteProjectInstanceCreate(projectId, locationId, websiteProjectInstanceCreate, xIdempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Create website/instance.credential
         * @summary Create website/instance.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {WebsiteCredential} websiteCredential 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceCredentialCreate(projectId: string, locationId: string, instanceId: string, websiteCredential: WebsiteCredential, options?: any): AxiosPromise<WebsiteCredential> {
            return WebsiteProjectInstanceApiFp(configuration).websiteProjectInstanceCredentialCreate(projectId, locationId, instanceId, websiteCredential, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete website/instance.credential
         * @summary Delete website/instance.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} credentialId credentialId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceCredentialDelete(projectId: string, locationId: string, instanceId: string, credentialId: string, options?: any): AxiosPromise<Website> {
            return WebsiteProjectInstanceApiFp(configuration).websiteProjectInstanceCredentialDelete(projectId, locationId, instanceId, credentialId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get website/instance.credential
         * @summary Get website/instance.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} credentialId credentialId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceCredentialGet(projectId: string, locationId: string, instanceId: string, credentialId: string, options?: any): AxiosPromise<WebsiteCredential> {
            return WebsiteProjectInstanceApiFp(configuration).websiteProjectInstanceCredentialGet(projectId, locationId, instanceId, credentialId, options).then((request) => request(axios, basePath));
        },
        /**
         * List website/instance.credential
         * @summary List website/instance.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceCredentialList(projectId: string, locationId: string, instanceId: string, options?: any): AxiosPromise<Array<WebsiteCredential>> {
            return WebsiteProjectInstanceApiFp(configuration).websiteProjectInstanceCredentialList(projectId, locationId, instanceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update website/instance.credential
         * @summary Update website/instance.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} credentialId credentialId
         * @param {WebsiteProjectInstanceCredentialPatch} websiteProjectInstanceCredentialPatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceCredentialPatch(projectId: string, locationId: string, instanceId: string, credentialId: string, websiteProjectInstanceCredentialPatch: WebsiteProjectInstanceCredentialPatch, options?: any): AxiosPromise<WebsiteCredential> {
            return WebsiteProjectInstanceApiFp(configuration).websiteProjectInstanceCredentialPatch(projectId, locationId, instanceId, credentialId, websiteProjectInstanceCredentialPatch, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete instance
         * @summary Delete website/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceDelete(projectId: string, locationId: string, instanceId: string, options?: any): AxiosPromise<void> {
            return WebsiteProjectInstanceApiFp(configuration).websiteProjectInstanceDelete(projectId, locationId, instanceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create website/instance.domain
         * @summary Create website/instance.domain
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {Domain} domain 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceDomainCreate(projectId: string, locationId: string, instanceId: string, domain: Domain, options?: any): AxiosPromise<Domain> {
            return WebsiteProjectInstanceApiFp(configuration).websiteProjectInstanceDomainCreate(projectId, locationId, instanceId, domain, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete website/instance.domain
         * @summary Delete website/instance.domain
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} domainId domainId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceDomainDelete(projectId: string, locationId: string, instanceId: string, domainId: string, options?: any): AxiosPromise<void> {
            return WebsiteProjectInstanceApiFp(configuration).websiteProjectInstanceDomainDelete(projectId, locationId, instanceId, domainId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get website/instance.domain
         * @summary Get website/instance.domain
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} domainId domainId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceDomainGet(projectId: string, locationId: string, instanceId: string, domainId: string, options?: any): AxiosPromise<Domain> {
            return WebsiteProjectInstanceApiFp(configuration).websiteProjectInstanceDomainGet(projectId, locationId, instanceId, domainId, options).then((request) => request(axios, basePath));
        },
        /**
         * List website/instance.domain
         * @summary List website/instance.domain
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceDomainList(projectId: string, locationId: string, instanceId: string, options?: any): AxiosPromise<Array<Domain>> {
            return WebsiteProjectInstanceApiFp(configuration).websiteProjectInstanceDomainList(projectId, locationId, instanceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create website/instance.env
         * @summary Create website/instance.env
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {WebsiteEnv} websiteEnv 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceEnvCreate(projectId: string, locationId: string, instanceId: string, websiteEnv: WebsiteEnv, options?: any): AxiosPromise<WebsiteEnv> {
            return WebsiteProjectInstanceApiFp(configuration).websiteProjectInstanceEnvCreate(projectId, locationId, instanceId, websiteEnv, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete website/instance.env
         * @summary Delete website/instance.env
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} envId envId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceEnvDelete(projectId: string, locationId: string, instanceId: string, envId: string, options?: any): AxiosPromise<void> {
            return WebsiteProjectInstanceApiFp(configuration).websiteProjectInstanceEnvDelete(projectId, locationId, instanceId, envId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get website/instance.env
         * @summary Get website/instance.env
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} envId envId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceEnvGet(projectId: string, locationId: string, instanceId: string, envId: string, options?: any): AxiosPromise<WebsiteEnv> {
            return WebsiteProjectInstanceApiFp(configuration).websiteProjectInstanceEnvGet(projectId, locationId, instanceId, envId, options).then((request) => request(axios, basePath));
        },
        /**
         * List website/instance.env
         * @summary List website/instance.env
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceEnvList(projectId: string, locationId: string, instanceId: string, options?: any): AxiosPromise<Array<WebsiteEnv>> {
            return WebsiteProjectInstanceApiFp(configuration).websiteProjectInstanceEnvList(projectId, locationId, instanceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get website/instance.event
         * @summary Get website/instance.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceEventGet(projectId: string, locationId: string, instanceId: string, eventId: string, options?: any): AxiosPromise<Event> {
            return WebsiteProjectInstanceApiFp(configuration).websiteProjectInstanceEventGet(projectId, locationId, instanceId, eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * List website/instance.event
         * @summary List website/instance.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceEventList(projectId: string, locationId: string, instanceId: string, $limit?: number, $skip?: number, options?: any): AxiosPromise<Array<Event>> {
            return WebsiteProjectInstanceApiFp(configuration).websiteProjectInstanceEventList(projectId, locationId, instanceId, $limit, $skip, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single instance
         * @summary Get website/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceGet(projectId: string, locationId: string, instanceId: string, options?: any): AxiosPromise<Website> {
            return WebsiteProjectInstanceApiFp(configuration).websiteProjectInstanceGet(projectId, locationId, instanceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create website/instance.link
         * @summary Create website/instance.link
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {WebsiteLink} websiteLink 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceLinkCreate(projectId: string, locationId: string, instanceId: string, websiteLink: WebsiteLink, options?: any): AxiosPromise<WebsiteLink> {
            return WebsiteProjectInstanceApiFp(configuration).websiteProjectInstanceLinkCreate(projectId, locationId, instanceId, websiteLink, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete website/instance.link
         * @summary Delete website/instance.link
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} linkId linkId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceLinkDelete(projectId: string, locationId: string, instanceId: string, linkId: string, options?: any): AxiosPromise<void> {
            return WebsiteProjectInstanceApiFp(configuration).websiteProjectInstanceLinkDelete(projectId, locationId, instanceId, linkId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get website/instance.link
         * @summary Get website/instance.link
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} linkId linkId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceLinkGet(projectId: string, locationId: string, instanceId: string, linkId: string, options?: any): AxiosPromise<WebsiteLink> {
            return WebsiteProjectInstanceApiFp(configuration).websiteProjectInstanceLinkGet(projectId, locationId, instanceId, linkId, options).then((request) => request(axios, basePath));
        },
        /**
         * List website/instance.link
         * @summary List website/instance.link
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceLinkList(projectId: string, locationId: string, instanceId: string, options?: any): AxiosPromise<Array<WebsiteLink>> {
            return WebsiteProjectInstanceApiFp(configuration).websiteProjectInstanceLinkList(projectId, locationId, instanceId, options).then((request) => request(axios, basePath));
        },
        /**
         * List instance
         * @summary List website/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [name] Filter by name
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceList(projectId: string, locationId: string, name?: string, tagValue?: string, tagKey?: string, options?: any): AxiosPromise<Array<Website>> {
            return WebsiteProjectInstanceApiFp(configuration).websiteProjectInstanceList(projectId, locationId, name, tagValue, tagKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get website/instance.log
         * @summary Get website/instance.log
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} logId logId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceLogGet(projectId: string, locationId: string, instanceId: string, logId: string, options?: any): AxiosPromise<Log> {
            return WebsiteProjectInstanceApiFp(configuration).websiteProjectInstanceLogGet(projectId, locationId, instanceId, logId, options).then((request) => request(axios, basePath));
        },
        /**
         * List website/instance.log
         * @summary List website/instance.log
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceLogList(projectId: string, locationId: string, instanceId: string, options?: any): AxiosPromise<Array<Log>> {
            return WebsiteProjectInstanceApiFp(configuration).websiteProjectInstanceLogList(projectId, locationId, instanceId, options).then((request) => request(axios, basePath));
        },
        /**
         * action read
         * @summary Read website/instance.log
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} logId logId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceLogRead(projectId: string, locationId: string, instanceId: string, logId: string, options?: any): AxiosPromise<void> {
            return WebsiteProjectInstanceApiFp(configuration).websiteProjectInstanceLogRead(projectId, locationId, instanceId, logId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get website/instance.metric
         * @summary Get website/instance.metric
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} metricId metricId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceMetricGet(projectId: string, locationId: string, instanceId: string, metricId: string, options?: any): AxiosPromise<Metric> {
            return WebsiteProjectInstanceApiFp(configuration).websiteProjectInstanceMetricGet(projectId, locationId, instanceId, metricId, options).then((request) => request(axios, basePath));
        },
        /**
         * List website/instance.metric
         * @summary List website/instance.metric
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceMetricList(projectId: string, locationId: string, instanceId: string, options?: any): AxiosPromise<Array<Metric>> {
            return WebsiteProjectInstanceApiFp(configuration).websiteProjectInstanceMetricList(projectId, locationId, instanceId, options).then((request) => request(axios, basePath));
        },
        /**
         * List website/instance.point
         * @summary List website/instance.point
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} metricId metricId
         * @param {string} [interval] interval
         * @param {string} [timespan] timespan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceMetricPointList(projectId: string, locationId: string, instanceId: string, metricId: string, interval?: string, timespan?: string, options?: any): AxiosPromise<Array<Point>> {
            return WebsiteProjectInstanceApiFp(configuration).websiteProjectInstanceMetricPointList(projectId, locationId, instanceId, metricId, interval, timespan, options).then((request) => request(axios, basePath));
        },
        /**
         * action restart
         * @summary Restart website/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceRestart(projectId: string, locationId: string, instanceId: string, xIdempotencyKey?: string, options?: any): AxiosPromise<Website> {
            return WebsiteProjectInstanceApiFp(configuration).websiteProjectInstanceRestart(projectId, locationId, instanceId, xIdempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get website/instance.service
         * @summary Get website/instance.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceServiceGet(projectId: string, locationId: string, instanceId: string, serviceId: string, options?: any): AxiosPromise<ResourceService> {
            return WebsiteProjectInstanceApiFp(configuration).websiteProjectInstanceServiceGet(projectId, locationId, instanceId, serviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * List website/instance.service
         * @summary List website/instance.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceServiceList(projectId: string, locationId: string, instanceId: string, options?: any): AxiosPromise<Array<ResourceService>> {
            return WebsiteProjectInstanceApiFp(configuration).websiteProjectInstanceServiceList(projectId, locationId, instanceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create website/instance.sideapp
         * @summary Create website/instance.sideapp
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {WebsiteSideapp} websiteSideapp 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceSideappCreate(projectId: string, locationId: string, instanceId: string, websiteSideapp: WebsiteSideapp, options?: any): AxiosPromise<WebsiteSideapp> {
            return WebsiteProjectInstanceApiFp(configuration).websiteProjectInstanceSideappCreate(projectId, locationId, instanceId, websiteSideapp, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete website/instance.sideapp
         * @summary Delete website/instance.sideapp
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} sideappId sideappId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceSideappDelete(projectId: string, locationId: string, instanceId: string, sideappId: string, options?: any): AxiosPromise<void> {
            return WebsiteProjectInstanceApiFp(configuration).websiteProjectInstanceSideappDelete(projectId, locationId, instanceId, sideappId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get website/instance.sideapp
         * @summary Get website/instance.sideapp
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} sideappId sideappId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceSideappGet(projectId: string, locationId: string, instanceId: string, sideappId: string, options?: any): AxiosPromise<WebsiteSideapp> {
            return WebsiteProjectInstanceApiFp(configuration).websiteProjectInstanceSideappGet(projectId, locationId, instanceId, sideappId, options).then((request) => request(axios, basePath));
        },
        /**
         * List website/instance.sideapp
         * @summary List website/instance.sideapp
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceSideappList(projectId: string, locationId: string, instanceId: string, options?: any): AxiosPromise<Array<WebsiteSideapp>> {
            return WebsiteProjectInstanceApiFp(configuration).websiteProjectInstanceSideappList(projectId, locationId, instanceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create website/instance.snapshot
         * @summary Create website/instance.snapshot
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {WebsiteSnapshot} websiteSnapshot 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceSnapshotCreate(projectId: string, locationId: string, instanceId: string, websiteSnapshot: WebsiteSnapshot, options?: any): AxiosPromise<WebsiteSnapshot> {
            return WebsiteProjectInstanceApiFp(configuration).websiteProjectInstanceSnapshotCreate(projectId, locationId, instanceId, websiteSnapshot, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete website/instance.snapshot
         * @summary Delete website/instance.snapshot
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} snapshotId snapshotId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceSnapshotDelete(projectId: string, locationId: string, instanceId: string, snapshotId: string, options?: any): AxiosPromise<Website> {
            return WebsiteProjectInstanceApiFp(configuration).websiteProjectInstanceSnapshotDelete(projectId, locationId, instanceId, snapshotId, options).then((request) => request(axios, basePath));
        },
        /**
         * action download
         * @summary Download website/instance.snapshot
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} snapshotId snapshotId
         * @param {WebsiteProjectInstanceSnapshotDownload} websiteProjectInstanceSnapshotDownload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceSnapshotDownload(projectId: string, locationId: string, instanceId: string, snapshotId: string, websiteProjectInstanceSnapshotDownload: WebsiteProjectInstanceSnapshotDownload, options?: any): AxiosPromise<void> {
            return WebsiteProjectInstanceApiFp(configuration).websiteProjectInstanceSnapshotDownload(projectId, locationId, instanceId, snapshotId, websiteProjectInstanceSnapshotDownload, options).then((request) => request(axios, basePath));
        },
        /**
         * Get website/instance.snapshot
         * @summary Get website/instance.snapshot
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} snapshotId snapshotId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceSnapshotGet(projectId: string, locationId: string, instanceId: string, snapshotId: string, options?: any): AxiosPromise<WebsiteSnapshot> {
            return WebsiteProjectInstanceApiFp(configuration).websiteProjectInstanceSnapshotGet(projectId, locationId, instanceId, snapshotId, options).then((request) => request(axios, basePath));
        },
        /**
         * List website/instance.snapshot
         * @summary List website/instance.snapshot
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceSnapshotList(projectId: string, locationId: string, instanceId: string, options?: any): AxiosPromise<Array<WebsiteSnapshot>> {
            return WebsiteProjectInstanceApiFp(configuration).websiteProjectInstanceSnapshotList(projectId, locationId, instanceId, options).then((request) => request(axios, basePath));
        },
        /**
         * action start
         * @summary Start website/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceStart(projectId: string, locationId: string, instanceId: string, xIdempotencyKey?: string, options?: any): AxiosPromise<Website> {
            return WebsiteProjectInstanceApiFp(configuration).websiteProjectInstanceStart(projectId, locationId, instanceId, xIdempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * action stop
         * @summary Stop website/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceStop(projectId: string, locationId: string, instanceId: string, xIdempotencyKey?: string, options?: any): AxiosPromise<Website> {
            return WebsiteProjectInstanceApiFp(configuration).websiteProjectInstanceStop(projectId, locationId, instanceId, xIdempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Create website/instance.tag
         * @summary Create website/instance.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceTagCreate(projectId: string, locationId: string, instanceId: string, tag: Tag, options?: any): AxiosPromise<Tag> {
            return WebsiteProjectInstanceApiFp(configuration).websiteProjectInstanceTagCreate(projectId, locationId, instanceId, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete website/instance.tag
         * @summary Delete website/instance.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceTagDelete(projectId: string, locationId: string, instanceId: string, tagId: string, options?: any): AxiosPromise<void> {
            return WebsiteProjectInstanceApiFp(configuration).websiteProjectInstanceTagDelete(projectId, locationId, instanceId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get website/instance.tag
         * @summary Get website/instance.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceTagGet(projectId: string, locationId: string, instanceId: string, tagId: string, options?: any): AxiosPromise<Tag> {
            return WebsiteProjectInstanceApiFp(configuration).websiteProjectInstanceTagGet(projectId, locationId, instanceId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * List website/instance.tag
         * @summary List website/instance.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceTagList(projectId: string, locationId: string, instanceId: string, options?: any): AxiosPromise<Array<Tag>> {
            return WebsiteProjectInstanceApiFp(configuration).websiteProjectInstanceTagList(projectId, locationId, instanceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Replace website/instance.tag
         * @summary Replace website/instance.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceTagPut(projectId: string, locationId: string, instanceId: string, tag: Array<Tag>, options?: any): AxiosPromise<Array<Tag>> {
            return WebsiteProjectInstanceApiFp(configuration).websiteProjectInstanceTagPut(projectId, locationId, instanceId, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * action transfer
         * @summary Transfer website/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {WebsiteProjectInstanceTransfer} websiteProjectInstanceTransfer 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceTransfer(projectId: string, locationId: string, instanceId: string, websiteProjectInstanceTransfer: WebsiteProjectInstanceTransfer, xIdempotencyKey?: string, options?: any): AxiosPromise<Website> {
            return WebsiteProjectInstanceApiFp(configuration).websiteProjectInstanceTransfer(projectId, locationId, instanceId, websiteProjectInstanceTransfer, xIdempotencyKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns modified instance
         * @summary Update website/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {WebsiteProjectInstanceUpdate} websiteProjectInstanceUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceUpdate(projectId: string, locationId: string, instanceId: string, websiteProjectInstanceUpdate: WebsiteProjectInstanceUpdate, options?: any): AxiosPromise<Website> {
            return WebsiteProjectInstanceApiFp(configuration).websiteProjectInstanceUpdate(projectId, locationId, instanceId, websiteProjectInstanceUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WebsiteProjectInstanceApi - object-oriented interface
 * @export
 * @class WebsiteProjectInstanceApi
 * @extends {BaseAPI}
 */
export class WebsiteProjectInstanceApi extends BaseAPI {
    /**
     * Get website/instance.connect
     * @summary Get website/instance.connect
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {string} connectId connectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsiteProjectInstanceApi
     */
    public websiteProjectInstanceConnectGet(projectId: string, locationId: string, instanceId: string, connectId: string, options?: any) {
        return WebsiteProjectInstanceApiFp(this.configuration).websiteProjectInstanceConnectGet(projectId, locationId, instanceId, connectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List website/instance.connect
     * @summary List website/instance.connect
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsiteProjectInstanceApi
     */
    public websiteProjectInstanceConnectList(projectId: string, locationId: string, instanceId: string, options?: any) {
        return WebsiteProjectInstanceApiFp(this.configuration).websiteProjectInstanceConnectList(projectId, locationId, instanceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create instance
     * @summary Create website/instance
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {WebsiteProjectInstanceCreate} websiteProjectInstanceCreate 
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsiteProjectInstanceApi
     */
    public websiteProjectInstanceCreate(projectId: string, locationId: string, websiteProjectInstanceCreate: WebsiteProjectInstanceCreate, xIdempotencyKey?: string, options?: any) {
        return WebsiteProjectInstanceApiFp(this.configuration).websiteProjectInstanceCreate(projectId, locationId, websiteProjectInstanceCreate, xIdempotencyKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create website/instance.credential
     * @summary Create website/instance.credential
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {WebsiteCredential} websiteCredential 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsiteProjectInstanceApi
     */
    public websiteProjectInstanceCredentialCreate(projectId: string, locationId: string, instanceId: string, websiteCredential: WebsiteCredential, options?: any) {
        return WebsiteProjectInstanceApiFp(this.configuration).websiteProjectInstanceCredentialCreate(projectId, locationId, instanceId, websiteCredential, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete website/instance.credential
     * @summary Delete website/instance.credential
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {string} credentialId credentialId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsiteProjectInstanceApi
     */
    public websiteProjectInstanceCredentialDelete(projectId: string, locationId: string, instanceId: string, credentialId: string, options?: any) {
        return WebsiteProjectInstanceApiFp(this.configuration).websiteProjectInstanceCredentialDelete(projectId, locationId, instanceId, credentialId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get website/instance.credential
     * @summary Get website/instance.credential
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {string} credentialId credentialId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsiteProjectInstanceApi
     */
    public websiteProjectInstanceCredentialGet(projectId: string, locationId: string, instanceId: string, credentialId: string, options?: any) {
        return WebsiteProjectInstanceApiFp(this.configuration).websiteProjectInstanceCredentialGet(projectId, locationId, instanceId, credentialId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List website/instance.credential
     * @summary List website/instance.credential
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsiteProjectInstanceApi
     */
    public websiteProjectInstanceCredentialList(projectId: string, locationId: string, instanceId: string, options?: any) {
        return WebsiteProjectInstanceApiFp(this.configuration).websiteProjectInstanceCredentialList(projectId, locationId, instanceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update website/instance.credential
     * @summary Update website/instance.credential
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {string} credentialId credentialId
     * @param {WebsiteProjectInstanceCredentialPatch} websiteProjectInstanceCredentialPatch 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsiteProjectInstanceApi
     */
    public websiteProjectInstanceCredentialPatch(projectId: string, locationId: string, instanceId: string, credentialId: string, websiteProjectInstanceCredentialPatch: WebsiteProjectInstanceCredentialPatch, options?: any) {
        return WebsiteProjectInstanceApiFp(this.configuration).websiteProjectInstanceCredentialPatch(projectId, locationId, instanceId, credentialId, websiteProjectInstanceCredentialPatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete instance
     * @summary Delete website/instance
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsiteProjectInstanceApi
     */
    public websiteProjectInstanceDelete(projectId: string, locationId: string, instanceId: string, options?: any) {
        return WebsiteProjectInstanceApiFp(this.configuration).websiteProjectInstanceDelete(projectId, locationId, instanceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create website/instance.domain
     * @summary Create website/instance.domain
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {Domain} domain 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsiteProjectInstanceApi
     */
    public websiteProjectInstanceDomainCreate(projectId: string, locationId: string, instanceId: string, domain: Domain, options?: any) {
        return WebsiteProjectInstanceApiFp(this.configuration).websiteProjectInstanceDomainCreate(projectId, locationId, instanceId, domain, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete website/instance.domain
     * @summary Delete website/instance.domain
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {string} domainId domainId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsiteProjectInstanceApi
     */
    public websiteProjectInstanceDomainDelete(projectId: string, locationId: string, instanceId: string, domainId: string, options?: any) {
        return WebsiteProjectInstanceApiFp(this.configuration).websiteProjectInstanceDomainDelete(projectId, locationId, instanceId, domainId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get website/instance.domain
     * @summary Get website/instance.domain
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {string} domainId domainId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsiteProjectInstanceApi
     */
    public websiteProjectInstanceDomainGet(projectId: string, locationId: string, instanceId: string, domainId: string, options?: any) {
        return WebsiteProjectInstanceApiFp(this.configuration).websiteProjectInstanceDomainGet(projectId, locationId, instanceId, domainId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List website/instance.domain
     * @summary List website/instance.domain
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsiteProjectInstanceApi
     */
    public websiteProjectInstanceDomainList(projectId: string, locationId: string, instanceId: string, options?: any) {
        return WebsiteProjectInstanceApiFp(this.configuration).websiteProjectInstanceDomainList(projectId, locationId, instanceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create website/instance.env
     * @summary Create website/instance.env
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {WebsiteEnv} websiteEnv 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsiteProjectInstanceApi
     */
    public websiteProjectInstanceEnvCreate(projectId: string, locationId: string, instanceId: string, websiteEnv: WebsiteEnv, options?: any) {
        return WebsiteProjectInstanceApiFp(this.configuration).websiteProjectInstanceEnvCreate(projectId, locationId, instanceId, websiteEnv, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete website/instance.env
     * @summary Delete website/instance.env
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {string} envId envId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsiteProjectInstanceApi
     */
    public websiteProjectInstanceEnvDelete(projectId: string, locationId: string, instanceId: string, envId: string, options?: any) {
        return WebsiteProjectInstanceApiFp(this.configuration).websiteProjectInstanceEnvDelete(projectId, locationId, instanceId, envId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get website/instance.env
     * @summary Get website/instance.env
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {string} envId envId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsiteProjectInstanceApi
     */
    public websiteProjectInstanceEnvGet(projectId: string, locationId: string, instanceId: string, envId: string, options?: any) {
        return WebsiteProjectInstanceApiFp(this.configuration).websiteProjectInstanceEnvGet(projectId, locationId, instanceId, envId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List website/instance.env
     * @summary List website/instance.env
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsiteProjectInstanceApi
     */
    public websiteProjectInstanceEnvList(projectId: string, locationId: string, instanceId: string, options?: any) {
        return WebsiteProjectInstanceApiFp(this.configuration).websiteProjectInstanceEnvList(projectId, locationId, instanceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get website/instance.event
     * @summary Get website/instance.event
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {string} eventId eventId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsiteProjectInstanceApi
     */
    public websiteProjectInstanceEventGet(projectId: string, locationId: string, instanceId: string, eventId: string, options?: any) {
        return WebsiteProjectInstanceApiFp(this.configuration).websiteProjectInstanceEventGet(projectId, locationId, instanceId, eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List website/instance.event
     * @summary List website/instance.event
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {number} [$limit] $limit
     * @param {number} [$skip] $skip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsiteProjectInstanceApi
     */
    public websiteProjectInstanceEventList(projectId: string, locationId: string, instanceId: string, $limit?: number, $skip?: number, options?: any) {
        return WebsiteProjectInstanceApiFp(this.configuration).websiteProjectInstanceEventList(projectId, locationId, instanceId, $limit, $skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single instance
     * @summary Get website/instance
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsiteProjectInstanceApi
     */
    public websiteProjectInstanceGet(projectId: string, locationId: string, instanceId: string, options?: any) {
        return WebsiteProjectInstanceApiFp(this.configuration).websiteProjectInstanceGet(projectId, locationId, instanceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create website/instance.link
     * @summary Create website/instance.link
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {WebsiteLink} websiteLink 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsiteProjectInstanceApi
     */
    public websiteProjectInstanceLinkCreate(projectId: string, locationId: string, instanceId: string, websiteLink: WebsiteLink, options?: any) {
        return WebsiteProjectInstanceApiFp(this.configuration).websiteProjectInstanceLinkCreate(projectId, locationId, instanceId, websiteLink, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete website/instance.link
     * @summary Delete website/instance.link
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {string} linkId linkId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsiteProjectInstanceApi
     */
    public websiteProjectInstanceLinkDelete(projectId: string, locationId: string, instanceId: string, linkId: string, options?: any) {
        return WebsiteProjectInstanceApiFp(this.configuration).websiteProjectInstanceLinkDelete(projectId, locationId, instanceId, linkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get website/instance.link
     * @summary Get website/instance.link
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {string} linkId linkId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsiteProjectInstanceApi
     */
    public websiteProjectInstanceLinkGet(projectId: string, locationId: string, instanceId: string, linkId: string, options?: any) {
        return WebsiteProjectInstanceApiFp(this.configuration).websiteProjectInstanceLinkGet(projectId, locationId, instanceId, linkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List website/instance.link
     * @summary List website/instance.link
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsiteProjectInstanceApi
     */
    public websiteProjectInstanceLinkList(projectId: string, locationId: string, instanceId: string, options?: any) {
        return WebsiteProjectInstanceApiFp(this.configuration).websiteProjectInstanceLinkList(projectId, locationId, instanceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List instance
     * @summary List website/instance
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} [name] Filter by name
     * @param {string} [tagValue] Filter by tag.value
     * @param {string} [tagKey] Filter by tag.key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsiteProjectInstanceApi
     */
    public websiteProjectInstanceList(projectId: string, locationId: string, name?: string, tagValue?: string, tagKey?: string, options?: any) {
        return WebsiteProjectInstanceApiFp(this.configuration).websiteProjectInstanceList(projectId, locationId, name, tagValue, tagKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get website/instance.log
     * @summary Get website/instance.log
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {string} logId logId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsiteProjectInstanceApi
     */
    public websiteProjectInstanceLogGet(projectId: string, locationId: string, instanceId: string, logId: string, options?: any) {
        return WebsiteProjectInstanceApiFp(this.configuration).websiteProjectInstanceLogGet(projectId, locationId, instanceId, logId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List website/instance.log
     * @summary List website/instance.log
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsiteProjectInstanceApi
     */
    public websiteProjectInstanceLogList(projectId: string, locationId: string, instanceId: string, options?: any) {
        return WebsiteProjectInstanceApiFp(this.configuration).websiteProjectInstanceLogList(projectId, locationId, instanceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * action read
     * @summary Read website/instance.log
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {string} logId logId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsiteProjectInstanceApi
     */
    public websiteProjectInstanceLogRead(projectId: string, locationId: string, instanceId: string, logId: string, options?: any) {
        return WebsiteProjectInstanceApiFp(this.configuration).websiteProjectInstanceLogRead(projectId, locationId, instanceId, logId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get website/instance.metric
     * @summary Get website/instance.metric
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {string} metricId metricId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsiteProjectInstanceApi
     */
    public websiteProjectInstanceMetricGet(projectId: string, locationId: string, instanceId: string, metricId: string, options?: any) {
        return WebsiteProjectInstanceApiFp(this.configuration).websiteProjectInstanceMetricGet(projectId, locationId, instanceId, metricId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List website/instance.metric
     * @summary List website/instance.metric
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsiteProjectInstanceApi
     */
    public websiteProjectInstanceMetricList(projectId: string, locationId: string, instanceId: string, options?: any) {
        return WebsiteProjectInstanceApiFp(this.configuration).websiteProjectInstanceMetricList(projectId, locationId, instanceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List website/instance.point
     * @summary List website/instance.point
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {string} metricId metricId
     * @param {string} [interval] interval
     * @param {string} [timespan] timespan
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsiteProjectInstanceApi
     */
    public websiteProjectInstanceMetricPointList(projectId: string, locationId: string, instanceId: string, metricId: string, interval?: string, timespan?: string, options?: any) {
        return WebsiteProjectInstanceApiFp(this.configuration).websiteProjectInstanceMetricPointList(projectId, locationId, instanceId, metricId, interval, timespan, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * action restart
     * @summary Restart website/instance
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsiteProjectInstanceApi
     */
    public websiteProjectInstanceRestart(projectId: string, locationId: string, instanceId: string, xIdempotencyKey?: string, options?: any) {
        return WebsiteProjectInstanceApiFp(this.configuration).websiteProjectInstanceRestart(projectId, locationId, instanceId, xIdempotencyKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get website/instance.service
     * @summary Get website/instance.service
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {string} serviceId serviceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsiteProjectInstanceApi
     */
    public websiteProjectInstanceServiceGet(projectId: string, locationId: string, instanceId: string, serviceId: string, options?: any) {
        return WebsiteProjectInstanceApiFp(this.configuration).websiteProjectInstanceServiceGet(projectId, locationId, instanceId, serviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List website/instance.service
     * @summary List website/instance.service
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsiteProjectInstanceApi
     */
    public websiteProjectInstanceServiceList(projectId: string, locationId: string, instanceId: string, options?: any) {
        return WebsiteProjectInstanceApiFp(this.configuration).websiteProjectInstanceServiceList(projectId, locationId, instanceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create website/instance.sideapp
     * @summary Create website/instance.sideapp
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {WebsiteSideapp} websiteSideapp 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsiteProjectInstanceApi
     */
    public websiteProjectInstanceSideappCreate(projectId: string, locationId: string, instanceId: string, websiteSideapp: WebsiteSideapp, options?: any) {
        return WebsiteProjectInstanceApiFp(this.configuration).websiteProjectInstanceSideappCreate(projectId, locationId, instanceId, websiteSideapp, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete website/instance.sideapp
     * @summary Delete website/instance.sideapp
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {string} sideappId sideappId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsiteProjectInstanceApi
     */
    public websiteProjectInstanceSideappDelete(projectId: string, locationId: string, instanceId: string, sideappId: string, options?: any) {
        return WebsiteProjectInstanceApiFp(this.configuration).websiteProjectInstanceSideappDelete(projectId, locationId, instanceId, sideappId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get website/instance.sideapp
     * @summary Get website/instance.sideapp
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {string} sideappId sideappId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsiteProjectInstanceApi
     */
    public websiteProjectInstanceSideappGet(projectId: string, locationId: string, instanceId: string, sideappId: string, options?: any) {
        return WebsiteProjectInstanceApiFp(this.configuration).websiteProjectInstanceSideappGet(projectId, locationId, instanceId, sideappId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List website/instance.sideapp
     * @summary List website/instance.sideapp
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsiteProjectInstanceApi
     */
    public websiteProjectInstanceSideappList(projectId: string, locationId: string, instanceId: string, options?: any) {
        return WebsiteProjectInstanceApiFp(this.configuration).websiteProjectInstanceSideappList(projectId, locationId, instanceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create website/instance.snapshot
     * @summary Create website/instance.snapshot
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {WebsiteSnapshot} websiteSnapshot 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsiteProjectInstanceApi
     */
    public websiteProjectInstanceSnapshotCreate(projectId: string, locationId: string, instanceId: string, websiteSnapshot: WebsiteSnapshot, options?: any) {
        return WebsiteProjectInstanceApiFp(this.configuration).websiteProjectInstanceSnapshotCreate(projectId, locationId, instanceId, websiteSnapshot, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete website/instance.snapshot
     * @summary Delete website/instance.snapshot
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {string} snapshotId snapshotId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsiteProjectInstanceApi
     */
    public websiteProjectInstanceSnapshotDelete(projectId: string, locationId: string, instanceId: string, snapshotId: string, options?: any) {
        return WebsiteProjectInstanceApiFp(this.configuration).websiteProjectInstanceSnapshotDelete(projectId, locationId, instanceId, snapshotId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * action download
     * @summary Download website/instance.snapshot
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {string} snapshotId snapshotId
     * @param {WebsiteProjectInstanceSnapshotDownload} websiteProjectInstanceSnapshotDownload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsiteProjectInstanceApi
     */
    public websiteProjectInstanceSnapshotDownload(projectId: string, locationId: string, instanceId: string, snapshotId: string, websiteProjectInstanceSnapshotDownload: WebsiteProjectInstanceSnapshotDownload, options?: any) {
        return WebsiteProjectInstanceApiFp(this.configuration).websiteProjectInstanceSnapshotDownload(projectId, locationId, instanceId, snapshotId, websiteProjectInstanceSnapshotDownload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get website/instance.snapshot
     * @summary Get website/instance.snapshot
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {string} snapshotId snapshotId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsiteProjectInstanceApi
     */
    public websiteProjectInstanceSnapshotGet(projectId: string, locationId: string, instanceId: string, snapshotId: string, options?: any) {
        return WebsiteProjectInstanceApiFp(this.configuration).websiteProjectInstanceSnapshotGet(projectId, locationId, instanceId, snapshotId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List website/instance.snapshot
     * @summary List website/instance.snapshot
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsiteProjectInstanceApi
     */
    public websiteProjectInstanceSnapshotList(projectId: string, locationId: string, instanceId: string, options?: any) {
        return WebsiteProjectInstanceApiFp(this.configuration).websiteProjectInstanceSnapshotList(projectId, locationId, instanceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * action start
     * @summary Start website/instance
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsiteProjectInstanceApi
     */
    public websiteProjectInstanceStart(projectId: string, locationId: string, instanceId: string, xIdempotencyKey?: string, options?: any) {
        return WebsiteProjectInstanceApiFp(this.configuration).websiteProjectInstanceStart(projectId, locationId, instanceId, xIdempotencyKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * action stop
     * @summary Stop website/instance
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsiteProjectInstanceApi
     */
    public websiteProjectInstanceStop(projectId: string, locationId: string, instanceId: string, xIdempotencyKey?: string, options?: any) {
        return WebsiteProjectInstanceApiFp(this.configuration).websiteProjectInstanceStop(projectId, locationId, instanceId, xIdempotencyKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create website/instance.tag
     * @summary Create website/instance.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {Tag} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsiteProjectInstanceApi
     */
    public websiteProjectInstanceTagCreate(projectId: string, locationId: string, instanceId: string, tag: Tag, options?: any) {
        return WebsiteProjectInstanceApiFp(this.configuration).websiteProjectInstanceTagCreate(projectId, locationId, instanceId, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete website/instance.tag
     * @summary Delete website/instance.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {string} tagId tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsiteProjectInstanceApi
     */
    public websiteProjectInstanceTagDelete(projectId: string, locationId: string, instanceId: string, tagId: string, options?: any) {
        return WebsiteProjectInstanceApiFp(this.configuration).websiteProjectInstanceTagDelete(projectId, locationId, instanceId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get website/instance.tag
     * @summary Get website/instance.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {string} tagId tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsiteProjectInstanceApi
     */
    public websiteProjectInstanceTagGet(projectId: string, locationId: string, instanceId: string, tagId: string, options?: any) {
        return WebsiteProjectInstanceApiFp(this.configuration).websiteProjectInstanceTagGet(projectId, locationId, instanceId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List website/instance.tag
     * @summary List website/instance.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsiteProjectInstanceApi
     */
    public websiteProjectInstanceTagList(projectId: string, locationId: string, instanceId: string, options?: any) {
        return WebsiteProjectInstanceApiFp(this.configuration).websiteProjectInstanceTagList(projectId, locationId, instanceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replace website/instance.tag
     * @summary Replace website/instance.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {Array<Tag>} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsiteProjectInstanceApi
     */
    public websiteProjectInstanceTagPut(projectId: string, locationId: string, instanceId: string, tag: Array<Tag>, options?: any) {
        return WebsiteProjectInstanceApiFp(this.configuration).websiteProjectInstanceTagPut(projectId, locationId, instanceId, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * action transfer
     * @summary Transfer website/instance
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {WebsiteProjectInstanceTransfer} websiteProjectInstanceTransfer 
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsiteProjectInstanceApi
     */
    public websiteProjectInstanceTransfer(projectId: string, locationId: string, instanceId: string, websiteProjectInstanceTransfer: WebsiteProjectInstanceTransfer, xIdempotencyKey?: string, options?: any) {
        return WebsiteProjectInstanceApiFp(this.configuration).websiteProjectInstanceTransfer(projectId, locationId, instanceId, websiteProjectInstanceTransfer, xIdempotencyKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns modified instance
     * @summary Update website/instance
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {WebsiteProjectInstanceUpdate} websiteProjectInstanceUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsiteProjectInstanceApi
     */
    public websiteProjectInstanceUpdate(projectId: string, locationId: string, instanceId: string, websiteProjectInstanceUpdate: WebsiteProjectInstanceUpdate, options?: any) {
        return WebsiteProjectInstanceApiFp(this.configuration).websiteProjectInstanceUpdate(projectId, locationId, instanceId, websiteProjectInstanceUpdate, options).then((request) => request(this.axios, this.basePath));
    }

}


