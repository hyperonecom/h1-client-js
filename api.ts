/* tslint:disable */
/* eslint-disable */
/**
 * HyperOne
 * HyperOne API
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface Agent
 */
export interface Agent {
    /**
     * 
     * @type {string}
     * @memberof Agent
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Agent
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Agent
     */
    flavour?: string;
    /**
     * 
     * @type {string}
     * @memberof Agent
     */
    modifiedOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Agent
     */
    modifiedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Agent
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Agent
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Agent
     */
    state?: AgentStateEnum;
    /**
     * 
     * @type {string}
     * @memberof Agent
     */
    project?: string;
    /**
     * 
     * @type {string}
     * @memberof Agent
     */
    uri?: string;
    /**
     * 
     * @type {string}
     * @memberof Agent
     */
    type?: string;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof Agent
     */
    tag?: Array<Tag>;
}

/**
    * @export
    * @enum {string}
    */
export enum AgentStateEnum {
    Online = 'Online',
    Suspended = 'Suspended',
    Unknown = 'Unknown',
    Processing = 'Processing',
    NotCreated = 'NotCreated'
}

/**
 * 
 * @export
 * @interface AgentCredential
 */
export interface AgentCredential {
    /**
     * 
     * @type {string}
     * @memberof AgentCredential
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof AgentCredential
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof AgentCredential
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof AgentCredential
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof AgentCredential
     */
    type: AgentCredentialTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof AgentCredential
     */
    value: string;
    /**
     * 
     * @type {string}
     * @memberof AgentCredential
     */
    fingerprint?: string;
    /**
     * 
     * @type {string}
     * @memberof AgentCredential
     */
    token?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum AgentCredentialTypeEnum {
    Ssh = 'ssh'
}

/**
 * 
 * @export
 * @interface Attempt
 */
export interface Attempt {
    /**
     * 
     * @type {string}
     * @memberof Attempt
     */
    id?: string;
    /**
     * 
     * @type {number}
     * @memberof Attempt
     */
    status?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Attempt
     */
    error?: boolean;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof Attempt
     */
    stdout?: { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof Attempt
     */
    stderr?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof Attempt
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Attempt
     */
    agent?: string;
}
/**
 * 
 * @export
 * @interface AuthToken
 */
export interface AuthToken {
    /**
     * 
     * @type {string}
     * @memberof AuthToken
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthToken
     */
    expiry?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthToken
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthToken
     */
    createdOn?: string;
    /**
     * 
     * @type {Array<AuthTokenAccess>}
     * @memberof AuthToken
     */
    access?: Array<AuthTokenAccess>;
    /**
     * 
     * @type {string}
     * @memberof AuthToken
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthToken
     */
    clientIp?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthToken
     */
    userAgent?: string;
}
/**
 * 
 * @export
 * @interface AuthTokenAccess
 */
export interface AuthTokenAccess {
    /**
     * 
     * @type {string}
     * @memberof AuthTokenAccess
     */
    method: AuthTokenAccessMethodEnum;
    /**
     * 
     * @type {string}
     * @memberof AuthTokenAccess
     */
    path: string;
}

/**
    * @export
    * @enum {string}
    */
export enum AuthTokenAccessMethodEnum {
    All = 'ALL',
    Get = 'GET',
    Post = 'POST',
    Patch = 'PATCH',
    Delete = 'DELETE'
}

/**
 * 
 * @export
 * @interface Backup
 */
export interface Backup {
    /**
     * 
     * @type {string}
     * @memberof Backup
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Backup
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Backup
     */
    flavour?: string;
    /**
     * 
     * @type {string}
     * @memberof Backup
     */
    modifiedOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Backup
     */
    modifiedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Backup
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Backup
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Backup
     */
    state?: BackupStateEnum;
    /**
     * 
     * @type {string}
     * @memberof Backup
     */
    project?: string;
    /**
     * 
     * @type {string}
     * @memberof Backup
     */
    uri?: string;
    /**
     * 
     * @type {number}
     * @memberof Backup
     */
    size?: number;
    /**
     * 
     * @type {string}
     * @memberof Backup
     */
    source?: string;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof Backup
     */
    tag?: Array<Tag>;
}

/**
    * @export
    * @enum {string}
    */
export enum BackupStateEnum {
    Online = 'Online',
    Unknown = 'Unknown',
    Processing = 'Processing',
    NotCreated = 'NotCreated'
}

/**
 * 
 * @export
 * @interface Billing
 */
export interface Billing {
    /**
     * 
     * @type {string}
     * @memberof Billing
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Billing
     */
    period?: string;
    /**
     * 
     * @type {number}
     * @memberof Billing
     */
    price?: number;
    /**
     * 
     * @type {number}
     * @memberof Billing
     */
    quantity?: number;
    /**
     * 
     * @type {string}
     * @memberof Billing
     */
    project?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Billing
     */
    oneTime?: boolean;
    /**
     * 
     * @type {BillingService}
     * @memberof Billing
     */
    service?: BillingService;
    /**
     * 
     * @type {BillingResource}
     * @memberof Billing
     */
    resource?: BillingResource;
    /**
     * 
     * @type {Array<BillingCharges>}
     * @memberof Billing
     */
    charges?: Array<BillingCharges>;
}
/**
 * 
 * @export
 * @interface BillingAddress
 */
export interface BillingAddress {
    /**
     * 
     * @type {string}
     * @memberof BillingAddress
     */
    country?: BillingAddressCountryEnum;
    /**
     * 
     * @type {string}
     * @memberof BillingAddress
     */
    city: string;
    /**
     * 
     * @type {string}
     * @memberof BillingAddress
     */
    street: string;
    /**
     * 
     * @type {string}
     * @memberof BillingAddress
     */
    zipcode: string;
}

/**
    * @export
    * @enum {string}
    */
export enum BillingAddressCountryEnum {
    Ad = 'AD',
    Be = 'BE',
    Hr = 'HR',
    Cy = 'CY',
    Cz = 'CZ',
    Dk = 'DK',
    Ee = 'EE',
    Fi = 'FI',
    Fr = 'FR',
    De = 'DE',
    Gr = 'GR',
    Hu = 'HU',
    Ie = 'IE',
    It = 'IT',
    Lv = 'LV',
    Lt = 'LT',
    Lu = 'LU',
    Mt = 'MT',
    Nl = 'NL',
    Pl = 'PL',
    Pt = 'PT',
    Ro = 'RO',
    Sk = 'SK',
    Si = 'SI',
    Es = 'ES',
    Gb = 'GB'
}

/**
 * 
 * @export
 * @interface BillingAddress1
 */
export interface BillingAddress1 {
    /**
     * 
     * @type {string}
     * @memberof BillingAddress1
     */
    city?: string;
    /**
     * 
     * @type {string}
     * @memberof BillingAddress1
     */
    zipcode?: string;
    /**
     * 
     * @type {string}
     * @memberof BillingAddress1
     */
    street?: string;
}
/**
 * 
 * @export
 * @interface BillingCharges
 */
export interface BillingCharges {
    /**
     * 
     * @type {string}
     * @memberof BillingCharges
     */
    id?: string;
    /**
     * 
     * @type {number}
     * @memberof BillingCharges
     */
    value?: number;
    /**
     * 
     * @type {string}
     * @memberof BillingCharges
     */
    start?: string;
    /**
     * 
     * @type {string}
     * @memberof BillingCharges
     */
    end?: string;
    /**
     * 
     * @type {number}
     * @memberof BillingCharges
     */
    price?: number;
    /**
     * 
     * @type {number}
     * @memberof BillingCharges
     */
    quantity?: number;
    /**
     * 
     * @type {string}
     * @memberof BillingCharges
     */
    paidFrom?: string;
    /**
     * 
     * @type {string}
     * @memberof BillingCharges
     */
    paidOn?: string;
}
/**
 * 
 * @export
 * @interface BillingProjectReservationAssign
 */
export interface BillingProjectReservationAssign {
    /**
     * 
     * @type {string}
     * @memberof BillingProjectReservationAssign
     */
    resource?: string;
}
/**
 * 
 * @export
 * @interface BillingProjectReservationCreate
 */
export interface BillingProjectReservationCreate {
    /**
     * 
     * @type {string}
     * @memberof BillingProjectReservationCreate
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof BillingProjectReservationCreate
     */
    service: string;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof BillingProjectReservationCreate
     */
    tag?: Array<Tag>;
}
/**
 * 
 * @export
 * @interface BillingProjectReservationUpdate
 */
export interface BillingProjectReservationUpdate {
    /**
     * 
     * @type {string}
     * @memberof BillingProjectReservationUpdate
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface BillingResource
 */
export interface BillingResource {
    /**
     * 
     * @type {string}
     * @memberof BillingResource
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof BillingResource
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof BillingResource
     */
    name?: string;
    /**
     * 
     * @type {boolean}
     * @memberof BillingResource
     */
    deleted?: boolean;
}
/**
 * 
 * @export
 * @interface BillingService
 */
export interface BillingService {
    /**
     * 
     * @type {string}
     * @memberof BillingService
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof BillingService
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof BillingService
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface Bucket
 */
export interface Bucket {
    /**
     * 
     * @type {string}
     * @memberof Bucket
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Bucket
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Bucket
     */
    flavour?: string;
    /**
     * 
     * @type {string}
     * @memberof Bucket
     */
    modifiedOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Bucket
     */
    modifiedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Bucket
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Bucket
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Bucket
     */
    state?: string;
    /**
     * 
     * @type {string}
     * @memberof Bucket
     */
    project?: string;
    /**
     * 
     * @type {string}
     * @memberof Bucket
     */
    organisation?: string;
    /**
     * 
     * @type {string}
     * @memberof Bucket
     */
    uri?: string;
    /**
     * 
     * @type {number}
     * @memberof Bucket
     */
    sizeUsed?: number;
}
/**
 * 
 * @export
 * @interface ComputeProjectReplicaCreate
 */
export interface ComputeProjectReplicaCreate {
    /**
     * 
     * @type {string}
     * @memberof ComputeProjectReplicaCreate
     */
    hostname: string;
    /**
     * 
     * @type {string}
     * @memberof ComputeProjectReplicaCreate
     */
    secret: string;
}
/**
 * 
 * @export
 * @interface ComputeProjectVmConnectOpen
 */
export interface ComputeProjectVmConnectOpen {
    /**
     * 
     * @type {string}
     * @memberof ComputeProjectVmConnectOpen
     */
    protocol?: ComputeProjectVmConnectOpenProtocolEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum ComputeProjectVmConnectOpenProtocolEnum {
    Http = 'http',
    Ws = 'ws'
}

/**
 * 
 * @export
 * @interface ComputeProjectVmCreate
 */
export interface ComputeProjectVmCreate {
    /**
     * 
     * @type {string}
     * @memberof ComputeProjectVmCreate
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof ComputeProjectVmCreate
     */
    service: string;
    /**
     * 
     * @type {string}
     * @memberof ComputeProjectVmCreate
     */
    image?: string;
    /**
     * 
     * @type {string}
     * @memberof ComputeProjectVmCreate
     */
    iso?: string;
    /**
     * 
     * @type {string}
     * @memberof ComputeProjectVmCreate
     */
    username?: string;
    /**
     * 
     * @type {string}
     * @memberof ComputeProjectVmCreate
     */
    userMetadata?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ComputeProjectVmCreate
     */
    start?: boolean;
    /**
     * 
     * @type {Array<ComputeProjectVmCreateCredential>}
     * @memberof ComputeProjectVmCreate
     */
    credential?: Array<ComputeProjectVmCreateCredential>;
    /**
     * 
     * @type {Array<ComputeProjectVmCreateDisk>}
     * @memberof ComputeProjectVmCreate
     */
    disk?: Array<ComputeProjectVmCreateDisk>;
    /**
     * 
     * @type {Array<ComputeProjectVmCreateNetadp>}
     * @memberof ComputeProjectVmCreate
     */
    netadp?: Array<ComputeProjectVmCreateNetadp>;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof ComputeProjectVmCreate
     */
    tag?: Array<Tag>;
}
/**
 * 
 * @export
 * @interface ComputeProjectVmCreateCredential
 */
export interface ComputeProjectVmCreateCredential {
    /**
     * 
     * @type {string}
     * @memberof ComputeProjectVmCreateCredential
     */
    type: ComputeProjectVmCreateCredentialTypeEnum;
    /**
     * - user credential (by id or name) - project credential (by id or name) - raw openssh public key (starting with `ssh-rsa/ssh-ed25519`) - defaults to user keys
     * @type {string}
     * @memberof ComputeProjectVmCreateCredential
     */
    value: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ComputeProjectVmCreateCredentialTypeEnum {
    Ssh = 'ssh',
    Plain = 'plain',
    Unix = 'unix'
}

/**
 * 
 * @export
 * @interface ComputeProjectVmCreateDisk
 */
export interface ComputeProjectVmCreateDisk {
    /**
     * 
     * @type {string}
     * @memberof ComputeProjectVmCreateDisk
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof ComputeProjectVmCreateDisk
     */
    service: string;
    /**
     * 
     * @type {number}
     * @memberof ComputeProjectVmCreateDisk
     */
    size: number;
}
/**
 * 
 * @export
 * @interface ComputeProjectVmCreateNetadp
 */
export interface ComputeProjectVmCreateNetadp {
    /**
     * 
     * @type {string}
     * @memberof ComputeProjectVmCreateNetadp
     */
    network: string;
    /**
     * 
     * @type {string}
     * @memberof ComputeProjectVmCreateNetadp
     */
    firewall?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ComputeProjectVmCreateNetadp
     */
    ip?: Array<string>;
}
/**
 * 
 * @export
 * @interface ComputeProjectVmDiskCreate
 */
export interface ComputeProjectVmDiskCreate {
    /**
     * 
     * @type {string}
     * @memberof ComputeProjectVmDiskCreate
     */
    disk: string;
}
/**
 * 
 * @export
 * @interface ComputeProjectVmFlavour
 */
export interface ComputeProjectVmFlavour {
    /**
     * 
     * @type {string}
     * @memberof ComputeProjectVmFlavour
     */
    service: string;
}
/**
 * 
 * @export
 * @interface ComputeProjectVmIsoCreate
 */
export interface ComputeProjectVmIsoCreate {
    /**
     * 
     * @type {string}
     * @memberof ComputeProjectVmIsoCreate
     */
    iso?: string;
}
/**
 * 
 * @export
 * @interface ComputeProjectVmPasswordReset
 */
export interface ComputeProjectVmPasswordReset {
    /**
     * 
     * @type {string}
     * @memberof ComputeProjectVmPasswordReset
     */
    userName: string;
    /**
     * 
     * @type {string}
     * @memberof ComputeProjectVmPasswordReset
     */
    modulus: string;
    /**
     * 
     * @type {string}
     * @memberof ComputeProjectVmPasswordReset
     */
    exponent: string;
}
/**
 * 
 * @export
 * @interface ComputeProjectVmSerialport
 */
export interface ComputeProjectVmSerialport {
    /**
     * 
     * @type {string}
     * @memberof ComputeProjectVmSerialport
     */
    number?: ComputeProjectVmSerialportNumberEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum ComputeProjectVmSerialportNumberEnum {
    _1 = '1',
    _2 = '2'
}

/**
 * 
 * @export
 * @interface ComputeProjectVmUpdate
 */
export interface ComputeProjectVmUpdate {
    /**
     * 
     * @type {string}
     * @memberof ComputeProjectVmUpdate
     */
    userMetadata?: string;
    /**
     * 
     * @type {string}
     * @memberof ComputeProjectVmUpdate
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface Connect
 */
export interface Connect {
    /**
     * 
     * @type {string}
     * @memberof Connect
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof Connect
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Connect
     */
    type: ConnectTypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum ConnectTypeEnum {
    Console = 'console'
}

/**
 * 
 * @export
 * @interface ContainerImage
 */
export interface ContainerImage {
    /**
     * 
     * @type {string}
     * @memberof ContainerImage
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ContainerImage
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof ContainerImage
     */
    digest: string;
    /**
     * 
     * @type {string}
     * @memberof ContainerImage
     */
    createdOn: string;
    /**
     * 
     * @type {string}
     * @memberof ContainerImage
     */
    modifiedOn: string;
}
/**
 * 
 * @export
 * @interface ContainerProjectRegistryCreate
 */
export interface ContainerProjectRegistryCreate {
    /**
     * 
     * @type {string}
     * @memberof ContainerProjectRegistryCreate
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof ContainerProjectRegistryCreate
     */
    service: string;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof ContainerProjectRegistryCreate
     */
    tag?: Array<Tag>;
}
/**
 * 
 * @export
 * @interface ContainerProjectRegistryCredentialPatch
 */
export interface ContainerProjectRegistryCredentialPatch {
    /**
     * 
     * @type {string}
     * @memberof ContainerProjectRegistryCredentialPatch
     */
    name: string;
}
/**
 * 
 * @export
 * @interface ContainerProjectRegistryTransfer
 */
export interface ContainerProjectRegistryTransfer {
    /**
     * 
     * @type {string}
     * @memberof ContainerProjectRegistryTransfer
     */
    project: string;
}
/**
 * 
 * @export
 * @interface ContainerProjectRegistryUpdate
 */
export interface ContainerProjectRegistryUpdate {
    /**
     * 
     * @type {string}
     * @memberof ContainerProjectRegistryUpdate
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface ContainerRepository
 */
export interface ContainerRepository {
    /**
     * 
     * @type {string}
     * @memberof ContainerRepository
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ContainerRepository
     */
    name: string;
}
/**
 * 
 * @export
 * @interface Database
 */
export interface Database {
    /**
     * 
     * @type {string}
     * @memberof Database
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Database
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Database
     */
    flavour?: string;
    /**
     * 
     * @type {string}
     * @memberof Database
     */
    modifiedOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Database
     */
    modifiedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Database
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Database
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Database
     */
    state?: DatabaseStateEnum;
    /**
     * 
     * @type {string}
     * @memberof Database
     */
    project?: string;
    /**
     * 
     * @type {string}
     * @memberof Database
     */
    uri?: string;
    /**
     * 
     * @type {string}
     * @memberof Database
     */
    plan?: string;
    /**
     * 
     * @type {string}
     * @memberof Database
     */
    fqdn?: string;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof Database
     */
    tag?: Array<Tag>;
}

/**
    * @export
    * @enum {string}
    */
export enum DatabaseStateEnum {
    Running = 'Running',
    Off = 'Off',
    Unknown = 'Unknown',
    Processing = 'Processing',
    NotCreated = 'NotCreated'
}

/**
 * 
 * @export
 * @interface DatabaseCredential
 */
export interface DatabaseCredential {
    /**
     * 
     * @type {string}
     * @memberof DatabaseCredential
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof DatabaseCredential
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof DatabaseCredential
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof DatabaseCredential
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof DatabaseCredential
     */
    type: DatabaseCredentialTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof DatabaseCredential
     */
    value: string;
    /**
     * 
     * @type {string}
     * @memberof DatabaseCredential
     */
    fingerprint?: string;
    /**
     * 
     * @type {string}
     * @memberof DatabaseCredential
     */
    token?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum DatabaseCredentialTypeEnum {
    Mysql = 'mysql',
    Plain = 'plain',
    Postgres = 'postgres'
}

/**
 * 
 * @export
 * @interface DatabaseProjectInstanceCreate
 */
export interface DatabaseProjectInstanceCreate {
    /**
     * 
     * @type {string}
     * @memberof DatabaseProjectInstanceCreate
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof DatabaseProjectInstanceCreate
     */
    service: string;
    /**
     * 
     * @type {string}
     * @memberof DatabaseProjectInstanceCreate
     */
    source?: string;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof DatabaseProjectInstanceCreate
     */
    tag?: Array<Tag>;
}
/**
 * 
 * @export
 * @interface DatabaseProjectInstanceCredentialPatch
 */
export interface DatabaseProjectInstanceCredentialPatch {
    /**
     * 
     * @type {string}
     * @memberof DatabaseProjectInstanceCredentialPatch
     */
    name: string;
}
/**
 * 
 * @export
 * @interface DatabaseProjectInstanceTransfer
 */
export interface DatabaseProjectInstanceTransfer {
    /**
     * 
     * @type {string}
     * @memberof DatabaseProjectInstanceTransfer
     */
    project: string;
}
/**
 * 
 * @export
 * @interface DatabaseProjectInstanceUpdate
 */
export interface DatabaseProjectInstanceUpdate {
    /**
     * 
     * @type {string}
     * @memberof DatabaseProjectInstanceUpdate
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof DatabaseProjectInstanceUpdate
     */
    plan?: string;
}
/**
 * 
 * @export
 * @interface Disk
 */
export interface Disk {
    /**
     * 
     * @type {string}
     * @memberof Disk
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Disk
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Disk
     */
    flavour?: string;
    /**
     * 
     * @type {string}
     * @memberof Disk
     */
    modifiedOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Disk
     */
    modifiedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Disk
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Disk
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Disk
     */
    state?: DiskStateEnum;
    /**
     * 
     * @type {string}
     * @memberof Disk
     */
    project?: string;
    /**
     * 
     * @type {string}
     * @memberof Disk
     */
    uri?: string;
    /**
     * 
     * @type {number}
     * @memberof Disk
     */
    size?: number;
    /**
     * 
     * @type {string}
     * @memberof Disk
     */
    vm?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Disk
     */
    persistent?: boolean;
    /**
     * 
     * @type {DiskMetadata}
     * @memberof Disk
     */
    metadata?: DiskMetadata;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof Disk
     */
    tag?: Array<Tag>;
}

/**
    * @export
    * @enum {string}
    */
export enum DiskStateEnum {
    Uploading = 'Uploading',
    Online = 'Online',
    Attached = 'Attached',
    Detached = 'Detached',
    Unknown = 'Unknown',
    Processing = 'Processing',
    NotCreated = 'NotCreated'
}

/**
 * 
 * @export
 * @interface DiskMetadata
 */
export interface DiskMetadata {
    /**
     * 
     * @type {string}
     * @memberof DiskMetadata
     */
    source?: string;
}
/**
 * 
 * @export
 * @interface DnsProjectZoneCreate
 */
export interface DnsProjectZoneCreate {
    /**
     * 
     * @type {string}
     * @memberof DnsProjectZoneCreate
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof DnsProjectZoneCreate
     */
    service: string;
    /**
     * 
     * @type {string}
     * @memberof DnsProjectZoneCreate
     */
    dnsName: string;
    /**
     * 
     * @type {ZoneSource}
     * @memberof DnsProjectZoneCreate
     */
    source?: ZoneSource;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof DnsProjectZoneCreate
     */
    tag?: Array<Tag>;
}
/**
 * 
 * @export
 * @interface DnsProjectZoneRecordsetPatch
 */
export interface DnsProjectZoneRecordsetPatch {
    /**
     * 
     * @type {number}
     * @memberof DnsProjectZoneRecordsetPatch
     */
    ttl?: number;
}
/**
 * 
 * @export
 * @interface DnsProjectZoneUpdate
 */
export interface DnsProjectZoneUpdate {
    /**
     * 
     * @type {string}
     * @memberof DnsProjectZoneUpdate
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface DnsRecord
 */
export interface DnsRecord {
    /**
     * 
     * @type {string}
     * @memberof DnsRecord
     */
    id?: string;
    /**
     * Template string: - {{REQUEST_IP}} is replaced by the requester ip address.
     * @type {string}
     * @memberof DnsRecord
     */
    content: string;
}
/**
 * 
 * @export
 * @interface DnsRecordset
 */
export interface DnsRecordset {
    /**
     * 
     * @type {string}
     * @memberof DnsRecordset
     */
    id?: string;
    /**
     * use \'@\' to reference the zone origin
     * @type {string}
     * @memberof DnsRecordset
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof DnsRecordset
     */
    type: DnsRecordsetTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof DnsRecordset
     */
    ttl?: number;
    /**
     * 
     * @type {Array<DnsRecord>}
     * @memberof DnsRecordset
     */
    record?: Array<DnsRecord>;
}

/**
    * @export
    * @enum {string}
    */
export enum DnsRecordsetTypeEnum {
    A = 'A',
    Aaaa = 'AAAA',
    Caa = 'CAA',
    Cname = 'CNAME',
    Mx = 'MX',
    Ns = 'NS',
    Ptr = 'PTR',
    Soa = 'SOA',
    Srv = 'SRV',
    Txt = 'TXT'
}

/**
 * 
 * @export
 * @interface Domain
 */
export interface Domain {
    /**
     * 
     * @type {string}
     * @memberof Domain
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Domain
     */
    value: string;
}
/**
 * 
 * @export
 * @interface EnabledService
 */
export interface EnabledService {
    /**
     * 
     * @type {string}
     * @memberof EnabledService
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof EnabledService
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof EnabledService
     */
    service?: string;
}
/**
 * 
 * @export
 * @interface Event
 */
export interface Event {
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    state?: EventStateEnum;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Event
     */
    resource?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum EventStateEnum {
    Pending = 'pending',
    Processing = 'processing',
    Finished = 'finished',
    Error = 'error'
}

/**
 * 
 * @export
 * @interface EventBase
 */
export interface EventBase {
    /**
     * 
     * @type {string}
     * @memberof EventBase
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof EventBase
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof EventBase
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof EventBase
     */
    state?: EventBaseStateEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum EventBaseStateEnum {
    Pending = 'pending',
    Processing = 'processing',
    Finished = 'finished',
    Error = 'error'
}

/**
 * 
 * @export
 * @interface Firewall
 */
export interface Firewall {
    /**
     * 
     * @type {string}
     * @memberof Firewall
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Firewall
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Firewall
     */
    flavour?: string;
    /**
     * 
     * @type {string}
     * @memberof Firewall
     */
    modifiedOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Firewall
     */
    modifiedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Firewall
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Firewall
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Firewall
     */
    state?: FirewallStateEnum;
    /**
     * 
     * @type {string}
     * @memberof Firewall
     */
    project?: string;
    /**
     * 
     * @type {string}
     * @memberof Firewall
     */
    uri?: string;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof Firewall
     */
    tag?: Array<Tag>;
}

/**
    * @export
    * @enum {string}
    */
export enum FirewallStateEnum {
    Attached = 'Attached',
    Detached = 'Detached',
    Unknown = 'Unknown',
    Processing = 'Processing',
    NotCreated = 'NotCreated'
}

/**
 * 
 * @export
 * @interface Hdd
 */
export interface Hdd {
    /**
     * 
     * @type {number}
     * @memberof Hdd
     */
    maximumIOPS?: number;
    /**
     * 
     * @type {string}
     * @memberof Hdd
     */
    controllerType?: string;
    /**
     * 
     * @type {string}
     * @memberof Hdd
     */
    controllerNumber?: string;
    /**
     * 
     * @type {number}
     * @memberof Hdd
     */
    controllerLocation?: number;
    /**
     * 
     * @type {string}
     * @memberof Hdd
     */
    disk?: string;
    /**
     * 
     * @type {string}
     * @memberof Hdd
     */
    id?: string;
}
/**
 * 
 * @export
 * @interface IamActor
 */
export interface IamActor {
    /**
     * 
     * @type {string}
     * @memberof IamActor
     */
    id?: string;
    /**
     * one of: * E-mail * User URI * Service Account URI * \'me\' -ยง requestor
     * @type {string}
     * @memberof IamActor
     */
    value: string;
}
/**
 * 
 * @export
 * @interface IamOrganisationCreate
 */
export interface IamOrganisationCreate {
    /**
     * 
     * @type {string}
     * @memberof IamOrganisationCreate
     */
    name: string;
    /**
     * 
     * @type {OrganisationBilling}
     * @memberof IamOrganisationCreate
     */
    billing?: OrganisationBilling;
}
/**
 * 
 * @export
 * @interface IamOrganisationInvitationAccept
 */
export interface IamOrganisationInvitationAccept {
    /**
     * 
     * @type {string}
     * @memberof IamOrganisationInvitationAccept
     */
    token: string;
}
/**
 * 
 * @export
 * @interface IamOrganisationOwnershipCreate
 */
export interface IamOrganisationOwnershipCreate {
    /**
     * 
     * @type {string}
     * @memberof IamOrganisationOwnershipCreate
     */
    email: string;
}
/**
 * 
 * @export
 * @interface IamOrganisationPaymentAllocate
 */
export interface IamOrganisationPaymentAllocate {
    /**
     * 
     * @type {string}
     * @memberof IamOrganisationPaymentAllocate
     */
    project: string;
}
/**
 * 
 * @export
 * @interface IamOrganisationProformaCreate
 */
export interface IamOrganisationProformaCreate {
    /**
     * 
     * @type {number}
     * @memberof IamOrganisationProformaCreate
     */
    amount: number;
    /**
     * 
     * @type {string}
     * @memberof IamOrganisationProformaCreate
     */
    project: string;
}
/**
 * 
 * @export
 * @interface IamOrganisationTransferAccept
 */
export interface IamOrganisationTransferAccept {
    /**
     * 
     * @type {string}
     * @memberof IamOrganisationTransferAccept
     */
    payment: string;
}
/**
 * 
 * @export
 * @interface IamOrganisationUpdate
 */
export interface IamOrganisationUpdate {
    /**
     * 
     * @type {string}
     * @memberof IamOrganisationUpdate
     */
    name?: string;
    /**
     * 
     * @type {OrganisationBilling1}
     * @memberof IamOrganisationUpdate
     */
    billing?: OrganisationBilling1;
}
/**
 * 
 * @export
 * @interface IamPermission
 */
export interface IamPermission {
    /**
     * 
     * @type {string}
     * @memberof IamPermission
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof IamPermission
     */
    value: string;
}
/**
 * 
 * @export
 * @interface IamProjectCreate
 */
export interface IamProjectCreate {
    /**
     * 
     * @type {string}
     * @memberof IamProjectCreate
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof IamProjectCreate
     */
    organisation: string;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof IamProjectCreate
     */
    tag?: Array<Tag>;
}
/**
 * 
 * @export
 * @interface IamProjectCredentialStorePatch
 */
export interface IamProjectCredentialStorePatch {
    /**
     * 
     * @type {string}
     * @memberof IamProjectCredentialStorePatch
     */
    name: string;
}
/**
 * 
 * @export
 * @interface IamProjectInvitationAccept
 */
export interface IamProjectInvitationAccept {
    /**
     * 
     * @type {string}
     * @memberof IamProjectInvitationAccept
     */
    token: string;
}
/**
 * 
 * @export
 * @interface IamProjectOwnershipCreate
 */
export interface IamProjectOwnershipCreate {
    /**
     * 
     * @type {string}
     * @memberof IamProjectOwnershipCreate
     */
    email: string;
}
/**
 * 
 * @export
 * @interface IamProjectPolicyCreate
 */
export interface IamProjectPolicyCreate {
    /**
     * 
     * @type {string}
     * @memberof IamProjectPolicyCreate
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof IamProjectPolicyCreate
     */
    role: string;
    /**
     * 
     * @type {string}
     * @memberof IamProjectPolicyCreate
     */
    resource: string;
    /**
     * 
     * @type {Array<IamProjectPolicyCreateActor>}
     * @memberof IamProjectPolicyCreate
     */
    actor?: Array<IamProjectPolicyCreateActor>;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof IamProjectPolicyCreate
     */
    tag?: Array<Tag>;
}
/**
 * 
 * @export
 * @interface IamProjectPolicyCreateActor
 */
export interface IamProjectPolicyCreateActor {
    /**
     * 
     * @type {string}
     * @memberof IamProjectPolicyCreateActor
     */
    value?: string;
}
/**
 * 
 * @export
 * @interface IamProjectPolicyUpdate
 */
export interface IamProjectPolicyUpdate {
    /**
     * 
     * @type {string}
     * @memberof IamProjectPolicyUpdate
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface IamProjectQuotaLimitPatch
 */
export interface IamProjectQuotaLimitPatch {
    /**
     * 
     * @type {number}
     * @memberof IamProjectQuotaLimitPatch
     */
    user?: number;
}
/**
 * 
 * @export
 * @interface IamProjectRoleCreate
 */
export interface IamProjectRoleCreate {
    /**
     * 
     * @type {string}
     * @memberof IamProjectRoleCreate
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof IamProjectRoleCreate
     */
    service?: string;
    /**
     * 
     * @type {string}
     * @memberof IamProjectRoleCreate
     */
    description?: string;
    /**
     * 
     * @type {Array<IamPermission>}
     * @memberof IamProjectRoleCreate
     */
    permission?: Array<IamPermission>;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof IamProjectRoleCreate
     */
    tag?: Array<Tag>;
}
/**
 * 
 * @export
 * @interface IamProjectRoleUpdate
 */
export interface IamProjectRoleUpdate {
    /**
     * 
     * @type {string}
     * @memberof IamProjectRoleUpdate
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof IamProjectRoleUpdate
     */
    description?: string;
}
/**
 * 
 * @export
 * @interface IamProjectSaCreate
 */
export interface IamProjectSaCreate {
    /**
     * 
     * @type {string}
     * @memberof IamProjectSaCreate
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof IamProjectSaCreate
     */
    service?: string;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof IamProjectSaCreate
     */
    tag?: Array<Tag>;
}
/**
 * 
 * @export
 * @interface IamProjectSaCredentialPatch
 */
export interface IamProjectSaCredentialPatch {
    /**
     * 
     * @type {string}
     * @memberof IamProjectSaCredentialPatch
     */
    name: string;
}
/**
 * 
 * @export
 * @interface IamProjectSaUpdate
 */
export interface IamProjectSaUpdate {
    /**
     * 
     * @type {string}
     * @memberof IamProjectSaUpdate
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface IamProjectThresholdCreate
 */
export interface IamProjectThresholdCreate {
    /**
     * 
     * @type {string}
     * @memberof IamProjectThresholdCreate
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof IamProjectThresholdCreate
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof IamProjectThresholdCreate
     */
    type?: string;
    /**
     * 
     * @type {number}
     * @memberof IamProjectThresholdCreate
     */
    value?: number;
    /**
     * 
     * @type {string}
     * @memberof IamProjectThresholdCreate
     */
    uri?: string;
}
/**
 * 
 * @export
 * @interface IamProjectTransfer
 */
export interface IamProjectTransfer {
    /**
     * 
     * @type {string}
     * @memberof IamProjectTransfer
     */
    organisation: string;
}
/**
 * 
 * @export
 * @interface IamProjectUpdate
 */
export interface IamProjectUpdate {
    /**
     * 
     * @type {string}
     * @memberof IamProjectUpdate
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface IamUserCredentialPatch
 */
export interface IamUserCredentialPatch {
    /**
     * 
     * @type {string}
     * @memberof IamUserCredentialPatch
     */
    name: string;
}
/**
 * 
 * @export
 * @interface IamUserUpdate
 */
export interface IamUserUpdate {
    /**
     * 
     * @type {string}
     * @memberof IamUserUpdate
     */
    phone?: string;
    /**
     * 
     * @type {string}
     * @memberof IamUserUpdate
     */
    firstName?: string;
    /**
     * 
     * @type {string}
     * @memberof IamUserUpdate
     */
    familyName?: string;
    /**
     * 
     * @type {string}
     * @memberof IamUserUpdate
     */
    lang?: IamUserUpdateLangEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum IamUserUpdateLangEnum {
    En = 'en',
    Pl = 'pl'
}

/**
 * 
 * @export
 * @interface Image
 */
export interface Image {
    /**
     * 
     * @type {string}
     * @memberof Image
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Image
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Image
     */
    flavour?: string;
    /**
     * 
     * @type {string}
     * @memberof Image
     */
    modifiedOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Image
     */
    modifiedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Image
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Image
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Image
     */
    state?: ImageStateEnum;
    /**
     * 
     * @type {string}
     * @memberof Image
     */
    project?: string;
    /**
     * 
     * @type {string}
     * @memberof Image
     */
    uri?: string;
    /**
     * 
     * @type {string}
     * @memberof Image
     */
    description?: string;
    /**
     * 
     * @type {number}
     * @memberof Image
     */
    disks?: number;
    /**
     * 
     * @type {number}
     * @memberof Image
     */
    fileSize?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof Image
     */
    license?: Array<string>;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof Image
     */
    tag?: Array<Tag>;
}

/**
    * @export
    * @enum {string}
    */
export enum ImageStateEnum {
    Online = 'Online',
    Unknown = 'Unknown',
    Processing = 'Processing',
    NotCreated = 'NotCreated'
}

/**
 * 
 * @export
 * @interface InlineResponse400
 */
export interface InlineResponse400 {
    /**
     * error description
     * @type {string}
     * @memberof InlineResponse400
     */
    message?: string;
}
/**
 * 
 * @export
 * @interface InsightProjectJournalCreate
 */
export interface InsightProjectJournalCreate {
    /**
     * 
     * @type {string}
     * @memberof InsightProjectJournalCreate
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof InsightProjectJournalCreate
     */
    service?: string;
    /**
     * 
     * @type {number}
     * @memberof InsightProjectJournalCreate
     */
    retention?: number;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof InsightProjectJournalCreate
     */
    tag?: Array<Tag>;
}
/**
 * 
 * @export
 * @interface InsightProjectJournalCredentialPatch
 */
export interface InsightProjectJournalCredentialPatch {
    /**
     * 
     * @type {string}
     * @memberof InsightProjectJournalCredentialPatch
     */
    name: string;
}
/**
 * 
 * @export
 * @interface InsightProjectJournalTransfer
 */
export interface InsightProjectJournalTransfer {
    /**
     * 
     * @type {string}
     * @memberof InsightProjectJournalTransfer
     */
    project: string;
}
/**
 * 
 * @export
 * @interface InsightProjectJournalUpdate
 */
export interface InsightProjectJournalUpdate {
    /**
     * 
     * @type {string}
     * @memberof InsightProjectJournalUpdate
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof InsightProjectJournalUpdate
     */
    retention?: number;
}
/**
 * 
 * @export
 * @interface Invitation
 */
export interface Invitation {
    /**
     * 
     * @type {string}
     * @memberof Invitation
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof Invitation
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof Invitation
     */
    resource: string;
}
/**
 * 
 * @export
 * @interface Invoice
 */
export interface Invoice {
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    additionalInfo?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Invoice
     */
    corrections?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    invoiceInfo?: string;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    invoiceNo?: string;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    issueDate?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Invoice
     */
    payments?: Array<string>;
    /**
     * 
     * @type {InvoiceSeller}
     * @memberof Invoice
     */
    seller?: InvoiceSeller;
    /**
     * 
     * @type {Array<InvoiceItems>}
     * @memberof Invoice
     */
    items?: Array<InvoiceItems>;
    /**
     * 
     * @type {InvoiceBuyer}
     * @memberof Invoice
     */
    buyer?: InvoiceBuyer;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    type?: InvoiceTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    summary?: string;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    project?: string;
    /**
     * 
     * @type {InvoiceDuplicate}
     * @memberof Invoice
     */
    duplicate?: InvoiceDuplicate;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    uri?: string;
    /**
     * 
     * @type {string}
     * @memberof Invoice
     */
    __array__?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum InvoiceTypeEnum {
    Vat = 'vat',
    Correction = 'correction'
}

/**
 * 
 * @export
 * @interface InvoiceBuyer
 */
export interface InvoiceBuyer {
    /**
     * 
     * @type {string}
     * @memberof InvoiceBuyer
     */
    company: string;
    /**
     * 
     * @type {InvoiceBuyerAddress}
     * @memberof InvoiceBuyer
     */
    address?: InvoiceBuyerAddress;
    /**
     * 
     * @type {string}
     * @memberof InvoiceBuyer
     */
    nip?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceBuyer
     */
    email?: string;
}
/**
 * 
 * @export
 * @interface InvoiceBuyerAddress
 */
export interface InvoiceBuyerAddress {
    /**
     * 
     * @type {string}
     * @memberof InvoiceBuyerAddress
     */
    street: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceBuyerAddress
     */
    zipcode?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceBuyerAddress
     */
    city: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceBuyerAddress
     */
    country: string;
}
/**
 * 
 * @export
 * @interface InvoiceDuplicate
 */
export interface InvoiceDuplicate {
    /**
     * 
     * @type {string}
     * @memberof InvoiceDuplicate
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceDuplicate
     */
    id?: string;
}
/**
 * 
 * @export
 * @interface InvoiceItems
 */
export interface InvoiceItems {
    /**
     * 
     * @type {string}
     * @memberof InvoiceItems
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceItems
     */
    price: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceItems
     */
    netto: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceItems
     */
    brutto: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceItems
     */
    vatAmount: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceItems
     */
    vatRate: string;
    /**
     * 
     * @type {number}
     * @memberof InvoiceItems
     */
    quantity: number;
}
/**
 * 
 * @export
 * @interface InvoiceSeller
 */
export interface InvoiceSeller {
    /**
     * 
     * @type {string}
     * @memberof InvoiceSeller
     */
    company: string;
    /**
     * 
     * @type {InvoiceSellerAddress}
     * @memberof InvoiceSeller
     */
    address?: InvoiceSellerAddress;
    /**
     * 
     * @type {string}
     * @memberof InvoiceSeller
     */
    nip: string;
}
/**
 * 
 * @export
 * @interface InvoiceSellerAddress
 */
export interface InvoiceSellerAddress {
    /**
     * 
     * @type {string}
     * @memberof InvoiceSellerAddress
     */
    street: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceSellerAddress
     */
    zipcode: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceSellerAddress
     */
    city: string;
    /**
     * 
     * @type {string}
     * @memberof InvoiceSellerAddress
     */
    country: string;
}
/**
 * 
 * @export
 * @interface Ip
 */
export interface Ip {
    /**
     * 
     * @type {string}
     * @memberof Ip
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Ip
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Ip
     */
    flavour?: string;
    /**
     * 
     * @type {string}
     * @memberof Ip
     */
    modifiedOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Ip
     */
    modifiedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Ip
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Ip
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Ip
     */
    state?: IpStateEnum;
    /**
     * 
     * @type {string}
     * @memberof Ip
     */
    project?: string;
    /**
     * 
     * @type {string}
     * @memberof Ip
     */
    uri?: string;
    /**
     * 
     * @type {string}
     * @memberof Ip
     */
    address?: string;
    /**
     * 
     * @type {string}
     * @memberof Ip
     */
    fqdn?: string;
    /**
     * 
     * @type {string}
     * @memberof Ip
     */
    network?: string;
    /**
     * 
     * @type {string}
     * @memberof Ip
     */
    ptrRecord?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Ip
     */
    persistent?: boolean;
    /**
     * 
     * @type {IpAssociated}
     * @memberof Ip
     */
    associated?: IpAssociated;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof Ip
     */
    tag?: Array<Tag>;
}

/**
    * @export
    * @enum {string}
    */
export enum IpStateEnum {
    Associated = 'Associated',
    Allocated = 'Allocated',
    Unallocated = 'Unallocated'
}

/**
 * 
 * @export
 * @interface IpAssociated
 */
export interface IpAssociated {
    /**
     * 
     * @type {string}
     * @memberof IpAssociated
     */
    ip?: string;
    /**
     * 
     * @type {string}
     * @memberof IpAssociated
     */
    fip?: string;
    /**
     * 
     * @type {string}
     * @memberof IpAssociated
     */
    netadp?: string;
}
/**
 * 
 * @export
 * @interface Iso
 */
export interface Iso {
    /**
     * 
     * @type {string}
     * @memberof Iso
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Iso
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Iso
     */
    flavour?: string;
    /**
     * 
     * @type {string}
     * @memberof Iso
     */
    modifiedOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Iso
     */
    modifiedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Iso
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Iso
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Iso
     */
    state?: IsoStateEnum;
    /**
     * 
     * @type {string}
     * @memberof Iso
     */
    project?: string;
    /**
     * 
     * @type {string}
     * @memberof Iso
     */
    uri?: string;
    /**
     * 
     * @type {number}
     * @memberof Iso
     */
    size?: number;
    /**
     * 
     * @type {IsoMetadata}
     * @memberof Iso
     */
    metadata?: IsoMetadata;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof Iso
     */
    tag?: Array<Tag>;
}

/**
    * @export
    * @enum {string}
    */
export enum IsoStateEnum {
    Uploading = 'Uploading',
    Online = 'Online',
    Unknown = 'Unknown',
    Processing = 'Processing',
    NotCreated = 'NotCreated'
}

/**
 * 
 * @export
 * @interface IsoMetadata
 */
export interface IsoMetadata {
    /**
     * 
     * @type {IsoMetadataSource}
     * @memberof IsoMetadata
     */
    source?: IsoMetadataSource;
}
/**
 * 
 * @export
 * @interface IsoMetadataSource
 */
export interface IsoMetadataSource {
    /**
     * 
     * @type {string}
     * @memberof IsoMetadataSource
     */
    filename?: string;
    /**
     * 
     * @type {number}
     * @memberof IsoMetadataSource
     */
    size?: number;
}
/**
 * 
 * @export
 * @interface Journal
 */
export interface Journal {
    /**
     * 
     * @type {string}
     * @memberof Journal
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Journal
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Journal
     */
    flavour?: string;
    /**
     * 
     * @type {string}
     * @memberof Journal
     */
    modifiedOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Journal
     */
    modifiedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Journal
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Journal
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Journal
     */
    state?: JournalStateEnum;
    /**
     * 
     * @type {string}
     * @memberof Journal
     */
    project?: string;
    /**
     * 
     * @type {string}
     * @memberof Journal
     */
    uri?: string;
    /**
     * 
     * @type {number}
     * @memberof Journal
     */
    sizeUsed?: number;
    /**
     * 
     * @type {number}
     * @memberof Journal
     */
    retention?: number;
    /**
     * 
     * @type {string}
     * @memberof Journal
     */
    fqdn?: string;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof Journal
     */
    tag?: Array<Tag>;
}

/**
    * @export
    * @enum {string}
    */
export enum JournalStateEnum {
    Online = 'Online',
    Unknown = 'Unknown',
    Processing = 'Processing',
    NotCreated = 'NotCreated'
}

/**
 * 
 * @export
 * @interface JournalCredential
 */
export interface JournalCredential {
    /**
     * 
     * @type {string}
     * @memberof JournalCredential
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof JournalCredential
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof JournalCredential
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof JournalCredential
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof JournalCredential
     */
    type: JournalCredentialTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof JournalCredential
     */
    value: string;
    /**
     * 
     * @type {string}
     * @memberof JournalCredential
     */
    fingerprint?: string;
    /**
     * 
     * @type {string}
     * @memberof JournalCredential
     */
    token?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum JournalCredentialTypeEnum {
    Sha512 = 'sha512',
    Plain = 'plain'
}

/**
 * 
 * @export
 * @interface Log
 */
export interface Log {
    /**
     * 
     * @type {string}
     * @memberof Log
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof Log
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Log
     */
    type: LogTypeEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum LogTypeEnum {
    Console = 'console'
}

/**
 * 
 * @export
 * @interface MessageData
 */
export interface MessageData {
    /**
     * 
     * @type {string}
     * @memberof MessageData
     */
    mime: MessageDataMimeEnum;
    /**
     * 
     * @type {string}
     * @memberof MessageData
     */
    url?: string;
    /**
     * 
     * @type {string}
     * @memberof MessageData
     */
    body?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum MessageDataMimeEnum {
    TextPlain = 'text/plain',
    ImagePng = 'image/png',
    ImageJpeg = 'image/jpeg'
}

/**
 * 
 * @export
 * @interface Metric
 */
export interface Metric {
    /**
     * 
     * @type {string}
     * @memberof Metric
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof Metric
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Metric
     */
    unit: string;
    /**
     * 
     * @type {Array<MetricDimension>}
     * @memberof Metric
     */
    dimension?: Array<MetricDimension>;
}
/**
 * 
 * @export
 * @interface MetricDimension
 */
export interface MetricDimension {
    /**
     * 
     * @type {string}
     * @memberof MetricDimension
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof MetricDimension
     */
    description: string;
}
/**
 * 
 * @export
 * @interface Netadp
 */
export interface Netadp {
    /**
     * 
     * @type {string}
     * @memberof Netadp
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Netadp
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Netadp
     */
    flavour?: string;
    /**
     * 
     * @type {string}
     * @memberof Netadp
     */
    modifiedOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Netadp
     */
    modifiedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Netadp
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Netadp
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Netadp
     */
    state?: NetadpStateEnum;
    /**
     * 
     * @type {string}
     * @memberof Netadp
     */
    project?: string;
    /**
     * 
     * @type {string}
     * @memberof Netadp
     */
    uri?: string;
    /**
     * 
     * @type {string}
     * @memberof Netadp
     */
    macaddress?: string;
    /**
     * 
     * @type {number}
     * @memberof Netadp
     */
    speed?: number;
    /**
     * 
     * @type {string}
     * @memberof Netadp
     */
    fqdn?: string;
    /**
     * 
     * @type {string}
     * @memberof Netadp
     */
    network?: string;
    /**
     * 
     * @type {string}
     * @memberof Netadp
     */
    firewall?: string;
    /**
     * 
     * @type {string}
     * @memberof Netadp
     */
    assigned?: string;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof Netadp
     */
    tag?: Array<Tag>;
}

/**
    * @export
    * @enum {string}
    */
export enum NetadpStateEnum {
    Online = 'Online',
    Deallocated = 'Deallocated',
    Unknown = 'Unknown',
    Processing = 'Processing',
    NotCreated = 'NotCreated'
}

/**
 * 
 * @export
 * @interface Netgw
 */
export interface Netgw {
    /**
     * 
     * @type {string}
     * @memberof Netgw
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Netgw
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Netgw
     */
    flavour?: string;
    /**
     * 
     * @type {string}
     * @memberof Netgw
     */
    modifiedOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Netgw
     */
    modifiedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Netgw
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Netgw
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Netgw
     */
    state?: NetgwStateEnum;
    /**
     * 
     * @type {string}
     * @memberof Netgw
     */
    project?: string;
    /**
     * 
     * @type {string}
     * @memberof Netgw
     */
    uri?: string;
    /**
     * 
     * @type {string}
     * @memberof Netgw
     */
    primaryIP?: string;
    /**
     * 
     * @type {string}
     * @memberof Netgw
     */
    network?: string;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof Netgw
     */
    tag?: Array<Tag>;
}

/**
    * @export
    * @enum {string}
    */
export enum NetgwStateEnum {
    Attached = 'Attached',
    Detached = 'Detached',
    Unknown = 'Unknown',
    Processing = 'Processing',
    NotCreated = 'NotCreated'
}

/**
 * 
 * @export
 * @interface NetgwPrivate
 */
export interface NetgwPrivate {
    /**
     * 
     * @type {string}
     * @memberof NetgwPrivate
     */
    network: string;
}
/**
 * 
 * @export
 * @interface NetgwPublic
 */
export interface NetgwPublic {
    /**
     * 
     * @type {string}
     * @memberof NetgwPublic
     */
    ip: string;
}
/**
 * 
 * @export
 * @interface Network
 */
export interface Network {
    /**
     * 
     * @type {string}
     * @memberof Network
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Network
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Network
     */
    flavour?: string;
    /**
     * 
     * @type {string}
     * @memberof Network
     */
    modifiedOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Network
     */
    modifiedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Network
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Network
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Network
     */
    state?: NetworkStateEnum;
    /**
     * 
     * @type {string}
     * @memberof Network
     */
    project?: string;
    /**
     * 
     * @type {string}
     * @memberof Network
     */
    uri?: string;
    /**
     * 
     * @type {string}
     * @memberof Network
     */
    address?: string;
    /**
     * 
     * @type {string}
     * @memberof Network
     */
    gateway?: string;
    /**
     * 
     * @type {string}
     * @memberof Network
     */
    type?: NetworkTypeEnum;
    /**
     * 
     * @type {NetworkDns}
     * @memberof Network
     */
    dns?: NetworkDns;
    /**
     * 
     * @type {string}
     * @memberof Network
     */
    netgw?: string;
    /**
     * 
     * @type {string}
     * @memberof Network
     */
    firewall?: string;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof Network
     */
    tag?: Array<Tag>;
}

/**
    * @export
    * @enum {string}
    */
export enum NetworkStateEnum {
    Online = 'Online',
    Unknown = 'Unknown',
    Processing = 'Processing',
    NotCreated = 'NotCreated'
}
/**
    * @export
    * @enum {string}
    */
export enum NetworkTypeEnum {
    Public = 'public',
    Private = 'private'
}

/**
 * 
 * @export
 * @interface NetworkDns
 */
export interface NetworkDns {
    /**
     * 
     * @type {Array<string>}
     * @memberof NetworkDns
     */
    nameservers?: Array<string>;
}
/**
 * 
 * @export
 * @interface NetworkingProjectFirewallCreate
 */
export interface NetworkingProjectFirewallCreate {
    /**
     * 
     * @type {string}
     * @memberof NetworkingProjectFirewallCreate
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof NetworkingProjectFirewallCreate
     */
    service?: string;
    /**
     * 
     * @type {Array<NetworkingRule>}
     * @memberof NetworkingProjectFirewallCreate
     */
    ingress?: Array<NetworkingRule>;
    /**
     * 
     * @type {Array<NetworkingRule>}
     * @memberof NetworkingProjectFirewallCreate
     */
    egress?: Array<NetworkingRule>;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof NetworkingProjectFirewallCreate
     */
    tag?: Array<Tag>;
}
/**
 * 
 * @export
 * @interface NetworkingProjectFirewallTransfer
 */
export interface NetworkingProjectFirewallTransfer {
    /**
     * 
     * @type {string}
     * @memberof NetworkingProjectFirewallTransfer
     */
    project: string;
}
/**
 * 
 * @export
 * @interface NetworkingProjectFirewallUpdate
 */
export interface NetworkingProjectFirewallUpdate {
    /**
     * 
     * @type {string}
     * @memberof NetworkingProjectFirewallUpdate
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface NetworkingProjectIpAssociate
 */
export interface NetworkingProjectIpAssociate {
    /**
     * 
     * @type {string}
     * @memberof NetworkingProjectIpAssociate
     */
    ip: string;
}
/**
 * 
 * @export
 * @interface NetworkingProjectIpCreate
 */
export interface NetworkingProjectIpCreate {
    /**
     * 
     * @type {string}
     * @memberof NetworkingProjectIpCreate
     */
    network?: string;
    /**
     * 
     * @type {string}
     * @memberof NetworkingProjectIpCreate
     */
    ptrRecord?: string;
    /**
     * 
     * @type {string}
     * @memberof NetworkingProjectIpCreate
     */
    address?: string;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof NetworkingProjectIpCreate
     */
    tag?: Array<Tag>;
}
/**
 * 
 * @export
 * @interface NetworkingProjectIpTransfer
 */
export interface NetworkingProjectIpTransfer {
    /**
     * 
     * @type {string}
     * @memberof NetworkingProjectIpTransfer
     */
    project: string;
}
/**
 * 
 * @export
 * @interface NetworkingProjectIpUpdate
 */
export interface NetworkingProjectIpUpdate {
    /**
     * 
     * @type {string}
     * @memberof NetworkingProjectIpUpdate
     */
    ptrRecord?: string;
}
/**
 * 
 * @export
 * @interface NetworkingProjectNetadpCreate
 */
export interface NetworkingProjectNetadpCreate {
    /**
     * 
     * @type {string}
     * @memberof NetworkingProjectNetadpCreate
     */
    vm: string;
    /**
     * 
     * @type {string}
     * @memberof NetworkingProjectNetadpCreate
     */
    network: string;
    /**
     * 
     * @type {string}
     * @memberof NetworkingProjectNetadpCreate
     */
    firewall?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof NetworkingProjectNetadpCreate
     */
    ip?: Array<string>;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof NetworkingProjectNetadpCreate
     */
    tag?: Array<Tag>;
}
/**
 * 
 * @export
 * @interface NetworkingProjectNetadpUpdate
 */
export interface NetworkingProjectNetadpUpdate {
    /**
     * 
     * @type {string}
     * @memberof NetworkingProjectNetadpUpdate
     */
    firewall?: string | null;
}
/**
 * 
 * @export
 * @interface NetworkingProjectNetgwAttach
 */
export interface NetworkingProjectNetgwAttach {
    /**
     * 
     * @type {NetgwPrivate}
     * @memberof NetworkingProjectNetgwAttach
     */
    _private?: NetgwPrivate;
}
/**
 * 
 * @export
 * @interface NetworkingProjectNetgwCreate
 */
export interface NetworkingProjectNetgwCreate {
    /**
     * 
     * @type {string}
     * @memberof NetworkingProjectNetgwCreate
     */
    name?: string;
    /**
     * 
     * @type {NetgwPublic}
     * @memberof NetworkingProjectNetgwCreate
     */
    _public?: NetgwPublic;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof NetworkingProjectNetgwCreate
     */
    tag?: Array<Tag>;
}
/**
 * 
 * @export
 * @interface NetworkingProjectNetgwUpdate
 */
export interface NetworkingProjectNetgwUpdate {
    /**
     * 
     * @type {string}
     * @memberof NetworkingProjectNetgwUpdate
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface NetworkingProjectNetworkCreate
 */
export interface NetworkingProjectNetworkCreate {
    /**
     * 
     * @type {string}
     * @memberof NetworkingProjectNetworkCreate
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof NetworkingProjectNetworkCreate
     */
    address?: string;
    /**
     * 
     * @type {string}
     * @memberof NetworkingProjectNetworkCreate
     */
    gateway?: string;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof NetworkingProjectNetworkCreate
     */
    tag?: Array<Tag>;
}
/**
 * 
 * @export
 * @interface NetworkingProjectNetworkUpdate
 */
export interface NetworkingProjectNetworkUpdate {
    /**
     * 
     * @type {string}
     * @memberof NetworkingProjectNetworkUpdate
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof NetworkingProjectNetworkUpdate
     */
    gateway?: string;
    /**
     * 
     * @type {string}
     * @memberof NetworkingProjectNetworkUpdate
     */
    firewall?: string;
}
/**
 * 
 * @export
 * @interface NetworkingRule
 */
export interface NetworkingRule {
    /**
     * 
     * @type {string}
     * @memberof NetworkingRule
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof NetworkingRule
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof NetworkingRule
     */
    action: NetworkingRuleActionEnum;
    /**
     * 
     * @type {number}
     * @memberof NetworkingRule
     */
    priority: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof NetworkingRule
     */
    filter: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof NetworkingRule
     */
    external?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof NetworkingRule
     */
    internal?: Array<string>;
}

/**
    * @export
    * @enum {string}
    */
export enum NetworkingRuleActionEnum {
    Allow = 'allow',
    Deny = 'deny'
}

/**
 * 
 * @export
 * @interface Organisation
 */
export interface Organisation {
    /**
     * 
     * @type {string}
     * @memberof Organisation
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Organisation
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Organisation
     */
    flavour?: string;
    /**
     * 
     * @type {string}
     * @memberof Organisation
     */
    modifiedOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Organisation
     */
    modifiedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Organisation
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Organisation
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Organisation
     */
    state?: OrganisationStateEnum;
    /**
     * 
     * @type {string}
     * @memberof Organisation
     */
    uri?: string;
    /**
     * 
     * @type {OrganisationBilling}
     * @memberof Organisation
     */
    billing?: OrganisationBilling;
    /**
     * 
     * @type {string}
     * @memberof Organisation
     */
    bankAccount?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum OrganisationStateEnum {
    Active = 'Active',
    Inactive = 'Inactive',
    Processing = 'Processing',
    NotCreated = 'NotCreated'
}

/**
 * 
 * @export
 * @interface OrganisationBilling
 */
export interface OrganisationBilling {
    /**
     * 
     * @type {string}
     * @memberof OrganisationBilling
     */
    currency?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganisationBilling
     */
    company?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganisationBilling
     */
    email?: string;
    /**
     * 
     * @type {InvoiceSellerAddress}
     * @memberof OrganisationBilling
     */
    address?: InvoiceSellerAddress;
    /**
     * 
     * @type {string}
     * @memberof OrganisationBilling
     */
    nip?: string;
}
/**
 * 
 * @export
 * @interface OrganisationBilling1
 */
export interface OrganisationBilling1 {
    /**
     * 
     * @type {string}
     * @memberof OrganisationBilling1
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof OrganisationBilling1
     */
    company?: string;
    /**
     * 
     * @type {BillingAddress1}
     * @memberof OrganisationBilling1
     */
    address?: BillingAddress1;
}
/**
 * 
 * @export
 * @interface Ownership
 */
export interface Ownership {
    /**
     * 
     * @type {string}
     * @memberof Ownership
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof Ownership
     */
    user: string;
}
/**
 * 
 * @export
 * @interface Payment
 */
export interface Payment {
    /**
     * 
     * @type {string}
     * @memberof Payment
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Payment
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Payment
     */
    modifiedOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Payment
     */
    modifiedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Payment
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Payment
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Payment
     */
    state?: PaymentStateEnum;
    /**
     * 
     * @type {string}
     * @memberof Payment
     */
    project?: string;
    /**
     * 
     * @type {string}
     * @memberof Payment
     */
    uri?: string;
    /**
     * 
     * @type {number}
     * @memberof Payment
     */
    creditsFree?: number;
    /**
     * 
     * @type {number}
     * @memberof Payment
     */
    credits?: number;
    /**
     * 
     * @type {string}
     * @memberof Payment
     */
    channel?: PaymentChannelEnum;
    /**
     * 
     * @type {number}
     * @memberof Payment
     */
    amount?: number;
}

/**
    * @export
    * @enum {string}
    */
export enum PaymentStateEnum {
    Unallocated = 'Unallocated',
    Allocated = 'Allocated',
    Expired = 'Expired'
}
/**
    * @export
    * @enum {string}
    */
export enum PaymentChannelEnum {
    Bank = 'bank',
    Dotpay = 'dotpay',
    Promo = 'promo',
    Paypal = 'paypal',
    Ecard = 'ecard',
    Przelewy24 = 'przelewy24'
}

/**
 * 
 * @export
 * @interface Plan
 */
export interface Plan {
    /**
     * 
     * @type {string}
     * @memberof Plan
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Plan
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Plan
     */
    flavour?: string;
    /**
     * 
     * @type {string}
     * @memberof Plan
     */
    modifiedOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Plan
     */
    modifiedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Plan
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Plan
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Plan
     */
    state?: PlanStateEnum;
    /**
     * 
     * @type {string}
     * @memberof Plan
     */
    project?: string;
    /**
     * 
     * @type {string}
     * @memberof Plan
     */
    uri?: string;
    /**
     * 
     * @type {Array<PlanWindow>}
     * @memberof Plan
     */
    window?: Array<PlanWindow>;
    /**
     * 
     * @type {Array<PlanRetention>}
     * @memberof Plan
     */
    retention?: Array<PlanRetention>;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof Plan
     */
    tag?: Array<Tag>;
}

/**
    * @export
    * @enum {string}
    */
export enum PlanStateEnum {
    Online = 'Online',
    Unauthorized = 'Unauthorized',
    Unknown = 'Unknown',
    Processing = 'Processing',
    NotCreated = 'NotCreated'
}

/**
 * 
 * @export
 * @interface PlanRetention
 */
export interface PlanRetention {
    /**
     * 
     * @type {string}
     * @memberof PlanRetention
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof PlanRetention
     */
    interval?: string;
    /**
     * 
     * @type {number}
     * @memberof PlanRetention
     */
    count?: number;
}
/**
 * 
 * @export
 * @interface PlanWindow
 */
export interface PlanWindow {
    /**
     * 
     * @type {string}
     * @memberof PlanWindow
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof PlanWindow
     */
    interval?: string;
}
/**
 * 
 * @export
 * @interface Point
 */
export interface Point {
    /**
     * 
     * @type {string}
     * @memberof Point
     */
    time: string;
    /**
     * 
     * @type {number}
     * @memberof Point
     */
    value: number;
}
/**
 * 
 * @export
 * @interface Policy
 */
export interface Policy {
    /**
     * 
     * @type {string}
     * @memberof Policy
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Policy
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Policy
     */
    flavour?: string;
    /**
     * 
     * @type {string}
     * @memberof Policy
     */
    modifiedOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Policy
     */
    modifiedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Policy
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Policy
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Policy
     */
    state?: PolicyStateEnum;
    /**
     * 
     * @type {string}
     * @memberof Policy
     */
    project?: string;
    /**
     * 
     * @type {string}
     * @memberof Policy
     */
    organisation?: string;
    /**
     * 
     * @type {string}
     * @memberof Policy
     */
    uri?: string;
    /**
     * 
     * @type {string}
     * @memberof Policy
     */
    role?: string;
    /**
     * 
     * @type {string}
     * @memberof Policy
     */
    resource?: string;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof Policy
     */
    tag?: Array<Tag>;
}

/**
    * @export
    * @enum {string}
    */
export enum PolicyStateEnum {
    Online = 'Online',
    Processing = 'Processing',
    NotCreated = 'NotCreated'
}

/**
 * 
 * @export
 * @interface Proforma
 */
export interface Proforma {
    /**
     * 
     * @type {string}
     * @memberof Proforma
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Proforma
     */
    invoiceNo?: string;
    /**
     * 
     * @type {ProformaSeller}
     * @memberof Proforma
     */
    seller?: ProformaSeller;
    /**
     * 
     * @type {InvoiceBuyer}
     * @memberof Proforma
     */
    buyer?: InvoiceBuyer;
    /**
     * 
     * @type {string}
     * @memberof Proforma
     */
    issueDate?: string;
    /**
     * 
     * @type {Array<InvoiceItems>}
     * @memberof Proforma
     */
    items?: Array<InvoiceItems>;
    /**
     * 
     * @type {string}
     * @memberof Proforma
     */
    summary?: string;
    /**
     * 
     * @type {string}
     * @memberof Proforma
     */
    project?: string;
    /**
     * 
     * @type {string}
     * @memberof Proforma
     */
    uri?: string;
    /**
     * 
     * @type {ProformaArray}
     * @memberof Proforma
     */
    __array__?: ProformaArray;
}
/**
 * 
 * @export
 * @interface ProformaArray
 */
export interface ProformaArray {
    /**
     * 
     * @type {string}
     * @memberof ProformaArray
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ProformaArray
     */
    invoiceNo?: string;
    /**
     * 
     * @type {string}
     * @memberof ProformaArray
     */
    issueDate?: string;
    /**
     * 
     * @type {string}
     * @memberof ProformaArray
     */
    summary?: string;
    /**
     * 
     * @type {string}
     * @memberof ProformaArray
     */
    project?: string;
    /**
     * 
     * @type {string}
     * @memberof ProformaArray
     */
    uri?: string;
}
/**
 * 
 * @export
 * @interface ProformaSeller
 */
export interface ProformaSeller {
    /**
     * 
     * @type {string}
     * @memberof ProformaSeller
     */
    company: string;
    /**
     * 
     * @type {InvoiceSellerAddress}
     * @memberof ProformaSeller
     */
    address?: InvoiceSellerAddress;
    /**
     * 
     * @type {string}
     * @memberof ProformaSeller
     */
    nip: string;
    /**
     * 
     * @type {string}
     * @memberof ProformaSeller
     */
    iban: string;
}
/**
 * 
 * @export
 * @interface Project
 */
export interface Project {
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    flavour?: string;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    modifiedOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    modifiedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    state?: ProjectStateEnum;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    organisation?: string;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    uri?: string;
    /**
     * 
     * @type {string}
     * @memberof Project
     */
    bankAccount?: string;
    /**
     * 
     * @type {ProjectBilling}
     * @memberof Project
     */
    billing?: ProjectBilling;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof Project
     */
    tag?: Array<Tag>;
}

/**
    * @export
    * @enum {string}
    */
export enum ProjectStateEnum {
    Active = 'Active',
    Inactive = 'Inactive',
    Limited = 'Limited',
    Transferring = 'Transferring',
    Processing = 'Processing',
    NotCreated = 'NotCreated'
}

/**
 * 
 * @export
 * @interface ProjectBilling
 */
export interface ProjectBilling {
    /**
     * 
     * @type {number}
     * @memberof ProjectBilling
     */
    credits?: number;
    /**
     * 
     * @type {number}
     * @memberof ProjectBilling
     */
    creditsBonus?: number;
    /**
     * 
     * @type {number}
     * @memberof ProjectBilling
     */
    creditLimit?: number;
}
/**
 * 
 * @export
 * @interface ProjectCredential
 */
export interface ProjectCredential {
    /**
     * 
     * @type {string}
     * @memberof ProjectCredential
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectCredential
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectCredential
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectCredential
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectCredential
     */
    type: ProjectCredentialTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof ProjectCredential
     */
    value: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectCredential
     */
    fingerprint?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectCredential
     */
    token?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ProjectCredentialTypeEnum {
    Ssh = 'ssh'
}

/**
 * 
 * @export
 * @interface ProjectFeature
 */
export interface ProjectFeature {
    /**
     * 
     * @type {boolean}
     * @memberof ProjectFeature
     */
    earlyAdopter?: boolean;
}
/**
 * 
 * @export
 * @interface ProjectThreshold
 */
export interface ProjectThreshold {
    /**
     * 
     * @type {string}
     * @memberof ProjectThreshold
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectThreshold
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectThreshold
     */
    type?: string;
    /**
     * 
     * @type {number}
     * @memberof ProjectThreshold
     */
    value?: number;
    /**
     * 
     * @type {string}
     * @memberof ProjectThreshold
     */
    uri?: string;
}
/**
 * 
 * @export
 * @interface ProviderAgentResource
 */
export interface ProviderAgentResource {
    /**
     * 
     * @type {string}
     * @memberof ProviderAgentResource
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ProviderAgentResource
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ProviderAgentResource
     */
    state?: string;
    /**
     * 
     * @type {string}
     * @memberof ProviderAgentResource
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof ProviderAgentResource
     */
    project?: string;
    /**
     * 
     * @type {string}
     * @memberof ProviderAgentResource
     */
    resource?: string;
}
/**
 * 
 * @export
 * @interface ProviderAgentResourceEvent
 */
export interface ProviderAgentResourceEvent {
    /**
     * 
     * @type {string}
     * @memberof ProviderAgentResourceEvent
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ProviderAgentResourceEvent
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ProviderAgentResourceEvent
     */
    state?: ProviderAgentResourceEventStateEnum;
    /**
     * 
     * @type {string}
     * @memberof ProviderAgentResourceEvent
     */
    createdOn?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ProviderAgentResourceEventStateEnum {
    Pending = 'pending',
    Processing = 'processing',
    Finished = 'finished',
    Error = 'error'
}

/**
 * 
 * @export
 * @interface ProviderProjectAgentCreate
 */
export interface ProviderProjectAgentCreate {
    /**
     * 
     * @type {string}
     * @memberof ProviderProjectAgentCreate
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof ProviderProjectAgentCreate
     */
    service: string;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof ProviderProjectAgentCreate
     */
    tag?: Array<Tag>;
}
/**
 * 
 * @export
 * @interface ProviderProjectAgentCredentialPatch
 */
export interface ProviderProjectAgentCredentialPatch {
    /**
     * 
     * @type {string}
     * @memberof ProviderProjectAgentCredentialPatch
     */
    name: string;
}
/**
 * 
 * @export
 * @interface ProviderProjectAgentTransfer
 */
export interface ProviderProjectAgentTransfer {
    /**
     * 
     * @type {string}
     * @memberof ProviderProjectAgentTransfer
     */
    project: string;
}
/**
 * 
 * @export
 * @interface ProviderProjectAgentUpdate
 */
export interface ProviderProjectAgentUpdate {
    /**
     * 
     * @type {string}
     * @memberof ProviderProjectAgentUpdate
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface Quota
 */
export interface Quota {
    /**
     * 
     * @type {string}
     * @memberof Quota
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Quota
     */
    name?: string;
    /**
     * 
     * @type {QuotaMetric}
     * @memberof Quota
     */
    metric?: QuotaMetric;
    /**
     * 
     * @type {number}
     * @memberof Quota
     */
    usage?: number;
    /**
     * 
     * @type {QuotaLimit}
     * @memberof Quota
     */
    limit?: QuotaLimit;
}
/**
 * 
 * @export
 * @interface QuotaLimit
 */
export interface QuotaLimit {
    /**
     * 
     * @type {number}
     * @memberof QuotaLimit
     */
    platform?: number;
    /**
     * 
     * @type {number}
     * @memberof QuotaLimit
     */
    user?: number;
    /**
     * 
     * @type {number}
     * @memberof QuotaLimit
     */
    effective?: number;
}
/**
 * 
 * @export
 * @interface QuotaMetric
 */
export interface QuotaMetric {
    /**
     * 
     * @type {string}
     * @memberof QuotaMetric
     */
    key?: string;
    /**
     * 
     * @type {string}
     * @memberof QuotaMetric
     */
    unit?: string;
}
/**
 * 
 * @export
 * @interface RecoveryProjectBackupCreate
 */
export interface RecoveryProjectBackupCreate {
    /**
     * 
     * @type {string}
     * @memberof RecoveryProjectBackupCreate
     */
    name: string;
    /**
     * 
     * @type {}
     * @memberof RecoveryProjectBackupCreate
     */
    source: any;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof RecoveryProjectBackupCreate
     */
    tag?: Array<Tag>;
}
/**
 * 
 * @export
 * @interface RecoveryProjectBackupExport
 */
export interface RecoveryProjectBackupExport {
    /**
     * 
     * @type {string}
     * @memberof RecoveryProjectBackupExport
     */
    bucket: string;
}
/**
 * 
 * @export
 * @interface RecoveryProjectBackupUpdate
 */
export interface RecoveryProjectBackupUpdate {
    /**
     * 
     * @type {string}
     * @memberof RecoveryProjectBackupUpdate
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface RecoveryProjectPlanCreate
 */
export interface RecoveryProjectPlanCreate {
    /**
     * 
     * @type {string}
     * @memberof RecoveryProjectPlanCreate
     */
    name: string;
    /**
     * 
     * @type {Array<RecoveryProjectPlanCreateWindow>}
     * @memberof RecoveryProjectPlanCreate
     */
    window?: Array<RecoveryProjectPlanCreateWindow>;
    /**
     * 
     * @type {Array<RecoveryProjectPlanCreateRetention>}
     * @memberof RecoveryProjectPlanCreate
     */
    retention?: Array<RecoveryProjectPlanCreateRetention>;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof RecoveryProjectPlanCreate
     */
    tag?: Array<Tag>;
}
/**
 * 
 * @export
 * @interface RecoveryProjectPlanCreateRetention
 */
export interface RecoveryProjectPlanCreateRetention {
    /**
     * 
     * @type {string}
     * @memberof RecoveryProjectPlanCreateRetention
     */
    interval: RecoveryProjectPlanCreateRetentionIntervalEnum;
    /**
     * 
     * @type {number}
     * @memberof RecoveryProjectPlanCreateRetention
     */
    count: number;
}

/**
    * @export
    * @enum {string}
    */
export enum RecoveryProjectPlanCreateRetentionIntervalEnum {
    P1D = 'R/2021-01-01T00:00:00Z/P1D',
    P1W = 'R/2021-01-01T00:00:00Z/P1W',
    P1M = 'R/2021-01-01T00:00:00Z/P1M'
}

/**
 * 
 * @export
 * @interface RecoveryProjectPlanCreateWindow
 */
export interface RecoveryProjectPlanCreateWindow {
    /**
     * 
     * @type {string}
     * @memberof RecoveryProjectPlanCreateWindow
     */
    interval: RecoveryProjectPlanCreateWindowIntervalEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum RecoveryProjectPlanCreateWindowIntervalEnum {
    _01T010000ZP1D = 'R/2021-01-01T01:00:00Z/P1D',
    _01T030000ZP1D = 'R/2021-01-01T03:00:00Z/P1D',
    _01T050000ZP1D = 'R/2021-01-01T05:00:00Z/P1D'
}

/**
 * 
 * @export
 * @interface RecoveryProjectPlanUpdate
 */
export interface RecoveryProjectPlanUpdate {
    /**
     * 
     * @type {string}
     * @memberof RecoveryProjectPlanUpdate
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface Registry
 */
export interface Registry {
    /**
     * 
     * @type {string}
     * @memberof Registry
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Registry
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Registry
     */
    flavour?: string;
    /**
     * 
     * @type {string}
     * @memberof Registry
     */
    modifiedOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Registry
     */
    modifiedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Registry
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Registry
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Registry
     */
    state?: RegistryStateEnum;
    /**
     * 
     * @type {string}
     * @memberof Registry
     */
    project?: string;
    /**
     * 
     * @type {string}
     * @memberof Registry
     */
    uri?: string;
    /**
     * 
     * @type {number}
     * @memberof Registry
     */
    sizeUsed?: number;
    /**
     * 
     * @type {string}
     * @memberof Registry
     */
    fqdn?: string;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof Registry
     */
    tag?: Array<Tag>;
}

/**
    * @export
    * @enum {string}
    */
export enum RegistryStateEnum {
    Running = 'Running',
    Off = 'Off',
    Unknown = 'Unknown',
    Processing = 'Processing',
    NotCreated = 'NotCreated'
}

/**
 * 
 * @export
 * @interface RegistryCredential
 */
export interface RegistryCredential {
    /**
     * 
     * @type {string}
     * @memberof RegistryCredential
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof RegistryCredential
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof RegistryCredential
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof RegistryCredential
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof RegistryCredential
     */
    type: RegistryCredentialTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof RegistryCredential
     */
    value: string;
    /**
     * 
     * @type {string}
     * @memberof RegistryCredential
     */
    fingerprint?: string;
    /**
     * 
     * @type {string}
     * @memberof RegistryCredential
     */
    token?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum RegistryCredentialTypeEnum {
    Sha512 = 'sha512',
    Plain = 'plain'
}

/**
 * 
 * @export
 * @interface Replica
 */
export interface Replica {
    /**
     * 
     * @type {string}
     * @memberof Replica
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Replica
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Replica
     */
    flavour?: string;
    /**
     * 
     * @type {string}
     * @memberof Replica
     */
    modifiedOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Replica
     */
    modifiedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Replica
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Replica
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Replica
     */
    state?: ReplicaStateEnum;
    /**
     * 
     * @type {string}
     * @memberof Replica
     */
    project?: string;
    /**
     * 
     * @type {string}
     * @memberof Replica
     */
    uri?: string;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof Replica
     */
    tag?: Array<Tag>;
}

/**
    * @export
    * @enum {string}
    */
export enum ReplicaStateEnum {
    Error = 'Error',
    FailOverWaitingCompletion = 'FailOverWaitingCompletion',
    FailedOver = 'FailedOver',
    NotApplicable = 'NotApplicable',
    ReadyForInitialReplication = 'ReadyForInitialReplication',
    Replicating = 'Replicating',
    Resynchronizing = 'Resynchronizing',
    ResynchronizeSuspended = 'ResynchronizeSuspended',
    Suspended = 'Suspended',
    SyncedReplicationComplete = 'SyncedReplicationComplete',
    WaitingForInitialReplication = 'WaitingForInitialReplication',
    WaitingForStartResynchronize = 'WaitingForStartResynchronize',
    Unknown = 'Unknown',
    Processing = 'Processing',
    NotCreated = 'NotCreated'
}

/**
 * 
 * @export
 * @interface Reservation
 */
export interface Reservation {
    /**
     * 
     * @type {string}
     * @memberof Reservation
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Reservation
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Reservation
     */
    flavour?: string;
    /**
     * 
     * @type {string}
     * @memberof Reservation
     */
    modifiedOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Reservation
     */
    modifiedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Reservation
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Reservation
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Reservation
     */
    state?: ReservationStateEnum;
    /**
     * 
     * @type {string}
     * @memberof Reservation
     */
    project?: string;
    /**
     * 
     * @type {string}
     * @memberof Reservation
     */
    uri?: string;
    /**
     * 
     * @type {string}
     * @memberof Reservation
     */
    kind?: string;
    /**
     * 
     * @type {string}
     * @memberof Reservation
     */
    assigned?: string;
    /**
     * 
     * @type {string}
     * @memberof Reservation
     */
    sourceService?: string;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof Reservation
     */
    tag?: Array<Tag>;
}

/**
    * @export
    * @enum {string}
    */
export enum ReservationStateEnum {
    Detached = 'Detached',
    Attached = 'Attached',
    Expired = 'Expired',
    Billing = 'Billing',
    Unknown = 'Unknown'
}

/**
 * 
 * @export
 * @interface ResourceConnect
 */
export interface ResourceConnect {
    /**
     * 
     * @type {string}
     * @memberof ResourceConnect
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ResourceConnect
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ResourceConnect
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof ResourceConnect
     */
    username?: string;
    /**
     * 
     * @type {string}
     * @memberof ResourceConnect
     */
    host?: string;
    /**
     * 
     * @type {string}
     * @memberof ResourceConnect
     */
    example?: string;
}
/**
 * 
 * @export
 * @interface ResourceService
 */
export interface ResourceService {
    /**
     * 
     * @type {string}
     * @memberof ResourceService
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ResourceService
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ResourceService
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof ResourceService
     */
    sourceService?: string;
    /**
     * 
     * @type {string}
     * @memberof ResourceService
     */
    billing?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof ResourceService
     */
    data?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface Role
 */
export interface Role {
    /**
     * 
     * @type {string}
     * @memberof Role
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Role
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Role
     */
    flavour?: string;
    /**
     * 
     * @type {string}
     * @memberof Role
     */
    modifiedOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Role
     */
    modifiedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Role
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Role
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Role
     */
    state?: RoleStateEnum;
    /**
     * 
     * @type {string}
     * @memberof Role
     */
    project?: string;
    /**
     * 
     * @type {string}
     * @memberof Role
     */
    organisation?: string;
    /**
     * 
     * @type {string}
     * @memberof Role
     */
    uri?: string;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof Role
     */
    tag?: Array<Tag>;
}

/**
    * @export
    * @enum {string}
    */
export enum RoleStateEnum {
    Online = 'Online',
    Processing = 'Processing',
    NotCreated = 'NotCreated'
}

/**
 * 
 * @export
 * @interface Sa
 */
export interface Sa {
    /**
     * 
     * @type {string}
     * @memberof Sa
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Sa
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Sa
     */
    flavour?: string;
    /**
     * 
     * @type {string}
     * @memberof Sa
     */
    modifiedOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Sa
     */
    modifiedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Sa
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Sa
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Sa
     */
    state?: SaStateEnum;
    /**
     * 
     * @type {string}
     * @memberof Sa
     */
    project?: string;
    /**
     * 
     * @type {string}
     * @memberof Sa
     */
    uri?: string;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof Sa
     */
    tag?: Array<Tag>;
}

/**
    * @export
    * @enum {string}
    */
export enum SaStateEnum {
    Online = 'Online',
    Processing = 'Processing',
    NotCreated = 'NotCreated'
}

/**
 * 
 * @export
 * @interface SaCredential
 */
export interface SaCredential {
    /**
     * 
     * @type {string}
     * @memberof SaCredential
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof SaCredential
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof SaCredential
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof SaCredential
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof SaCredential
     */
    type: SaCredentialTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof SaCredential
     */
    value: string;
    /**
     * 
     * @type {string}
     * @memberof SaCredential
     */
    fingerprint?: string;
    /**
     * 
     * @type {string}
     * @memberof SaCredential
     */
    token?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum SaCredentialTypeEnum {
    Ssh = 'ssh'
}

/**
 * 
 * @export
 * @interface Service
 */
export interface Service {
    /**
     * 
     * @type {string}
     * @memberof Service
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Service
     */
    resource?: string;
    /**
     * 
     * @type {string}
     * @memberof Service
     */
    type?: string;
    /**
     * 
     * @type {ServiceBilling}
     * @memberof Service
     */
    billing?: ServiceBilling;
    /**
     * 
     * @type {ServiceDisplay}
     * @memberof Service
     */
    display?: ServiceDisplay;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof Service
     */
    data?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof Service
     */
    name?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Service
     */
    availableServices?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Service
     */
    uri?: string;
}
/**
 * 
 * @export
 * @interface ServiceBilling
 */
export interface ServiceBilling {
    /**
     * 
     * @type {ServiceBillingPrice}
     * @memberof ServiceBilling
     */
    price?: ServiceBillingPrice;
    /**
     * 
     * @type {string}
     * @memberof ServiceBilling
     */
    period?: string;
    /**
     * 
     * @type {number}
     * @memberof ServiceBilling
     */
    quantity?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ServiceBilling
     */
    oneTime?: boolean;
    /**
     * 
     * @type {ServiceBillingReservations}
     * @memberof ServiceBilling
     */
    reservations?: ServiceBillingReservations;
}
/**
 * 
 * @export
 * @interface ServiceBillingPrice
 */
export interface ServiceBillingPrice {
    /**
     * 
     * @type {number}
     * @memberof ServiceBillingPrice
     */
    PLN?: number;
    /**
     * 
     * @type {number}
     * @memberof ServiceBillingPrice
     */
    EUR?: number;
    /**
     * 
     * @type {number}
     * @memberof ServiceBillingPrice
     */
    USD?: number;
    /**
     * 
     * @type {number}
     * @memberof ServiceBillingPrice
     */
    GBP?: number;
}
/**
 * 
 * @export
 * @interface ServiceBillingReservations
 */
export interface ServiceBillingReservations {
    /**
     * 
     * @type {string}
     * @memberof ServiceBillingReservations
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceBillingReservations
     */
    period?: string;
    /**
     * 
     * @type {ServiceBillingPrice}
     * @memberof ServiceBillingReservations
     */
    price?: ServiceBillingPrice;
    /**
     * 
     * @type {ServiceBillingPrice}
     * @memberof ServiceBillingReservations
     */
    resourcePrice?: ServiceBillingPrice;
}
/**
 * 
 * @export
 * @interface ServiceDisplay
 */
export interface ServiceDisplay {
    /**
     * 
     * @type {ServiceDisplayUnit}
     * @memberof ServiceDisplay
     */
    unit?: ServiceDisplayUnit;
}
/**
 * 
 * @export
 * @interface ServiceDisplayUnit
 */
export interface ServiceDisplayUnit {
    /**
     * 
     * @type {string}
     * @memberof ServiceDisplayUnit
     */
    usage?: string;
    /**
     * 
     * @type {string}
     * @memberof ServiceDisplayUnit
     */
    billing?: string;
}
/**
 * 
 * @export
 * @interface StorageObject
 */
export interface StorageObject {
    /**
     * 
     * @type {string}
     * @memberof StorageObject
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof StorageObject
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof StorageObject
     */
    size?: number;
    /**
     * 
     * @type {string}
     * @memberof StorageObject
     */
    createdOn?: string;
}
/**
 * 
 * @export
 * @interface StorageProjectBucketUpload
 */
export interface StorageProjectBucketUpload {
    /**
     * 
     * @type {string}
     * @memberof StorageProjectBucketUpload
     */
    name: string;
}
/**
 * 
 * @export
 * @interface StorageProjectDiskCreate
 */
export interface StorageProjectDiskCreate {
    /**
     * 
     * @type {string}
     * @memberof StorageProjectDiskCreate
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof StorageProjectDiskCreate
     */
    service: string;
    /**
     * 
     * @type {number}
     * @memberof StorageProjectDiskCreate
     */
    size: number;
    /**
     * 
     * @type {}
     * @memberof StorageProjectDiskCreate
     */
    source?: any;
    /**
     * 
     * @type {string}
     * @memberof StorageProjectDiskCreate
     */
    vm?: string;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof StorageProjectDiskCreate
     */
    tag?: Array<Tag>;
}
/**
 * 
 * @export
 * @interface StorageProjectDiskResize
 */
export interface StorageProjectDiskResize {
    /**
     * 
     * @type {number}
     * @memberof StorageProjectDiskResize
     */
    size: number;
}
/**
 * 
 * @export
 * @interface StorageProjectDiskTransfer
 */
export interface StorageProjectDiskTransfer {
    /**
     * 
     * @type {string}
     * @memberof StorageProjectDiskTransfer
     */
    project: string;
}
/**
 * 
 * @export
 * @interface StorageProjectDiskUpdate
 */
export interface StorageProjectDiskUpdate {
    /**
     * 
     * @type {string}
     * @memberof StorageProjectDiskUpdate
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface StorageProjectImageCreate
 */
export interface StorageProjectImageCreate {
    /**
     * 
     * @type {string}
     * @memberof StorageProjectImageCreate
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof StorageProjectImageCreate
     */
    service?: string;
    /**
     * 
     * @type {string}
     * @memberof StorageProjectImageCreate
     */
    vm?: string;
    /**
     * 
     * @type {string}
     * @memberof StorageProjectImageCreate
     */
    replica?: string;
    /**
     * 
     * @type {string}
     * @memberof StorageProjectImageCreate
     */
    description?: string;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof StorageProjectImageCreate
     */
    tag?: Array<Tag>;
}
/**
 * 
 * @export
 * @interface StorageProjectImageTransfer
 */
export interface StorageProjectImageTransfer {
    /**
     * 
     * @type {string}
     * @memberof StorageProjectImageTransfer
     */
    project: string;
}
/**
 * 
 * @export
 * @interface StorageProjectImageUpdate
 */
export interface StorageProjectImageUpdate {
    /**
     * 
     * @type {string}
     * @memberof StorageProjectImageUpdate
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof StorageProjectImageUpdate
     */
    description?: string;
}
/**
 * 
 * @export
 * @interface StorageProjectIsoCreate
 */
export interface StorageProjectIsoCreate {
    /**
     * 
     * @type {string}
     * @memberof StorageProjectIsoCreate
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof StorageProjectIsoCreate
     */
    source: string;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof StorageProjectIsoCreate
     */
    tag?: Array<Tag>;
}
/**
 * 
 * @export
 * @interface StorageProjectIsoDetach
 */
export interface StorageProjectIsoDetach {
    /**
     * 
     * @type {string}
     * @memberof StorageProjectIsoDetach
     */
    vm: string;
}
/**
 * 
 * @export
 * @interface StorageProjectIsoTransfer
 */
export interface StorageProjectIsoTransfer {
    /**
     * 
     * @type {string}
     * @memberof StorageProjectIsoTransfer
     */
    project: string;
}
/**
 * 
 * @export
 * @interface StorageProjectIsoUpdate
 */
export interface StorageProjectIsoUpdate {
    /**
     * 
     * @type {string}
     * @memberof StorageProjectIsoUpdate
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface StorageProjectVaultCreate
 */
export interface StorageProjectVaultCreate {
    /**
     * 
     * @type {string}
     * @memberof StorageProjectVaultCreate
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof StorageProjectVaultCreate
     */
    service?: string;
    /**
     * 
     * @type {number}
     * @memberof StorageProjectVaultCreate
     */
    size: number;
    /**
     * 
     * @type {string}
     * @memberof StorageProjectVaultCreate
     */
    source?: string;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof StorageProjectVaultCreate
     */
    tag?: Array<Tag>;
}
/**
 * 
 * @export
 * @interface StorageProjectVaultCredentialPatch
 */
export interface StorageProjectVaultCredentialPatch {
    /**
     * 
     * @type {string}
     * @memberof StorageProjectVaultCredentialPatch
     */
    name: string;
}
/**
 * 
 * @export
 * @interface StorageProjectVaultDelete
 */
export interface StorageProjectVaultDelete {
    /**
     * 
     * @type {boolean}
     * @memberof StorageProjectVaultDelete
     */
    removeAllSnapshots?: boolean;
}
/**
 * 
 * @export
 * @interface StorageProjectVaultResize
 */
export interface StorageProjectVaultResize {
    /**
     * 
     * @type {number}
     * @memberof StorageProjectVaultResize
     */
    size: number;
}
/**
 * 
 * @export
 * @interface StorageProjectVaultSnapshotCreate
 */
export interface StorageProjectVaultSnapshotCreate {
    /**
     * 
     * @type {string}
     * @memberof StorageProjectVaultSnapshotCreate
     */
    name: string;
}
/**
 * 
 * @export
 * @interface StorageProjectVaultUpdate
 */
export interface StorageProjectVaultUpdate {
    /**
     * 
     * @type {string}
     * @memberof StorageProjectVaultUpdate
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface StorageS3credential
 */
export interface StorageS3credential {
    /**
     * 
     * @type {string}
     * @memberof StorageS3credential
     */
    accessKeyId?: string;
    /**
     * 
     * @type {string}
     * @memberof StorageS3credential
     */
    sessionToken?: string;
    /**
     * 
     * @type {string}
     * @memberof StorageS3credential
     */
    secretAccessKey?: string;
    /**
     * 
     * @type {string}
     * @memberof StorageS3credential
     */
    endpoint?: string;
    /**
     * 
     * @type {string}
     * @memberof StorageS3credential
     */
    region?: string;
    /**
     * 
     * @type {string}
     * @memberof StorageS3credential
     */
    location?: string;
    /**
     * 
     * @type {string}
     * @memberof StorageS3credential
     */
    bucket?: string;
    /**
     * 
     * @type {string}
     * @memberof StorageS3credential
     */
    key?: string;
}
/**
 * 
 * @export
 * @interface StorageSnapshot
 */
export interface StorageSnapshot {
    /**
     * 
     * @type {string}
     * @memberof StorageSnapshot
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof StorageSnapshot
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof StorageSnapshot
     */
    flavour?: string;
    /**
     * 
     * @type {string}
     * @memberof StorageSnapshot
     */
    modifiedOn?: string;
    /**
     * 
     * @type {string}
     * @memberof StorageSnapshot
     */
    modifiedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof StorageSnapshot
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof StorageSnapshot
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof StorageSnapshot
     */
    state?: string;
    /**
     * 
     * @type {string}
     * @memberof StorageSnapshot
     */
    project?: string;
    /**
     * 
     * @type {string}
     * @memberof StorageSnapshot
     */
    organisation?: string;
    /**
     * 
     * @type {string}
     * @memberof StorageSnapshot
     */
    uri?: string;
    /**
     * 
     * @type {number}
     * @memberof StorageSnapshot
     */
    sizeUsed?: number;
}
/**
 * 
 * @export
 * @interface SupportMessage
 */
export interface SupportMessage {
    /**
     * 
     * @type {string}
     * @memberof SupportMessage
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof SupportMessage
     */
    type: SupportMessageTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof SupportMessage
     */
    user?: string;
    /**
     * 
     * @type {MessageData}
     * @memberof SupportMessage
     */
    data?: MessageData;
    /**
     * 
     * @type {string}
     * @memberof SupportMessage
     */
    origin?: string;
    /**
     * 
     * @type {string}
     * @memberof SupportMessage
     */
    date?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum SupportMessageTypeEnum {
    Text = 'text',
    Attachment = 'attachment'
}

/**
 * 
 * @export
 * @interface SupportProjectTicketCreate
 */
export interface SupportProjectTicketCreate {
    /**
     * 
     * @type {string}
     * @memberof SupportProjectTicketCreate
     */
    type: SupportProjectTicketCreateTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof SupportProjectTicketCreate
     */
    subject: string;
    /**
     * 
     * @type {string}
     * @memberof SupportProjectTicketCreate
     */
    message: string;
}

/**
    * @export
    * @enum {string}
    */
export enum SupportProjectTicketCreateTypeEnum {
    Sales = 'sales',
    Billing = 'billing',
    ServiceSupport = 'service support'
}

/**
 * 
 * @export
 * @interface Tag
 */
export interface Tag {
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    id: string;
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    key: string;
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    value: string;
}
/**
 * 
 * @export
 * @interface Ticket
 */
export interface Ticket {
    /**
     * 
     * @type {string}
     * @memberof Ticket
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Ticket
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof Ticket
     */
    state?: TicketStateEnum;
    /**
     * 
     * @type {string}
     * @memberof Ticket
     */
    subject?: string;
    /**
     * 
     * @type {string}
     * @memberof Ticket
     */
    project?: string;
    /**
     * 
     * @type {string}
     * @memberof Ticket
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Ticket
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Ticket
     */
    modifiedOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Ticket
     */
    modifiedBy?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum TicketStateEnum {
    Open = 'open',
    Closed = 'closed'
}

/**
 * 
 * @export
 * @interface Transfer
 */
export interface Transfer {
    /**
     * 
     * @type {string}
     * @memberof Transfer
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Transfer
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof Transfer
     */
    state?: string;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    firstName?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    familyName?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    modifiedOn?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    lang?: UserLangEnum;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    phone?: string;
    /**
     * 
     * @type {UserLimit}
     * @memberof User
     */
    limit?: UserLimit;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    uri?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum UserLangEnum {
    En = 'en',
    Pl = 'pl'
}

/**
 * 
 * @export
 * @interface UserCredential
 */
export interface UserCredential {
    /**
     * 
     * @type {string}
     * @memberof UserCredential
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof UserCredential
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof UserCredential
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof UserCredential
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof UserCredential
     */
    type: UserCredentialTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof UserCredential
     */
    value: string;
    /**
     * 
     * @type {string}
     * @memberof UserCredential
     */
    fingerprint?: string;
    /**
     * 
     * @type {string}
     * @memberof UserCredential
     */
    token?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum UserCredentialTypeEnum {
    Ssh = 'ssh',
    Sha512 = 'sha512',
    Totp = 'totp',
    Otac = 'otac',
    Plain = 'plain'
}

/**
 * 
 * @export
 * @interface UserLimit
 */
export interface UserLimit {
    /**
     * 
     * @type {UserLimitOrganisation}
     * @memberof UserLimit
     */
    organisation?: UserLimitOrganisation;
}
/**
 * 
 * @export
 * @interface UserLimitOrganisation
 */
export interface UserLimitOrganisation {
    /**
     * 
     * @type {number}
     * @memberof UserLimitOrganisation
     */
    count: number;
}
/**
 * 
 * @export
 * @interface Vault
 */
export interface Vault {
    /**
     * 
     * @type {string}
     * @memberof Vault
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Vault
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Vault
     */
    flavour?: string;
    /**
     * 
     * @type {string}
     * @memberof Vault
     */
    modifiedOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Vault
     */
    modifiedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Vault
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Vault
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Vault
     */
    state?: VaultStateEnum;
    /**
     * 
     * @type {string}
     * @memberof Vault
     */
    project?: string;
    /**
     * 
     * @type {string}
     * @memberof Vault
     */
    uri?: string;
    /**
     * 
     * @type {number}
     * @memberof Vault
     */
    sizeUsed?: number;
    /**
     * 
     * @type {number}
     * @memberof Vault
     */
    size?: number;
    /**
     * 
     * @type {string}
     * @memberof Vault
     */
    fqdn?: string;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof Vault
     */
    tag?: Array<Tag>;
}

/**
    * @export
    * @enum {string}
    */
export enum VaultStateEnum {
    Online = 'Online',
    Off = 'Off',
    Unknown = 'Unknown',
    Processing = 'Processing',
    NotCreated = 'NotCreated'
}

/**
 * 
 * @export
 * @interface VaultCredential
 */
export interface VaultCredential {
    /**
     * 
     * @type {string}
     * @memberof VaultCredential
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof VaultCredential
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof VaultCredential
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof VaultCredential
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof VaultCredential
     */
    type: VaultCredentialTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof VaultCredential
     */
    value: string;
    /**
     * 
     * @type {string}
     * @memberof VaultCredential
     */
    fingerprint?: string;
    /**
     * 
     * @type {string}
     * @memberof VaultCredential
     */
    token?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum VaultCredentialTypeEnum {
    Ssh = 'ssh',
    Sha512 = 'sha512',
    Plain = 'plain'
}

/**
 * 
 * @export
 * @interface Vm
 */
export interface Vm {
    /**
     * 
     * @type {string}
     * @memberof Vm
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Vm
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Vm
     */
    flavour?: string;
    /**
     * 
     * @type {string}
     * @memberof Vm
     */
    modifiedOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Vm
     */
    modifiedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Vm
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Vm
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Vm
     */
    state?: VmStateEnum;
    /**
     * 
     * @type {string}
     * @memberof Vm
     */
    project?: string;
    /**
     * 
     * @type {string}
     * @memberof Vm
     */
    uri?: string;
    /**
     * 
     * @type {string}
     * @memberof Vm
     */
    userMetadata?: string;
    /**
     * 
     * @type {number}
     * @memberof Vm
     */
    cpu?: number;
    /**
     * 
     * @type {number}
     * @memberof Vm
     */
    memory?: number;
    /**
     * 
     * @type {string}
     * @memberof Vm
     */
    fqdn?: string;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof Vm
     */
    tag?: Array<Tag>;
}

/**
    * @export
    * @enum {string}
    */
export enum VmStateEnum {
    Other = 'Other',
    Running = 'Running',
    Off = 'Off',
    Stopping = 'Stopping',
    Saved = 'Saved',
    Paused = 'Paused',
    Starting = 'Starting',
    Reset = 'Reset',
    Saving = 'Saving',
    Pausing = 'Pausing',
    Resuming = 'Resuming',
    FastSaved = 'FastSaved',
    FastSaving = 'FastSaving',
    RunningCritical = 'RunningCritical',
    OffCritical = 'OffCritical',
    StoppingCritical = 'StoppingCritical',
    SavedCritical = 'SavedCritical',
    PausedCritical = 'PausedCritical',
    StartingCritical = 'StartingCritical',
    ResetCritical = 'ResetCritical',
    SavingCritical = 'SavingCritical',
    PausingCritical = 'PausingCritical',
    ResumingCritical = 'ResumingCritical',
    FastSavedCritical = 'FastSavedCritical',
    FastSavingCritical = 'FastSavingCritical',
    Unknown = 'Unknown',
    Processing = 'Processing',
    NotCreated = 'NotCreated'
}

/**
 * 
 * @export
 * @interface Vmhost
 */
export interface Vmhost {
    /**
     * 
     * @type {string}
     * @memberof Vmhost
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Vmhost
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Vmhost
     */
    flavour?: string;
    /**
     * 
     * @type {string}
     * @memberof Vmhost
     */
    modifiedOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Vmhost
     */
    modifiedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Vmhost
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Vmhost
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Vmhost
     */
    state?: VmhostStateEnum;
    /**
     * 
     * @type {string}
     * @memberof Vmhost
     */
    project?: string;
    /**
     * 
     * @type {string}
     * @memberof Vmhost
     */
    uri?: string;
    /**
     * 
     * @type {string}
     * @memberof Vmhost
     */
    type?: VmhostTypeEnum;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof Vmhost
     */
    tag?: Array<Tag>;
}

/**
    * @export
    * @enum {string}
    */
export enum VmhostStateEnum {
    Running = 'Running',
    Unknown = 'Unknown',
    Processing = 'Processing',
    NotCreated = 'NotCreated'
}
/**
    * @export
    * @enum {string}
    */
export enum VmhostTypeEnum {
    Compute = 'compute',
    Network = 'network',
    Vault = 'vault',
    Container = 'container'
}

/**
 * 
 * @export
 * @interface Website
 */
export interface Website {
    /**
     * 
     * @type {string}
     * @memberof Website
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Website
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Website
     */
    flavour?: string;
    /**
     * 
     * @type {string}
     * @memberof Website
     */
    modifiedOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Website
     */
    modifiedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Website
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Website
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Website
     */
    state?: WebsiteStateEnum;
    /**
     * 
     * @type {string}
     * @memberof Website
     */
    project?: string;
    /**
     * 
     * @type {string}
     * @memberof Website
     */
    uri?: string;
    /**
     * 
     * @type {string}
     * @memberof Website
     */
    image?: string;
    /**
     * 
     * @type {string}
     * @memberof Website
     */
    plan?: string;
    /**
     * 
     * @type {string}
     * @memberof Website
     */
    fqdn?: string;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof Website
     */
    tag?: Array<Tag>;
}

/**
    * @export
    * @enum {string}
    */
export enum WebsiteStateEnum {
    Running = 'Running',
    Restarting = 'Restarting',
    Off = 'Off',
    Unknown = 'Unknown',
    Processing = 'Processing',
    NotCreated = 'NotCreated'
}

/**
 * 
 * @export
 * @interface WebsiteCredential
 */
export interface WebsiteCredential {
    /**
     * 
     * @type {string}
     * @memberof WebsiteCredential
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof WebsiteCredential
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof WebsiteCredential
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof WebsiteCredential
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof WebsiteCredential
     */
    type: WebsiteCredentialTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof WebsiteCredential
     */
    value: string;
    /**
     * 
     * @type {string}
     * @memberof WebsiteCredential
     */
    fingerprint?: string;
    /**
     * 
     * @type {string}
     * @memberof WebsiteCredential
     */
    token?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum WebsiteCredentialTypeEnum {
    Ssh = 'ssh',
    Sha512 = 'sha512',
    Plain = 'plain'
}

/**
 * 
 * @export
 * @interface WebsiteEnv
 */
export interface WebsiteEnv {
    /**
     * 
     * @type {string}
     * @memberof WebsiteEnv
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof WebsiteEnv
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof WebsiteEnv
     */
    value: string;
}
/**
 * 
 * @export
 * @interface WebsiteLink
 */
export interface WebsiteLink {
    /**
     * 
     * @type {string}
     * @memberof WebsiteLink
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof WebsiteLink
     */
    actor: string;
    /**
     * 
     * @type {string}
     * @memberof WebsiteLink
     */
    purpose: WebsiteLinkPurposeEnum;
    /**
     * 
     * @type {string}
     * @memberof WebsiteLink
     */
    resource: string;
}

/**
    * @export
    * @enum {string}
    */
export enum WebsiteLinkPurposeEnum {
    Logs = 'logs'
}

/**
 * 
 * @export
 * @interface WebsiteProjectInstanceCreate
 */
export interface WebsiteProjectInstanceCreate {
    /**
     * 
     * @type {string}
     * @memberof WebsiteProjectInstanceCreate
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof WebsiteProjectInstanceCreate
     */
    service: string;
    /**
     * 
     * @type {string}
     * @memberof WebsiteProjectInstanceCreate
     */
    image: string;
    /**
     * 
     * @type {}
     * @memberof WebsiteProjectInstanceCreate
     */
    source?: any;
    /**
     * 
     * @type {Array<WebsiteEnv>}
     * @memberof WebsiteProjectInstanceCreate
     */
    env?: Array<WebsiteEnv>;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof WebsiteProjectInstanceCreate
     */
    tag?: Array<Tag>;
}
/**
 * 
 * @export
 * @interface WebsiteProjectInstanceCredentialPatch
 */
export interface WebsiteProjectInstanceCredentialPatch {
    /**
     * 
     * @type {string}
     * @memberof WebsiteProjectInstanceCredentialPatch
     */
    name: string;
}
/**
 * 
 * @export
 * @interface WebsiteProjectInstanceSnapshotDownload
 */
export interface WebsiteProjectInstanceSnapshotDownload {
    /**
     * 
     * @type {string}
     * @memberof WebsiteProjectInstanceSnapshotDownload
     */
    incremental?: string;
}
/**
 * 
 * @export
 * @interface WebsiteProjectInstanceTransfer
 */
export interface WebsiteProjectInstanceTransfer {
    /**
     * 
     * @type {string}
     * @memberof WebsiteProjectInstanceTransfer
     */
    project: string;
}
/**
 * 
 * @export
 * @interface WebsiteProjectInstanceUpdate
 */
export interface WebsiteProjectInstanceUpdate {
    /**
     * 
     * @type {string}
     * @memberof WebsiteProjectInstanceUpdate
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof WebsiteProjectInstanceUpdate
     */
    image?: string;
    /**
     * 
     * @type {string}
     * @memberof WebsiteProjectInstanceUpdate
     */
    plan?: string;
}
/**
 * 
 * @export
 * @interface WebsiteSideapp
 */
export interface WebsiteSideapp {
    /**
     * 
     * @type {string}
     * @memberof WebsiteSideapp
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof WebsiteSideapp
     */
    name: string;
}
/**
 * 
 * @export
 * @interface WebsiteSnapshot
 */
export interface WebsiteSnapshot {
    /**
     * 
     * @type {string}
     * @memberof WebsiteSnapshot
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof WebsiteSnapshot
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof WebsiteSnapshot
     */
    creation?: string;
    /**
     * 
     * @type {number}
     * @memberof WebsiteSnapshot
     */
    used?: number;
}
/**
 * 
 * @export
 * @interface Zone
 */
export interface Zone {
    /**
     * 
     * @type {string}
     * @memberof Zone
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof Zone
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Zone
     */
    flavour?: string;
    /**
     * 
     * @type {string}
     * @memberof Zone
     */
    modifiedOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Zone
     */
    modifiedBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Zone
     */
    createdOn?: string;
    /**
     * 
     * @type {string}
     * @memberof Zone
     */
    createdBy?: string;
    /**
     * 
     * @type {string}
     * @memberof Zone
     */
    state?: ZoneStateEnum;
    /**
     * 
     * @type {string}
     * @memberof Zone
     */
    project?: string;
    /**
     * 
     * @type {string}
     * @memberof Zone
     */
    uri?: string;
    /**
     * 
     * @type {Array<ZoneRrsets>}
     * @memberof Zone
     */
    rrsets?: Array<ZoneRrsets>;
    /**
     * 
     * @type {string}
     * @memberof Zone
     */
    dnsName?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Zone
     */
    nameserver?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof Zone
     */
    fqdn?: string;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof Zone
     */
    tag?: Array<Tag>;
}

/**
    * @export
    * @enum {string}
    */
export enum ZoneStateEnum {
    Online = 'Online',
    Offline = 'Offline',
    Unknown = 'Unknown',
    Processing = 'Processing',
    NotCreated = 'NotCreated'
}

/**
 * 
 * @export
 * @interface ZoneRrsets
 */
export interface ZoneRrsets {
    /**
     * 
     * @type {string}
     * @memberof ZoneRrsets
     */
    records?: string;
    /**
     * 
     * @type {string}
     * @memberof ZoneRrsets
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ZoneRrsets
     */
    type?: string;
    /**
     * 
     * @type {number}
     * @memberof ZoneRrsets
     */
    ttl?: number;
}
/**
 * 
 * @export
 * @interface ZoneSource
 */
export interface ZoneSource {
    /**
     * 
     * @type {boolean}
     * @memberof ZoneSource
     */
    dnsProbing?: boolean;
}

/**
 * BillingProjectReservationApi - axios parameter creator
 * @export
 */
export const BillingProjectReservationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * action assign
         * @summary Assign billing/reservation
         * @param {string} projectId Project Id
         * @param {string} reservationId Reservation Id
         * @param {BillingProjectReservationAssign} billingProjectReservationAssign 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingProjectReservationAssign: async (projectId: string, reservationId: string, billingProjectReservationAssign: BillingProjectReservationAssign, xIdempotencyKey?: string, xDryRun?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('billingProjectReservationAssign', 'projectId', projectId)
            // verify required parameter 'reservationId' is not null or undefined
            assertParamExists('billingProjectReservationAssign', 'reservationId', reservationId)
            // verify required parameter 'billingProjectReservationAssign' is not null or undefined
            assertParamExists('billingProjectReservationAssign', 'billingProjectReservationAssign', billingProjectReservationAssign)
            const localVarPath = `/billing/project/{projectId}/reservation/{reservationId}/actions/assign`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"reservationId"}}`, encodeURIComponent(String(reservationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }

            if (xDryRun !== undefined && xDryRun !== null) {
                localVarHeaderParameter['x-dry-run'] = String(xDryRun);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(billingProjectReservationAssign, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create reservation
         * @summary Create billing/reservation
         * @param {string} projectId Project Id
         * @param {BillingProjectReservationCreate} billingProjectReservationCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingProjectReservationCreate: async (projectId: string, billingProjectReservationCreate: BillingProjectReservationCreate, xIdempotencyKey?: string, xDryRun?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('billingProjectReservationCreate', 'projectId', projectId)
            // verify required parameter 'billingProjectReservationCreate' is not null or undefined
            assertParamExists('billingProjectReservationCreate', 'billingProjectReservationCreate', billingProjectReservationCreate)
            const localVarPath = `/billing/project/{projectId}/reservation`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }

            if (xDryRun !== undefined && xDryRun !== null) {
                localVarHeaderParameter['x-dry-run'] = String(xDryRun);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(billingProjectReservationCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete reservation
         * @summary Delete billing/reservation
         * @param {string} projectId Project Id
         * @param {string} reservationId Reservation Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingProjectReservationDelete: async (projectId: string, reservationId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('billingProjectReservationDelete', 'projectId', projectId)
            // verify required parameter 'reservationId' is not null or undefined
            assertParamExists('billingProjectReservationDelete', 'reservationId', reservationId)
            const localVarPath = `/billing/project/{projectId}/reservation/{reservationId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"reservationId"}}`, encodeURIComponent(String(reservationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get billing/reservation.event
         * @summary Get billing/reservation.event
         * @param {string} projectId Project Id
         * @param {string} reservationId Reservation Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingProjectReservationEventGet: async (projectId: string, reservationId: string, eventId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('billingProjectReservationEventGet', 'projectId', projectId)
            // verify required parameter 'reservationId' is not null or undefined
            assertParamExists('billingProjectReservationEventGet', 'reservationId', reservationId)
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('billingProjectReservationEventGet', 'eventId', eventId)
            const localVarPath = `/billing/project/{projectId}/reservation/{reservationId}/event/{eventId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"reservationId"}}`, encodeURIComponent(String(reservationId)))
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List billing/reservation.event
         * @summary List billing/reservation.event
         * @param {string} projectId Project Id
         * @param {string} reservationId Reservation Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingProjectReservationEventList: async (projectId: string, reservationId: string, $limit?: number, $skip?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('billingProjectReservationEventList', 'projectId', projectId)
            // verify required parameter 'reservationId' is not null or undefined
            assertParamExists('billingProjectReservationEventList', 'reservationId', reservationId)
            const localVarPath = `/billing/project/{projectId}/reservation/{reservationId}/event`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"reservationId"}}`, encodeURIComponent(String(reservationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if ($limit !== undefined) {
                localVarQueryParameter['$limit'] = $limit;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * action extend
         * @summary Extend billing/reservation
         * @param {string} projectId Project Id
         * @param {string} reservationId Reservation Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingProjectReservationExtend: async (projectId: string, reservationId: string, xIdempotencyKey?: string, xDryRun?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('billingProjectReservationExtend', 'projectId', projectId)
            // verify required parameter 'reservationId' is not null or undefined
            assertParamExists('billingProjectReservationExtend', 'reservationId', reservationId)
            const localVarPath = `/billing/project/{projectId}/reservation/{reservationId}/actions/extend`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"reservationId"}}`, encodeURIComponent(String(reservationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }

            if (xDryRun !== undefined && xDryRun !== null) {
                localVarHeaderParameter['x-dry-run'] = String(xDryRun);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single reservation
         * @summary Get billing/reservation
         * @param {string} projectId Project Id
         * @param {string} reservationId Reservation Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingProjectReservationGet: async (projectId: string, reservationId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('billingProjectReservationGet', 'projectId', projectId)
            // verify required parameter 'reservationId' is not null or undefined
            assertParamExists('billingProjectReservationGet', 'reservationId', reservationId)
            const localVarPath = `/billing/project/{projectId}/reservation/{reservationId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"reservationId"}}`, encodeURIComponent(String(reservationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List reservation
         * @summary List billing/reservation
         * @param {string} projectId Project Id
         * @param {string} [name] Filter by name
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingProjectReservationList: async (projectId: string, name?: string, tagValue?: string, tagKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('billingProjectReservationList', 'projectId', projectId)
            const localVarPath = `/billing/project/{projectId}/reservation`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (tagValue !== undefined) {
                localVarQueryParameter['tag.value'] = tagValue;
            }

            if (tagKey !== undefined) {
                localVarQueryParameter['tag.key'] = tagKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get billing/reservation.service
         * @summary Get billing/reservation.service
         * @param {string} projectId Project Id
         * @param {string} reservationId Reservation Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingProjectReservationServiceGet: async (projectId: string, reservationId: string, serviceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('billingProjectReservationServiceGet', 'projectId', projectId)
            // verify required parameter 'reservationId' is not null or undefined
            assertParamExists('billingProjectReservationServiceGet', 'reservationId', reservationId)
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('billingProjectReservationServiceGet', 'serviceId', serviceId)
            const localVarPath = `/billing/project/{projectId}/reservation/{reservationId}/service/{serviceId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"reservationId"}}`, encodeURIComponent(String(reservationId)))
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List billing/reservation.service
         * @summary List billing/reservation.service
         * @param {string} projectId Project Id
         * @param {string} reservationId Reservation Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingProjectReservationServiceList: async (projectId: string, reservationId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('billingProjectReservationServiceList', 'projectId', projectId)
            // verify required parameter 'reservationId' is not null or undefined
            assertParamExists('billingProjectReservationServiceList', 'reservationId', reservationId)
            const localVarPath = `/billing/project/{projectId}/reservation/{reservationId}/service`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"reservationId"}}`, encodeURIComponent(String(reservationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create billing/reservation.tag
         * @summary Create billing/reservation.tag
         * @param {string} projectId Project Id
         * @param {string} reservationId Reservation Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingProjectReservationTagCreate: async (projectId: string, reservationId: string, tag: Tag, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('billingProjectReservationTagCreate', 'projectId', projectId)
            // verify required parameter 'reservationId' is not null or undefined
            assertParamExists('billingProjectReservationTagCreate', 'reservationId', reservationId)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('billingProjectReservationTagCreate', 'tag', tag)
            const localVarPath = `/billing/project/{projectId}/reservation/{reservationId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"reservationId"}}`, encodeURIComponent(String(reservationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tag, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete billing/reservation.tag
         * @summary Delete billing/reservation.tag
         * @param {string} projectId Project Id
         * @param {string} reservationId Reservation Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingProjectReservationTagDelete: async (projectId: string, reservationId: string, tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('billingProjectReservationTagDelete', 'projectId', projectId)
            // verify required parameter 'reservationId' is not null or undefined
            assertParamExists('billingProjectReservationTagDelete', 'reservationId', reservationId)
            // verify required parameter 'tagId' is not null or undefined
            assertParamExists('billingProjectReservationTagDelete', 'tagId', tagId)
            const localVarPath = `/billing/project/{projectId}/reservation/{reservationId}/tag/{tagId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"reservationId"}}`, encodeURIComponent(String(reservationId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get billing/reservation.tag
         * @summary Get billing/reservation.tag
         * @param {string} projectId Project Id
         * @param {string} reservationId Reservation Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingProjectReservationTagGet: async (projectId: string, reservationId: string, tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('billingProjectReservationTagGet', 'projectId', projectId)
            // verify required parameter 'reservationId' is not null or undefined
            assertParamExists('billingProjectReservationTagGet', 'reservationId', reservationId)
            // verify required parameter 'tagId' is not null or undefined
            assertParamExists('billingProjectReservationTagGet', 'tagId', tagId)
            const localVarPath = `/billing/project/{projectId}/reservation/{reservationId}/tag/{tagId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"reservationId"}}`, encodeURIComponent(String(reservationId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List billing/reservation.tag
         * @summary List billing/reservation.tag
         * @param {string} projectId Project Id
         * @param {string} reservationId Reservation Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingProjectReservationTagList: async (projectId: string, reservationId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('billingProjectReservationTagList', 'projectId', projectId)
            // verify required parameter 'reservationId' is not null or undefined
            assertParamExists('billingProjectReservationTagList', 'reservationId', reservationId)
            const localVarPath = `/billing/project/{projectId}/reservation/{reservationId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"reservationId"}}`, encodeURIComponent(String(reservationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replace billing/reservation.tag
         * @summary Replace billing/reservation.tag
         * @param {string} projectId Project Id
         * @param {string} reservationId Reservation Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingProjectReservationTagPut: async (projectId: string, reservationId: string, tag: Array<Tag>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('billingProjectReservationTagPut', 'projectId', projectId)
            // verify required parameter 'reservationId' is not null or undefined
            assertParamExists('billingProjectReservationTagPut', 'reservationId', reservationId)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('billingProjectReservationTagPut', 'tag', tag)
            const localVarPath = `/billing/project/{projectId}/reservation/{reservationId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"reservationId"}}`, encodeURIComponent(String(reservationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tag, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns modified reservation
         * @summary Update billing/reservation
         * @param {string} projectId Project Id
         * @param {string} reservationId Reservation Id
         * @param {BillingProjectReservationUpdate} billingProjectReservationUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingProjectReservationUpdate: async (projectId: string, reservationId: string, billingProjectReservationUpdate: BillingProjectReservationUpdate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('billingProjectReservationUpdate', 'projectId', projectId)
            // verify required parameter 'reservationId' is not null or undefined
            assertParamExists('billingProjectReservationUpdate', 'reservationId', reservationId)
            // verify required parameter 'billingProjectReservationUpdate' is not null or undefined
            assertParamExists('billingProjectReservationUpdate', 'billingProjectReservationUpdate', billingProjectReservationUpdate)
            const localVarPath = `/billing/project/{projectId}/reservation/{reservationId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"reservationId"}}`, encodeURIComponent(String(reservationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(billingProjectReservationUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BillingProjectReservationApi - functional programming interface
 * @export
 */
export const BillingProjectReservationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BillingProjectReservationApiAxiosParamCreator(configuration)
    return {
        /**
         * action assign
         * @summary Assign billing/reservation
         * @param {string} projectId Project Id
         * @param {string} reservationId Reservation Id
         * @param {BillingProjectReservationAssign} billingProjectReservationAssign 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async billingProjectReservationAssign(projectId: string, reservationId: string, billingProjectReservationAssign: BillingProjectReservationAssign, xIdempotencyKey?: string, xDryRun?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Reservation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.billingProjectReservationAssign(projectId, reservationId, billingProjectReservationAssign, xIdempotencyKey, xDryRun, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create reservation
         * @summary Create billing/reservation
         * @param {string} projectId Project Id
         * @param {BillingProjectReservationCreate} billingProjectReservationCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async billingProjectReservationCreate(projectId: string, billingProjectReservationCreate: BillingProjectReservationCreate, xIdempotencyKey?: string, xDryRun?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Reservation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.billingProjectReservationCreate(projectId, billingProjectReservationCreate, xIdempotencyKey, xDryRun, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete reservation
         * @summary Delete billing/reservation
         * @param {string} projectId Project Id
         * @param {string} reservationId Reservation Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async billingProjectReservationDelete(projectId: string, reservationId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.billingProjectReservationDelete(projectId, reservationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get billing/reservation.event
         * @summary Get billing/reservation.event
         * @param {string} projectId Project Id
         * @param {string} reservationId Reservation Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async billingProjectReservationEventGet(projectId: string, reservationId: string, eventId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.billingProjectReservationEventGet(projectId, reservationId, eventId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List billing/reservation.event
         * @summary List billing/reservation.event
         * @param {string} projectId Project Id
         * @param {string} reservationId Reservation Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async billingProjectReservationEventList(projectId: string, reservationId: string, $limit?: number, $skip?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Event>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.billingProjectReservationEventList(projectId, reservationId, $limit, $skip, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * action extend
         * @summary Extend billing/reservation
         * @param {string} projectId Project Id
         * @param {string} reservationId Reservation Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async billingProjectReservationExtend(projectId: string, reservationId: string, xIdempotencyKey?: string, xDryRun?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Reservation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.billingProjectReservationExtend(projectId, reservationId, xIdempotencyKey, xDryRun, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a single reservation
         * @summary Get billing/reservation
         * @param {string} projectId Project Id
         * @param {string} reservationId Reservation Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async billingProjectReservationGet(projectId: string, reservationId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Reservation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.billingProjectReservationGet(projectId, reservationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List reservation
         * @summary List billing/reservation
         * @param {string} projectId Project Id
         * @param {string} [name] Filter by name
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async billingProjectReservationList(projectId: string, name?: string, tagValue?: string, tagKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Reservation>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.billingProjectReservationList(projectId, name, tagValue, tagKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get billing/reservation.service
         * @summary Get billing/reservation.service
         * @param {string} projectId Project Id
         * @param {string} reservationId Reservation Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async billingProjectReservationServiceGet(projectId: string, reservationId: string, serviceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceService>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.billingProjectReservationServiceGet(projectId, reservationId, serviceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List billing/reservation.service
         * @summary List billing/reservation.service
         * @param {string} projectId Project Id
         * @param {string} reservationId Reservation Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async billingProjectReservationServiceList(projectId: string, reservationId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResourceService>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.billingProjectReservationServiceList(projectId, reservationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create billing/reservation.tag
         * @summary Create billing/reservation.tag
         * @param {string} projectId Project Id
         * @param {string} reservationId Reservation Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async billingProjectReservationTagCreate(projectId: string, reservationId: string, tag: Tag, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.billingProjectReservationTagCreate(projectId, reservationId, tag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete billing/reservation.tag
         * @summary Delete billing/reservation.tag
         * @param {string} projectId Project Id
         * @param {string} reservationId Reservation Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async billingProjectReservationTagDelete(projectId: string, reservationId: string, tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.billingProjectReservationTagDelete(projectId, reservationId, tagId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get billing/reservation.tag
         * @summary Get billing/reservation.tag
         * @param {string} projectId Project Id
         * @param {string} reservationId Reservation Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async billingProjectReservationTagGet(projectId: string, reservationId: string, tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.billingProjectReservationTagGet(projectId, reservationId, tagId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List billing/reservation.tag
         * @summary List billing/reservation.tag
         * @param {string} projectId Project Id
         * @param {string} reservationId Reservation Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async billingProjectReservationTagList(projectId: string, reservationId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.billingProjectReservationTagList(projectId, reservationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Replace billing/reservation.tag
         * @summary Replace billing/reservation.tag
         * @param {string} projectId Project Id
         * @param {string} reservationId Reservation Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async billingProjectReservationTagPut(projectId: string, reservationId: string, tag: Array<Tag>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.billingProjectReservationTagPut(projectId, reservationId, tag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns modified reservation
         * @summary Update billing/reservation
         * @param {string} projectId Project Id
         * @param {string} reservationId Reservation Id
         * @param {BillingProjectReservationUpdate} billingProjectReservationUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async billingProjectReservationUpdate(projectId: string, reservationId: string, billingProjectReservationUpdate: BillingProjectReservationUpdate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Reservation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.billingProjectReservationUpdate(projectId, reservationId, billingProjectReservationUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BillingProjectReservationApi - factory interface
 * @export
 */
export const BillingProjectReservationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BillingProjectReservationApiFp(configuration)
    return {
        /**
         * action assign
         * @summary Assign billing/reservation
         * @param {string} projectId Project Id
         * @param {string} reservationId Reservation Id
         * @param {BillingProjectReservationAssign} billingProjectReservationAssign 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingProjectReservationAssign(projectId: string, reservationId: string, billingProjectReservationAssign: BillingProjectReservationAssign, xIdempotencyKey?: string, xDryRun?: string, options?: any): AxiosPromise<Reservation> {
            return localVarFp.billingProjectReservationAssign(projectId, reservationId, billingProjectReservationAssign, xIdempotencyKey, xDryRun, options).then((request) => request(axios, basePath));
        },
        /**
         * Create reservation
         * @summary Create billing/reservation
         * @param {string} projectId Project Id
         * @param {BillingProjectReservationCreate} billingProjectReservationCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingProjectReservationCreate(projectId: string, billingProjectReservationCreate: BillingProjectReservationCreate, xIdempotencyKey?: string, xDryRun?: string, options?: any): AxiosPromise<Reservation> {
            return localVarFp.billingProjectReservationCreate(projectId, billingProjectReservationCreate, xIdempotencyKey, xDryRun, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete reservation
         * @summary Delete billing/reservation
         * @param {string} projectId Project Id
         * @param {string} reservationId Reservation Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingProjectReservationDelete(projectId: string, reservationId: string, options?: any): AxiosPromise<void> {
            return localVarFp.billingProjectReservationDelete(projectId, reservationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get billing/reservation.event
         * @summary Get billing/reservation.event
         * @param {string} projectId Project Id
         * @param {string} reservationId Reservation Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingProjectReservationEventGet(projectId: string, reservationId: string, eventId: string, options?: any): AxiosPromise<Event> {
            return localVarFp.billingProjectReservationEventGet(projectId, reservationId, eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * List billing/reservation.event
         * @summary List billing/reservation.event
         * @param {string} projectId Project Id
         * @param {string} reservationId Reservation Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingProjectReservationEventList(projectId: string, reservationId: string, $limit?: number, $skip?: number, options?: any): AxiosPromise<Array<Event>> {
            return localVarFp.billingProjectReservationEventList(projectId, reservationId, $limit, $skip, options).then((request) => request(axios, basePath));
        },
        /**
         * action extend
         * @summary Extend billing/reservation
         * @param {string} projectId Project Id
         * @param {string} reservationId Reservation Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingProjectReservationExtend(projectId: string, reservationId: string, xIdempotencyKey?: string, xDryRun?: string, options?: any): AxiosPromise<Reservation> {
            return localVarFp.billingProjectReservationExtend(projectId, reservationId, xIdempotencyKey, xDryRun, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single reservation
         * @summary Get billing/reservation
         * @param {string} projectId Project Id
         * @param {string} reservationId Reservation Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingProjectReservationGet(projectId: string, reservationId: string, options?: any): AxiosPromise<Reservation> {
            return localVarFp.billingProjectReservationGet(projectId, reservationId, options).then((request) => request(axios, basePath));
        },
        /**
         * List reservation
         * @summary List billing/reservation
         * @param {string} projectId Project Id
         * @param {string} [name] Filter by name
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingProjectReservationList(projectId: string, name?: string, tagValue?: string, tagKey?: string, options?: any): AxiosPromise<Array<Reservation>> {
            return localVarFp.billingProjectReservationList(projectId, name, tagValue, tagKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get billing/reservation.service
         * @summary Get billing/reservation.service
         * @param {string} projectId Project Id
         * @param {string} reservationId Reservation Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingProjectReservationServiceGet(projectId: string, reservationId: string, serviceId: string, options?: any): AxiosPromise<ResourceService> {
            return localVarFp.billingProjectReservationServiceGet(projectId, reservationId, serviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * List billing/reservation.service
         * @summary List billing/reservation.service
         * @param {string} projectId Project Id
         * @param {string} reservationId Reservation Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingProjectReservationServiceList(projectId: string, reservationId: string, options?: any): AxiosPromise<Array<ResourceService>> {
            return localVarFp.billingProjectReservationServiceList(projectId, reservationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create billing/reservation.tag
         * @summary Create billing/reservation.tag
         * @param {string} projectId Project Id
         * @param {string} reservationId Reservation Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingProjectReservationTagCreate(projectId: string, reservationId: string, tag: Tag, options?: any): AxiosPromise<Tag> {
            return localVarFp.billingProjectReservationTagCreate(projectId, reservationId, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete billing/reservation.tag
         * @summary Delete billing/reservation.tag
         * @param {string} projectId Project Id
         * @param {string} reservationId Reservation Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingProjectReservationTagDelete(projectId: string, reservationId: string, tagId: string, options?: any): AxiosPromise<void> {
            return localVarFp.billingProjectReservationTagDelete(projectId, reservationId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get billing/reservation.tag
         * @summary Get billing/reservation.tag
         * @param {string} projectId Project Id
         * @param {string} reservationId Reservation Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingProjectReservationTagGet(projectId: string, reservationId: string, tagId: string, options?: any): AxiosPromise<Tag> {
            return localVarFp.billingProjectReservationTagGet(projectId, reservationId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * List billing/reservation.tag
         * @summary List billing/reservation.tag
         * @param {string} projectId Project Id
         * @param {string} reservationId Reservation Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingProjectReservationTagList(projectId: string, reservationId: string, options?: any): AxiosPromise<Array<Tag>> {
            return localVarFp.billingProjectReservationTagList(projectId, reservationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Replace billing/reservation.tag
         * @summary Replace billing/reservation.tag
         * @param {string} projectId Project Id
         * @param {string} reservationId Reservation Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingProjectReservationTagPut(projectId: string, reservationId: string, tag: Array<Tag>, options?: any): AxiosPromise<Array<Tag>> {
            return localVarFp.billingProjectReservationTagPut(projectId, reservationId, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns modified reservation
         * @summary Update billing/reservation
         * @param {string} projectId Project Id
         * @param {string} reservationId Reservation Id
         * @param {BillingProjectReservationUpdate} billingProjectReservationUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingProjectReservationUpdate(projectId: string, reservationId: string, billingProjectReservationUpdate: BillingProjectReservationUpdate, options?: any): AxiosPromise<Reservation> {
            return localVarFp.billingProjectReservationUpdate(projectId, reservationId, billingProjectReservationUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BillingProjectReservationApi - object-oriented interface
 * @export
 * @class BillingProjectReservationApi
 * @extends {BaseAPI}
 */
export class BillingProjectReservationApi extends BaseAPI {
    /**
     * action assign
     * @summary Assign billing/reservation
     * @param {string} projectId Project Id
     * @param {string} reservationId Reservation Id
     * @param {BillingProjectReservationAssign} billingProjectReservationAssign 
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {string} [xDryRun] Dry run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingProjectReservationApi
     */
    public billingProjectReservationAssign(projectId: string, reservationId: string, billingProjectReservationAssign: BillingProjectReservationAssign, xIdempotencyKey?: string, xDryRun?: string, options?: any) {
        return BillingProjectReservationApiFp(this.configuration).billingProjectReservationAssign(projectId, reservationId, billingProjectReservationAssign, xIdempotencyKey, xDryRun, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create reservation
     * @summary Create billing/reservation
     * @param {string} projectId Project Id
     * @param {BillingProjectReservationCreate} billingProjectReservationCreate 
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {string} [xDryRun] Dry run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingProjectReservationApi
     */
    public billingProjectReservationCreate(projectId: string, billingProjectReservationCreate: BillingProjectReservationCreate, xIdempotencyKey?: string, xDryRun?: string, options?: any) {
        return BillingProjectReservationApiFp(this.configuration).billingProjectReservationCreate(projectId, billingProjectReservationCreate, xIdempotencyKey, xDryRun, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete reservation
     * @summary Delete billing/reservation
     * @param {string} projectId Project Id
     * @param {string} reservationId Reservation Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingProjectReservationApi
     */
    public billingProjectReservationDelete(projectId: string, reservationId: string, options?: any) {
        return BillingProjectReservationApiFp(this.configuration).billingProjectReservationDelete(projectId, reservationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get billing/reservation.event
     * @summary Get billing/reservation.event
     * @param {string} projectId Project Id
     * @param {string} reservationId Reservation Id
     * @param {string} eventId eventId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingProjectReservationApi
     */
    public billingProjectReservationEventGet(projectId: string, reservationId: string, eventId: string, options?: any) {
        return BillingProjectReservationApiFp(this.configuration).billingProjectReservationEventGet(projectId, reservationId, eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List billing/reservation.event
     * @summary List billing/reservation.event
     * @param {string} projectId Project Id
     * @param {string} reservationId Reservation Id
     * @param {number} [$limit] $limit
     * @param {number} [$skip] $skip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingProjectReservationApi
     */
    public billingProjectReservationEventList(projectId: string, reservationId: string, $limit?: number, $skip?: number, options?: any) {
        return BillingProjectReservationApiFp(this.configuration).billingProjectReservationEventList(projectId, reservationId, $limit, $skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * action extend
     * @summary Extend billing/reservation
     * @param {string} projectId Project Id
     * @param {string} reservationId Reservation Id
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {string} [xDryRun] Dry run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingProjectReservationApi
     */
    public billingProjectReservationExtend(projectId: string, reservationId: string, xIdempotencyKey?: string, xDryRun?: string, options?: any) {
        return BillingProjectReservationApiFp(this.configuration).billingProjectReservationExtend(projectId, reservationId, xIdempotencyKey, xDryRun, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single reservation
     * @summary Get billing/reservation
     * @param {string} projectId Project Id
     * @param {string} reservationId Reservation Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingProjectReservationApi
     */
    public billingProjectReservationGet(projectId: string, reservationId: string, options?: any) {
        return BillingProjectReservationApiFp(this.configuration).billingProjectReservationGet(projectId, reservationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List reservation
     * @summary List billing/reservation
     * @param {string} projectId Project Id
     * @param {string} [name] Filter by name
     * @param {string} [tagValue] Filter by tag.value
     * @param {string} [tagKey] Filter by tag.key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingProjectReservationApi
     */
    public billingProjectReservationList(projectId: string, name?: string, tagValue?: string, tagKey?: string, options?: any) {
        return BillingProjectReservationApiFp(this.configuration).billingProjectReservationList(projectId, name, tagValue, tagKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get billing/reservation.service
     * @summary Get billing/reservation.service
     * @param {string} projectId Project Id
     * @param {string} reservationId Reservation Id
     * @param {string} serviceId serviceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingProjectReservationApi
     */
    public billingProjectReservationServiceGet(projectId: string, reservationId: string, serviceId: string, options?: any) {
        return BillingProjectReservationApiFp(this.configuration).billingProjectReservationServiceGet(projectId, reservationId, serviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List billing/reservation.service
     * @summary List billing/reservation.service
     * @param {string} projectId Project Id
     * @param {string} reservationId Reservation Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingProjectReservationApi
     */
    public billingProjectReservationServiceList(projectId: string, reservationId: string, options?: any) {
        return BillingProjectReservationApiFp(this.configuration).billingProjectReservationServiceList(projectId, reservationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create billing/reservation.tag
     * @summary Create billing/reservation.tag
     * @param {string} projectId Project Id
     * @param {string} reservationId Reservation Id
     * @param {Tag} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingProjectReservationApi
     */
    public billingProjectReservationTagCreate(projectId: string, reservationId: string, tag: Tag, options?: any) {
        return BillingProjectReservationApiFp(this.configuration).billingProjectReservationTagCreate(projectId, reservationId, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete billing/reservation.tag
     * @summary Delete billing/reservation.tag
     * @param {string} projectId Project Id
     * @param {string} reservationId Reservation Id
     * @param {string} tagId tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingProjectReservationApi
     */
    public billingProjectReservationTagDelete(projectId: string, reservationId: string, tagId: string, options?: any) {
        return BillingProjectReservationApiFp(this.configuration).billingProjectReservationTagDelete(projectId, reservationId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get billing/reservation.tag
     * @summary Get billing/reservation.tag
     * @param {string} projectId Project Id
     * @param {string} reservationId Reservation Id
     * @param {string} tagId tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingProjectReservationApi
     */
    public billingProjectReservationTagGet(projectId: string, reservationId: string, tagId: string, options?: any) {
        return BillingProjectReservationApiFp(this.configuration).billingProjectReservationTagGet(projectId, reservationId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List billing/reservation.tag
     * @summary List billing/reservation.tag
     * @param {string} projectId Project Id
     * @param {string} reservationId Reservation Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingProjectReservationApi
     */
    public billingProjectReservationTagList(projectId: string, reservationId: string, options?: any) {
        return BillingProjectReservationApiFp(this.configuration).billingProjectReservationTagList(projectId, reservationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replace billing/reservation.tag
     * @summary Replace billing/reservation.tag
     * @param {string} projectId Project Id
     * @param {string} reservationId Reservation Id
     * @param {Array<Tag>} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingProjectReservationApi
     */
    public billingProjectReservationTagPut(projectId: string, reservationId: string, tag: Array<Tag>, options?: any) {
        return BillingProjectReservationApiFp(this.configuration).billingProjectReservationTagPut(projectId, reservationId, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns modified reservation
     * @summary Update billing/reservation
     * @param {string} projectId Project Id
     * @param {string} reservationId Reservation Id
     * @param {BillingProjectReservationUpdate} billingProjectReservationUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingProjectReservationApi
     */
    public billingProjectReservationUpdate(projectId: string, reservationId: string, billingProjectReservationUpdate: BillingProjectReservationUpdate, options?: any) {
        return BillingProjectReservationApiFp(this.configuration).billingProjectReservationUpdate(projectId, reservationId, billingProjectReservationUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * BillingProjectServiceApi - axios parameter creator
 * @export
 */
export const BillingProjectServiceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a single service
         * @summary Get billing/service
         * @param {string} projectId Project Id
         * @param {string} serviceId Service Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingProjectServiceGet: async (projectId: string, serviceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('billingProjectServiceGet', 'projectId', projectId)
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('billingProjectServiceGet', 'serviceId', serviceId)
            const localVarPath = `/billing/project/{projectId}/service/{serviceId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List service
         * @summary List billing/service
         * @param {string} projectId Project Id
         * @param {string} [kind] Filter by kind
         * @param {string} [name] Filter by name
         * @param {string} [type] Filter by type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingProjectServiceList: async (projectId: string, kind?: string, name?: string, type?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('billingProjectServiceList', 'projectId', projectId)
            const localVarPath = `/billing/project/{projectId}/service`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (kind !== undefined) {
                localVarQueryParameter['kind'] = kind;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * BillingProjectServiceApi - functional programming interface
 * @export
 */
export const BillingProjectServiceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = BillingProjectServiceApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns a single service
         * @summary Get billing/service
         * @param {string} projectId Project Id
         * @param {string} serviceId Service Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async billingProjectServiceGet(projectId: string, serviceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Service>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.billingProjectServiceGet(projectId, serviceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List service
         * @summary List billing/service
         * @param {string} projectId Project Id
         * @param {string} [kind] Filter by kind
         * @param {string} [name] Filter by name
         * @param {string} [type] Filter by type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async billingProjectServiceList(projectId: string, kind?: string, name?: string, type?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Service>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.billingProjectServiceList(projectId, kind, name, type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * BillingProjectServiceApi - factory interface
 * @export
 */
export const BillingProjectServiceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = BillingProjectServiceApiFp(configuration)
    return {
        /**
         * Returns a single service
         * @summary Get billing/service
         * @param {string} projectId Project Id
         * @param {string} serviceId Service Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingProjectServiceGet(projectId: string, serviceId: string, options?: any): AxiosPromise<Service> {
            return localVarFp.billingProjectServiceGet(projectId, serviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * List service
         * @summary List billing/service
         * @param {string} projectId Project Id
         * @param {string} [kind] Filter by kind
         * @param {string} [name] Filter by name
         * @param {string} [type] Filter by type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        billingProjectServiceList(projectId: string, kind?: string, name?: string, type?: string, options?: any): AxiosPromise<Array<Service>> {
            return localVarFp.billingProjectServiceList(projectId, kind, name, type, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * BillingProjectServiceApi - object-oriented interface
 * @export
 * @class BillingProjectServiceApi
 * @extends {BaseAPI}
 */
export class BillingProjectServiceApi extends BaseAPI {
    /**
     * Returns a single service
     * @summary Get billing/service
     * @param {string} projectId Project Id
     * @param {string} serviceId Service Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingProjectServiceApi
     */
    public billingProjectServiceGet(projectId: string, serviceId: string, options?: any) {
        return BillingProjectServiceApiFp(this.configuration).billingProjectServiceGet(projectId, serviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List service
     * @summary List billing/service
     * @param {string} projectId Project Id
     * @param {string} [kind] Filter by kind
     * @param {string} [name] Filter by name
     * @param {string} [type] Filter by type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BillingProjectServiceApi
     */
    public billingProjectServiceList(projectId: string, kind?: string, name?: string, type?: string, options?: any) {
        return BillingProjectServiceApiFp(this.configuration).billingProjectServiceList(projectId, kind, name, type, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ComputeProjectReplicaApi - axios parameter creator
 * @export
 */
export const ComputeProjectReplicaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create replica
         * @summary Create compute/replica
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {ComputeProjectReplicaCreate} computeProjectReplicaCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectReplicaCreate: async (projectId: string, locationId: string, computeProjectReplicaCreate: ComputeProjectReplicaCreate, xIdempotencyKey?: string, xDryRun?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('computeProjectReplicaCreate', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('computeProjectReplicaCreate', 'locationId', locationId)
            // verify required parameter 'computeProjectReplicaCreate' is not null or undefined
            assertParamExists('computeProjectReplicaCreate', 'computeProjectReplicaCreate', computeProjectReplicaCreate)
            const localVarPath = `/compute/{locationId}/project/{projectId}/replica`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }

            if (xDryRun !== undefined && xDryRun !== null) {
                localVarHeaderParameter['x-dry-run'] = String(xDryRun);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(computeProjectReplicaCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete replica
         * @summary Delete compute/replica
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} replicaId Replica Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectReplicaDelete: async (projectId: string, locationId: string, replicaId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('computeProjectReplicaDelete', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('computeProjectReplicaDelete', 'locationId', locationId)
            // verify required parameter 'replicaId' is not null or undefined
            assertParamExists('computeProjectReplicaDelete', 'replicaId', replicaId)
            const localVarPath = `/compute/{locationId}/project/{projectId}/replica/{replicaId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"replicaId"}}`, encodeURIComponent(String(replicaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get compute/replica.event
         * @summary Get compute/replica.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} replicaId Replica Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectReplicaEventGet: async (projectId: string, locationId: string, replicaId: string, eventId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('computeProjectReplicaEventGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('computeProjectReplicaEventGet', 'locationId', locationId)
            // verify required parameter 'replicaId' is not null or undefined
            assertParamExists('computeProjectReplicaEventGet', 'replicaId', replicaId)
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('computeProjectReplicaEventGet', 'eventId', eventId)
            const localVarPath = `/compute/{locationId}/project/{projectId}/replica/{replicaId}/event/{eventId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"replicaId"}}`, encodeURIComponent(String(replicaId)))
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List compute/replica.event
         * @summary List compute/replica.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} replicaId Replica Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectReplicaEventList: async (projectId: string, locationId: string, replicaId: string, $limit?: number, $skip?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('computeProjectReplicaEventList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('computeProjectReplicaEventList', 'locationId', locationId)
            // verify required parameter 'replicaId' is not null or undefined
            assertParamExists('computeProjectReplicaEventList', 'replicaId', replicaId)
            const localVarPath = `/compute/{locationId}/project/{projectId}/replica/{replicaId}/event`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"replicaId"}}`, encodeURIComponent(String(replicaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if ($limit !== undefined) {
                localVarQueryParameter['$limit'] = $limit;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single replica
         * @summary Get compute/replica
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} replicaId Replica Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectReplicaGet: async (projectId: string, locationId: string, replicaId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('computeProjectReplicaGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('computeProjectReplicaGet', 'locationId', locationId)
            // verify required parameter 'replicaId' is not null or undefined
            assertParamExists('computeProjectReplicaGet', 'replicaId', replicaId)
            const localVarPath = `/compute/{locationId}/project/{projectId}/replica/{replicaId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"replicaId"}}`, encodeURIComponent(String(replicaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List replica
         * @summary List compute/replica
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [name] Filter by name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectReplicaList: async (projectId: string, locationId: string, name?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('computeProjectReplicaList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('computeProjectReplicaList', 'locationId', locationId)
            const localVarPath = `/compute/{locationId}/project/{projectId}/replica`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get compute/replica.service
         * @summary Get compute/replica.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} replicaId Replica Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectReplicaServiceGet: async (projectId: string, locationId: string, replicaId: string, serviceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('computeProjectReplicaServiceGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('computeProjectReplicaServiceGet', 'locationId', locationId)
            // verify required parameter 'replicaId' is not null or undefined
            assertParamExists('computeProjectReplicaServiceGet', 'replicaId', replicaId)
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('computeProjectReplicaServiceGet', 'serviceId', serviceId)
            const localVarPath = `/compute/{locationId}/project/{projectId}/replica/{replicaId}/service/{serviceId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"replicaId"}}`, encodeURIComponent(String(replicaId)))
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List compute/replica.service
         * @summary List compute/replica.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} replicaId Replica Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectReplicaServiceList: async (projectId: string, locationId: string, replicaId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('computeProjectReplicaServiceList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('computeProjectReplicaServiceList', 'locationId', locationId)
            // verify required parameter 'replicaId' is not null or undefined
            assertParamExists('computeProjectReplicaServiceList', 'replicaId', replicaId)
            const localVarPath = `/compute/{locationId}/project/{projectId}/replica/{replicaId}/service`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"replicaId"}}`, encodeURIComponent(String(replicaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create compute/replica.tag
         * @summary Create compute/replica.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} replicaId Replica Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectReplicaTagCreate: async (projectId: string, locationId: string, replicaId: string, tag: Tag, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('computeProjectReplicaTagCreate', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('computeProjectReplicaTagCreate', 'locationId', locationId)
            // verify required parameter 'replicaId' is not null or undefined
            assertParamExists('computeProjectReplicaTagCreate', 'replicaId', replicaId)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('computeProjectReplicaTagCreate', 'tag', tag)
            const localVarPath = `/compute/{locationId}/project/{projectId}/replica/{replicaId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"replicaId"}}`, encodeURIComponent(String(replicaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tag, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete compute/replica.tag
         * @summary Delete compute/replica.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} replicaId Replica Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectReplicaTagDelete: async (projectId: string, locationId: string, replicaId: string, tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('computeProjectReplicaTagDelete', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('computeProjectReplicaTagDelete', 'locationId', locationId)
            // verify required parameter 'replicaId' is not null or undefined
            assertParamExists('computeProjectReplicaTagDelete', 'replicaId', replicaId)
            // verify required parameter 'tagId' is not null or undefined
            assertParamExists('computeProjectReplicaTagDelete', 'tagId', tagId)
            const localVarPath = `/compute/{locationId}/project/{projectId}/replica/{replicaId}/tag/{tagId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"replicaId"}}`, encodeURIComponent(String(replicaId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get compute/replica.tag
         * @summary Get compute/replica.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} replicaId Replica Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectReplicaTagGet: async (projectId: string, locationId: string, replicaId: string, tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('computeProjectReplicaTagGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('computeProjectReplicaTagGet', 'locationId', locationId)
            // verify required parameter 'replicaId' is not null or undefined
            assertParamExists('computeProjectReplicaTagGet', 'replicaId', replicaId)
            // verify required parameter 'tagId' is not null or undefined
            assertParamExists('computeProjectReplicaTagGet', 'tagId', tagId)
            const localVarPath = `/compute/{locationId}/project/{projectId}/replica/{replicaId}/tag/{tagId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"replicaId"}}`, encodeURIComponent(String(replicaId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List compute/replica.tag
         * @summary List compute/replica.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} replicaId Replica Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectReplicaTagList: async (projectId: string, locationId: string, replicaId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('computeProjectReplicaTagList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('computeProjectReplicaTagList', 'locationId', locationId)
            // verify required parameter 'replicaId' is not null or undefined
            assertParamExists('computeProjectReplicaTagList', 'replicaId', replicaId)
            const localVarPath = `/compute/{locationId}/project/{projectId}/replica/{replicaId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"replicaId"}}`, encodeURIComponent(String(replicaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replace compute/replica.tag
         * @summary Replace compute/replica.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} replicaId Replica Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectReplicaTagPut: async (projectId: string, locationId: string, replicaId: string, tag: Array<Tag>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('computeProjectReplicaTagPut', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('computeProjectReplicaTagPut', 'locationId', locationId)
            // verify required parameter 'replicaId' is not null or undefined
            assertParamExists('computeProjectReplicaTagPut', 'replicaId', replicaId)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('computeProjectReplicaTagPut', 'tag', tag)
            const localVarPath = `/compute/{locationId}/project/{projectId}/replica/{replicaId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"replicaId"}}`, encodeURIComponent(String(replicaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tag, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ComputeProjectReplicaApi - functional programming interface
 * @export
 */
export const ComputeProjectReplicaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ComputeProjectReplicaApiAxiosParamCreator(configuration)
    return {
        /**
         * Create replica
         * @summary Create compute/replica
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {ComputeProjectReplicaCreate} computeProjectReplicaCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeProjectReplicaCreate(projectId: string, locationId: string, computeProjectReplicaCreate: ComputeProjectReplicaCreate, xIdempotencyKey?: string, xDryRun?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Replica>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.computeProjectReplicaCreate(projectId, locationId, computeProjectReplicaCreate, xIdempotencyKey, xDryRun, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete replica
         * @summary Delete compute/replica
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} replicaId Replica Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeProjectReplicaDelete(projectId: string, locationId: string, replicaId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.computeProjectReplicaDelete(projectId, locationId, replicaId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get compute/replica.event
         * @summary Get compute/replica.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} replicaId Replica Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeProjectReplicaEventGet(projectId: string, locationId: string, replicaId: string, eventId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.computeProjectReplicaEventGet(projectId, locationId, replicaId, eventId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List compute/replica.event
         * @summary List compute/replica.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} replicaId Replica Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeProjectReplicaEventList(projectId: string, locationId: string, replicaId: string, $limit?: number, $skip?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Event>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.computeProjectReplicaEventList(projectId, locationId, replicaId, $limit, $skip, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a single replica
         * @summary Get compute/replica
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} replicaId Replica Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeProjectReplicaGet(projectId: string, locationId: string, replicaId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Replica>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.computeProjectReplicaGet(projectId, locationId, replicaId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List replica
         * @summary List compute/replica
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [name] Filter by name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeProjectReplicaList(projectId: string, locationId: string, name?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Replica>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.computeProjectReplicaList(projectId, locationId, name, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get compute/replica.service
         * @summary Get compute/replica.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} replicaId Replica Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeProjectReplicaServiceGet(projectId: string, locationId: string, replicaId: string, serviceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceService>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.computeProjectReplicaServiceGet(projectId, locationId, replicaId, serviceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List compute/replica.service
         * @summary List compute/replica.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} replicaId Replica Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeProjectReplicaServiceList(projectId: string, locationId: string, replicaId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResourceService>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.computeProjectReplicaServiceList(projectId, locationId, replicaId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create compute/replica.tag
         * @summary Create compute/replica.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} replicaId Replica Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeProjectReplicaTagCreate(projectId: string, locationId: string, replicaId: string, tag: Tag, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.computeProjectReplicaTagCreate(projectId, locationId, replicaId, tag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete compute/replica.tag
         * @summary Delete compute/replica.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} replicaId Replica Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeProjectReplicaTagDelete(projectId: string, locationId: string, replicaId: string, tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.computeProjectReplicaTagDelete(projectId, locationId, replicaId, tagId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get compute/replica.tag
         * @summary Get compute/replica.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} replicaId Replica Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeProjectReplicaTagGet(projectId: string, locationId: string, replicaId: string, tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.computeProjectReplicaTagGet(projectId, locationId, replicaId, tagId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List compute/replica.tag
         * @summary List compute/replica.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} replicaId Replica Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeProjectReplicaTagList(projectId: string, locationId: string, replicaId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.computeProjectReplicaTagList(projectId, locationId, replicaId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Replace compute/replica.tag
         * @summary Replace compute/replica.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} replicaId Replica Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeProjectReplicaTagPut(projectId: string, locationId: string, replicaId: string, tag: Array<Tag>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.computeProjectReplicaTagPut(projectId, locationId, replicaId, tag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ComputeProjectReplicaApi - factory interface
 * @export
 */
export const ComputeProjectReplicaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ComputeProjectReplicaApiFp(configuration)
    return {
        /**
         * Create replica
         * @summary Create compute/replica
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {ComputeProjectReplicaCreate} computeProjectReplicaCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectReplicaCreate(projectId: string, locationId: string, computeProjectReplicaCreate: ComputeProjectReplicaCreate, xIdempotencyKey?: string, xDryRun?: string, options?: any): AxiosPromise<Replica> {
            return localVarFp.computeProjectReplicaCreate(projectId, locationId, computeProjectReplicaCreate, xIdempotencyKey, xDryRun, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete replica
         * @summary Delete compute/replica
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} replicaId Replica Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectReplicaDelete(projectId: string, locationId: string, replicaId: string, options?: any): AxiosPromise<void> {
            return localVarFp.computeProjectReplicaDelete(projectId, locationId, replicaId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get compute/replica.event
         * @summary Get compute/replica.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} replicaId Replica Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectReplicaEventGet(projectId: string, locationId: string, replicaId: string, eventId: string, options?: any): AxiosPromise<Event> {
            return localVarFp.computeProjectReplicaEventGet(projectId, locationId, replicaId, eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * List compute/replica.event
         * @summary List compute/replica.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} replicaId Replica Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectReplicaEventList(projectId: string, locationId: string, replicaId: string, $limit?: number, $skip?: number, options?: any): AxiosPromise<Array<Event>> {
            return localVarFp.computeProjectReplicaEventList(projectId, locationId, replicaId, $limit, $skip, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single replica
         * @summary Get compute/replica
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} replicaId Replica Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectReplicaGet(projectId: string, locationId: string, replicaId: string, options?: any): AxiosPromise<Replica> {
            return localVarFp.computeProjectReplicaGet(projectId, locationId, replicaId, options).then((request) => request(axios, basePath));
        },
        /**
         * List replica
         * @summary List compute/replica
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [name] Filter by name
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectReplicaList(projectId: string, locationId: string, name?: string, options?: any): AxiosPromise<Array<Replica>> {
            return localVarFp.computeProjectReplicaList(projectId, locationId, name, options).then((request) => request(axios, basePath));
        },
        /**
         * Get compute/replica.service
         * @summary Get compute/replica.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} replicaId Replica Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectReplicaServiceGet(projectId: string, locationId: string, replicaId: string, serviceId: string, options?: any): AxiosPromise<ResourceService> {
            return localVarFp.computeProjectReplicaServiceGet(projectId, locationId, replicaId, serviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * List compute/replica.service
         * @summary List compute/replica.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} replicaId Replica Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectReplicaServiceList(projectId: string, locationId: string, replicaId: string, options?: any): AxiosPromise<Array<ResourceService>> {
            return localVarFp.computeProjectReplicaServiceList(projectId, locationId, replicaId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create compute/replica.tag
         * @summary Create compute/replica.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} replicaId Replica Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectReplicaTagCreate(projectId: string, locationId: string, replicaId: string, tag: Tag, options?: any): AxiosPromise<Tag> {
            return localVarFp.computeProjectReplicaTagCreate(projectId, locationId, replicaId, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete compute/replica.tag
         * @summary Delete compute/replica.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} replicaId Replica Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectReplicaTagDelete(projectId: string, locationId: string, replicaId: string, tagId: string, options?: any): AxiosPromise<void> {
            return localVarFp.computeProjectReplicaTagDelete(projectId, locationId, replicaId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get compute/replica.tag
         * @summary Get compute/replica.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} replicaId Replica Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectReplicaTagGet(projectId: string, locationId: string, replicaId: string, tagId: string, options?: any): AxiosPromise<Tag> {
            return localVarFp.computeProjectReplicaTagGet(projectId, locationId, replicaId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * List compute/replica.tag
         * @summary List compute/replica.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} replicaId Replica Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectReplicaTagList(projectId: string, locationId: string, replicaId: string, options?: any): AxiosPromise<Array<Tag>> {
            return localVarFp.computeProjectReplicaTagList(projectId, locationId, replicaId, options).then((request) => request(axios, basePath));
        },
        /**
         * Replace compute/replica.tag
         * @summary Replace compute/replica.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} replicaId Replica Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectReplicaTagPut(projectId: string, locationId: string, replicaId: string, tag: Array<Tag>, options?: any): AxiosPromise<Array<Tag>> {
            return localVarFp.computeProjectReplicaTagPut(projectId, locationId, replicaId, tag, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ComputeProjectReplicaApi - object-oriented interface
 * @export
 * @class ComputeProjectReplicaApi
 * @extends {BaseAPI}
 */
export class ComputeProjectReplicaApi extends BaseAPI {
    /**
     * Create replica
     * @summary Create compute/replica
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {ComputeProjectReplicaCreate} computeProjectReplicaCreate 
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {string} [xDryRun] Dry run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputeProjectReplicaApi
     */
    public computeProjectReplicaCreate(projectId: string, locationId: string, computeProjectReplicaCreate: ComputeProjectReplicaCreate, xIdempotencyKey?: string, xDryRun?: string, options?: any) {
        return ComputeProjectReplicaApiFp(this.configuration).computeProjectReplicaCreate(projectId, locationId, computeProjectReplicaCreate, xIdempotencyKey, xDryRun, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete replica
     * @summary Delete compute/replica
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} replicaId Replica Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputeProjectReplicaApi
     */
    public computeProjectReplicaDelete(projectId: string, locationId: string, replicaId: string, options?: any) {
        return ComputeProjectReplicaApiFp(this.configuration).computeProjectReplicaDelete(projectId, locationId, replicaId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get compute/replica.event
     * @summary Get compute/replica.event
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} replicaId Replica Id
     * @param {string} eventId eventId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputeProjectReplicaApi
     */
    public computeProjectReplicaEventGet(projectId: string, locationId: string, replicaId: string, eventId: string, options?: any) {
        return ComputeProjectReplicaApiFp(this.configuration).computeProjectReplicaEventGet(projectId, locationId, replicaId, eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List compute/replica.event
     * @summary List compute/replica.event
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} replicaId Replica Id
     * @param {number} [$limit] $limit
     * @param {number} [$skip] $skip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputeProjectReplicaApi
     */
    public computeProjectReplicaEventList(projectId: string, locationId: string, replicaId: string, $limit?: number, $skip?: number, options?: any) {
        return ComputeProjectReplicaApiFp(this.configuration).computeProjectReplicaEventList(projectId, locationId, replicaId, $limit, $skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single replica
     * @summary Get compute/replica
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} replicaId Replica Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputeProjectReplicaApi
     */
    public computeProjectReplicaGet(projectId: string, locationId: string, replicaId: string, options?: any) {
        return ComputeProjectReplicaApiFp(this.configuration).computeProjectReplicaGet(projectId, locationId, replicaId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List replica
     * @summary List compute/replica
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} [name] Filter by name
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputeProjectReplicaApi
     */
    public computeProjectReplicaList(projectId: string, locationId: string, name?: string, options?: any) {
        return ComputeProjectReplicaApiFp(this.configuration).computeProjectReplicaList(projectId, locationId, name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get compute/replica.service
     * @summary Get compute/replica.service
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} replicaId Replica Id
     * @param {string} serviceId serviceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputeProjectReplicaApi
     */
    public computeProjectReplicaServiceGet(projectId: string, locationId: string, replicaId: string, serviceId: string, options?: any) {
        return ComputeProjectReplicaApiFp(this.configuration).computeProjectReplicaServiceGet(projectId, locationId, replicaId, serviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List compute/replica.service
     * @summary List compute/replica.service
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} replicaId Replica Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputeProjectReplicaApi
     */
    public computeProjectReplicaServiceList(projectId: string, locationId: string, replicaId: string, options?: any) {
        return ComputeProjectReplicaApiFp(this.configuration).computeProjectReplicaServiceList(projectId, locationId, replicaId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create compute/replica.tag
     * @summary Create compute/replica.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} replicaId Replica Id
     * @param {Tag} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputeProjectReplicaApi
     */
    public computeProjectReplicaTagCreate(projectId: string, locationId: string, replicaId: string, tag: Tag, options?: any) {
        return ComputeProjectReplicaApiFp(this.configuration).computeProjectReplicaTagCreate(projectId, locationId, replicaId, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete compute/replica.tag
     * @summary Delete compute/replica.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} replicaId Replica Id
     * @param {string} tagId tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputeProjectReplicaApi
     */
    public computeProjectReplicaTagDelete(projectId: string, locationId: string, replicaId: string, tagId: string, options?: any) {
        return ComputeProjectReplicaApiFp(this.configuration).computeProjectReplicaTagDelete(projectId, locationId, replicaId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get compute/replica.tag
     * @summary Get compute/replica.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} replicaId Replica Id
     * @param {string} tagId tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputeProjectReplicaApi
     */
    public computeProjectReplicaTagGet(projectId: string, locationId: string, replicaId: string, tagId: string, options?: any) {
        return ComputeProjectReplicaApiFp(this.configuration).computeProjectReplicaTagGet(projectId, locationId, replicaId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List compute/replica.tag
     * @summary List compute/replica.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} replicaId Replica Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputeProjectReplicaApi
     */
    public computeProjectReplicaTagList(projectId: string, locationId: string, replicaId: string, options?: any) {
        return ComputeProjectReplicaApiFp(this.configuration).computeProjectReplicaTagList(projectId, locationId, replicaId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replace compute/replica.tag
     * @summary Replace compute/replica.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} replicaId Replica Id
     * @param {Array<Tag>} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputeProjectReplicaApi
     */
    public computeProjectReplicaTagPut(projectId: string, locationId: string, replicaId: string, tag: Array<Tag>, options?: any) {
        return ComputeProjectReplicaApiFp(this.configuration).computeProjectReplicaTagPut(projectId, locationId, replicaId, tag, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ComputeProjectVmApi - axios parameter creator
 * @export
 */
export const ComputeProjectVmApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get compute/vm.connect
         * @summary Get compute/vm.connect
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {string} connectId connectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmConnectGet: async (projectId: string, locationId: string, vmId: string, connectId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('computeProjectVmConnectGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('computeProjectVmConnectGet', 'locationId', locationId)
            // verify required parameter 'vmId' is not null or undefined
            assertParamExists('computeProjectVmConnectGet', 'vmId', vmId)
            // verify required parameter 'connectId' is not null or undefined
            assertParamExists('computeProjectVmConnectGet', 'connectId', connectId)
            const localVarPath = `/compute/{locationId}/project/{projectId}/vm/{vmId}/connect/{connectId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"vmId"}}`, encodeURIComponent(String(vmId)))
                .replace(`{${"connectId"}}`, encodeURIComponent(String(connectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List compute/vm.connect
         * @summary List compute/vm.connect
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmConnectList: async (projectId: string, locationId: string, vmId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('computeProjectVmConnectList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('computeProjectVmConnectList', 'locationId', locationId)
            // verify required parameter 'vmId' is not null or undefined
            assertParamExists('computeProjectVmConnectList', 'vmId', vmId)
            const localVarPath = `/compute/{locationId}/project/{projectId}/vm/{vmId}/connect`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"vmId"}}`, encodeURIComponent(String(vmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * action open
         * @summary Open compute/vm.connect
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {string} connectId connectId
         * @param {ComputeProjectVmConnectOpen} computeProjectVmConnectOpen 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmConnectOpen: async (projectId: string, locationId: string, vmId: string, connectId: string, computeProjectVmConnectOpen: ComputeProjectVmConnectOpen, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('computeProjectVmConnectOpen', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('computeProjectVmConnectOpen', 'locationId', locationId)
            // verify required parameter 'vmId' is not null or undefined
            assertParamExists('computeProjectVmConnectOpen', 'vmId', vmId)
            // verify required parameter 'connectId' is not null or undefined
            assertParamExists('computeProjectVmConnectOpen', 'connectId', connectId)
            // verify required parameter 'computeProjectVmConnectOpen' is not null or undefined
            assertParamExists('computeProjectVmConnectOpen', 'computeProjectVmConnectOpen', computeProjectVmConnectOpen)
            const localVarPath = `/compute/{locationId}/project/{projectId}/vm/{vmId}/connect/{connectId}/actions/open`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"vmId"}}`, encodeURIComponent(String(vmId)))
                .replace(`{${"connectId"}}`, encodeURIComponent(String(connectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(computeProjectVmConnectOpen, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create vm
         * @summary Create compute/vm
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {ComputeProjectVmCreate} computeProjectVmCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmCreate: async (projectId: string, locationId: string, computeProjectVmCreate: ComputeProjectVmCreate, xIdempotencyKey?: string, xDryRun?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('computeProjectVmCreate', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('computeProjectVmCreate', 'locationId', locationId)
            // verify required parameter 'computeProjectVmCreate' is not null or undefined
            assertParamExists('computeProjectVmCreate', 'computeProjectVmCreate', computeProjectVmCreate)
            const localVarPath = `/compute/{locationId}/project/{projectId}/vm`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }

            if (xDryRun !== undefined && xDryRun !== null) {
                localVarHeaderParameter['x-dry-run'] = String(xDryRun);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(computeProjectVmCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete vm
         * @summary Delete compute/vm
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmDelete: async (projectId: string, locationId: string, vmId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('computeProjectVmDelete', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('computeProjectVmDelete', 'locationId', locationId)
            // verify required parameter 'vmId' is not null or undefined
            assertParamExists('computeProjectVmDelete', 'vmId', vmId)
            const localVarPath = `/compute/{locationId}/project/{projectId}/vm/{vmId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"vmId"}}`, encodeURIComponent(String(vmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create compute/vm.disk
         * @summary Create compute/vm.disk
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {ComputeProjectVmDiskCreate} computeProjectVmDiskCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmDiskCreate: async (projectId: string, locationId: string, vmId: string, computeProjectVmDiskCreate: ComputeProjectVmDiskCreate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('computeProjectVmDiskCreate', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('computeProjectVmDiskCreate', 'locationId', locationId)
            // verify required parameter 'vmId' is not null or undefined
            assertParamExists('computeProjectVmDiskCreate', 'vmId', vmId)
            // verify required parameter 'computeProjectVmDiskCreate' is not null or undefined
            assertParamExists('computeProjectVmDiskCreate', 'computeProjectVmDiskCreate', computeProjectVmDiskCreate)
            const localVarPath = `/compute/{locationId}/project/{projectId}/vm/{vmId}/disk`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"vmId"}}`, encodeURIComponent(String(vmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(computeProjectVmDiskCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List compute/vm.disk
         * @summary List compute/vm.disk
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmDiskList: async (projectId: string, locationId: string, vmId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('computeProjectVmDiskList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('computeProjectVmDiskList', 'locationId', locationId)
            // verify required parameter 'vmId' is not null or undefined
            assertParamExists('computeProjectVmDiskList', 'vmId', vmId)
            const localVarPath = `/compute/{locationId}/project/{projectId}/vm/{vmId}/disk`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"vmId"}}`, encodeURIComponent(String(vmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get compute/vm.event
         * @summary Get compute/vm.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmEventGet: async (projectId: string, locationId: string, vmId: string, eventId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('computeProjectVmEventGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('computeProjectVmEventGet', 'locationId', locationId)
            // verify required parameter 'vmId' is not null or undefined
            assertParamExists('computeProjectVmEventGet', 'vmId', vmId)
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('computeProjectVmEventGet', 'eventId', eventId)
            const localVarPath = `/compute/{locationId}/project/{projectId}/vm/{vmId}/event/{eventId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"vmId"}}`, encodeURIComponent(String(vmId)))
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List compute/vm.event
         * @summary List compute/vm.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmEventList: async (projectId: string, locationId: string, vmId: string, $limit?: number, $skip?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('computeProjectVmEventList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('computeProjectVmEventList', 'locationId', locationId)
            // verify required parameter 'vmId' is not null or undefined
            assertParamExists('computeProjectVmEventList', 'vmId', vmId)
            const localVarPath = `/compute/{locationId}/project/{projectId}/vm/{vmId}/event`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"vmId"}}`, encodeURIComponent(String(vmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if ($limit !== undefined) {
                localVarQueryParameter['$limit'] = $limit;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * action flavour
         * @summary Flavour compute/vm
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {ComputeProjectVmFlavour} computeProjectVmFlavour 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmFlavour: async (projectId: string, locationId: string, vmId: string, computeProjectVmFlavour: ComputeProjectVmFlavour, xIdempotencyKey?: string, xDryRun?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('computeProjectVmFlavour', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('computeProjectVmFlavour', 'locationId', locationId)
            // verify required parameter 'vmId' is not null or undefined
            assertParamExists('computeProjectVmFlavour', 'vmId', vmId)
            // verify required parameter 'computeProjectVmFlavour' is not null or undefined
            assertParamExists('computeProjectVmFlavour', 'computeProjectVmFlavour', computeProjectVmFlavour)
            const localVarPath = `/compute/{locationId}/project/{projectId}/vm/{vmId}/actions/flavour`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"vmId"}}`, encodeURIComponent(String(vmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }

            if (xDryRun !== undefined && xDryRun !== null) {
                localVarHeaderParameter['x-dry-run'] = String(xDryRun);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(computeProjectVmFlavour, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single vm
         * @summary Get compute/vm
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmGet: async (projectId: string, locationId: string, vmId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('computeProjectVmGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('computeProjectVmGet', 'locationId', locationId)
            // verify required parameter 'vmId' is not null or undefined
            assertParamExists('computeProjectVmGet', 'vmId', vmId)
            const localVarPath = `/compute/{locationId}/project/{projectId}/vm/{vmId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"vmId"}}`, encodeURIComponent(String(vmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create compute/vm.iso
         * @summary Create compute/vm.iso
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {ComputeProjectVmIsoCreate} computeProjectVmIsoCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmIsoCreate: async (projectId: string, locationId: string, vmId: string, computeProjectVmIsoCreate: ComputeProjectVmIsoCreate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('computeProjectVmIsoCreate', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('computeProjectVmIsoCreate', 'locationId', locationId)
            // verify required parameter 'vmId' is not null or undefined
            assertParamExists('computeProjectVmIsoCreate', 'vmId', vmId)
            // verify required parameter 'computeProjectVmIsoCreate' is not null or undefined
            assertParamExists('computeProjectVmIsoCreate', 'computeProjectVmIsoCreate', computeProjectVmIsoCreate)
            const localVarPath = `/compute/{locationId}/project/{projectId}/vm/{vmId}/iso`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"vmId"}}`, encodeURIComponent(String(vmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(computeProjectVmIsoCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List compute/vm.iso
         * @summary List compute/vm.iso
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmIsoList: async (projectId: string, locationId: string, vmId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('computeProjectVmIsoList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('computeProjectVmIsoList', 'locationId', locationId)
            // verify required parameter 'vmId' is not null or undefined
            assertParamExists('computeProjectVmIsoList', 'vmId', vmId)
            const localVarPath = `/compute/{locationId}/project/{projectId}/vm/{vmId}/iso`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"vmId"}}`, encodeURIComponent(String(vmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List vm
         * @summary List compute/vm
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [name] Filter by name
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmList: async (projectId: string, locationId: string, name?: string, tagValue?: string, tagKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('computeProjectVmList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('computeProjectVmList', 'locationId', locationId)
            const localVarPath = `/compute/{locationId}/project/{projectId}/vm`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (tagValue !== undefined) {
                localVarQueryParameter['tag.value'] = tagValue;
            }

            if (tagKey !== undefined) {
                localVarQueryParameter['tag.key'] = tagKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get compute/vm.metric
         * @summary Get compute/vm.metric
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {string} metricId metricId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmMetricGet: async (projectId: string, locationId: string, vmId: string, metricId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('computeProjectVmMetricGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('computeProjectVmMetricGet', 'locationId', locationId)
            // verify required parameter 'vmId' is not null or undefined
            assertParamExists('computeProjectVmMetricGet', 'vmId', vmId)
            // verify required parameter 'metricId' is not null or undefined
            assertParamExists('computeProjectVmMetricGet', 'metricId', metricId)
            const localVarPath = `/compute/{locationId}/project/{projectId}/vm/{vmId}/metric/{metricId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"vmId"}}`, encodeURIComponent(String(vmId)))
                .replace(`{${"metricId"}}`, encodeURIComponent(String(metricId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List compute/vm.metric
         * @summary List compute/vm.metric
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmMetricList: async (projectId: string, locationId: string, vmId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('computeProjectVmMetricList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('computeProjectVmMetricList', 'locationId', locationId)
            // verify required parameter 'vmId' is not null or undefined
            assertParamExists('computeProjectVmMetricList', 'vmId', vmId)
            const localVarPath = `/compute/{locationId}/project/{projectId}/vm/{vmId}/metric`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"vmId"}}`, encodeURIComponent(String(vmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List compute/vm.point
         * @summary List compute/vm.point
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {string} metricId metricId
         * @param {string} [interval] interval
         * @param {string} [timespan] timespan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmMetricPointList: async (projectId: string, locationId: string, vmId: string, metricId: string, interval?: string, timespan?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('computeProjectVmMetricPointList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('computeProjectVmMetricPointList', 'locationId', locationId)
            // verify required parameter 'vmId' is not null or undefined
            assertParamExists('computeProjectVmMetricPointList', 'vmId', vmId)
            // verify required parameter 'metricId' is not null or undefined
            assertParamExists('computeProjectVmMetricPointList', 'metricId', metricId)
            const localVarPath = `/compute/{locationId}/project/{projectId}/vm/{vmId}/metric/{metricId}/point`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"vmId"}}`, encodeURIComponent(String(vmId)))
                .replace(`{${"metricId"}}`, encodeURIComponent(String(metricId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (timespan !== undefined) {
                localVarQueryParameter['timespan'] = timespan;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * action password_reset
         * @summary Password reset compute/vm
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {ComputeProjectVmPasswordReset} computeProjectVmPasswordReset 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmPasswordReset: async (projectId: string, locationId: string, vmId: string, computeProjectVmPasswordReset: ComputeProjectVmPasswordReset, xIdempotencyKey?: string, xDryRun?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('computeProjectVmPasswordReset', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('computeProjectVmPasswordReset', 'locationId', locationId)
            // verify required parameter 'vmId' is not null or undefined
            assertParamExists('computeProjectVmPasswordReset', 'vmId', vmId)
            // verify required parameter 'computeProjectVmPasswordReset' is not null or undefined
            assertParamExists('computeProjectVmPasswordReset', 'computeProjectVmPasswordReset', computeProjectVmPasswordReset)
            const localVarPath = `/compute/{locationId}/project/{projectId}/vm/{vmId}/actions/password_reset`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"vmId"}}`, encodeURIComponent(String(vmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }

            if (xDryRun !== undefined && xDryRun !== null) {
                localVarHeaderParameter['x-dry-run'] = String(xDryRun);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(computeProjectVmPasswordReset, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * action restart
         * @summary Restart compute/vm
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmRestart: async (projectId: string, locationId: string, vmId: string, xIdempotencyKey?: string, xDryRun?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('computeProjectVmRestart', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('computeProjectVmRestart', 'locationId', locationId)
            // verify required parameter 'vmId' is not null or undefined
            assertParamExists('computeProjectVmRestart', 'vmId', vmId)
            const localVarPath = `/compute/{locationId}/project/{projectId}/vm/{vmId}/actions/restart`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"vmId"}}`, encodeURIComponent(String(vmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }

            if (xDryRun !== undefined && xDryRun !== null) {
                localVarHeaderParameter['x-dry-run'] = String(xDryRun);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * action serialport
         * @summary Serialport compute/vm
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {ComputeProjectVmSerialport} computeProjectVmSerialport 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmSerialport: async (projectId: string, locationId: string, vmId: string, computeProjectVmSerialport: ComputeProjectVmSerialport, xIdempotencyKey?: string, xDryRun?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('computeProjectVmSerialport', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('computeProjectVmSerialport', 'locationId', locationId)
            // verify required parameter 'vmId' is not null or undefined
            assertParamExists('computeProjectVmSerialport', 'vmId', vmId)
            // verify required parameter 'computeProjectVmSerialport' is not null or undefined
            assertParamExists('computeProjectVmSerialport', 'computeProjectVmSerialport', computeProjectVmSerialport)
            const localVarPath = `/compute/{locationId}/project/{projectId}/vm/{vmId}/actions/serialport`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"vmId"}}`, encodeURIComponent(String(vmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }

            if (xDryRun !== undefined && xDryRun !== null) {
                localVarHeaderParameter['x-dry-run'] = String(xDryRun);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(computeProjectVmSerialport, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get compute/vm.service
         * @summary Get compute/vm.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmServiceGet: async (projectId: string, locationId: string, vmId: string, serviceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('computeProjectVmServiceGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('computeProjectVmServiceGet', 'locationId', locationId)
            // verify required parameter 'vmId' is not null or undefined
            assertParamExists('computeProjectVmServiceGet', 'vmId', vmId)
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('computeProjectVmServiceGet', 'serviceId', serviceId)
            const localVarPath = `/compute/{locationId}/project/{projectId}/vm/{vmId}/service/{serviceId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"vmId"}}`, encodeURIComponent(String(vmId)))
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List compute/vm.service
         * @summary List compute/vm.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmServiceList: async (projectId: string, locationId: string, vmId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('computeProjectVmServiceList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('computeProjectVmServiceList', 'locationId', locationId)
            // verify required parameter 'vmId' is not null or undefined
            assertParamExists('computeProjectVmServiceList', 'vmId', vmId)
            const localVarPath = `/compute/{locationId}/project/{projectId}/vm/{vmId}/service`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"vmId"}}`, encodeURIComponent(String(vmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * action start
         * @summary Start compute/vm
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmStart: async (projectId: string, locationId: string, vmId: string, xIdempotencyKey?: string, xDryRun?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('computeProjectVmStart', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('computeProjectVmStart', 'locationId', locationId)
            // verify required parameter 'vmId' is not null or undefined
            assertParamExists('computeProjectVmStart', 'vmId', vmId)
            const localVarPath = `/compute/{locationId}/project/{projectId}/vm/{vmId}/actions/start`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"vmId"}}`, encodeURIComponent(String(vmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }

            if (xDryRun !== undefined && xDryRun !== null) {
                localVarHeaderParameter['x-dry-run'] = String(xDryRun);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * action stop
         * @summary Stop compute/vm
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmStop: async (projectId: string, locationId: string, vmId: string, xIdempotencyKey?: string, xDryRun?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('computeProjectVmStop', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('computeProjectVmStop', 'locationId', locationId)
            // verify required parameter 'vmId' is not null or undefined
            assertParamExists('computeProjectVmStop', 'vmId', vmId)
            const localVarPath = `/compute/{locationId}/project/{projectId}/vm/{vmId}/actions/stop`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"vmId"}}`, encodeURIComponent(String(vmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }

            if (xDryRun !== undefined && xDryRun !== null) {
                localVarHeaderParameter['x-dry-run'] = String(xDryRun);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create compute/vm.tag
         * @summary Create compute/vm.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmTagCreate: async (projectId: string, locationId: string, vmId: string, tag: Tag, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('computeProjectVmTagCreate', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('computeProjectVmTagCreate', 'locationId', locationId)
            // verify required parameter 'vmId' is not null or undefined
            assertParamExists('computeProjectVmTagCreate', 'vmId', vmId)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('computeProjectVmTagCreate', 'tag', tag)
            const localVarPath = `/compute/{locationId}/project/{projectId}/vm/{vmId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"vmId"}}`, encodeURIComponent(String(vmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tag, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete compute/vm.tag
         * @summary Delete compute/vm.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmTagDelete: async (projectId: string, locationId: string, vmId: string, tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('computeProjectVmTagDelete', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('computeProjectVmTagDelete', 'locationId', locationId)
            // verify required parameter 'vmId' is not null or undefined
            assertParamExists('computeProjectVmTagDelete', 'vmId', vmId)
            // verify required parameter 'tagId' is not null or undefined
            assertParamExists('computeProjectVmTagDelete', 'tagId', tagId)
            const localVarPath = `/compute/{locationId}/project/{projectId}/vm/{vmId}/tag/{tagId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"vmId"}}`, encodeURIComponent(String(vmId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get compute/vm.tag
         * @summary Get compute/vm.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmTagGet: async (projectId: string, locationId: string, vmId: string, tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('computeProjectVmTagGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('computeProjectVmTagGet', 'locationId', locationId)
            // verify required parameter 'vmId' is not null or undefined
            assertParamExists('computeProjectVmTagGet', 'vmId', vmId)
            // verify required parameter 'tagId' is not null or undefined
            assertParamExists('computeProjectVmTagGet', 'tagId', tagId)
            const localVarPath = `/compute/{locationId}/project/{projectId}/vm/{vmId}/tag/{tagId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"vmId"}}`, encodeURIComponent(String(vmId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List compute/vm.tag
         * @summary List compute/vm.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmTagList: async (projectId: string, locationId: string, vmId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('computeProjectVmTagList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('computeProjectVmTagList', 'locationId', locationId)
            // verify required parameter 'vmId' is not null or undefined
            assertParamExists('computeProjectVmTagList', 'vmId', vmId)
            const localVarPath = `/compute/{locationId}/project/{projectId}/vm/{vmId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"vmId"}}`, encodeURIComponent(String(vmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replace compute/vm.tag
         * @summary Replace compute/vm.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmTagPut: async (projectId: string, locationId: string, vmId: string, tag: Array<Tag>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('computeProjectVmTagPut', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('computeProjectVmTagPut', 'locationId', locationId)
            // verify required parameter 'vmId' is not null or undefined
            assertParamExists('computeProjectVmTagPut', 'vmId', vmId)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('computeProjectVmTagPut', 'tag', tag)
            const localVarPath = `/compute/{locationId}/project/{projectId}/vm/{vmId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"vmId"}}`, encodeURIComponent(String(vmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tag, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * action turnoff
         * @summary Turnoff compute/vm
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmTurnoff: async (projectId: string, locationId: string, vmId: string, xIdempotencyKey?: string, xDryRun?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('computeProjectVmTurnoff', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('computeProjectVmTurnoff', 'locationId', locationId)
            // verify required parameter 'vmId' is not null or undefined
            assertParamExists('computeProjectVmTurnoff', 'vmId', vmId)
            const localVarPath = `/compute/{locationId}/project/{projectId}/vm/{vmId}/actions/turnoff`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"vmId"}}`, encodeURIComponent(String(vmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }

            if (xDryRun !== undefined && xDryRun !== null) {
                localVarHeaderParameter['x-dry-run'] = String(xDryRun);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns modified vm
         * @summary Update compute/vm
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {ComputeProjectVmUpdate} computeProjectVmUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmUpdate: async (projectId: string, locationId: string, vmId: string, computeProjectVmUpdate: ComputeProjectVmUpdate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('computeProjectVmUpdate', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('computeProjectVmUpdate', 'locationId', locationId)
            // verify required parameter 'vmId' is not null or undefined
            assertParamExists('computeProjectVmUpdate', 'vmId', vmId)
            // verify required parameter 'computeProjectVmUpdate' is not null or undefined
            assertParamExists('computeProjectVmUpdate', 'computeProjectVmUpdate', computeProjectVmUpdate)
            const localVarPath = `/compute/{locationId}/project/{projectId}/vm/{vmId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"vmId"}}`, encodeURIComponent(String(vmId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(computeProjectVmUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ComputeProjectVmApi - functional programming interface
 * @export
 */
export const ComputeProjectVmApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ComputeProjectVmApiAxiosParamCreator(configuration)
    return {
        /**
         * Get compute/vm.connect
         * @summary Get compute/vm.connect
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {string} connectId connectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeProjectVmConnectGet(projectId: string, locationId: string, vmId: string, connectId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Connect>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.computeProjectVmConnectGet(projectId, locationId, vmId, connectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List compute/vm.connect
         * @summary List compute/vm.connect
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeProjectVmConnectList(projectId: string, locationId: string, vmId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Connect>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.computeProjectVmConnectList(projectId, locationId, vmId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * action open
         * @summary Open compute/vm.connect
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {string} connectId connectId
         * @param {ComputeProjectVmConnectOpen} computeProjectVmConnectOpen 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeProjectVmConnectOpen(projectId: string, locationId: string, vmId: string, connectId: string, computeProjectVmConnectOpen: ComputeProjectVmConnectOpen, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.computeProjectVmConnectOpen(projectId, locationId, vmId, connectId, computeProjectVmConnectOpen, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create vm
         * @summary Create compute/vm
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {ComputeProjectVmCreate} computeProjectVmCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeProjectVmCreate(projectId: string, locationId: string, computeProjectVmCreate: ComputeProjectVmCreate, xIdempotencyKey?: string, xDryRun?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Vm>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.computeProjectVmCreate(projectId, locationId, computeProjectVmCreate, xIdempotencyKey, xDryRun, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete vm
         * @summary Delete compute/vm
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeProjectVmDelete(projectId: string, locationId: string, vmId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.computeProjectVmDelete(projectId, locationId, vmId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create compute/vm.disk
         * @summary Create compute/vm.disk
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {ComputeProjectVmDiskCreate} computeProjectVmDiskCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeProjectVmDiskCreate(projectId: string, locationId: string, vmId: string, computeProjectVmDiskCreate: ComputeProjectVmDiskCreate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Disk>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.computeProjectVmDiskCreate(projectId, locationId, vmId, computeProjectVmDiskCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List compute/vm.disk
         * @summary List compute/vm.disk
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeProjectVmDiskList(projectId: string, locationId: string, vmId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Disk>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.computeProjectVmDiskList(projectId, locationId, vmId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get compute/vm.event
         * @summary Get compute/vm.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeProjectVmEventGet(projectId: string, locationId: string, vmId: string, eventId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.computeProjectVmEventGet(projectId, locationId, vmId, eventId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List compute/vm.event
         * @summary List compute/vm.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeProjectVmEventList(projectId: string, locationId: string, vmId: string, $limit?: number, $skip?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Event>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.computeProjectVmEventList(projectId, locationId, vmId, $limit, $skip, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * action flavour
         * @summary Flavour compute/vm
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {ComputeProjectVmFlavour} computeProjectVmFlavour 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeProjectVmFlavour(projectId: string, locationId: string, vmId: string, computeProjectVmFlavour: ComputeProjectVmFlavour, xIdempotencyKey?: string, xDryRun?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Vm>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.computeProjectVmFlavour(projectId, locationId, vmId, computeProjectVmFlavour, xIdempotencyKey, xDryRun, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a single vm
         * @summary Get compute/vm
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeProjectVmGet(projectId: string, locationId: string, vmId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Vm>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.computeProjectVmGet(projectId, locationId, vmId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create compute/vm.iso
         * @summary Create compute/vm.iso
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {ComputeProjectVmIsoCreate} computeProjectVmIsoCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeProjectVmIsoCreate(projectId: string, locationId: string, vmId: string, computeProjectVmIsoCreate: ComputeProjectVmIsoCreate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Iso>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.computeProjectVmIsoCreate(projectId, locationId, vmId, computeProjectVmIsoCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List compute/vm.iso
         * @summary List compute/vm.iso
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeProjectVmIsoList(projectId: string, locationId: string, vmId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Iso>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.computeProjectVmIsoList(projectId, locationId, vmId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List vm
         * @summary List compute/vm
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [name] Filter by name
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeProjectVmList(projectId: string, locationId: string, name?: string, tagValue?: string, tagKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Vm>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.computeProjectVmList(projectId, locationId, name, tagValue, tagKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get compute/vm.metric
         * @summary Get compute/vm.metric
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {string} metricId metricId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeProjectVmMetricGet(projectId: string, locationId: string, vmId: string, metricId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Metric>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.computeProjectVmMetricGet(projectId, locationId, vmId, metricId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List compute/vm.metric
         * @summary List compute/vm.metric
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeProjectVmMetricList(projectId: string, locationId: string, vmId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Metric>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.computeProjectVmMetricList(projectId, locationId, vmId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List compute/vm.point
         * @summary List compute/vm.point
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {string} metricId metricId
         * @param {string} [interval] interval
         * @param {string} [timespan] timespan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeProjectVmMetricPointList(projectId: string, locationId: string, vmId: string, metricId: string, interval?: string, timespan?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Point>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.computeProjectVmMetricPointList(projectId, locationId, vmId, metricId, interval, timespan, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * action password_reset
         * @summary Password reset compute/vm
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {ComputeProjectVmPasswordReset} computeProjectVmPasswordReset 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeProjectVmPasswordReset(projectId: string, locationId: string, vmId: string, computeProjectVmPasswordReset: ComputeProjectVmPasswordReset, xIdempotencyKey?: string, xDryRun?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Vm>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.computeProjectVmPasswordReset(projectId, locationId, vmId, computeProjectVmPasswordReset, xIdempotencyKey, xDryRun, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * action restart
         * @summary Restart compute/vm
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeProjectVmRestart(projectId: string, locationId: string, vmId: string, xIdempotencyKey?: string, xDryRun?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Vm>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.computeProjectVmRestart(projectId, locationId, vmId, xIdempotencyKey, xDryRun, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * action serialport
         * @summary Serialport compute/vm
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {ComputeProjectVmSerialport} computeProjectVmSerialport 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeProjectVmSerialport(projectId: string, locationId: string, vmId: string, computeProjectVmSerialport: ComputeProjectVmSerialport, xIdempotencyKey?: string, xDryRun?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.computeProjectVmSerialport(projectId, locationId, vmId, computeProjectVmSerialport, xIdempotencyKey, xDryRun, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get compute/vm.service
         * @summary Get compute/vm.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeProjectVmServiceGet(projectId: string, locationId: string, vmId: string, serviceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceService>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.computeProjectVmServiceGet(projectId, locationId, vmId, serviceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List compute/vm.service
         * @summary List compute/vm.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeProjectVmServiceList(projectId: string, locationId: string, vmId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResourceService>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.computeProjectVmServiceList(projectId, locationId, vmId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * action start
         * @summary Start compute/vm
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeProjectVmStart(projectId: string, locationId: string, vmId: string, xIdempotencyKey?: string, xDryRun?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Vm>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.computeProjectVmStart(projectId, locationId, vmId, xIdempotencyKey, xDryRun, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * action stop
         * @summary Stop compute/vm
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeProjectVmStop(projectId: string, locationId: string, vmId: string, xIdempotencyKey?: string, xDryRun?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Vm>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.computeProjectVmStop(projectId, locationId, vmId, xIdempotencyKey, xDryRun, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create compute/vm.tag
         * @summary Create compute/vm.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeProjectVmTagCreate(projectId: string, locationId: string, vmId: string, tag: Tag, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.computeProjectVmTagCreate(projectId, locationId, vmId, tag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete compute/vm.tag
         * @summary Delete compute/vm.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeProjectVmTagDelete(projectId: string, locationId: string, vmId: string, tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.computeProjectVmTagDelete(projectId, locationId, vmId, tagId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get compute/vm.tag
         * @summary Get compute/vm.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeProjectVmTagGet(projectId: string, locationId: string, vmId: string, tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.computeProjectVmTagGet(projectId, locationId, vmId, tagId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List compute/vm.tag
         * @summary List compute/vm.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeProjectVmTagList(projectId: string, locationId: string, vmId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.computeProjectVmTagList(projectId, locationId, vmId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Replace compute/vm.tag
         * @summary Replace compute/vm.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeProjectVmTagPut(projectId: string, locationId: string, vmId: string, tag: Array<Tag>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.computeProjectVmTagPut(projectId, locationId, vmId, tag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * action turnoff
         * @summary Turnoff compute/vm
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeProjectVmTurnoff(projectId: string, locationId: string, vmId: string, xIdempotencyKey?: string, xDryRun?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Vm>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.computeProjectVmTurnoff(projectId, locationId, vmId, xIdempotencyKey, xDryRun, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns modified vm
         * @summary Update compute/vm
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {ComputeProjectVmUpdate} computeProjectVmUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async computeProjectVmUpdate(projectId: string, locationId: string, vmId: string, computeProjectVmUpdate: ComputeProjectVmUpdate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Vm>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.computeProjectVmUpdate(projectId, locationId, vmId, computeProjectVmUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ComputeProjectVmApi - factory interface
 * @export
 */
export const ComputeProjectVmApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ComputeProjectVmApiFp(configuration)
    return {
        /**
         * Get compute/vm.connect
         * @summary Get compute/vm.connect
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {string} connectId connectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmConnectGet(projectId: string, locationId: string, vmId: string, connectId: string, options?: any): AxiosPromise<Connect> {
            return localVarFp.computeProjectVmConnectGet(projectId, locationId, vmId, connectId, options).then((request) => request(axios, basePath));
        },
        /**
         * List compute/vm.connect
         * @summary List compute/vm.connect
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmConnectList(projectId: string, locationId: string, vmId: string, options?: any): AxiosPromise<Array<Connect>> {
            return localVarFp.computeProjectVmConnectList(projectId, locationId, vmId, options).then((request) => request(axios, basePath));
        },
        /**
         * action open
         * @summary Open compute/vm.connect
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {string} connectId connectId
         * @param {ComputeProjectVmConnectOpen} computeProjectVmConnectOpen 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmConnectOpen(projectId: string, locationId: string, vmId: string, connectId: string, computeProjectVmConnectOpen: ComputeProjectVmConnectOpen, options?: any): AxiosPromise<void> {
            return localVarFp.computeProjectVmConnectOpen(projectId, locationId, vmId, connectId, computeProjectVmConnectOpen, options).then((request) => request(axios, basePath));
        },
        /**
         * Create vm
         * @summary Create compute/vm
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {ComputeProjectVmCreate} computeProjectVmCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmCreate(projectId: string, locationId: string, computeProjectVmCreate: ComputeProjectVmCreate, xIdempotencyKey?: string, xDryRun?: string, options?: any): AxiosPromise<Vm> {
            return localVarFp.computeProjectVmCreate(projectId, locationId, computeProjectVmCreate, xIdempotencyKey, xDryRun, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete vm
         * @summary Delete compute/vm
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmDelete(projectId: string, locationId: string, vmId: string, options?: any): AxiosPromise<void> {
            return localVarFp.computeProjectVmDelete(projectId, locationId, vmId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create compute/vm.disk
         * @summary Create compute/vm.disk
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {ComputeProjectVmDiskCreate} computeProjectVmDiskCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmDiskCreate(projectId: string, locationId: string, vmId: string, computeProjectVmDiskCreate: ComputeProjectVmDiskCreate, options?: any): AxiosPromise<Disk> {
            return localVarFp.computeProjectVmDiskCreate(projectId, locationId, vmId, computeProjectVmDiskCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * List compute/vm.disk
         * @summary List compute/vm.disk
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmDiskList(projectId: string, locationId: string, vmId: string, options?: any): AxiosPromise<Array<Disk>> {
            return localVarFp.computeProjectVmDiskList(projectId, locationId, vmId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get compute/vm.event
         * @summary Get compute/vm.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmEventGet(projectId: string, locationId: string, vmId: string, eventId: string, options?: any): AxiosPromise<Event> {
            return localVarFp.computeProjectVmEventGet(projectId, locationId, vmId, eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * List compute/vm.event
         * @summary List compute/vm.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmEventList(projectId: string, locationId: string, vmId: string, $limit?: number, $skip?: number, options?: any): AxiosPromise<Array<Event>> {
            return localVarFp.computeProjectVmEventList(projectId, locationId, vmId, $limit, $skip, options).then((request) => request(axios, basePath));
        },
        /**
         * action flavour
         * @summary Flavour compute/vm
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {ComputeProjectVmFlavour} computeProjectVmFlavour 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmFlavour(projectId: string, locationId: string, vmId: string, computeProjectVmFlavour: ComputeProjectVmFlavour, xIdempotencyKey?: string, xDryRun?: string, options?: any): AxiosPromise<Vm> {
            return localVarFp.computeProjectVmFlavour(projectId, locationId, vmId, computeProjectVmFlavour, xIdempotencyKey, xDryRun, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single vm
         * @summary Get compute/vm
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmGet(projectId: string, locationId: string, vmId: string, options?: any): AxiosPromise<Vm> {
            return localVarFp.computeProjectVmGet(projectId, locationId, vmId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create compute/vm.iso
         * @summary Create compute/vm.iso
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {ComputeProjectVmIsoCreate} computeProjectVmIsoCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmIsoCreate(projectId: string, locationId: string, vmId: string, computeProjectVmIsoCreate: ComputeProjectVmIsoCreate, options?: any): AxiosPromise<Iso> {
            return localVarFp.computeProjectVmIsoCreate(projectId, locationId, vmId, computeProjectVmIsoCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * List compute/vm.iso
         * @summary List compute/vm.iso
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmIsoList(projectId: string, locationId: string, vmId: string, options?: any): AxiosPromise<Array<Iso>> {
            return localVarFp.computeProjectVmIsoList(projectId, locationId, vmId, options).then((request) => request(axios, basePath));
        },
        /**
         * List vm
         * @summary List compute/vm
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [name] Filter by name
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmList(projectId: string, locationId: string, name?: string, tagValue?: string, tagKey?: string, options?: any): AxiosPromise<Array<Vm>> {
            return localVarFp.computeProjectVmList(projectId, locationId, name, tagValue, tagKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get compute/vm.metric
         * @summary Get compute/vm.metric
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {string} metricId metricId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmMetricGet(projectId: string, locationId: string, vmId: string, metricId: string, options?: any): AxiosPromise<Metric> {
            return localVarFp.computeProjectVmMetricGet(projectId, locationId, vmId, metricId, options).then((request) => request(axios, basePath));
        },
        /**
         * List compute/vm.metric
         * @summary List compute/vm.metric
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmMetricList(projectId: string, locationId: string, vmId: string, options?: any): AxiosPromise<Array<Metric>> {
            return localVarFp.computeProjectVmMetricList(projectId, locationId, vmId, options).then((request) => request(axios, basePath));
        },
        /**
         * List compute/vm.point
         * @summary List compute/vm.point
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {string} metricId metricId
         * @param {string} [interval] interval
         * @param {string} [timespan] timespan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmMetricPointList(projectId: string, locationId: string, vmId: string, metricId: string, interval?: string, timespan?: string, options?: any): AxiosPromise<Array<Point>> {
            return localVarFp.computeProjectVmMetricPointList(projectId, locationId, vmId, metricId, interval, timespan, options).then((request) => request(axios, basePath));
        },
        /**
         * action password_reset
         * @summary Password reset compute/vm
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {ComputeProjectVmPasswordReset} computeProjectVmPasswordReset 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmPasswordReset(projectId: string, locationId: string, vmId: string, computeProjectVmPasswordReset: ComputeProjectVmPasswordReset, xIdempotencyKey?: string, xDryRun?: string, options?: any): AxiosPromise<Vm> {
            return localVarFp.computeProjectVmPasswordReset(projectId, locationId, vmId, computeProjectVmPasswordReset, xIdempotencyKey, xDryRun, options).then((request) => request(axios, basePath));
        },
        /**
         * action restart
         * @summary Restart compute/vm
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmRestart(projectId: string, locationId: string, vmId: string, xIdempotencyKey?: string, xDryRun?: string, options?: any): AxiosPromise<Vm> {
            return localVarFp.computeProjectVmRestart(projectId, locationId, vmId, xIdempotencyKey, xDryRun, options).then((request) => request(axios, basePath));
        },
        /**
         * action serialport
         * @summary Serialport compute/vm
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {ComputeProjectVmSerialport} computeProjectVmSerialport 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmSerialport(projectId: string, locationId: string, vmId: string, computeProjectVmSerialport: ComputeProjectVmSerialport, xIdempotencyKey?: string, xDryRun?: string, options?: any): AxiosPromise<any> {
            return localVarFp.computeProjectVmSerialport(projectId, locationId, vmId, computeProjectVmSerialport, xIdempotencyKey, xDryRun, options).then((request) => request(axios, basePath));
        },
        /**
         * Get compute/vm.service
         * @summary Get compute/vm.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmServiceGet(projectId: string, locationId: string, vmId: string, serviceId: string, options?: any): AxiosPromise<ResourceService> {
            return localVarFp.computeProjectVmServiceGet(projectId, locationId, vmId, serviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * List compute/vm.service
         * @summary List compute/vm.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmServiceList(projectId: string, locationId: string, vmId: string, options?: any): AxiosPromise<Array<ResourceService>> {
            return localVarFp.computeProjectVmServiceList(projectId, locationId, vmId, options).then((request) => request(axios, basePath));
        },
        /**
         * action start
         * @summary Start compute/vm
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmStart(projectId: string, locationId: string, vmId: string, xIdempotencyKey?: string, xDryRun?: string, options?: any): AxiosPromise<Vm> {
            return localVarFp.computeProjectVmStart(projectId, locationId, vmId, xIdempotencyKey, xDryRun, options).then((request) => request(axios, basePath));
        },
        /**
         * action stop
         * @summary Stop compute/vm
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmStop(projectId: string, locationId: string, vmId: string, xIdempotencyKey?: string, xDryRun?: string, options?: any): AxiosPromise<Vm> {
            return localVarFp.computeProjectVmStop(projectId, locationId, vmId, xIdempotencyKey, xDryRun, options).then((request) => request(axios, basePath));
        },
        /**
         * Create compute/vm.tag
         * @summary Create compute/vm.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmTagCreate(projectId: string, locationId: string, vmId: string, tag: Tag, options?: any): AxiosPromise<Tag> {
            return localVarFp.computeProjectVmTagCreate(projectId, locationId, vmId, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete compute/vm.tag
         * @summary Delete compute/vm.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmTagDelete(projectId: string, locationId: string, vmId: string, tagId: string, options?: any): AxiosPromise<void> {
            return localVarFp.computeProjectVmTagDelete(projectId, locationId, vmId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get compute/vm.tag
         * @summary Get compute/vm.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmTagGet(projectId: string, locationId: string, vmId: string, tagId: string, options?: any): AxiosPromise<Tag> {
            return localVarFp.computeProjectVmTagGet(projectId, locationId, vmId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * List compute/vm.tag
         * @summary List compute/vm.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmTagList(projectId: string, locationId: string, vmId: string, options?: any): AxiosPromise<Array<Tag>> {
            return localVarFp.computeProjectVmTagList(projectId, locationId, vmId, options).then((request) => request(axios, basePath));
        },
        /**
         * Replace compute/vm.tag
         * @summary Replace compute/vm.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmTagPut(projectId: string, locationId: string, vmId: string, tag: Array<Tag>, options?: any): AxiosPromise<Array<Tag>> {
            return localVarFp.computeProjectVmTagPut(projectId, locationId, vmId, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * action turnoff
         * @summary Turnoff compute/vm
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmTurnoff(projectId: string, locationId: string, vmId: string, xIdempotencyKey?: string, xDryRun?: string, options?: any): AxiosPromise<Vm> {
            return localVarFp.computeProjectVmTurnoff(projectId, locationId, vmId, xIdempotencyKey, xDryRun, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns modified vm
         * @summary Update compute/vm
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vmId Vm Id
         * @param {ComputeProjectVmUpdate} computeProjectVmUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        computeProjectVmUpdate(projectId: string, locationId: string, vmId: string, computeProjectVmUpdate: ComputeProjectVmUpdate, options?: any): AxiosPromise<Vm> {
            return localVarFp.computeProjectVmUpdate(projectId, locationId, vmId, computeProjectVmUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ComputeProjectVmApi - object-oriented interface
 * @export
 * @class ComputeProjectVmApi
 * @extends {BaseAPI}
 */
export class ComputeProjectVmApi extends BaseAPI {
    /**
     * Get compute/vm.connect
     * @summary Get compute/vm.connect
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} vmId Vm Id
     * @param {string} connectId connectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputeProjectVmApi
     */
    public computeProjectVmConnectGet(projectId: string, locationId: string, vmId: string, connectId: string, options?: any) {
        return ComputeProjectVmApiFp(this.configuration).computeProjectVmConnectGet(projectId, locationId, vmId, connectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List compute/vm.connect
     * @summary List compute/vm.connect
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} vmId Vm Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputeProjectVmApi
     */
    public computeProjectVmConnectList(projectId: string, locationId: string, vmId: string, options?: any) {
        return ComputeProjectVmApiFp(this.configuration).computeProjectVmConnectList(projectId, locationId, vmId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * action open
     * @summary Open compute/vm.connect
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} vmId Vm Id
     * @param {string} connectId connectId
     * @param {ComputeProjectVmConnectOpen} computeProjectVmConnectOpen 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputeProjectVmApi
     */
    public computeProjectVmConnectOpen(projectId: string, locationId: string, vmId: string, connectId: string, computeProjectVmConnectOpen: ComputeProjectVmConnectOpen, options?: any) {
        return ComputeProjectVmApiFp(this.configuration).computeProjectVmConnectOpen(projectId, locationId, vmId, connectId, computeProjectVmConnectOpen, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create vm
     * @summary Create compute/vm
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {ComputeProjectVmCreate} computeProjectVmCreate 
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {string} [xDryRun] Dry run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputeProjectVmApi
     */
    public computeProjectVmCreate(projectId: string, locationId: string, computeProjectVmCreate: ComputeProjectVmCreate, xIdempotencyKey?: string, xDryRun?: string, options?: any) {
        return ComputeProjectVmApiFp(this.configuration).computeProjectVmCreate(projectId, locationId, computeProjectVmCreate, xIdempotencyKey, xDryRun, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete vm
     * @summary Delete compute/vm
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} vmId Vm Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputeProjectVmApi
     */
    public computeProjectVmDelete(projectId: string, locationId: string, vmId: string, options?: any) {
        return ComputeProjectVmApiFp(this.configuration).computeProjectVmDelete(projectId, locationId, vmId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create compute/vm.disk
     * @summary Create compute/vm.disk
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} vmId Vm Id
     * @param {ComputeProjectVmDiskCreate} computeProjectVmDiskCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputeProjectVmApi
     */
    public computeProjectVmDiskCreate(projectId: string, locationId: string, vmId: string, computeProjectVmDiskCreate: ComputeProjectVmDiskCreate, options?: any) {
        return ComputeProjectVmApiFp(this.configuration).computeProjectVmDiskCreate(projectId, locationId, vmId, computeProjectVmDiskCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List compute/vm.disk
     * @summary List compute/vm.disk
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} vmId Vm Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputeProjectVmApi
     */
    public computeProjectVmDiskList(projectId: string, locationId: string, vmId: string, options?: any) {
        return ComputeProjectVmApiFp(this.configuration).computeProjectVmDiskList(projectId, locationId, vmId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get compute/vm.event
     * @summary Get compute/vm.event
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} vmId Vm Id
     * @param {string} eventId eventId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputeProjectVmApi
     */
    public computeProjectVmEventGet(projectId: string, locationId: string, vmId: string, eventId: string, options?: any) {
        return ComputeProjectVmApiFp(this.configuration).computeProjectVmEventGet(projectId, locationId, vmId, eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List compute/vm.event
     * @summary List compute/vm.event
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} vmId Vm Id
     * @param {number} [$limit] $limit
     * @param {number} [$skip] $skip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputeProjectVmApi
     */
    public computeProjectVmEventList(projectId: string, locationId: string, vmId: string, $limit?: number, $skip?: number, options?: any) {
        return ComputeProjectVmApiFp(this.configuration).computeProjectVmEventList(projectId, locationId, vmId, $limit, $skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * action flavour
     * @summary Flavour compute/vm
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} vmId Vm Id
     * @param {ComputeProjectVmFlavour} computeProjectVmFlavour 
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {string} [xDryRun] Dry run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputeProjectVmApi
     */
    public computeProjectVmFlavour(projectId: string, locationId: string, vmId: string, computeProjectVmFlavour: ComputeProjectVmFlavour, xIdempotencyKey?: string, xDryRun?: string, options?: any) {
        return ComputeProjectVmApiFp(this.configuration).computeProjectVmFlavour(projectId, locationId, vmId, computeProjectVmFlavour, xIdempotencyKey, xDryRun, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single vm
     * @summary Get compute/vm
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} vmId Vm Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputeProjectVmApi
     */
    public computeProjectVmGet(projectId: string, locationId: string, vmId: string, options?: any) {
        return ComputeProjectVmApiFp(this.configuration).computeProjectVmGet(projectId, locationId, vmId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create compute/vm.iso
     * @summary Create compute/vm.iso
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} vmId Vm Id
     * @param {ComputeProjectVmIsoCreate} computeProjectVmIsoCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputeProjectVmApi
     */
    public computeProjectVmIsoCreate(projectId: string, locationId: string, vmId: string, computeProjectVmIsoCreate: ComputeProjectVmIsoCreate, options?: any) {
        return ComputeProjectVmApiFp(this.configuration).computeProjectVmIsoCreate(projectId, locationId, vmId, computeProjectVmIsoCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List compute/vm.iso
     * @summary List compute/vm.iso
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} vmId Vm Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputeProjectVmApi
     */
    public computeProjectVmIsoList(projectId: string, locationId: string, vmId: string, options?: any) {
        return ComputeProjectVmApiFp(this.configuration).computeProjectVmIsoList(projectId, locationId, vmId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List vm
     * @summary List compute/vm
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} [name] Filter by name
     * @param {string} [tagValue] Filter by tag.value
     * @param {string} [tagKey] Filter by tag.key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputeProjectVmApi
     */
    public computeProjectVmList(projectId: string, locationId: string, name?: string, tagValue?: string, tagKey?: string, options?: any) {
        return ComputeProjectVmApiFp(this.configuration).computeProjectVmList(projectId, locationId, name, tagValue, tagKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get compute/vm.metric
     * @summary Get compute/vm.metric
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} vmId Vm Id
     * @param {string} metricId metricId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputeProjectVmApi
     */
    public computeProjectVmMetricGet(projectId: string, locationId: string, vmId: string, metricId: string, options?: any) {
        return ComputeProjectVmApiFp(this.configuration).computeProjectVmMetricGet(projectId, locationId, vmId, metricId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List compute/vm.metric
     * @summary List compute/vm.metric
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} vmId Vm Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputeProjectVmApi
     */
    public computeProjectVmMetricList(projectId: string, locationId: string, vmId: string, options?: any) {
        return ComputeProjectVmApiFp(this.configuration).computeProjectVmMetricList(projectId, locationId, vmId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List compute/vm.point
     * @summary List compute/vm.point
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} vmId Vm Id
     * @param {string} metricId metricId
     * @param {string} [interval] interval
     * @param {string} [timespan] timespan
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputeProjectVmApi
     */
    public computeProjectVmMetricPointList(projectId: string, locationId: string, vmId: string, metricId: string, interval?: string, timespan?: string, options?: any) {
        return ComputeProjectVmApiFp(this.configuration).computeProjectVmMetricPointList(projectId, locationId, vmId, metricId, interval, timespan, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * action password_reset
     * @summary Password reset compute/vm
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} vmId Vm Id
     * @param {ComputeProjectVmPasswordReset} computeProjectVmPasswordReset 
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {string} [xDryRun] Dry run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputeProjectVmApi
     */
    public computeProjectVmPasswordReset(projectId: string, locationId: string, vmId: string, computeProjectVmPasswordReset: ComputeProjectVmPasswordReset, xIdempotencyKey?: string, xDryRun?: string, options?: any) {
        return ComputeProjectVmApiFp(this.configuration).computeProjectVmPasswordReset(projectId, locationId, vmId, computeProjectVmPasswordReset, xIdempotencyKey, xDryRun, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * action restart
     * @summary Restart compute/vm
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} vmId Vm Id
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {string} [xDryRun] Dry run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputeProjectVmApi
     */
    public computeProjectVmRestart(projectId: string, locationId: string, vmId: string, xIdempotencyKey?: string, xDryRun?: string, options?: any) {
        return ComputeProjectVmApiFp(this.configuration).computeProjectVmRestart(projectId, locationId, vmId, xIdempotencyKey, xDryRun, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * action serialport
     * @summary Serialport compute/vm
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} vmId Vm Id
     * @param {ComputeProjectVmSerialport} computeProjectVmSerialport 
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {string} [xDryRun] Dry run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputeProjectVmApi
     */
    public computeProjectVmSerialport(projectId: string, locationId: string, vmId: string, computeProjectVmSerialport: ComputeProjectVmSerialport, xIdempotencyKey?: string, xDryRun?: string, options?: any) {
        return ComputeProjectVmApiFp(this.configuration).computeProjectVmSerialport(projectId, locationId, vmId, computeProjectVmSerialport, xIdempotencyKey, xDryRun, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get compute/vm.service
     * @summary Get compute/vm.service
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} vmId Vm Id
     * @param {string} serviceId serviceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputeProjectVmApi
     */
    public computeProjectVmServiceGet(projectId: string, locationId: string, vmId: string, serviceId: string, options?: any) {
        return ComputeProjectVmApiFp(this.configuration).computeProjectVmServiceGet(projectId, locationId, vmId, serviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List compute/vm.service
     * @summary List compute/vm.service
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} vmId Vm Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputeProjectVmApi
     */
    public computeProjectVmServiceList(projectId: string, locationId: string, vmId: string, options?: any) {
        return ComputeProjectVmApiFp(this.configuration).computeProjectVmServiceList(projectId, locationId, vmId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * action start
     * @summary Start compute/vm
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} vmId Vm Id
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {string} [xDryRun] Dry run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputeProjectVmApi
     */
    public computeProjectVmStart(projectId: string, locationId: string, vmId: string, xIdempotencyKey?: string, xDryRun?: string, options?: any) {
        return ComputeProjectVmApiFp(this.configuration).computeProjectVmStart(projectId, locationId, vmId, xIdempotencyKey, xDryRun, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * action stop
     * @summary Stop compute/vm
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} vmId Vm Id
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {string} [xDryRun] Dry run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputeProjectVmApi
     */
    public computeProjectVmStop(projectId: string, locationId: string, vmId: string, xIdempotencyKey?: string, xDryRun?: string, options?: any) {
        return ComputeProjectVmApiFp(this.configuration).computeProjectVmStop(projectId, locationId, vmId, xIdempotencyKey, xDryRun, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create compute/vm.tag
     * @summary Create compute/vm.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} vmId Vm Id
     * @param {Tag} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputeProjectVmApi
     */
    public computeProjectVmTagCreate(projectId: string, locationId: string, vmId: string, tag: Tag, options?: any) {
        return ComputeProjectVmApiFp(this.configuration).computeProjectVmTagCreate(projectId, locationId, vmId, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete compute/vm.tag
     * @summary Delete compute/vm.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} vmId Vm Id
     * @param {string} tagId tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputeProjectVmApi
     */
    public computeProjectVmTagDelete(projectId: string, locationId: string, vmId: string, tagId: string, options?: any) {
        return ComputeProjectVmApiFp(this.configuration).computeProjectVmTagDelete(projectId, locationId, vmId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get compute/vm.tag
     * @summary Get compute/vm.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} vmId Vm Id
     * @param {string} tagId tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputeProjectVmApi
     */
    public computeProjectVmTagGet(projectId: string, locationId: string, vmId: string, tagId: string, options?: any) {
        return ComputeProjectVmApiFp(this.configuration).computeProjectVmTagGet(projectId, locationId, vmId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List compute/vm.tag
     * @summary List compute/vm.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} vmId Vm Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputeProjectVmApi
     */
    public computeProjectVmTagList(projectId: string, locationId: string, vmId: string, options?: any) {
        return ComputeProjectVmApiFp(this.configuration).computeProjectVmTagList(projectId, locationId, vmId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replace compute/vm.tag
     * @summary Replace compute/vm.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} vmId Vm Id
     * @param {Array<Tag>} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputeProjectVmApi
     */
    public computeProjectVmTagPut(projectId: string, locationId: string, vmId: string, tag: Array<Tag>, options?: any) {
        return ComputeProjectVmApiFp(this.configuration).computeProjectVmTagPut(projectId, locationId, vmId, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * action turnoff
     * @summary Turnoff compute/vm
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} vmId Vm Id
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {string} [xDryRun] Dry run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputeProjectVmApi
     */
    public computeProjectVmTurnoff(projectId: string, locationId: string, vmId: string, xIdempotencyKey?: string, xDryRun?: string, options?: any) {
        return ComputeProjectVmApiFp(this.configuration).computeProjectVmTurnoff(projectId, locationId, vmId, xIdempotencyKey, xDryRun, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns modified vm
     * @summary Update compute/vm
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} vmId Vm Id
     * @param {ComputeProjectVmUpdate} computeProjectVmUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ComputeProjectVmApi
     */
    public computeProjectVmUpdate(projectId: string, locationId: string, vmId: string, computeProjectVmUpdate: ComputeProjectVmUpdate, options?: any) {
        return ComputeProjectVmApiFp(this.configuration).computeProjectVmUpdate(projectId, locationId, vmId, computeProjectVmUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ContainerProjectRegistryApi - axios parameter creator
 * @export
 */
export const ContainerProjectRegistryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create registry
         * @summary Create container/registry
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {ContainerProjectRegistryCreate} containerProjectRegistryCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryCreate: async (projectId: string, locationId: string, containerProjectRegistryCreate: ContainerProjectRegistryCreate, xIdempotencyKey?: string, xDryRun?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('containerProjectRegistryCreate', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('containerProjectRegistryCreate', 'locationId', locationId)
            // verify required parameter 'containerProjectRegistryCreate' is not null or undefined
            assertParamExists('containerProjectRegistryCreate', 'containerProjectRegistryCreate', containerProjectRegistryCreate)
            const localVarPath = `/container/{locationId}/project/{projectId}/registry`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }

            if (xDryRun !== undefined && xDryRun !== null) {
                localVarHeaderParameter['x-dry-run'] = String(xDryRun);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(containerProjectRegistryCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create container/registry.credential
         * @summary Create container/registry.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {RegistryCredential} registryCredential 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryCredentialCreate: async (projectId: string, locationId: string, registryId: string, registryCredential: RegistryCredential, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('containerProjectRegistryCredentialCreate', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('containerProjectRegistryCredentialCreate', 'locationId', locationId)
            // verify required parameter 'registryId' is not null or undefined
            assertParamExists('containerProjectRegistryCredentialCreate', 'registryId', registryId)
            // verify required parameter 'registryCredential' is not null or undefined
            assertParamExists('containerProjectRegistryCredentialCreate', 'registryCredential', registryCredential)
            const localVarPath = `/container/{locationId}/project/{projectId}/registry/{registryId}/credential`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"registryId"}}`, encodeURIComponent(String(registryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registryCredential, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete container/registry.credential
         * @summary Delete container/registry.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {string} credentialId credentialId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryCredentialDelete: async (projectId: string, locationId: string, registryId: string, credentialId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('containerProjectRegistryCredentialDelete', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('containerProjectRegistryCredentialDelete', 'locationId', locationId)
            // verify required parameter 'registryId' is not null or undefined
            assertParamExists('containerProjectRegistryCredentialDelete', 'registryId', registryId)
            // verify required parameter 'credentialId' is not null or undefined
            assertParamExists('containerProjectRegistryCredentialDelete', 'credentialId', credentialId)
            const localVarPath = `/container/{locationId}/project/{projectId}/registry/{registryId}/credential/{credentialId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"registryId"}}`, encodeURIComponent(String(registryId)))
                .replace(`{${"credentialId"}}`, encodeURIComponent(String(credentialId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get container/registry.credential
         * @summary Get container/registry.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {string} credentialId credentialId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryCredentialGet: async (projectId: string, locationId: string, registryId: string, credentialId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('containerProjectRegistryCredentialGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('containerProjectRegistryCredentialGet', 'locationId', locationId)
            // verify required parameter 'registryId' is not null or undefined
            assertParamExists('containerProjectRegistryCredentialGet', 'registryId', registryId)
            // verify required parameter 'credentialId' is not null or undefined
            assertParamExists('containerProjectRegistryCredentialGet', 'credentialId', credentialId)
            const localVarPath = `/container/{locationId}/project/{projectId}/registry/{registryId}/credential/{credentialId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"registryId"}}`, encodeURIComponent(String(registryId)))
                .replace(`{${"credentialId"}}`, encodeURIComponent(String(credentialId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List container/registry.credential
         * @summary List container/registry.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryCredentialList: async (projectId: string, locationId: string, registryId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('containerProjectRegistryCredentialList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('containerProjectRegistryCredentialList', 'locationId', locationId)
            // verify required parameter 'registryId' is not null or undefined
            assertParamExists('containerProjectRegistryCredentialList', 'registryId', registryId)
            const localVarPath = `/container/{locationId}/project/{projectId}/registry/{registryId}/credential`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"registryId"}}`, encodeURIComponent(String(registryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update container/registry.credential
         * @summary Update container/registry.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {string} credentialId credentialId
         * @param {ContainerProjectRegistryCredentialPatch} containerProjectRegistryCredentialPatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryCredentialPatch: async (projectId: string, locationId: string, registryId: string, credentialId: string, containerProjectRegistryCredentialPatch: ContainerProjectRegistryCredentialPatch, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('containerProjectRegistryCredentialPatch', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('containerProjectRegistryCredentialPatch', 'locationId', locationId)
            // verify required parameter 'registryId' is not null or undefined
            assertParamExists('containerProjectRegistryCredentialPatch', 'registryId', registryId)
            // verify required parameter 'credentialId' is not null or undefined
            assertParamExists('containerProjectRegistryCredentialPatch', 'credentialId', credentialId)
            // verify required parameter 'containerProjectRegistryCredentialPatch' is not null or undefined
            assertParamExists('containerProjectRegistryCredentialPatch', 'containerProjectRegistryCredentialPatch', containerProjectRegistryCredentialPatch)
            const localVarPath = `/container/{locationId}/project/{projectId}/registry/{registryId}/credential/{credentialId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"registryId"}}`, encodeURIComponent(String(registryId)))
                .replace(`{${"credentialId"}}`, encodeURIComponent(String(credentialId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(containerProjectRegistryCredentialPatch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete registry
         * @summary Delete container/registry
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryDelete: async (projectId: string, locationId: string, registryId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('containerProjectRegistryDelete', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('containerProjectRegistryDelete', 'locationId', locationId)
            // verify required parameter 'registryId' is not null or undefined
            assertParamExists('containerProjectRegistryDelete', 'registryId', registryId)
            const localVarPath = `/container/{locationId}/project/{projectId}/registry/{registryId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"registryId"}}`, encodeURIComponent(String(registryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create container/registry.domain
         * @summary Create container/registry.domain
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {Domain} domain 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryDomainCreate: async (projectId: string, locationId: string, registryId: string, domain: Domain, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('containerProjectRegistryDomainCreate', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('containerProjectRegistryDomainCreate', 'locationId', locationId)
            // verify required parameter 'registryId' is not null or undefined
            assertParamExists('containerProjectRegistryDomainCreate', 'registryId', registryId)
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('containerProjectRegistryDomainCreate', 'domain', domain)
            const localVarPath = `/container/{locationId}/project/{projectId}/registry/{registryId}/domain`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"registryId"}}`, encodeURIComponent(String(registryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(domain, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete container/registry.domain
         * @summary Delete container/registry.domain
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {string} domainId domainId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryDomainDelete: async (projectId: string, locationId: string, registryId: string, domainId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('containerProjectRegistryDomainDelete', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('containerProjectRegistryDomainDelete', 'locationId', locationId)
            // verify required parameter 'registryId' is not null or undefined
            assertParamExists('containerProjectRegistryDomainDelete', 'registryId', registryId)
            // verify required parameter 'domainId' is not null or undefined
            assertParamExists('containerProjectRegistryDomainDelete', 'domainId', domainId)
            const localVarPath = `/container/{locationId}/project/{projectId}/registry/{registryId}/domain/{domainId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"registryId"}}`, encodeURIComponent(String(registryId)))
                .replace(`{${"domainId"}}`, encodeURIComponent(String(domainId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get container/registry.domain
         * @summary Get container/registry.domain
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {string} domainId domainId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryDomainGet: async (projectId: string, locationId: string, registryId: string, domainId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('containerProjectRegistryDomainGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('containerProjectRegistryDomainGet', 'locationId', locationId)
            // verify required parameter 'registryId' is not null or undefined
            assertParamExists('containerProjectRegistryDomainGet', 'registryId', registryId)
            // verify required parameter 'domainId' is not null or undefined
            assertParamExists('containerProjectRegistryDomainGet', 'domainId', domainId)
            const localVarPath = `/container/{locationId}/project/{projectId}/registry/{registryId}/domain/{domainId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"registryId"}}`, encodeURIComponent(String(registryId)))
                .replace(`{${"domainId"}}`, encodeURIComponent(String(domainId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List container/registry.domain
         * @summary List container/registry.domain
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryDomainList: async (projectId: string, locationId: string, registryId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('containerProjectRegistryDomainList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('containerProjectRegistryDomainList', 'locationId', locationId)
            // verify required parameter 'registryId' is not null or undefined
            assertParamExists('containerProjectRegistryDomainList', 'registryId', registryId)
            const localVarPath = `/container/{locationId}/project/{projectId}/registry/{registryId}/domain`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"registryId"}}`, encodeURIComponent(String(registryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get container/registry.event
         * @summary Get container/registry.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryEventGet: async (projectId: string, locationId: string, registryId: string, eventId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('containerProjectRegistryEventGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('containerProjectRegistryEventGet', 'locationId', locationId)
            // verify required parameter 'registryId' is not null or undefined
            assertParamExists('containerProjectRegistryEventGet', 'registryId', registryId)
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('containerProjectRegistryEventGet', 'eventId', eventId)
            const localVarPath = `/container/{locationId}/project/{projectId}/registry/{registryId}/event/{eventId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"registryId"}}`, encodeURIComponent(String(registryId)))
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List container/registry.event
         * @summary List container/registry.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryEventList: async (projectId: string, locationId: string, registryId: string, $limit?: number, $skip?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('containerProjectRegistryEventList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('containerProjectRegistryEventList', 'locationId', locationId)
            // verify required parameter 'registryId' is not null or undefined
            assertParamExists('containerProjectRegistryEventList', 'registryId', registryId)
            const localVarPath = `/container/{locationId}/project/{projectId}/registry/{registryId}/event`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"registryId"}}`, encodeURIComponent(String(registryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if ($limit !== undefined) {
                localVarQueryParameter['$limit'] = $limit;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single registry
         * @summary Get container/registry
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryGet: async (projectId: string, locationId: string, registryId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('containerProjectRegistryGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('containerProjectRegistryGet', 'locationId', locationId)
            // verify required parameter 'registryId' is not null or undefined
            assertParamExists('containerProjectRegistryGet', 'registryId', registryId)
            const localVarPath = `/container/{locationId}/project/{projectId}/registry/{registryId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"registryId"}}`, encodeURIComponent(String(registryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List registry
         * @summary List container/registry
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [name] Filter by name
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryList: async (projectId: string, locationId: string, name?: string, tagValue?: string, tagKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('containerProjectRegistryList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('containerProjectRegistryList', 'locationId', locationId)
            const localVarPath = `/container/{locationId}/project/{projectId}/registry`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (tagValue !== undefined) {
                localVarQueryParameter['tag.value'] = tagValue;
            }

            if (tagKey !== undefined) {
                localVarQueryParameter['tag.key'] = tagKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get container/registry.repository
         * @summary Get container/registry.repository
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {string} repositoryId repositoryId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryRepositoryGet: async (projectId: string, locationId: string, registryId: string, repositoryId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('containerProjectRegistryRepositoryGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('containerProjectRegistryRepositoryGet', 'locationId', locationId)
            // verify required parameter 'registryId' is not null or undefined
            assertParamExists('containerProjectRegistryRepositoryGet', 'registryId', registryId)
            // verify required parameter 'repositoryId' is not null or undefined
            assertParamExists('containerProjectRegistryRepositoryGet', 'repositoryId', repositoryId)
            const localVarPath = `/container/{locationId}/project/{projectId}/registry/{registryId}/repository/{repositoryId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"registryId"}}`, encodeURIComponent(String(registryId)))
                .replace(`{${"repositoryId"}}`, encodeURIComponent(String(repositoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete container/registry.image
         * @summary Delete container/registry.image
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {string} repositoryId repositoryId
         * @param {string} imageId imageId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryRepositoryImageDelete: async (projectId: string, locationId: string, registryId: string, repositoryId: string, imageId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('containerProjectRegistryRepositoryImageDelete', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('containerProjectRegistryRepositoryImageDelete', 'locationId', locationId)
            // verify required parameter 'registryId' is not null or undefined
            assertParamExists('containerProjectRegistryRepositoryImageDelete', 'registryId', registryId)
            // verify required parameter 'repositoryId' is not null or undefined
            assertParamExists('containerProjectRegistryRepositoryImageDelete', 'repositoryId', repositoryId)
            // verify required parameter 'imageId' is not null or undefined
            assertParamExists('containerProjectRegistryRepositoryImageDelete', 'imageId', imageId)
            const localVarPath = `/container/{locationId}/project/{projectId}/registry/{registryId}/repository/{repositoryId}/image/{imageId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"registryId"}}`, encodeURIComponent(String(registryId)))
                .replace(`{${"repositoryId"}}`, encodeURIComponent(String(repositoryId)))
                .replace(`{${"imageId"}}`, encodeURIComponent(String(imageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get container/registry.image
         * @summary Get container/registry.image
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {string} repositoryId repositoryId
         * @param {string} imageId imageId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryRepositoryImageGet: async (projectId: string, locationId: string, registryId: string, repositoryId: string, imageId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('containerProjectRegistryRepositoryImageGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('containerProjectRegistryRepositoryImageGet', 'locationId', locationId)
            // verify required parameter 'registryId' is not null or undefined
            assertParamExists('containerProjectRegistryRepositoryImageGet', 'registryId', registryId)
            // verify required parameter 'repositoryId' is not null or undefined
            assertParamExists('containerProjectRegistryRepositoryImageGet', 'repositoryId', repositoryId)
            // verify required parameter 'imageId' is not null or undefined
            assertParamExists('containerProjectRegistryRepositoryImageGet', 'imageId', imageId)
            const localVarPath = `/container/{locationId}/project/{projectId}/registry/{registryId}/repository/{repositoryId}/image/{imageId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"registryId"}}`, encodeURIComponent(String(registryId)))
                .replace(`{${"repositoryId"}}`, encodeURIComponent(String(repositoryId)))
                .replace(`{${"imageId"}}`, encodeURIComponent(String(imageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List container/registry.image
         * @summary List container/registry.image
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {string} repositoryId repositoryId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryRepositoryImageList: async (projectId: string, locationId: string, registryId: string, repositoryId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('containerProjectRegistryRepositoryImageList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('containerProjectRegistryRepositoryImageList', 'locationId', locationId)
            // verify required parameter 'registryId' is not null or undefined
            assertParamExists('containerProjectRegistryRepositoryImageList', 'registryId', registryId)
            // verify required parameter 'repositoryId' is not null or undefined
            assertParamExists('containerProjectRegistryRepositoryImageList', 'repositoryId', repositoryId)
            const localVarPath = `/container/{locationId}/project/{projectId}/registry/{registryId}/repository/{repositoryId}/image`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"registryId"}}`, encodeURIComponent(String(registryId)))
                .replace(`{${"repositoryId"}}`, encodeURIComponent(String(repositoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List container/registry.repository
         * @summary List container/registry.repository
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryRepositoryList: async (projectId: string, locationId: string, registryId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('containerProjectRegistryRepositoryList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('containerProjectRegistryRepositoryList', 'locationId', locationId)
            // verify required parameter 'registryId' is not null or undefined
            assertParamExists('containerProjectRegistryRepositoryList', 'registryId', registryId)
            const localVarPath = `/container/{locationId}/project/{projectId}/registry/{registryId}/repository`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"registryId"}}`, encodeURIComponent(String(registryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get container/registry.service
         * @summary Get container/registry.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryServiceGet: async (projectId: string, locationId: string, registryId: string, serviceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('containerProjectRegistryServiceGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('containerProjectRegistryServiceGet', 'locationId', locationId)
            // verify required parameter 'registryId' is not null or undefined
            assertParamExists('containerProjectRegistryServiceGet', 'registryId', registryId)
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('containerProjectRegistryServiceGet', 'serviceId', serviceId)
            const localVarPath = `/container/{locationId}/project/{projectId}/registry/{registryId}/service/{serviceId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"registryId"}}`, encodeURIComponent(String(registryId)))
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List container/registry.service
         * @summary List container/registry.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryServiceList: async (projectId: string, locationId: string, registryId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('containerProjectRegistryServiceList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('containerProjectRegistryServiceList', 'locationId', locationId)
            // verify required parameter 'registryId' is not null or undefined
            assertParamExists('containerProjectRegistryServiceList', 'registryId', registryId)
            const localVarPath = `/container/{locationId}/project/{projectId}/registry/{registryId}/service`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"registryId"}}`, encodeURIComponent(String(registryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * action start
         * @summary Start container/registry
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryStart: async (projectId: string, locationId: string, registryId: string, xIdempotencyKey?: string, xDryRun?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('containerProjectRegistryStart', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('containerProjectRegistryStart', 'locationId', locationId)
            // verify required parameter 'registryId' is not null or undefined
            assertParamExists('containerProjectRegistryStart', 'registryId', registryId)
            const localVarPath = `/container/{locationId}/project/{projectId}/registry/{registryId}/actions/start`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"registryId"}}`, encodeURIComponent(String(registryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }

            if (xDryRun !== undefined && xDryRun !== null) {
                localVarHeaderParameter['x-dry-run'] = String(xDryRun);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * action stop
         * @summary Stop container/registry
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryStop: async (projectId: string, locationId: string, registryId: string, xIdempotencyKey?: string, xDryRun?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('containerProjectRegistryStop', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('containerProjectRegistryStop', 'locationId', locationId)
            // verify required parameter 'registryId' is not null or undefined
            assertParamExists('containerProjectRegistryStop', 'registryId', registryId)
            const localVarPath = `/container/{locationId}/project/{projectId}/registry/{registryId}/actions/stop`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"registryId"}}`, encodeURIComponent(String(registryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }

            if (xDryRun !== undefined && xDryRun !== null) {
                localVarHeaderParameter['x-dry-run'] = String(xDryRun);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create container/registry.tag
         * @summary Create container/registry.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryTagCreate: async (projectId: string, locationId: string, registryId: string, tag: Tag, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('containerProjectRegistryTagCreate', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('containerProjectRegistryTagCreate', 'locationId', locationId)
            // verify required parameter 'registryId' is not null or undefined
            assertParamExists('containerProjectRegistryTagCreate', 'registryId', registryId)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('containerProjectRegistryTagCreate', 'tag', tag)
            const localVarPath = `/container/{locationId}/project/{projectId}/registry/{registryId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"registryId"}}`, encodeURIComponent(String(registryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tag, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete container/registry.tag
         * @summary Delete container/registry.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryTagDelete: async (projectId: string, locationId: string, registryId: string, tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('containerProjectRegistryTagDelete', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('containerProjectRegistryTagDelete', 'locationId', locationId)
            // verify required parameter 'registryId' is not null or undefined
            assertParamExists('containerProjectRegistryTagDelete', 'registryId', registryId)
            // verify required parameter 'tagId' is not null or undefined
            assertParamExists('containerProjectRegistryTagDelete', 'tagId', tagId)
            const localVarPath = `/container/{locationId}/project/{projectId}/registry/{registryId}/tag/{tagId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"registryId"}}`, encodeURIComponent(String(registryId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get container/registry.tag
         * @summary Get container/registry.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryTagGet: async (projectId: string, locationId: string, registryId: string, tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('containerProjectRegistryTagGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('containerProjectRegistryTagGet', 'locationId', locationId)
            // verify required parameter 'registryId' is not null or undefined
            assertParamExists('containerProjectRegistryTagGet', 'registryId', registryId)
            // verify required parameter 'tagId' is not null or undefined
            assertParamExists('containerProjectRegistryTagGet', 'tagId', tagId)
            const localVarPath = `/container/{locationId}/project/{projectId}/registry/{registryId}/tag/{tagId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"registryId"}}`, encodeURIComponent(String(registryId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List container/registry.tag
         * @summary List container/registry.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryTagList: async (projectId: string, locationId: string, registryId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('containerProjectRegistryTagList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('containerProjectRegistryTagList', 'locationId', locationId)
            // verify required parameter 'registryId' is not null or undefined
            assertParamExists('containerProjectRegistryTagList', 'registryId', registryId)
            const localVarPath = `/container/{locationId}/project/{projectId}/registry/{registryId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"registryId"}}`, encodeURIComponent(String(registryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replace container/registry.tag
         * @summary Replace container/registry.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryTagPut: async (projectId: string, locationId: string, registryId: string, tag: Array<Tag>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('containerProjectRegistryTagPut', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('containerProjectRegistryTagPut', 'locationId', locationId)
            // verify required parameter 'registryId' is not null or undefined
            assertParamExists('containerProjectRegistryTagPut', 'registryId', registryId)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('containerProjectRegistryTagPut', 'tag', tag)
            const localVarPath = `/container/{locationId}/project/{projectId}/registry/{registryId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"registryId"}}`, encodeURIComponent(String(registryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tag, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * action transfer
         * @summary Transfer container/registry
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {ContainerProjectRegistryTransfer} containerProjectRegistryTransfer 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryTransfer: async (projectId: string, locationId: string, registryId: string, containerProjectRegistryTransfer: ContainerProjectRegistryTransfer, xIdempotencyKey?: string, xDryRun?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('containerProjectRegistryTransfer', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('containerProjectRegistryTransfer', 'locationId', locationId)
            // verify required parameter 'registryId' is not null or undefined
            assertParamExists('containerProjectRegistryTransfer', 'registryId', registryId)
            // verify required parameter 'containerProjectRegistryTransfer' is not null or undefined
            assertParamExists('containerProjectRegistryTransfer', 'containerProjectRegistryTransfer', containerProjectRegistryTransfer)
            const localVarPath = `/container/{locationId}/project/{projectId}/registry/{registryId}/actions/transfer`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"registryId"}}`, encodeURIComponent(String(registryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }

            if (xDryRun !== undefined && xDryRun !== null) {
                localVarHeaderParameter['x-dry-run'] = String(xDryRun);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(containerProjectRegistryTransfer, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns modified registry
         * @summary Update container/registry
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {ContainerProjectRegistryUpdate} containerProjectRegistryUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryUpdate: async (projectId: string, locationId: string, registryId: string, containerProjectRegistryUpdate: ContainerProjectRegistryUpdate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('containerProjectRegistryUpdate', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('containerProjectRegistryUpdate', 'locationId', locationId)
            // verify required parameter 'registryId' is not null or undefined
            assertParamExists('containerProjectRegistryUpdate', 'registryId', registryId)
            // verify required parameter 'containerProjectRegistryUpdate' is not null or undefined
            assertParamExists('containerProjectRegistryUpdate', 'containerProjectRegistryUpdate', containerProjectRegistryUpdate)
            const localVarPath = `/container/{locationId}/project/{projectId}/registry/{registryId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"registryId"}}`, encodeURIComponent(String(registryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(containerProjectRegistryUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContainerProjectRegistryApi - functional programming interface
 * @export
 */
export const ContainerProjectRegistryApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ContainerProjectRegistryApiAxiosParamCreator(configuration)
    return {
        /**
         * Create registry
         * @summary Create container/registry
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {ContainerProjectRegistryCreate} containerProjectRegistryCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async containerProjectRegistryCreate(projectId: string, locationId: string, containerProjectRegistryCreate: ContainerProjectRegistryCreate, xIdempotencyKey?: string, xDryRun?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Registry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.containerProjectRegistryCreate(projectId, locationId, containerProjectRegistryCreate, xIdempotencyKey, xDryRun, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create container/registry.credential
         * @summary Create container/registry.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {RegistryCredential} registryCredential 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async containerProjectRegistryCredentialCreate(projectId: string, locationId: string, registryId: string, registryCredential: RegistryCredential, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegistryCredential>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.containerProjectRegistryCredentialCreate(projectId, locationId, registryId, registryCredential, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete container/registry.credential
         * @summary Delete container/registry.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {string} credentialId credentialId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async containerProjectRegistryCredentialDelete(projectId: string, locationId: string, registryId: string, credentialId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Registry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.containerProjectRegistryCredentialDelete(projectId, locationId, registryId, credentialId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get container/registry.credential
         * @summary Get container/registry.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {string} credentialId credentialId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async containerProjectRegistryCredentialGet(projectId: string, locationId: string, registryId: string, credentialId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegistryCredential>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.containerProjectRegistryCredentialGet(projectId, locationId, registryId, credentialId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List container/registry.credential
         * @summary List container/registry.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async containerProjectRegistryCredentialList(projectId: string, locationId: string, registryId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RegistryCredential>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.containerProjectRegistryCredentialList(projectId, locationId, registryId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update container/registry.credential
         * @summary Update container/registry.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {string} credentialId credentialId
         * @param {ContainerProjectRegistryCredentialPatch} containerProjectRegistryCredentialPatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async containerProjectRegistryCredentialPatch(projectId: string, locationId: string, registryId: string, credentialId: string, containerProjectRegistryCredentialPatch: ContainerProjectRegistryCredentialPatch, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegistryCredential>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.containerProjectRegistryCredentialPatch(projectId, locationId, registryId, credentialId, containerProjectRegistryCredentialPatch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete registry
         * @summary Delete container/registry
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async containerProjectRegistryDelete(projectId: string, locationId: string, registryId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.containerProjectRegistryDelete(projectId, locationId, registryId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create container/registry.domain
         * @summary Create container/registry.domain
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {Domain} domain 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async containerProjectRegistryDomainCreate(projectId: string, locationId: string, registryId: string, domain: Domain, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Domain>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.containerProjectRegistryDomainCreate(projectId, locationId, registryId, domain, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete container/registry.domain
         * @summary Delete container/registry.domain
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {string} domainId domainId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async containerProjectRegistryDomainDelete(projectId: string, locationId: string, registryId: string, domainId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.containerProjectRegistryDomainDelete(projectId, locationId, registryId, domainId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get container/registry.domain
         * @summary Get container/registry.domain
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {string} domainId domainId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async containerProjectRegistryDomainGet(projectId: string, locationId: string, registryId: string, domainId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Domain>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.containerProjectRegistryDomainGet(projectId, locationId, registryId, domainId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List container/registry.domain
         * @summary List container/registry.domain
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async containerProjectRegistryDomainList(projectId: string, locationId: string, registryId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Domain>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.containerProjectRegistryDomainList(projectId, locationId, registryId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get container/registry.event
         * @summary Get container/registry.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async containerProjectRegistryEventGet(projectId: string, locationId: string, registryId: string, eventId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.containerProjectRegistryEventGet(projectId, locationId, registryId, eventId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List container/registry.event
         * @summary List container/registry.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async containerProjectRegistryEventList(projectId: string, locationId: string, registryId: string, $limit?: number, $skip?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Event>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.containerProjectRegistryEventList(projectId, locationId, registryId, $limit, $skip, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a single registry
         * @summary Get container/registry
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async containerProjectRegistryGet(projectId: string, locationId: string, registryId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Registry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.containerProjectRegistryGet(projectId, locationId, registryId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List registry
         * @summary List container/registry
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [name] Filter by name
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async containerProjectRegistryList(projectId: string, locationId: string, name?: string, tagValue?: string, tagKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Registry>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.containerProjectRegistryList(projectId, locationId, name, tagValue, tagKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get container/registry.repository
         * @summary Get container/registry.repository
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {string} repositoryId repositoryId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async containerProjectRegistryRepositoryGet(projectId: string, locationId: string, registryId: string, repositoryId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerRepository>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.containerProjectRegistryRepositoryGet(projectId, locationId, registryId, repositoryId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete container/registry.image
         * @summary Delete container/registry.image
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {string} repositoryId repositoryId
         * @param {string} imageId imageId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async containerProjectRegistryRepositoryImageDelete(projectId: string, locationId: string, registryId: string, repositoryId: string, imageId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.containerProjectRegistryRepositoryImageDelete(projectId, locationId, registryId, repositoryId, imageId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get container/registry.image
         * @summary Get container/registry.image
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {string} repositoryId repositoryId
         * @param {string} imageId imageId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async containerProjectRegistryRepositoryImageGet(projectId: string, locationId: string, registryId: string, repositoryId: string, imageId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContainerImage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.containerProjectRegistryRepositoryImageGet(projectId, locationId, registryId, repositoryId, imageId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List container/registry.image
         * @summary List container/registry.image
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {string} repositoryId repositoryId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async containerProjectRegistryRepositoryImageList(projectId: string, locationId: string, registryId: string, repositoryId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ContainerImage>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.containerProjectRegistryRepositoryImageList(projectId, locationId, registryId, repositoryId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List container/registry.repository
         * @summary List container/registry.repository
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async containerProjectRegistryRepositoryList(projectId: string, locationId: string, registryId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ContainerRepository>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.containerProjectRegistryRepositoryList(projectId, locationId, registryId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get container/registry.service
         * @summary Get container/registry.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async containerProjectRegistryServiceGet(projectId: string, locationId: string, registryId: string, serviceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceService>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.containerProjectRegistryServiceGet(projectId, locationId, registryId, serviceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List container/registry.service
         * @summary List container/registry.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async containerProjectRegistryServiceList(projectId: string, locationId: string, registryId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResourceService>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.containerProjectRegistryServiceList(projectId, locationId, registryId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * action start
         * @summary Start container/registry
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async containerProjectRegistryStart(projectId: string, locationId: string, registryId: string, xIdempotencyKey?: string, xDryRun?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Registry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.containerProjectRegistryStart(projectId, locationId, registryId, xIdempotencyKey, xDryRun, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * action stop
         * @summary Stop container/registry
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async containerProjectRegistryStop(projectId: string, locationId: string, registryId: string, xIdempotencyKey?: string, xDryRun?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Registry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.containerProjectRegistryStop(projectId, locationId, registryId, xIdempotencyKey, xDryRun, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create container/registry.tag
         * @summary Create container/registry.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async containerProjectRegistryTagCreate(projectId: string, locationId: string, registryId: string, tag: Tag, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.containerProjectRegistryTagCreate(projectId, locationId, registryId, tag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete container/registry.tag
         * @summary Delete container/registry.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async containerProjectRegistryTagDelete(projectId: string, locationId: string, registryId: string, tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.containerProjectRegistryTagDelete(projectId, locationId, registryId, tagId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get container/registry.tag
         * @summary Get container/registry.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async containerProjectRegistryTagGet(projectId: string, locationId: string, registryId: string, tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.containerProjectRegistryTagGet(projectId, locationId, registryId, tagId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List container/registry.tag
         * @summary List container/registry.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async containerProjectRegistryTagList(projectId: string, locationId: string, registryId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.containerProjectRegistryTagList(projectId, locationId, registryId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Replace container/registry.tag
         * @summary Replace container/registry.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async containerProjectRegistryTagPut(projectId: string, locationId: string, registryId: string, tag: Array<Tag>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.containerProjectRegistryTagPut(projectId, locationId, registryId, tag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * action transfer
         * @summary Transfer container/registry
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {ContainerProjectRegistryTransfer} containerProjectRegistryTransfer 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async containerProjectRegistryTransfer(projectId: string, locationId: string, registryId: string, containerProjectRegistryTransfer: ContainerProjectRegistryTransfer, xIdempotencyKey?: string, xDryRun?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Registry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.containerProjectRegistryTransfer(projectId, locationId, registryId, containerProjectRegistryTransfer, xIdempotencyKey, xDryRun, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns modified registry
         * @summary Update container/registry
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {ContainerProjectRegistryUpdate} containerProjectRegistryUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async containerProjectRegistryUpdate(projectId: string, locationId: string, registryId: string, containerProjectRegistryUpdate: ContainerProjectRegistryUpdate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Registry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.containerProjectRegistryUpdate(projectId, locationId, registryId, containerProjectRegistryUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ContainerProjectRegistryApi - factory interface
 * @export
 */
export const ContainerProjectRegistryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ContainerProjectRegistryApiFp(configuration)
    return {
        /**
         * Create registry
         * @summary Create container/registry
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {ContainerProjectRegistryCreate} containerProjectRegistryCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryCreate(projectId: string, locationId: string, containerProjectRegistryCreate: ContainerProjectRegistryCreate, xIdempotencyKey?: string, xDryRun?: string, options?: any): AxiosPromise<Registry> {
            return localVarFp.containerProjectRegistryCreate(projectId, locationId, containerProjectRegistryCreate, xIdempotencyKey, xDryRun, options).then((request) => request(axios, basePath));
        },
        /**
         * Create container/registry.credential
         * @summary Create container/registry.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {RegistryCredential} registryCredential 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryCredentialCreate(projectId: string, locationId: string, registryId: string, registryCredential: RegistryCredential, options?: any): AxiosPromise<RegistryCredential> {
            return localVarFp.containerProjectRegistryCredentialCreate(projectId, locationId, registryId, registryCredential, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete container/registry.credential
         * @summary Delete container/registry.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {string} credentialId credentialId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryCredentialDelete(projectId: string, locationId: string, registryId: string, credentialId: string, options?: any): AxiosPromise<Registry> {
            return localVarFp.containerProjectRegistryCredentialDelete(projectId, locationId, registryId, credentialId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get container/registry.credential
         * @summary Get container/registry.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {string} credentialId credentialId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryCredentialGet(projectId: string, locationId: string, registryId: string, credentialId: string, options?: any): AxiosPromise<RegistryCredential> {
            return localVarFp.containerProjectRegistryCredentialGet(projectId, locationId, registryId, credentialId, options).then((request) => request(axios, basePath));
        },
        /**
         * List container/registry.credential
         * @summary List container/registry.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryCredentialList(projectId: string, locationId: string, registryId: string, options?: any): AxiosPromise<Array<RegistryCredential>> {
            return localVarFp.containerProjectRegistryCredentialList(projectId, locationId, registryId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update container/registry.credential
         * @summary Update container/registry.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {string} credentialId credentialId
         * @param {ContainerProjectRegistryCredentialPatch} containerProjectRegistryCredentialPatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryCredentialPatch(projectId: string, locationId: string, registryId: string, credentialId: string, containerProjectRegistryCredentialPatch: ContainerProjectRegistryCredentialPatch, options?: any): AxiosPromise<RegistryCredential> {
            return localVarFp.containerProjectRegistryCredentialPatch(projectId, locationId, registryId, credentialId, containerProjectRegistryCredentialPatch, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete registry
         * @summary Delete container/registry
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryDelete(projectId: string, locationId: string, registryId: string, options?: any): AxiosPromise<void> {
            return localVarFp.containerProjectRegistryDelete(projectId, locationId, registryId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create container/registry.domain
         * @summary Create container/registry.domain
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {Domain} domain 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryDomainCreate(projectId: string, locationId: string, registryId: string, domain: Domain, options?: any): AxiosPromise<Domain> {
            return localVarFp.containerProjectRegistryDomainCreate(projectId, locationId, registryId, domain, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete container/registry.domain
         * @summary Delete container/registry.domain
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {string} domainId domainId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryDomainDelete(projectId: string, locationId: string, registryId: string, domainId: string, options?: any): AxiosPromise<void> {
            return localVarFp.containerProjectRegistryDomainDelete(projectId, locationId, registryId, domainId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get container/registry.domain
         * @summary Get container/registry.domain
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {string} domainId domainId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryDomainGet(projectId: string, locationId: string, registryId: string, domainId: string, options?: any): AxiosPromise<Domain> {
            return localVarFp.containerProjectRegistryDomainGet(projectId, locationId, registryId, domainId, options).then((request) => request(axios, basePath));
        },
        /**
         * List container/registry.domain
         * @summary List container/registry.domain
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryDomainList(projectId: string, locationId: string, registryId: string, options?: any): AxiosPromise<Array<Domain>> {
            return localVarFp.containerProjectRegistryDomainList(projectId, locationId, registryId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get container/registry.event
         * @summary Get container/registry.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryEventGet(projectId: string, locationId: string, registryId: string, eventId: string, options?: any): AxiosPromise<Event> {
            return localVarFp.containerProjectRegistryEventGet(projectId, locationId, registryId, eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * List container/registry.event
         * @summary List container/registry.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryEventList(projectId: string, locationId: string, registryId: string, $limit?: number, $skip?: number, options?: any): AxiosPromise<Array<Event>> {
            return localVarFp.containerProjectRegistryEventList(projectId, locationId, registryId, $limit, $skip, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single registry
         * @summary Get container/registry
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryGet(projectId: string, locationId: string, registryId: string, options?: any): AxiosPromise<Registry> {
            return localVarFp.containerProjectRegistryGet(projectId, locationId, registryId, options).then((request) => request(axios, basePath));
        },
        /**
         * List registry
         * @summary List container/registry
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [name] Filter by name
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryList(projectId: string, locationId: string, name?: string, tagValue?: string, tagKey?: string, options?: any): AxiosPromise<Array<Registry>> {
            return localVarFp.containerProjectRegistryList(projectId, locationId, name, tagValue, tagKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get container/registry.repository
         * @summary Get container/registry.repository
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {string} repositoryId repositoryId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryRepositoryGet(projectId: string, locationId: string, registryId: string, repositoryId: string, options?: any): AxiosPromise<ContainerRepository> {
            return localVarFp.containerProjectRegistryRepositoryGet(projectId, locationId, registryId, repositoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete container/registry.image
         * @summary Delete container/registry.image
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {string} repositoryId repositoryId
         * @param {string} imageId imageId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryRepositoryImageDelete(projectId: string, locationId: string, registryId: string, repositoryId: string, imageId: string, options?: any): AxiosPromise<void> {
            return localVarFp.containerProjectRegistryRepositoryImageDelete(projectId, locationId, registryId, repositoryId, imageId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get container/registry.image
         * @summary Get container/registry.image
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {string} repositoryId repositoryId
         * @param {string} imageId imageId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryRepositoryImageGet(projectId: string, locationId: string, registryId: string, repositoryId: string, imageId: string, options?: any): AxiosPromise<ContainerImage> {
            return localVarFp.containerProjectRegistryRepositoryImageGet(projectId, locationId, registryId, repositoryId, imageId, options).then((request) => request(axios, basePath));
        },
        /**
         * List container/registry.image
         * @summary List container/registry.image
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {string} repositoryId repositoryId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryRepositoryImageList(projectId: string, locationId: string, registryId: string, repositoryId: string, options?: any): AxiosPromise<Array<ContainerImage>> {
            return localVarFp.containerProjectRegistryRepositoryImageList(projectId, locationId, registryId, repositoryId, options).then((request) => request(axios, basePath));
        },
        /**
         * List container/registry.repository
         * @summary List container/registry.repository
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryRepositoryList(projectId: string, locationId: string, registryId: string, options?: any): AxiosPromise<Array<ContainerRepository>> {
            return localVarFp.containerProjectRegistryRepositoryList(projectId, locationId, registryId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get container/registry.service
         * @summary Get container/registry.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryServiceGet(projectId: string, locationId: string, registryId: string, serviceId: string, options?: any): AxiosPromise<ResourceService> {
            return localVarFp.containerProjectRegistryServiceGet(projectId, locationId, registryId, serviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * List container/registry.service
         * @summary List container/registry.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryServiceList(projectId: string, locationId: string, registryId: string, options?: any): AxiosPromise<Array<ResourceService>> {
            return localVarFp.containerProjectRegistryServiceList(projectId, locationId, registryId, options).then((request) => request(axios, basePath));
        },
        /**
         * action start
         * @summary Start container/registry
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryStart(projectId: string, locationId: string, registryId: string, xIdempotencyKey?: string, xDryRun?: string, options?: any): AxiosPromise<Registry> {
            return localVarFp.containerProjectRegistryStart(projectId, locationId, registryId, xIdempotencyKey, xDryRun, options).then((request) => request(axios, basePath));
        },
        /**
         * action stop
         * @summary Stop container/registry
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryStop(projectId: string, locationId: string, registryId: string, xIdempotencyKey?: string, xDryRun?: string, options?: any): AxiosPromise<Registry> {
            return localVarFp.containerProjectRegistryStop(projectId, locationId, registryId, xIdempotencyKey, xDryRun, options).then((request) => request(axios, basePath));
        },
        /**
         * Create container/registry.tag
         * @summary Create container/registry.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryTagCreate(projectId: string, locationId: string, registryId: string, tag: Tag, options?: any): AxiosPromise<Tag> {
            return localVarFp.containerProjectRegistryTagCreate(projectId, locationId, registryId, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete container/registry.tag
         * @summary Delete container/registry.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryTagDelete(projectId: string, locationId: string, registryId: string, tagId: string, options?: any): AxiosPromise<void> {
            return localVarFp.containerProjectRegistryTagDelete(projectId, locationId, registryId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get container/registry.tag
         * @summary Get container/registry.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryTagGet(projectId: string, locationId: string, registryId: string, tagId: string, options?: any): AxiosPromise<Tag> {
            return localVarFp.containerProjectRegistryTagGet(projectId, locationId, registryId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * List container/registry.tag
         * @summary List container/registry.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryTagList(projectId: string, locationId: string, registryId: string, options?: any): AxiosPromise<Array<Tag>> {
            return localVarFp.containerProjectRegistryTagList(projectId, locationId, registryId, options).then((request) => request(axios, basePath));
        },
        /**
         * Replace container/registry.tag
         * @summary Replace container/registry.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryTagPut(projectId: string, locationId: string, registryId: string, tag: Array<Tag>, options?: any): AxiosPromise<Array<Tag>> {
            return localVarFp.containerProjectRegistryTagPut(projectId, locationId, registryId, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * action transfer
         * @summary Transfer container/registry
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {ContainerProjectRegistryTransfer} containerProjectRegistryTransfer 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryTransfer(projectId: string, locationId: string, registryId: string, containerProjectRegistryTransfer: ContainerProjectRegistryTransfer, xIdempotencyKey?: string, xDryRun?: string, options?: any): AxiosPromise<Registry> {
            return localVarFp.containerProjectRegistryTransfer(projectId, locationId, registryId, containerProjectRegistryTransfer, xIdempotencyKey, xDryRun, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns modified registry
         * @summary Update container/registry
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} registryId Registry Id
         * @param {ContainerProjectRegistryUpdate} containerProjectRegistryUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        containerProjectRegistryUpdate(projectId: string, locationId: string, registryId: string, containerProjectRegistryUpdate: ContainerProjectRegistryUpdate, options?: any): AxiosPromise<Registry> {
            return localVarFp.containerProjectRegistryUpdate(projectId, locationId, registryId, containerProjectRegistryUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ContainerProjectRegistryApi - object-oriented interface
 * @export
 * @class ContainerProjectRegistryApi
 * @extends {BaseAPI}
 */
export class ContainerProjectRegistryApi extends BaseAPI {
    /**
     * Create registry
     * @summary Create container/registry
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {ContainerProjectRegistryCreate} containerProjectRegistryCreate 
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {string} [xDryRun] Dry run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerProjectRegistryApi
     */
    public containerProjectRegistryCreate(projectId: string, locationId: string, containerProjectRegistryCreate: ContainerProjectRegistryCreate, xIdempotencyKey?: string, xDryRun?: string, options?: any) {
        return ContainerProjectRegistryApiFp(this.configuration).containerProjectRegistryCreate(projectId, locationId, containerProjectRegistryCreate, xIdempotencyKey, xDryRun, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create container/registry.credential
     * @summary Create container/registry.credential
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} registryId Registry Id
     * @param {RegistryCredential} registryCredential 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerProjectRegistryApi
     */
    public containerProjectRegistryCredentialCreate(projectId: string, locationId: string, registryId: string, registryCredential: RegistryCredential, options?: any) {
        return ContainerProjectRegistryApiFp(this.configuration).containerProjectRegistryCredentialCreate(projectId, locationId, registryId, registryCredential, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete container/registry.credential
     * @summary Delete container/registry.credential
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} registryId Registry Id
     * @param {string} credentialId credentialId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerProjectRegistryApi
     */
    public containerProjectRegistryCredentialDelete(projectId: string, locationId: string, registryId: string, credentialId: string, options?: any) {
        return ContainerProjectRegistryApiFp(this.configuration).containerProjectRegistryCredentialDelete(projectId, locationId, registryId, credentialId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get container/registry.credential
     * @summary Get container/registry.credential
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} registryId Registry Id
     * @param {string} credentialId credentialId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerProjectRegistryApi
     */
    public containerProjectRegistryCredentialGet(projectId: string, locationId: string, registryId: string, credentialId: string, options?: any) {
        return ContainerProjectRegistryApiFp(this.configuration).containerProjectRegistryCredentialGet(projectId, locationId, registryId, credentialId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List container/registry.credential
     * @summary List container/registry.credential
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} registryId Registry Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerProjectRegistryApi
     */
    public containerProjectRegistryCredentialList(projectId: string, locationId: string, registryId: string, options?: any) {
        return ContainerProjectRegistryApiFp(this.configuration).containerProjectRegistryCredentialList(projectId, locationId, registryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update container/registry.credential
     * @summary Update container/registry.credential
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} registryId Registry Id
     * @param {string} credentialId credentialId
     * @param {ContainerProjectRegistryCredentialPatch} containerProjectRegistryCredentialPatch 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerProjectRegistryApi
     */
    public containerProjectRegistryCredentialPatch(projectId: string, locationId: string, registryId: string, credentialId: string, containerProjectRegistryCredentialPatch: ContainerProjectRegistryCredentialPatch, options?: any) {
        return ContainerProjectRegistryApiFp(this.configuration).containerProjectRegistryCredentialPatch(projectId, locationId, registryId, credentialId, containerProjectRegistryCredentialPatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete registry
     * @summary Delete container/registry
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} registryId Registry Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerProjectRegistryApi
     */
    public containerProjectRegistryDelete(projectId: string, locationId: string, registryId: string, options?: any) {
        return ContainerProjectRegistryApiFp(this.configuration).containerProjectRegistryDelete(projectId, locationId, registryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create container/registry.domain
     * @summary Create container/registry.domain
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} registryId Registry Id
     * @param {Domain} domain 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerProjectRegistryApi
     */
    public containerProjectRegistryDomainCreate(projectId: string, locationId: string, registryId: string, domain: Domain, options?: any) {
        return ContainerProjectRegistryApiFp(this.configuration).containerProjectRegistryDomainCreate(projectId, locationId, registryId, domain, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete container/registry.domain
     * @summary Delete container/registry.domain
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} registryId Registry Id
     * @param {string} domainId domainId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerProjectRegistryApi
     */
    public containerProjectRegistryDomainDelete(projectId: string, locationId: string, registryId: string, domainId: string, options?: any) {
        return ContainerProjectRegistryApiFp(this.configuration).containerProjectRegistryDomainDelete(projectId, locationId, registryId, domainId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get container/registry.domain
     * @summary Get container/registry.domain
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} registryId Registry Id
     * @param {string} domainId domainId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerProjectRegistryApi
     */
    public containerProjectRegistryDomainGet(projectId: string, locationId: string, registryId: string, domainId: string, options?: any) {
        return ContainerProjectRegistryApiFp(this.configuration).containerProjectRegistryDomainGet(projectId, locationId, registryId, domainId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List container/registry.domain
     * @summary List container/registry.domain
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} registryId Registry Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerProjectRegistryApi
     */
    public containerProjectRegistryDomainList(projectId: string, locationId: string, registryId: string, options?: any) {
        return ContainerProjectRegistryApiFp(this.configuration).containerProjectRegistryDomainList(projectId, locationId, registryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get container/registry.event
     * @summary Get container/registry.event
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} registryId Registry Id
     * @param {string} eventId eventId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerProjectRegistryApi
     */
    public containerProjectRegistryEventGet(projectId: string, locationId: string, registryId: string, eventId: string, options?: any) {
        return ContainerProjectRegistryApiFp(this.configuration).containerProjectRegistryEventGet(projectId, locationId, registryId, eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List container/registry.event
     * @summary List container/registry.event
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} registryId Registry Id
     * @param {number} [$limit] $limit
     * @param {number} [$skip] $skip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerProjectRegistryApi
     */
    public containerProjectRegistryEventList(projectId: string, locationId: string, registryId: string, $limit?: number, $skip?: number, options?: any) {
        return ContainerProjectRegistryApiFp(this.configuration).containerProjectRegistryEventList(projectId, locationId, registryId, $limit, $skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single registry
     * @summary Get container/registry
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} registryId Registry Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerProjectRegistryApi
     */
    public containerProjectRegistryGet(projectId: string, locationId: string, registryId: string, options?: any) {
        return ContainerProjectRegistryApiFp(this.configuration).containerProjectRegistryGet(projectId, locationId, registryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List registry
     * @summary List container/registry
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} [name] Filter by name
     * @param {string} [tagValue] Filter by tag.value
     * @param {string} [tagKey] Filter by tag.key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerProjectRegistryApi
     */
    public containerProjectRegistryList(projectId: string, locationId: string, name?: string, tagValue?: string, tagKey?: string, options?: any) {
        return ContainerProjectRegistryApiFp(this.configuration).containerProjectRegistryList(projectId, locationId, name, tagValue, tagKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get container/registry.repository
     * @summary Get container/registry.repository
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} registryId Registry Id
     * @param {string} repositoryId repositoryId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerProjectRegistryApi
     */
    public containerProjectRegistryRepositoryGet(projectId: string, locationId: string, registryId: string, repositoryId: string, options?: any) {
        return ContainerProjectRegistryApiFp(this.configuration).containerProjectRegistryRepositoryGet(projectId, locationId, registryId, repositoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete container/registry.image
     * @summary Delete container/registry.image
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} registryId Registry Id
     * @param {string} repositoryId repositoryId
     * @param {string} imageId imageId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerProjectRegistryApi
     */
    public containerProjectRegistryRepositoryImageDelete(projectId: string, locationId: string, registryId: string, repositoryId: string, imageId: string, options?: any) {
        return ContainerProjectRegistryApiFp(this.configuration).containerProjectRegistryRepositoryImageDelete(projectId, locationId, registryId, repositoryId, imageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get container/registry.image
     * @summary Get container/registry.image
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} registryId Registry Id
     * @param {string} repositoryId repositoryId
     * @param {string} imageId imageId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerProjectRegistryApi
     */
    public containerProjectRegistryRepositoryImageGet(projectId: string, locationId: string, registryId: string, repositoryId: string, imageId: string, options?: any) {
        return ContainerProjectRegistryApiFp(this.configuration).containerProjectRegistryRepositoryImageGet(projectId, locationId, registryId, repositoryId, imageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List container/registry.image
     * @summary List container/registry.image
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} registryId Registry Id
     * @param {string} repositoryId repositoryId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerProjectRegistryApi
     */
    public containerProjectRegistryRepositoryImageList(projectId: string, locationId: string, registryId: string, repositoryId: string, options?: any) {
        return ContainerProjectRegistryApiFp(this.configuration).containerProjectRegistryRepositoryImageList(projectId, locationId, registryId, repositoryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List container/registry.repository
     * @summary List container/registry.repository
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} registryId Registry Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerProjectRegistryApi
     */
    public containerProjectRegistryRepositoryList(projectId: string, locationId: string, registryId: string, options?: any) {
        return ContainerProjectRegistryApiFp(this.configuration).containerProjectRegistryRepositoryList(projectId, locationId, registryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get container/registry.service
     * @summary Get container/registry.service
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} registryId Registry Id
     * @param {string} serviceId serviceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerProjectRegistryApi
     */
    public containerProjectRegistryServiceGet(projectId: string, locationId: string, registryId: string, serviceId: string, options?: any) {
        return ContainerProjectRegistryApiFp(this.configuration).containerProjectRegistryServiceGet(projectId, locationId, registryId, serviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List container/registry.service
     * @summary List container/registry.service
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} registryId Registry Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerProjectRegistryApi
     */
    public containerProjectRegistryServiceList(projectId: string, locationId: string, registryId: string, options?: any) {
        return ContainerProjectRegistryApiFp(this.configuration).containerProjectRegistryServiceList(projectId, locationId, registryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * action start
     * @summary Start container/registry
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} registryId Registry Id
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {string} [xDryRun] Dry run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerProjectRegistryApi
     */
    public containerProjectRegistryStart(projectId: string, locationId: string, registryId: string, xIdempotencyKey?: string, xDryRun?: string, options?: any) {
        return ContainerProjectRegistryApiFp(this.configuration).containerProjectRegistryStart(projectId, locationId, registryId, xIdempotencyKey, xDryRun, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * action stop
     * @summary Stop container/registry
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} registryId Registry Id
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {string} [xDryRun] Dry run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerProjectRegistryApi
     */
    public containerProjectRegistryStop(projectId: string, locationId: string, registryId: string, xIdempotencyKey?: string, xDryRun?: string, options?: any) {
        return ContainerProjectRegistryApiFp(this.configuration).containerProjectRegistryStop(projectId, locationId, registryId, xIdempotencyKey, xDryRun, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create container/registry.tag
     * @summary Create container/registry.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} registryId Registry Id
     * @param {Tag} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerProjectRegistryApi
     */
    public containerProjectRegistryTagCreate(projectId: string, locationId: string, registryId: string, tag: Tag, options?: any) {
        return ContainerProjectRegistryApiFp(this.configuration).containerProjectRegistryTagCreate(projectId, locationId, registryId, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete container/registry.tag
     * @summary Delete container/registry.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} registryId Registry Id
     * @param {string} tagId tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerProjectRegistryApi
     */
    public containerProjectRegistryTagDelete(projectId: string, locationId: string, registryId: string, tagId: string, options?: any) {
        return ContainerProjectRegistryApiFp(this.configuration).containerProjectRegistryTagDelete(projectId, locationId, registryId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get container/registry.tag
     * @summary Get container/registry.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} registryId Registry Id
     * @param {string} tagId tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerProjectRegistryApi
     */
    public containerProjectRegistryTagGet(projectId: string, locationId: string, registryId: string, tagId: string, options?: any) {
        return ContainerProjectRegistryApiFp(this.configuration).containerProjectRegistryTagGet(projectId, locationId, registryId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List container/registry.tag
     * @summary List container/registry.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} registryId Registry Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerProjectRegistryApi
     */
    public containerProjectRegistryTagList(projectId: string, locationId: string, registryId: string, options?: any) {
        return ContainerProjectRegistryApiFp(this.configuration).containerProjectRegistryTagList(projectId, locationId, registryId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replace container/registry.tag
     * @summary Replace container/registry.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} registryId Registry Id
     * @param {Array<Tag>} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerProjectRegistryApi
     */
    public containerProjectRegistryTagPut(projectId: string, locationId: string, registryId: string, tag: Array<Tag>, options?: any) {
        return ContainerProjectRegistryApiFp(this.configuration).containerProjectRegistryTagPut(projectId, locationId, registryId, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * action transfer
     * @summary Transfer container/registry
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} registryId Registry Id
     * @param {ContainerProjectRegistryTransfer} containerProjectRegistryTransfer 
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {string} [xDryRun] Dry run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerProjectRegistryApi
     */
    public containerProjectRegistryTransfer(projectId: string, locationId: string, registryId: string, containerProjectRegistryTransfer: ContainerProjectRegistryTransfer, xIdempotencyKey?: string, xDryRun?: string, options?: any) {
        return ContainerProjectRegistryApiFp(this.configuration).containerProjectRegistryTransfer(projectId, locationId, registryId, containerProjectRegistryTransfer, xIdempotencyKey, xDryRun, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns modified registry
     * @summary Update container/registry
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} registryId Registry Id
     * @param {ContainerProjectRegistryUpdate} containerProjectRegistryUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContainerProjectRegistryApi
     */
    public containerProjectRegistryUpdate(projectId: string, locationId: string, registryId: string, containerProjectRegistryUpdate: ContainerProjectRegistryUpdate, options?: any) {
        return ContainerProjectRegistryApiFp(this.configuration).containerProjectRegistryUpdate(projectId, locationId, registryId, containerProjectRegistryUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DatabaseProjectInstanceApi - axios parameter creator
 * @export
 */
export const DatabaseProjectInstanceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get database/instance.connect
         * @summary Get database/instance.connect
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} connectId connectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseProjectInstanceConnectGet: async (projectId: string, locationId: string, instanceId: string, connectId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('databaseProjectInstanceConnectGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('databaseProjectInstanceConnectGet', 'locationId', locationId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('databaseProjectInstanceConnectGet', 'instanceId', instanceId)
            // verify required parameter 'connectId' is not null or undefined
            assertParamExists('databaseProjectInstanceConnectGet', 'connectId', connectId)
            const localVarPath = `/database/{locationId}/project/{projectId}/instance/{instanceId}/connect/{connectId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"connectId"}}`, encodeURIComponent(String(connectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List database/instance.connect
         * @summary List database/instance.connect
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseProjectInstanceConnectList: async (projectId: string, locationId: string, instanceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('databaseProjectInstanceConnectList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('databaseProjectInstanceConnectList', 'locationId', locationId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('databaseProjectInstanceConnectList', 'instanceId', instanceId)
            const localVarPath = `/database/{locationId}/project/{projectId}/instance/{instanceId}/connect`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create instance
         * @summary Create database/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {DatabaseProjectInstanceCreate} databaseProjectInstanceCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseProjectInstanceCreate: async (projectId: string, locationId: string, databaseProjectInstanceCreate: DatabaseProjectInstanceCreate, xIdempotencyKey?: string, xDryRun?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('databaseProjectInstanceCreate', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('databaseProjectInstanceCreate', 'locationId', locationId)
            // verify required parameter 'databaseProjectInstanceCreate' is not null or undefined
            assertParamExists('databaseProjectInstanceCreate', 'databaseProjectInstanceCreate', databaseProjectInstanceCreate)
            const localVarPath = `/database/{locationId}/project/{projectId}/instance`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }

            if (xDryRun !== undefined && xDryRun !== null) {
                localVarHeaderParameter['x-dry-run'] = String(xDryRun);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(databaseProjectInstanceCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create database/instance.credential
         * @summary Create database/instance.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {DatabaseCredential} databaseCredential 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseProjectInstanceCredentialCreate: async (projectId: string, locationId: string, instanceId: string, databaseCredential: DatabaseCredential, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('databaseProjectInstanceCredentialCreate', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('databaseProjectInstanceCredentialCreate', 'locationId', locationId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('databaseProjectInstanceCredentialCreate', 'instanceId', instanceId)
            // verify required parameter 'databaseCredential' is not null or undefined
            assertParamExists('databaseProjectInstanceCredentialCreate', 'databaseCredential', databaseCredential)
            const localVarPath = `/database/{locationId}/project/{projectId}/instance/{instanceId}/credential`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(databaseCredential, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete database/instance.credential
         * @summary Delete database/instance.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} credentialId credentialId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseProjectInstanceCredentialDelete: async (projectId: string, locationId: string, instanceId: string, credentialId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('databaseProjectInstanceCredentialDelete', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('databaseProjectInstanceCredentialDelete', 'locationId', locationId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('databaseProjectInstanceCredentialDelete', 'instanceId', instanceId)
            // verify required parameter 'credentialId' is not null or undefined
            assertParamExists('databaseProjectInstanceCredentialDelete', 'credentialId', credentialId)
            const localVarPath = `/database/{locationId}/project/{projectId}/instance/{instanceId}/credential/{credentialId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"credentialId"}}`, encodeURIComponent(String(credentialId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get database/instance.credential
         * @summary Get database/instance.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} credentialId credentialId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseProjectInstanceCredentialGet: async (projectId: string, locationId: string, instanceId: string, credentialId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('databaseProjectInstanceCredentialGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('databaseProjectInstanceCredentialGet', 'locationId', locationId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('databaseProjectInstanceCredentialGet', 'instanceId', instanceId)
            // verify required parameter 'credentialId' is not null or undefined
            assertParamExists('databaseProjectInstanceCredentialGet', 'credentialId', credentialId)
            const localVarPath = `/database/{locationId}/project/{projectId}/instance/{instanceId}/credential/{credentialId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"credentialId"}}`, encodeURIComponent(String(credentialId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List database/instance.credential
         * @summary List database/instance.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseProjectInstanceCredentialList: async (projectId: string, locationId: string, instanceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('databaseProjectInstanceCredentialList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('databaseProjectInstanceCredentialList', 'locationId', locationId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('databaseProjectInstanceCredentialList', 'instanceId', instanceId)
            const localVarPath = `/database/{locationId}/project/{projectId}/instance/{instanceId}/credential`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update database/instance.credential
         * @summary Update database/instance.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} credentialId credentialId
         * @param {DatabaseProjectInstanceCredentialPatch} databaseProjectInstanceCredentialPatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseProjectInstanceCredentialPatch: async (projectId: string, locationId: string, instanceId: string, credentialId: string, databaseProjectInstanceCredentialPatch: DatabaseProjectInstanceCredentialPatch, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('databaseProjectInstanceCredentialPatch', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('databaseProjectInstanceCredentialPatch', 'locationId', locationId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('databaseProjectInstanceCredentialPatch', 'instanceId', instanceId)
            // verify required parameter 'credentialId' is not null or undefined
            assertParamExists('databaseProjectInstanceCredentialPatch', 'credentialId', credentialId)
            // verify required parameter 'databaseProjectInstanceCredentialPatch' is not null or undefined
            assertParamExists('databaseProjectInstanceCredentialPatch', 'databaseProjectInstanceCredentialPatch', databaseProjectInstanceCredentialPatch)
            const localVarPath = `/database/{locationId}/project/{projectId}/instance/{instanceId}/credential/{credentialId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"credentialId"}}`, encodeURIComponent(String(credentialId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(databaseProjectInstanceCredentialPatch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete instance
         * @summary Delete database/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseProjectInstanceDelete: async (projectId: string, locationId: string, instanceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('databaseProjectInstanceDelete', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('databaseProjectInstanceDelete', 'locationId', locationId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('databaseProjectInstanceDelete', 'instanceId', instanceId)
            const localVarPath = `/database/{locationId}/project/{projectId}/instance/{instanceId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get database/instance.event
         * @summary Get database/instance.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseProjectInstanceEventGet: async (projectId: string, locationId: string, instanceId: string, eventId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('databaseProjectInstanceEventGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('databaseProjectInstanceEventGet', 'locationId', locationId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('databaseProjectInstanceEventGet', 'instanceId', instanceId)
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('databaseProjectInstanceEventGet', 'eventId', eventId)
            const localVarPath = `/database/{locationId}/project/{projectId}/instance/{instanceId}/event/{eventId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List database/instance.event
         * @summary List database/instance.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseProjectInstanceEventList: async (projectId: string, locationId: string, instanceId: string, $limit?: number, $skip?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('databaseProjectInstanceEventList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('databaseProjectInstanceEventList', 'locationId', locationId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('databaseProjectInstanceEventList', 'instanceId', instanceId)
            const localVarPath = `/database/{locationId}/project/{projectId}/instance/{instanceId}/event`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if ($limit !== undefined) {
                localVarQueryParameter['$limit'] = $limit;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single instance
         * @summary Get database/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseProjectInstanceGet: async (projectId: string, locationId: string, instanceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('databaseProjectInstanceGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('databaseProjectInstanceGet', 'locationId', locationId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('databaseProjectInstanceGet', 'instanceId', instanceId)
            const localVarPath = `/database/{locationId}/project/{projectId}/instance/{instanceId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List instance
         * @summary List database/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [name] Filter by name
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseProjectInstanceList: async (projectId: string, locationId: string, name?: string, tagValue?: string, tagKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('databaseProjectInstanceList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('databaseProjectInstanceList', 'locationId', locationId)
            const localVarPath = `/database/{locationId}/project/{projectId}/instance`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (tagValue !== undefined) {
                localVarQueryParameter['tag.value'] = tagValue;
            }

            if (tagKey !== undefined) {
                localVarQueryParameter['tag.key'] = tagKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get database/instance.metric
         * @summary Get database/instance.metric
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} metricId metricId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseProjectInstanceMetricGet: async (projectId: string, locationId: string, instanceId: string, metricId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('databaseProjectInstanceMetricGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('databaseProjectInstanceMetricGet', 'locationId', locationId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('databaseProjectInstanceMetricGet', 'instanceId', instanceId)
            // verify required parameter 'metricId' is not null or undefined
            assertParamExists('databaseProjectInstanceMetricGet', 'metricId', metricId)
            const localVarPath = `/database/{locationId}/project/{projectId}/instance/{instanceId}/metric/{metricId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"metricId"}}`, encodeURIComponent(String(metricId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List database/instance.metric
         * @summary List database/instance.metric
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseProjectInstanceMetricList: async (projectId: string, locationId: string, instanceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('databaseProjectInstanceMetricList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('databaseProjectInstanceMetricList', 'locationId', locationId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('databaseProjectInstanceMetricList', 'instanceId', instanceId)
            const localVarPath = `/database/{locationId}/project/{projectId}/instance/{instanceId}/metric`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List database/instance.point
         * @summary List database/instance.point
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} metricId metricId
         * @param {string} [interval] interval
         * @param {string} [timespan] timespan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseProjectInstanceMetricPointList: async (projectId: string, locationId: string, instanceId: string, metricId: string, interval?: string, timespan?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('databaseProjectInstanceMetricPointList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('databaseProjectInstanceMetricPointList', 'locationId', locationId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('databaseProjectInstanceMetricPointList', 'instanceId', instanceId)
            // verify required parameter 'metricId' is not null or undefined
            assertParamExists('databaseProjectInstanceMetricPointList', 'metricId', metricId)
            const localVarPath = `/database/{locationId}/project/{projectId}/instance/{instanceId}/metric/{metricId}/point`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"metricId"}}`, encodeURIComponent(String(metricId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (timespan !== undefined) {
                localVarQueryParameter['timespan'] = timespan;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get database/instance.service
         * @summary Get database/instance.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseProjectInstanceServiceGet: async (projectId: string, locationId: string, instanceId: string, serviceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('databaseProjectInstanceServiceGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('databaseProjectInstanceServiceGet', 'locationId', locationId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('databaseProjectInstanceServiceGet', 'instanceId', instanceId)
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('databaseProjectInstanceServiceGet', 'serviceId', serviceId)
            const localVarPath = `/database/{locationId}/project/{projectId}/instance/{instanceId}/service/{serviceId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List database/instance.service
         * @summary List database/instance.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseProjectInstanceServiceList: async (projectId: string, locationId: string, instanceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('databaseProjectInstanceServiceList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('databaseProjectInstanceServiceList', 'locationId', locationId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('databaseProjectInstanceServiceList', 'instanceId', instanceId)
            const localVarPath = `/database/{locationId}/project/{projectId}/instance/{instanceId}/service`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * action start
         * @summary Start database/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseProjectInstanceStart: async (projectId: string, locationId: string, instanceId: string, xIdempotencyKey?: string, xDryRun?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('databaseProjectInstanceStart', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('databaseProjectInstanceStart', 'locationId', locationId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('databaseProjectInstanceStart', 'instanceId', instanceId)
            const localVarPath = `/database/{locationId}/project/{projectId}/instance/{instanceId}/actions/start`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }

            if (xDryRun !== undefined && xDryRun !== null) {
                localVarHeaderParameter['x-dry-run'] = String(xDryRun);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * action stop
         * @summary Stop database/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseProjectInstanceStop: async (projectId: string, locationId: string, instanceId: string, xIdempotencyKey?: string, xDryRun?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('databaseProjectInstanceStop', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('databaseProjectInstanceStop', 'locationId', locationId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('databaseProjectInstanceStop', 'instanceId', instanceId)
            const localVarPath = `/database/{locationId}/project/{projectId}/instance/{instanceId}/actions/stop`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }

            if (xDryRun !== undefined && xDryRun !== null) {
                localVarHeaderParameter['x-dry-run'] = String(xDryRun);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create database/instance.tag
         * @summary Create database/instance.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseProjectInstanceTagCreate: async (projectId: string, locationId: string, instanceId: string, tag: Tag, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('databaseProjectInstanceTagCreate', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('databaseProjectInstanceTagCreate', 'locationId', locationId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('databaseProjectInstanceTagCreate', 'instanceId', instanceId)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('databaseProjectInstanceTagCreate', 'tag', tag)
            const localVarPath = `/database/{locationId}/project/{projectId}/instance/{instanceId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tag, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete database/instance.tag
         * @summary Delete database/instance.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseProjectInstanceTagDelete: async (projectId: string, locationId: string, instanceId: string, tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('databaseProjectInstanceTagDelete', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('databaseProjectInstanceTagDelete', 'locationId', locationId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('databaseProjectInstanceTagDelete', 'instanceId', instanceId)
            // verify required parameter 'tagId' is not null or undefined
            assertParamExists('databaseProjectInstanceTagDelete', 'tagId', tagId)
            const localVarPath = `/database/{locationId}/project/{projectId}/instance/{instanceId}/tag/{tagId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get database/instance.tag
         * @summary Get database/instance.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseProjectInstanceTagGet: async (projectId: string, locationId: string, instanceId: string, tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('databaseProjectInstanceTagGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('databaseProjectInstanceTagGet', 'locationId', locationId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('databaseProjectInstanceTagGet', 'instanceId', instanceId)
            // verify required parameter 'tagId' is not null or undefined
            assertParamExists('databaseProjectInstanceTagGet', 'tagId', tagId)
            const localVarPath = `/database/{locationId}/project/{projectId}/instance/{instanceId}/tag/{tagId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List database/instance.tag
         * @summary List database/instance.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseProjectInstanceTagList: async (projectId: string, locationId: string, instanceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('databaseProjectInstanceTagList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('databaseProjectInstanceTagList', 'locationId', locationId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('databaseProjectInstanceTagList', 'instanceId', instanceId)
            const localVarPath = `/database/{locationId}/project/{projectId}/instance/{instanceId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replace database/instance.tag
         * @summary Replace database/instance.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseProjectInstanceTagPut: async (projectId: string, locationId: string, instanceId: string, tag: Array<Tag>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('databaseProjectInstanceTagPut', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('databaseProjectInstanceTagPut', 'locationId', locationId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('databaseProjectInstanceTagPut', 'instanceId', instanceId)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('databaseProjectInstanceTagPut', 'tag', tag)
            const localVarPath = `/database/{locationId}/project/{projectId}/instance/{instanceId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tag, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * action transfer
         * @summary Transfer database/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {DatabaseProjectInstanceTransfer} databaseProjectInstanceTransfer 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseProjectInstanceTransfer: async (projectId: string, locationId: string, instanceId: string, databaseProjectInstanceTransfer: DatabaseProjectInstanceTransfer, xIdempotencyKey?: string, xDryRun?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('databaseProjectInstanceTransfer', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('databaseProjectInstanceTransfer', 'locationId', locationId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('databaseProjectInstanceTransfer', 'instanceId', instanceId)
            // verify required parameter 'databaseProjectInstanceTransfer' is not null or undefined
            assertParamExists('databaseProjectInstanceTransfer', 'databaseProjectInstanceTransfer', databaseProjectInstanceTransfer)
            const localVarPath = `/database/{locationId}/project/{projectId}/instance/{instanceId}/actions/transfer`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }

            if (xDryRun !== undefined && xDryRun !== null) {
                localVarHeaderParameter['x-dry-run'] = String(xDryRun);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(databaseProjectInstanceTransfer, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns modified instance
         * @summary Update database/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {DatabaseProjectInstanceUpdate} databaseProjectInstanceUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseProjectInstanceUpdate: async (projectId: string, locationId: string, instanceId: string, databaseProjectInstanceUpdate: DatabaseProjectInstanceUpdate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('databaseProjectInstanceUpdate', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('databaseProjectInstanceUpdate', 'locationId', locationId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('databaseProjectInstanceUpdate', 'instanceId', instanceId)
            // verify required parameter 'databaseProjectInstanceUpdate' is not null or undefined
            assertParamExists('databaseProjectInstanceUpdate', 'databaseProjectInstanceUpdate', databaseProjectInstanceUpdate)
            const localVarPath = `/database/{locationId}/project/{projectId}/instance/{instanceId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(databaseProjectInstanceUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DatabaseProjectInstanceApi - functional programming interface
 * @export
 */
export const DatabaseProjectInstanceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DatabaseProjectInstanceApiAxiosParamCreator(configuration)
    return {
        /**
         * Get database/instance.connect
         * @summary Get database/instance.connect
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} connectId connectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async databaseProjectInstanceConnectGet(projectId: string, locationId: string, instanceId: string, connectId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceConnect>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.databaseProjectInstanceConnectGet(projectId, locationId, instanceId, connectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List database/instance.connect
         * @summary List database/instance.connect
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async databaseProjectInstanceConnectList(projectId: string, locationId: string, instanceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResourceConnect>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.databaseProjectInstanceConnectList(projectId, locationId, instanceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create instance
         * @summary Create database/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {DatabaseProjectInstanceCreate} databaseProjectInstanceCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async databaseProjectInstanceCreate(projectId: string, locationId: string, databaseProjectInstanceCreate: DatabaseProjectInstanceCreate, xIdempotencyKey?: string, xDryRun?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Database>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.databaseProjectInstanceCreate(projectId, locationId, databaseProjectInstanceCreate, xIdempotencyKey, xDryRun, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create database/instance.credential
         * @summary Create database/instance.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {DatabaseCredential} databaseCredential 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async databaseProjectInstanceCredentialCreate(projectId: string, locationId: string, instanceId: string, databaseCredential: DatabaseCredential, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DatabaseCredential>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.databaseProjectInstanceCredentialCreate(projectId, locationId, instanceId, databaseCredential, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete database/instance.credential
         * @summary Delete database/instance.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} credentialId credentialId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async databaseProjectInstanceCredentialDelete(projectId: string, locationId: string, instanceId: string, credentialId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Database>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.databaseProjectInstanceCredentialDelete(projectId, locationId, instanceId, credentialId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get database/instance.credential
         * @summary Get database/instance.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} credentialId credentialId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async databaseProjectInstanceCredentialGet(projectId: string, locationId: string, instanceId: string, credentialId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DatabaseCredential>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.databaseProjectInstanceCredentialGet(projectId, locationId, instanceId, credentialId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List database/instance.credential
         * @summary List database/instance.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async databaseProjectInstanceCredentialList(projectId: string, locationId: string, instanceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DatabaseCredential>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.databaseProjectInstanceCredentialList(projectId, locationId, instanceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update database/instance.credential
         * @summary Update database/instance.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} credentialId credentialId
         * @param {DatabaseProjectInstanceCredentialPatch} databaseProjectInstanceCredentialPatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async databaseProjectInstanceCredentialPatch(projectId: string, locationId: string, instanceId: string, credentialId: string, databaseProjectInstanceCredentialPatch: DatabaseProjectInstanceCredentialPatch, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DatabaseCredential>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.databaseProjectInstanceCredentialPatch(projectId, locationId, instanceId, credentialId, databaseProjectInstanceCredentialPatch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete instance
         * @summary Delete database/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async databaseProjectInstanceDelete(projectId: string, locationId: string, instanceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.databaseProjectInstanceDelete(projectId, locationId, instanceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get database/instance.event
         * @summary Get database/instance.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async databaseProjectInstanceEventGet(projectId: string, locationId: string, instanceId: string, eventId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.databaseProjectInstanceEventGet(projectId, locationId, instanceId, eventId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List database/instance.event
         * @summary List database/instance.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async databaseProjectInstanceEventList(projectId: string, locationId: string, instanceId: string, $limit?: number, $skip?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Event>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.databaseProjectInstanceEventList(projectId, locationId, instanceId, $limit, $skip, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a single instance
         * @summary Get database/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async databaseProjectInstanceGet(projectId: string, locationId: string, instanceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Database>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.databaseProjectInstanceGet(projectId, locationId, instanceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List instance
         * @summary List database/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [name] Filter by name
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async databaseProjectInstanceList(projectId: string, locationId: string, name?: string, tagValue?: string, tagKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Database>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.databaseProjectInstanceList(projectId, locationId, name, tagValue, tagKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get database/instance.metric
         * @summary Get database/instance.metric
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} metricId metricId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async databaseProjectInstanceMetricGet(projectId: string, locationId: string, instanceId: string, metricId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Metric>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.databaseProjectInstanceMetricGet(projectId, locationId, instanceId, metricId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List database/instance.metric
         * @summary List database/instance.metric
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async databaseProjectInstanceMetricList(projectId: string, locationId: string, instanceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Metric>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.databaseProjectInstanceMetricList(projectId, locationId, instanceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List database/instance.point
         * @summary List database/instance.point
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} metricId metricId
         * @param {string} [interval] interval
         * @param {string} [timespan] timespan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async databaseProjectInstanceMetricPointList(projectId: string, locationId: string, instanceId: string, metricId: string, interval?: string, timespan?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Point>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.databaseProjectInstanceMetricPointList(projectId, locationId, instanceId, metricId, interval, timespan, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get database/instance.service
         * @summary Get database/instance.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async databaseProjectInstanceServiceGet(projectId: string, locationId: string, instanceId: string, serviceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceService>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.databaseProjectInstanceServiceGet(projectId, locationId, instanceId, serviceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List database/instance.service
         * @summary List database/instance.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async databaseProjectInstanceServiceList(projectId: string, locationId: string, instanceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResourceService>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.databaseProjectInstanceServiceList(projectId, locationId, instanceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * action start
         * @summary Start database/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async databaseProjectInstanceStart(projectId: string, locationId: string, instanceId: string, xIdempotencyKey?: string, xDryRun?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Database>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.databaseProjectInstanceStart(projectId, locationId, instanceId, xIdempotencyKey, xDryRun, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * action stop
         * @summary Stop database/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async databaseProjectInstanceStop(projectId: string, locationId: string, instanceId: string, xIdempotencyKey?: string, xDryRun?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Database>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.databaseProjectInstanceStop(projectId, locationId, instanceId, xIdempotencyKey, xDryRun, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create database/instance.tag
         * @summary Create database/instance.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async databaseProjectInstanceTagCreate(projectId: string, locationId: string, instanceId: string, tag: Tag, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.databaseProjectInstanceTagCreate(projectId, locationId, instanceId, tag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete database/instance.tag
         * @summary Delete database/instance.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async databaseProjectInstanceTagDelete(projectId: string, locationId: string, instanceId: string, tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.databaseProjectInstanceTagDelete(projectId, locationId, instanceId, tagId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get database/instance.tag
         * @summary Get database/instance.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async databaseProjectInstanceTagGet(projectId: string, locationId: string, instanceId: string, tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.databaseProjectInstanceTagGet(projectId, locationId, instanceId, tagId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List database/instance.tag
         * @summary List database/instance.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async databaseProjectInstanceTagList(projectId: string, locationId: string, instanceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.databaseProjectInstanceTagList(projectId, locationId, instanceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Replace database/instance.tag
         * @summary Replace database/instance.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async databaseProjectInstanceTagPut(projectId: string, locationId: string, instanceId: string, tag: Array<Tag>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.databaseProjectInstanceTagPut(projectId, locationId, instanceId, tag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * action transfer
         * @summary Transfer database/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {DatabaseProjectInstanceTransfer} databaseProjectInstanceTransfer 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async databaseProjectInstanceTransfer(projectId: string, locationId: string, instanceId: string, databaseProjectInstanceTransfer: DatabaseProjectInstanceTransfer, xIdempotencyKey?: string, xDryRun?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Database>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.databaseProjectInstanceTransfer(projectId, locationId, instanceId, databaseProjectInstanceTransfer, xIdempotencyKey, xDryRun, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns modified instance
         * @summary Update database/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {DatabaseProjectInstanceUpdate} databaseProjectInstanceUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async databaseProjectInstanceUpdate(projectId: string, locationId: string, instanceId: string, databaseProjectInstanceUpdate: DatabaseProjectInstanceUpdate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Database>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.databaseProjectInstanceUpdate(projectId, locationId, instanceId, databaseProjectInstanceUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DatabaseProjectInstanceApi - factory interface
 * @export
 */
export const DatabaseProjectInstanceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DatabaseProjectInstanceApiFp(configuration)
    return {
        /**
         * Get database/instance.connect
         * @summary Get database/instance.connect
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} connectId connectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseProjectInstanceConnectGet(projectId: string, locationId: string, instanceId: string, connectId: string, options?: any): AxiosPromise<ResourceConnect> {
            return localVarFp.databaseProjectInstanceConnectGet(projectId, locationId, instanceId, connectId, options).then((request) => request(axios, basePath));
        },
        /**
         * List database/instance.connect
         * @summary List database/instance.connect
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseProjectInstanceConnectList(projectId: string, locationId: string, instanceId: string, options?: any): AxiosPromise<Array<ResourceConnect>> {
            return localVarFp.databaseProjectInstanceConnectList(projectId, locationId, instanceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create instance
         * @summary Create database/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {DatabaseProjectInstanceCreate} databaseProjectInstanceCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseProjectInstanceCreate(projectId: string, locationId: string, databaseProjectInstanceCreate: DatabaseProjectInstanceCreate, xIdempotencyKey?: string, xDryRun?: string, options?: any): AxiosPromise<Database> {
            return localVarFp.databaseProjectInstanceCreate(projectId, locationId, databaseProjectInstanceCreate, xIdempotencyKey, xDryRun, options).then((request) => request(axios, basePath));
        },
        /**
         * Create database/instance.credential
         * @summary Create database/instance.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {DatabaseCredential} databaseCredential 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseProjectInstanceCredentialCreate(projectId: string, locationId: string, instanceId: string, databaseCredential: DatabaseCredential, options?: any): AxiosPromise<DatabaseCredential> {
            return localVarFp.databaseProjectInstanceCredentialCreate(projectId, locationId, instanceId, databaseCredential, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete database/instance.credential
         * @summary Delete database/instance.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} credentialId credentialId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseProjectInstanceCredentialDelete(projectId: string, locationId: string, instanceId: string, credentialId: string, options?: any): AxiosPromise<Database> {
            return localVarFp.databaseProjectInstanceCredentialDelete(projectId, locationId, instanceId, credentialId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get database/instance.credential
         * @summary Get database/instance.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} credentialId credentialId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseProjectInstanceCredentialGet(projectId: string, locationId: string, instanceId: string, credentialId: string, options?: any): AxiosPromise<DatabaseCredential> {
            return localVarFp.databaseProjectInstanceCredentialGet(projectId, locationId, instanceId, credentialId, options).then((request) => request(axios, basePath));
        },
        /**
         * List database/instance.credential
         * @summary List database/instance.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseProjectInstanceCredentialList(projectId: string, locationId: string, instanceId: string, options?: any): AxiosPromise<Array<DatabaseCredential>> {
            return localVarFp.databaseProjectInstanceCredentialList(projectId, locationId, instanceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update database/instance.credential
         * @summary Update database/instance.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} credentialId credentialId
         * @param {DatabaseProjectInstanceCredentialPatch} databaseProjectInstanceCredentialPatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseProjectInstanceCredentialPatch(projectId: string, locationId: string, instanceId: string, credentialId: string, databaseProjectInstanceCredentialPatch: DatabaseProjectInstanceCredentialPatch, options?: any): AxiosPromise<DatabaseCredential> {
            return localVarFp.databaseProjectInstanceCredentialPatch(projectId, locationId, instanceId, credentialId, databaseProjectInstanceCredentialPatch, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete instance
         * @summary Delete database/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseProjectInstanceDelete(projectId: string, locationId: string, instanceId: string, options?: any): AxiosPromise<void> {
            return localVarFp.databaseProjectInstanceDelete(projectId, locationId, instanceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get database/instance.event
         * @summary Get database/instance.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseProjectInstanceEventGet(projectId: string, locationId: string, instanceId: string, eventId: string, options?: any): AxiosPromise<Event> {
            return localVarFp.databaseProjectInstanceEventGet(projectId, locationId, instanceId, eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * List database/instance.event
         * @summary List database/instance.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseProjectInstanceEventList(projectId: string, locationId: string, instanceId: string, $limit?: number, $skip?: number, options?: any): AxiosPromise<Array<Event>> {
            return localVarFp.databaseProjectInstanceEventList(projectId, locationId, instanceId, $limit, $skip, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single instance
         * @summary Get database/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseProjectInstanceGet(projectId: string, locationId: string, instanceId: string, options?: any): AxiosPromise<Database> {
            return localVarFp.databaseProjectInstanceGet(projectId, locationId, instanceId, options).then((request) => request(axios, basePath));
        },
        /**
         * List instance
         * @summary List database/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [name] Filter by name
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseProjectInstanceList(projectId: string, locationId: string, name?: string, tagValue?: string, tagKey?: string, options?: any): AxiosPromise<Array<Database>> {
            return localVarFp.databaseProjectInstanceList(projectId, locationId, name, tagValue, tagKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get database/instance.metric
         * @summary Get database/instance.metric
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} metricId metricId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseProjectInstanceMetricGet(projectId: string, locationId: string, instanceId: string, metricId: string, options?: any): AxiosPromise<Metric> {
            return localVarFp.databaseProjectInstanceMetricGet(projectId, locationId, instanceId, metricId, options).then((request) => request(axios, basePath));
        },
        /**
         * List database/instance.metric
         * @summary List database/instance.metric
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseProjectInstanceMetricList(projectId: string, locationId: string, instanceId: string, options?: any): AxiosPromise<Array<Metric>> {
            return localVarFp.databaseProjectInstanceMetricList(projectId, locationId, instanceId, options).then((request) => request(axios, basePath));
        },
        /**
         * List database/instance.point
         * @summary List database/instance.point
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} metricId metricId
         * @param {string} [interval] interval
         * @param {string} [timespan] timespan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseProjectInstanceMetricPointList(projectId: string, locationId: string, instanceId: string, metricId: string, interval?: string, timespan?: string, options?: any): AxiosPromise<Array<Point>> {
            return localVarFp.databaseProjectInstanceMetricPointList(projectId, locationId, instanceId, metricId, interval, timespan, options).then((request) => request(axios, basePath));
        },
        /**
         * Get database/instance.service
         * @summary Get database/instance.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseProjectInstanceServiceGet(projectId: string, locationId: string, instanceId: string, serviceId: string, options?: any): AxiosPromise<ResourceService> {
            return localVarFp.databaseProjectInstanceServiceGet(projectId, locationId, instanceId, serviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * List database/instance.service
         * @summary List database/instance.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseProjectInstanceServiceList(projectId: string, locationId: string, instanceId: string, options?: any): AxiosPromise<Array<ResourceService>> {
            return localVarFp.databaseProjectInstanceServiceList(projectId, locationId, instanceId, options).then((request) => request(axios, basePath));
        },
        /**
         * action start
         * @summary Start database/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseProjectInstanceStart(projectId: string, locationId: string, instanceId: string, xIdempotencyKey?: string, xDryRun?: string, options?: any): AxiosPromise<Database> {
            return localVarFp.databaseProjectInstanceStart(projectId, locationId, instanceId, xIdempotencyKey, xDryRun, options).then((request) => request(axios, basePath));
        },
        /**
         * action stop
         * @summary Stop database/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseProjectInstanceStop(projectId: string, locationId: string, instanceId: string, xIdempotencyKey?: string, xDryRun?: string, options?: any): AxiosPromise<Database> {
            return localVarFp.databaseProjectInstanceStop(projectId, locationId, instanceId, xIdempotencyKey, xDryRun, options).then((request) => request(axios, basePath));
        },
        /**
         * Create database/instance.tag
         * @summary Create database/instance.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseProjectInstanceTagCreate(projectId: string, locationId: string, instanceId: string, tag: Tag, options?: any): AxiosPromise<Tag> {
            return localVarFp.databaseProjectInstanceTagCreate(projectId, locationId, instanceId, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete database/instance.tag
         * @summary Delete database/instance.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseProjectInstanceTagDelete(projectId: string, locationId: string, instanceId: string, tagId: string, options?: any): AxiosPromise<void> {
            return localVarFp.databaseProjectInstanceTagDelete(projectId, locationId, instanceId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get database/instance.tag
         * @summary Get database/instance.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseProjectInstanceTagGet(projectId: string, locationId: string, instanceId: string, tagId: string, options?: any): AxiosPromise<Tag> {
            return localVarFp.databaseProjectInstanceTagGet(projectId, locationId, instanceId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * List database/instance.tag
         * @summary List database/instance.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseProjectInstanceTagList(projectId: string, locationId: string, instanceId: string, options?: any): AxiosPromise<Array<Tag>> {
            return localVarFp.databaseProjectInstanceTagList(projectId, locationId, instanceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Replace database/instance.tag
         * @summary Replace database/instance.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseProjectInstanceTagPut(projectId: string, locationId: string, instanceId: string, tag: Array<Tag>, options?: any): AxiosPromise<Array<Tag>> {
            return localVarFp.databaseProjectInstanceTagPut(projectId, locationId, instanceId, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * action transfer
         * @summary Transfer database/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {DatabaseProjectInstanceTransfer} databaseProjectInstanceTransfer 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseProjectInstanceTransfer(projectId: string, locationId: string, instanceId: string, databaseProjectInstanceTransfer: DatabaseProjectInstanceTransfer, xIdempotencyKey?: string, xDryRun?: string, options?: any): AxiosPromise<Database> {
            return localVarFp.databaseProjectInstanceTransfer(projectId, locationId, instanceId, databaseProjectInstanceTransfer, xIdempotencyKey, xDryRun, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns modified instance
         * @summary Update database/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {DatabaseProjectInstanceUpdate} databaseProjectInstanceUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        databaseProjectInstanceUpdate(projectId: string, locationId: string, instanceId: string, databaseProjectInstanceUpdate: DatabaseProjectInstanceUpdate, options?: any): AxiosPromise<Database> {
            return localVarFp.databaseProjectInstanceUpdate(projectId, locationId, instanceId, databaseProjectInstanceUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DatabaseProjectInstanceApi - object-oriented interface
 * @export
 * @class DatabaseProjectInstanceApi
 * @extends {BaseAPI}
 */
export class DatabaseProjectInstanceApi extends BaseAPI {
    /**
     * Get database/instance.connect
     * @summary Get database/instance.connect
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {string} connectId connectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseProjectInstanceApi
     */
    public databaseProjectInstanceConnectGet(projectId: string, locationId: string, instanceId: string, connectId: string, options?: any) {
        return DatabaseProjectInstanceApiFp(this.configuration).databaseProjectInstanceConnectGet(projectId, locationId, instanceId, connectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List database/instance.connect
     * @summary List database/instance.connect
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseProjectInstanceApi
     */
    public databaseProjectInstanceConnectList(projectId: string, locationId: string, instanceId: string, options?: any) {
        return DatabaseProjectInstanceApiFp(this.configuration).databaseProjectInstanceConnectList(projectId, locationId, instanceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create instance
     * @summary Create database/instance
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {DatabaseProjectInstanceCreate} databaseProjectInstanceCreate 
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {string} [xDryRun] Dry run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseProjectInstanceApi
     */
    public databaseProjectInstanceCreate(projectId: string, locationId: string, databaseProjectInstanceCreate: DatabaseProjectInstanceCreate, xIdempotencyKey?: string, xDryRun?: string, options?: any) {
        return DatabaseProjectInstanceApiFp(this.configuration).databaseProjectInstanceCreate(projectId, locationId, databaseProjectInstanceCreate, xIdempotencyKey, xDryRun, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create database/instance.credential
     * @summary Create database/instance.credential
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {DatabaseCredential} databaseCredential 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseProjectInstanceApi
     */
    public databaseProjectInstanceCredentialCreate(projectId: string, locationId: string, instanceId: string, databaseCredential: DatabaseCredential, options?: any) {
        return DatabaseProjectInstanceApiFp(this.configuration).databaseProjectInstanceCredentialCreate(projectId, locationId, instanceId, databaseCredential, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete database/instance.credential
     * @summary Delete database/instance.credential
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {string} credentialId credentialId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseProjectInstanceApi
     */
    public databaseProjectInstanceCredentialDelete(projectId: string, locationId: string, instanceId: string, credentialId: string, options?: any) {
        return DatabaseProjectInstanceApiFp(this.configuration).databaseProjectInstanceCredentialDelete(projectId, locationId, instanceId, credentialId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get database/instance.credential
     * @summary Get database/instance.credential
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {string} credentialId credentialId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseProjectInstanceApi
     */
    public databaseProjectInstanceCredentialGet(projectId: string, locationId: string, instanceId: string, credentialId: string, options?: any) {
        return DatabaseProjectInstanceApiFp(this.configuration).databaseProjectInstanceCredentialGet(projectId, locationId, instanceId, credentialId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List database/instance.credential
     * @summary List database/instance.credential
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseProjectInstanceApi
     */
    public databaseProjectInstanceCredentialList(projectId: string, locationId: string, instanceId: string, options?: any) {
        return DatabaseProjectInstanceApiFp(this.configuration).databaseProjectInstanceCredentialList(projectId, locationId, instanceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update database/instance.credential
     * @summary Update database/instance.credential
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {string} credentialId credentialId
     * @param {DatabaseProjectInstanceCredentialPatch} databaseProjectInstanceCredentialPatch 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseProjectInstanceApi
     */
    public databaseProjectInstanceCredentialPatch(projectId: string, locationId: string, instanceId: string, credentialId: string, databaseProjectInstanceCredentialPatch: DatabaseProjectInstanceCredentialPatch, options?: any) {
        return DatabaseProjectInstanceApiFp(this.configuration).databaseProjectInstanceCredentialPatch(projectId, locationId, instanceId, credentialId, databaseProjectInstanceCredentialPatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete instance
     * @summary Delete database/instance
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseProjectInstanceApi
     */
    public databaseProjectInstanceDelete(projectId: string, locationId: string, instanceId: string, options?: any) {
        return DatabaseProjectInstanceApiFp(this.configuration).databaseProjectInstanceDelete(projectId, locationId, instanceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get database/instance.event
     * @summary Get database/instance.event
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {string} eventId eventId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseProjectInstanceApi
     */
    public databaseProjectInstanceEventGet(projectId: string, locationId: string, instanceId: string, eventId: string, options?: any) {
        return DatabaseProjectInstanceApiFp(this.configuration).databaseProjectInstanceEventGet(projectId, locationId, instanceId, eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List database/instance.event
     * @summary List database/instance.event
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {number} [$limit] $limit
     * @param {number} [$skip] $skip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseProjectInstanceApi
     */
    public databaseProjectInstanceEventList(projectId: string, locationId: string, instanceId: string, $limit?: number, $skip?: number, options?: any) {
        return DatabaseProjectInstanceApiFp(this.configuration).databaseProjectInstanceEventList(projectId, locationId, instanceId, $limit, $skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single instance
     * @summary Get database/instance
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseProjectInstanceApi
     */
    public databaseProjectInstanceGet(projectId: string, locationId: string, instanceId: string, options?: any) {
        return DatabaseProjectInstanceApiFp(this.configuration).databaseProjectInstanceGet(projectId, locationId, instanceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List instance
     * @summary List database/instance
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} [name] Filter by name
     * @param {string} [tagValue] Filter by tag.value
     * @param {string} [tagKey] Filter by tag.key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseProjectInstanceApi
     */
    public databaseProjectInstanceList(projectId: string, locationId: string, name?: string, tagValue?: string, tagKey?: string, options?: any) {
        return DatabaseProjectInstanceApiFp(this.configuration).databaseProjectInstanceList(projectId, locationId, name, tagValue, tagKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get database/instance.metric
     * @summary Get database/instance.metric
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {string} metricId metricId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseProjectInstanceApi
     */
    public databaseProjectInstanceMetricGet(projectId: string, locationId: string, instanceId: string, metricId: string, options?: any) {
        return DatabaseProjectInstanceApiFp(this.configuration).databaseProjectInstanceMetricGet(projectId, locationId, instanceId, metricId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List database/instance.metric
     * @summary List database/instance.metric
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseProjectInstanceApi
     */
    public databaseProjectInstanceMetricList(projectId: string, locationId: string, instanceId: string, options?: any) {
        return DatabaseProjectInstanceApiFp(this.configuration).databaseProjectInstanceMetricList(projectId, locationId, instanceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List database/instance.point
     * @summary List database/instance.point
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {string} metricId metricId
     * @param {string} [interval] interval
     * @param {string} [timespan] timespan
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseProjectInstanceApi
     */
    public databaseProjectInstanceMetricPointList(projectId: string, locationId: string, instanceId: string, metricId: string, interval?: string, timespan?: string, options?: any) {
        return DatabaseProjectInstanceApiFp(this.configuration).databaseProjectInstanceMetricPointList(projectId, locationId, instanceId, metricId, interval, timespan, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get database/instance.service
     * @summary Get database/instance.service
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {string} serviceId serviceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseProjectInstanceApi
     */
    public databaseProjectInstanceServiceGet(projectId: string, locationId: string, instanceId: string, serviceId: string, options?: any) {
        return DatabaseProjectInstanceApiFp(this.configuration).databaseProjectInstanceServiceGet(projectId, locationId, instanceId, serviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List database/instance.service
     * @summary List database/instance.service
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseProjectInstanceApi
     */
    public databaseProjectInstanceServiceList(projectId: string, locationId: string, instanceId: string, options?: any) {
        return DatabaseProjectInstanceApiFp(this.configuration).databaseProjectInstanceServiceList(projectId, locationId, instanceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * action start
     * @summary Start database/instance
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {string} [xDryRun] Dry run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseProjectInstanceApi
     */
    public databaseProjectInstanceStart(projectId: string, locationId: string, instanceId: string, xIdempotencyKey?: string, xDryRun?: string, options?: any) {
        return DatabaseProjectInstanceApiFp(this.configuration).databaseProjectInstanceStart(projectId, locationId, instanceId, xIdempotencyKey, xDryRun, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * action stop
     * @summary Stop database/instance
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {string} [xDryRun] Dry run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseProjectInstanceApi
     */
    public databaseProjectInstanceStop(projectId: string, locationId: string, instanceId: string, xIdempotencyKey?: string, xDryRun?: string, options?: any) {
        return DatabaseProjectInstanceApiFp(this.configuration).databaseProjectInstanceStop(projectId, locationId, instanceId, xIdempotencyKey, xDryRun, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create database/instance.tag
     * @summary Create database/instance.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {Tag} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseProjectInstanceApi
     */
    public databaseProjectInstanceTagCreate(projectId: string, locationId: string, instanceId: string, tag: Tag, options?: any) {
        return DatabaseProjectInstanceApiFp(this.configuration).databaseProjectInstanceTagCreate(projectId, locationId, instanceId, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete database/instance.tag
     * @summary Delete database/instance.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {string} tagId tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseProjectInstanceApi
     */
    public databaseProjectInstanceTagDelete(projectId: string, locationId: string, instanceId: string, tagId: string, options?: any) {
        return DatabaseProjectInstanceApiFp(this.configuration).databaseProjectInstanceTagDelete(projectId, locationId, instanceId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get database/instance.tag
     * @summary Get database/instance.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {string} tagId tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseProjectInstanceApi
     */
    public databaseProjectInstanceTagGet(projectId: string, locationId: string, instanceId: string, tagId: string, options?: any) {
        return DatabaseProjectInstanceApiFp(this.configuration).databaseProjectInstanceTagGet(projectId, locationId, instanceId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List database/instance.tag
     * @summary List database/instance.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseProjectInstanceApi
     */
    public databaseProjectInstanceTagList(projectId: string, locationId: string, instanceId: string, options?: any) {
        return DatabaseProjectInstanceApiFp(this.configuration).databaseProjectInstanceTagList(projectId, locationId, instanceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replace database/instance.tag
     * @summary Replace database/instance.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {Array<Tag>} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseProjectInstanceApi
     */
    public databaseProjectInstanceTagPut(projectId: string, locationId: string, instanceId: string, tag: Array<Tag>, options?: any) {
        return DatabaseProjectInstanceApiFp(this.configuration).databaseProjectInstanceTagPut(projectId, locationId, instanceId, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * action transfer
     * @summary Transfer database/instance
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {DatabaseProjectInstanceTransfer} databaseProjectInstanceTransfer 
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {string} [xDryRun] Dry run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseProjectInstanceApi
     */
    public databaseProjectInstanceTransfer(projectId: string, locationId: string, instanceId: string, databaseProjectInstanceTransfer: DatabaseProjectInstanceTransfer, xIdempotencyKey?: string, xDryRun?: string, options?: any) {
        return DatabaseProjectInstanceApiFp(this.configuration).databaseProjectInstanceTransfer(projectId, locationId, instanceId, databaseProjectInstanceTransfer, xIdempotencyKey, xDryRun, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns modified instance
     * @summary Update database/instance
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {DatabaseProjectInstanceUpdate} databaseProjectInstanceUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DatabaseProjectInstanceApi
     */
    public databaseProjectInstanceUpdate(projectId: string, locationId: string, instanceId: string, databaseProjectInstanceUpdate: DatabaseProjectInstanceUpdate, options?: any) {
        return DatabaseProjectInstanceApiFp(this.configuration).databaseProjectInstanceUpdate(projectId, locationId, instanceId, databaseProjectInstanceUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DnsProjectZoneApi - axios parameter creator
 * @export
 */
export const DnsProjectZoneApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create zone
         * @summary Create dns/zone
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {DnsProjectZoneCreate} dnsProjectZoneCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dnsProjectZoneCreate: async (projectId: string, locationId: string, dnsProjectZoneCreate: DnsProjectZoneCreate, xIdempotencyKey?: string, xDryRun?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('dnsProjectZoneCreate', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('dnsProjectZoneCreate', 'locationId', locationId)
            // verify required parameter 'dnsProjectZoneCreate' is not null or undefined
            assertParamExists('dnsProjectZoneCreate', 'dnsProjectZoneCreate', dnsProjectZoneCreate)
            const localVarPath = `/dns/{locationId}/project/{projectId}/zone`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }

            if (xDryRun !== undefined && xDryRun !== null) {
                localVarHeaderParameter['x-dry-run'] = String(xDryRun);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dnsProjectZoneCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete zone
         * @summary Delete dns/zone
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dnsProjectZoneDelete: async (projectId: string, locationId: string, zoneId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('dnsProjectZoneDelete', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('dnsProjectZoneDelete', 'locationId', locationId)
            // verify required parameter 'zoneId' is not null or undefined
            assertParamExists('dnsProjectZoneDelete', 'zoneId', zoneId)
            const localVarPath = `/dns/{locationId}/project/{projectId}/zone/{zoneId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"zoneId"}}`, encodeURIComponent(String(zoneId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get dns/zone.event
         * @summary Get dns/zone.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dnsProjectZoneEventGet: async (projectId: string, locationId: string, zoneId: string, eventId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('dnsProjectZoneEventGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('dnsProjectZoneEventGet', 'locationId', locationId)
            // verify required parameter 'zoneId' is not null or undefined
            assertParamExists('dnsProjectZoneEventGet', 'zoneId', zoneId)
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('dnsProjectZoneEventGet', 'eventId', eventId)
            const localVarPath = `/dns/{locationId}/project/{projectId}/zone/{zoneId}/event/{eventId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"zoneId"}}`, encodeURIComponent(String(zoneId)))
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List dns/zone.event
         * @summary List dns/zone.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dnsProjectZoneEventList: async (projectId: string, locationId: string, zoneId: string, $limit?: number, $skip?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('dnsProjectZoneEventList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('dnsProjectZoneEventList', 'locationId', locationId)
            // verify required parameter 'zoneId' is not null or undefined
            assertParamExists('dnsProjectZoneEventList', 'zoneId', zoneId)
            const localVarPath = `/dns/{locationId}/project/{projectId}/zone/{zoneId}/event`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"zoneId"}}`, encodeURIComponent(String(zoneId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if ($limit !== undefined) {
                localVarQueryParameter['$limit'] = $limit;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single zone
         * @summary Get dns/zone
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dnsProjectZoneGet: async (projectId: string, locationId: string, zoneId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('dnsProjectZoneGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('dnsProjectZoneGet', 'locationId', locationId)
            // verify required parameter 'zoneId' is not null or undefined
            assertParamExists('dnsProjectZoneGet', 'zoneId', zoneId)
            const localVarPath = `/dns/{locationId}/project/{projectId}/zone/{zoneId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"zoneId"}}`, encodeURIComponent(String(zoneId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List zone
         * @summary List dns/zone
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [name] Filter by name
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dnsProjectZoneList: async (projectId: string, locationId: string, name?: string, tagValue?: string, tagKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('dnsProjectZoneList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('dnsProjectZoneList', 'locationId', locationId)
            const localVarPath = `/dns/{locationId}/project/{projectId}/zone`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (tagValue !== undefined) {
                localVarQueryParameter['tag.value'] = tagValue;
            }

            if (tagKey !== undefined) {
                localVarQueryParameter['tag.key'] = tagKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create dns/zone.recordset
         * @summary Create dns/zone.recordset
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {DnsRecordset} dnsRecordset 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dnsProjectZoneRecordsetCreate: async (projectId: string, locationId: string, zoneId: string, dnsRecordset: DnsRecordset, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('dnsProjectZoneRecordsetCreate', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('dnsProjectZoneRecordsetCreate', 'locationId', locationId)
            // verify required parameter 'zoneId' is not null or undefined
            assertParamExists('dnsProjectZoneRecordsetCreate', 'zoneId', zoneId)
            // verify required parameter 'dnsRecordset' is not null or undefined
            assertParamExists('dnsProjectZoneRecordsetCreate', 'dnsRecordset', dnsRecordset)
            const localVarPath = `/dns/{locationId}/project/{projectId}/zone/{zoneId}/recordset`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"zoneId"}}`, encodeURIComponent(String(zoneId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dnsRecordset, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete dns/zone.recordset
         * @summary Delete dns/zone.recordset
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {string} recordsetId recordsetId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dnsProjectZoneRecordsetDelete: async (projectId: string, locationId: string, zoneId: string, recordsetId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('dnsProjectZoneRecordsetDelete', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('dnsProjectZoneRecordsetDelete', 'locationId', locationId)
            // verify required parameter 'zoneId' is not null or undefined
            assertParamExists('dnsProjectZoneRecordsetDelete', 'zoneId', zoneId)
            // verify required parameter 'recordsetId' is not null or undefined
            assertParamExists('dnsProjectZoneRecordsetDelete', 'recordsetId', recordsetId)
            const localVarPath = `/dns/{locationId}/project/{projectId}/zone/{zoneId}/recordset/{recordsetId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"zoneId"}}`, encodeURIComponent(String(zoneId)))
                .replace(`{${"recordsetId"}}`, encodeURIComponent(String(recordsetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get dns/zone.recordset
         * @summary Get dns/zone.recordset
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {string} recordsetId recordsetId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dnsProjectZoneRecordsetGet: async (projectId: string, locationId: string, zoneId: string, recordsetId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('dnsProjectZoneRecordsetGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('dnsProjectZoneRecordsetGet', 'locationId', locationId)
            // verify required parameter 'zoneId' is not null or undefined
            assertParamExists('dnsProjectZoneRecordsetGet', 'zoneId', zoneId)
            // verify required parameter 'recordsetId' is not null or undefined
            assertParamExists('dnsProjectZoneRecordsetGet', 'recordsetId', recordsetId)
            const localVarPath = `/dns/{locationId}/project/{projectId}/zone/{zoneId}/recordset/{recordsetId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"zoneId"}}`, encodeURIComponent(String(zoneId)))
                .replace(`{${"recordsetId"}}`, encodeURIComponent(String(recordsetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List dns/zone.recordset
         * @summary List dns/zone.recordset
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dnsProjectZoneRecordsetList: async (projectId: string, locationId: string, zoneId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('dnsProjectZoneRecordsetList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('dnsProjectZoneRecordsetList', 'locationId', locationId)
            // verify required parameter 'zoneId' is not null or undefined
            assertParamExists('dnsProjectZoneRecordsetList', 'zoneId', zoneId)
            const localVarPath = `/dns/{locationId}/project/{projectId}/zone/{zoneId}/recordset`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"zoneId"}}`, encodeURIComponent(String(zoneId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update dns/zone.recordset
         * @summary Update dns/zone.recordset
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {string} recordsetId recordsetId
         * @param {DnsProjectZoneRecordsetPatch} dnsProjectZoneRecordsetPatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dnsProjectZoneRecordsetPatch: async (projectId: string, locationId: string, zoneId: string, recordsetId: string, dnsProjectZoneRecordsetPatch: DnsProjectZoneRecordsetPatch, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('dnsProjectZoneRecordsetPatch', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('dnsProjectZoneRecordsetPatch', 'locationId', locationId)
            // verify required parameter 'zoneId' is not null or undefined
            assertParamExists('dnsProjectZoneRecordsetPatch', 'zoneId', zoneId)
            // verify required parameter 'recordsetId' is not null or undefined
            assertParamExists('dnsProjectZoneRecordsetPatch', 'recordsetId', recordsetId)
            // verify required parameter 'dnsProjectZoneRecordsetPatch' is not null or undefined
            assertParamExists('dnsProjectZoneRecordsetPatch', 'dnsProjectZoneRecordsetPatch', dnsProjectZoneRecordsetPatch)
            const localVarPath = `/dns/{locationId}/project/{projectId}/zone/{zoneId}/recordset/{recordsetId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"zoneId"}}`, encodeURIComponent(String(zoneId)))
                .replace(`{${"recordsetId"}}`, encodeURIComponent(String(recordsetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dnsProjectZoneRecordsetPatch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create dns/zone.record
         * @summary Create dns/zone.record
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {string} recordsetId recordsetId
         * @param {DnsRecord} dnsRecord 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dnsProjectZoneRecordsetRecordCreate: async (projectId: string, locationId: string, zoneId: string, recordsetId: string, dnsRecord: DnsRecord, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('dnsProjectZoneRecordsetRecordCreate', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('dnsProjectZoneRecordsetRecordCreate', 'locationId', locationId)
            // verify required parameter 'zoneId' is not null or undefined
            assertParamExists('dnsProjectZoneRecordsetRecordCreate', 'zoneId', zoneId)
            // verify required parameter 'recordsetId' is not null or undefined
            assertParamExists('dnsProjectZoneRecordsetRecordCreate', 'recordsetId', recordsetId)
            // verify required parameter 'dnsRecord' is not null or undefined
            assertParamExists('dnsProjectZoneRecordsetRecordCreate', 'dnsRecord', dnsRecord)
            const localVarPath = `/dns/{locationId}/project/{projectId}/zone/{zoneId}/recordset/{recordsetId}/record`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"zoneId"}}`, encodeURIComponent(String(zoneId)))
                .replace(`{${"recordsetId"}}`, encodeURIComponent(String(recordsetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dnsRecord, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete dns/zone.record
         * @summary Delete dns/zone.record
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {string} recordsetId recordsetId
         * @param {string} recordId recordId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dnsProjectZoneRecordsetRecordDelete: async (projectId: string, locationId: string, zoneId: string, recordsetId: string, recordId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('dnsProjectZoneRecordsetRecordDelete', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('dnsProjectZoneRecordsetRecordDelete', 'locationId', locationId)
            // verify required parameter 'zoneId' is not null or undefined
            assertParamExists('dnsProjectZoneRecordsetRecordDelete', 'zoneId', zoneId)
            // verify required parameter 'recordsetId' is not null or undefined
            assertParamExists('dnsProjectZoneRecordsetRecordDelete', 'recordsetId', recordsetId)
            // verify required parameter 'recordId' is not null or undefined
            assertParamExists('dnsProjectZoneRecordsetRecordDelete', 'recordId', recordId)
            const localVarPath = `/dns/{locationId}/project/{projectId}/zone/{zoneId}/recordset/{recordsetId}/record/{recordId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"zoneId"}}`, encodeURIComponent(String(zoneId)))
                .replace(`{${"recordsetId"}}`, encodeURIComponent(String(recordsetId)))
                .replace(`{${"recordId"}}`, encodeURIComponent(String(recordId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get dns/zone.record
         * @summary Get dns/zone.record
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {string} recordsetId recordsetId
         * @param {string} recordId recordId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dnsProjectZoneRecordsetRecordGet: async (projectId: string, locationId: string, zoneId: string, recordsetId: string, recordId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('dnsProjectZoneRecordsetRecordGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('dnsProjectZoneRecordsetRecordGet', 'locationId', locationId)
            // verify required parameter 'zoneId' is not null or undefined
            assertParamExists('dnsProjectZoneRecordsetRecordGet', 'zoneId', zoneId)
            // verify required parameter 'recordsetId' is not null or undefined
            assertParamExists('dnsProjectZoneRecordsetRecordGet', 'recordsetId', recordsetId)
            // verify required parameter 'recordId' is not null or undefined
            assertParamExists('dnsProjectZoneRecordsetRecordGet', 'recordId', recordId)
            const localVarPath = `/dns/{locationId}/project/{projectId}/zone/{zoneId}/recordset/{recordsetId}/record/{recordId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"zoneId"}}`, encodeURIComponent(String(zoneId)))
                .replace(`{${"recordsetId"}}`, encodeURIComponent(String(recordsetId)))
                .replace(`{${"recordId"}}`, encodeURIComponent(String(recordId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List dns/zone.record
         * @summary List dns/zone.record
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {string} recordsetId recordsetId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dnsProjectZoneRecordsetRecordList: async (projectId: string, locationId: string, zoneId: string, recordsetId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('dnsProjectZoneRecordsetRecordList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('dnsProjectZoneRecordsetRecordList', 'locationId', locationId)
            // verify required parameter 'zoneId' is not null or undefined
            assertParamExists('dnsProjectZoneRecordsetRecordList', 'zoneId', zoneId)
            // verify required parameter 'recordsetId' is not null or undefined
            assertParamExists('dnsProjectZoneRecordsetRecordList', 'recordsetId', recordsetId)
            const localVarPath = `/dns/{locationId}/project/{projectId}/zone/{zoneId}/recordset/{recordsetId}/record`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"zoneId"}}`, encodeURIComponent(String(zoneId)))
                .replace(`{${"recordsetId"}}`, encodeURIComponent(String(recordsetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replace dns/zone.record
         * @summary Replace dns/zone.record
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {string} recordsetId recordsetId
         * @param {Array<DnsRecord>} dnsRecord 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dnsProjectZoneRecordsetRecordPut: async (projectId: string, locationId: string, zoneId: string, recordsetId: string, dnsRecord: Array<DnsRecord>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('dnsProjectZoneRecordsetRecordPut', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('dnsProjectZoneRecordsetRecordPut', 'locationId', locationId)
            // verify required parameter 'zoneId' is not null or undefined
            assertParamExists('dnsProjectZoneRecordsetRecordPut', 'zoneId', zoneId)
            // verify required parameter 'recordsetId' is not null or undefined
            assertParamExists('dnsProjectZoneRecordsetRecordPut', 'recordsetId', recordsetId)
            // verify required parameter 'dnsRecord' is not null or undefined
            assertParamExists('dnsProjectZoneRecordsetRecordPut', 'dnsRecord', dnsRecord)
            const localVarPath = `/dns/{locationId}/project/{projectId}/zone/{zoneId}/recordset/{recordsetId}/record`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"zoneId"}}`, encodeURIComponent(String(zoneId)))
                .replace(`{${"recordsetId"}}`, encodeURIComponent(String(recordsetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dnsRecord, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get dns/zone.service
         * @summary Get dns/zone.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dnsProjectZoneServiceGet: async (projectId: string, locationId: string, zoneId: string, serviceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('dnsProjectZoneServiceGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('dnsProjectZoneServiceGet', 'locationId', locationId)
            // verify required parameter 'zoneId' is not null or undefined
            assertParamExists('dnsProjectZoneServiceGet', 'zoneId', zoneId)
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('dnsProjectZoneServiceGet', 'serviceId', serviceId)
            const localVarPath = `/dns/{locationId}/project/{projectId}/zone/{zoneId}/service/{serviceId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"zoneId"}}`, encodeURIComponent(String(zoneId)))
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List dns/zone.service
         * @summary List dns/zone.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dnsProjectZoneServiceList: async (projectId: string, locationId: string, zoneId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('dnsProjectZoneServiceList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('dnsProjectZoneServiceList', 'locationId', locationId)
            // verify required parameter 'zoneId' is not null or undefined
            assertParamExists('dnsProjectZoneServiceList', 'zoneId', zoneId)
            const localVarPath = `/dns/{locationId}/project/{projectId}/zone/{zoneId}/service`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"zoneId"}}`, encodeURIComponent(String(zoneId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create dns/zone.tag
         * @summary Create dns/zone.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dnsProjectZoneTagCreate: async (projectId: string, locationId: string, zoneId: string, tag: Tag, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('dnsProjectZoneTagCreate', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('dnsProjectZoneTagCreate', 'locationId', locationId)
            // verify required parameter 'zoneId' is not null or undefined
            assertParamExists('dnsProjectZoneTagCreate', 'zoneId', zoneId)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('dnsProjectZoneTagCreate', 'tag', tag)
            const localVarPath = `/dns/{locationId}/project/{projectId}/zone/{zoneId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"zoneId"}}`, encodeURIComponent(String(zoneId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tag, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete dns/zone.tag
         * @summary Delete dns/zone.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dnsProjectZoneTagDelete: async (projectId: string, locationId: string, zoneId: string, tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('dnsProjectZoneTagDelete', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('dnsProjectZoneTagDelete', 'locationId', locationId)
            // verify required parameter 'zoneId' is not null or undefined
            assertParamExists('dnsProjectZoneTagDelete', 'zoneId', zoneId)
            // verify required parameter 'tagId' is not null or undefined
            assertParamExists('dnsProjectZoneTagDelete', 'tagId', tagId)
            const localVarPath = `/dns/{locationId}/project/{projectId}/zone/{zoneId}/tag/{tagId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"zoneId"}}`, encodeURIComponent(String(zoneId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get dns/zone.tag
         * @summary Get dns/zone.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dnsProjectZoneTagGet: async (projectId: string, locationId: string, zoneId: string, tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('dnsProjectZoneTagGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('dnsProjectZoneTagGet', 'locationId', locationId)
            // verify required parameter 'zoneId' is not null or undefined
            assertParamExists('dnsProjectZoneTagGet', 'zoneId', zoneId)
            // verify required parameter 'tagId' is not null or undefined
            assertParamExists('dnsProjectZoneTagGet', 'tagId', tagId)
            const localVarPath = `/dns/{locationId}/project/{projectId}/zone/{zoneId}/tag/{tagId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"zoneId"}}`, encodeURIComponent(String(zoneId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List dns/zone.tag
         * @summary List dns/zone.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dnsProjectZoneTagList: async (projectId: string, locationId: string, zoneId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('dnsProjectZoneTagList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('dnsProjectZoneTagList', 'locationId', locationId)
            // verify required parameter 'zoneId' is not null or undefined
            assertParamExists('dnsProjectZoneTagList', 'zoneId', zoneId)
            const localVarPath = `/dns/{locationId}/project/{projectId}/zone/{zoneId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"zoneId"}}`, encodeURIComponent(String(zoneId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replace dns/zone.tag
         * @summary Replace dns/zone.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dnsProjectZoneTagPut: async (projectId: string, locationId: string, zoneId: string, tag: Array<Tag>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('dnsProjectZoneTagPut', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('dnsProjectZoneTagPut', 'locationId', locationId)
            // verify required parameter 'zoneId' is not null or undefined
            assertParamExists('dnsProjectZoneTagPut', 'zoneId', zoneId)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('dnsProjectZoneTagPut', 'tag', tag)
            const localVarPath = `/dns/{locationId}/project/{projectId}/zone/{zoneId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"zoneId"}}`, encodeURIComponent(String(zoneId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tag, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns modified zone
         * @summary Update dns/zone
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {DnsProjectZoneUpdate} dnsProjectZoneUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dnsProjectZoneUpdate: async (projectId: string, locationId: string, zoneId: string, dnsProjectZoneUpdate: DnsProjectZoneUpdate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('dnsProjectZoneUpdate', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('dnsProjectZoneUpdate', 'locationId', locationId)
            // verify required parameter 'zoneId' is not null or undefined
            assertParamExists('dnsProjectZoneUpdate', 'zoneId', zoneId)
            // verify required parameter 'dnsProjectZoneUpdate' is not null or undefined
            assertParamExists('dnsProjectZoneUpdate', 'dnsProjectZoneUpdate', dnsProjectZoneUpdate)
            const localVarPath = `/dns/{locationId}/project/{projectId}/zone/{zoneId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"zoneId"}}`, encodeURIComponent(String(zoneId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(dnsProjectZoneUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DnsProjectZoneApi - functional programming interface
 * @export
 */
export const DnsProjectZoneApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DnsProjectZoneApiAxiosParamCreator(configuration)
    return {
        /**
         * Create zone
         * @summary Create dns/zone
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {DnsProjectZoneCreate} dnsProjectZoneCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dnsProjectZoneCreate(projectId: string, locationId: string, dnsProjectZoneCreate: DnsProjectZoneCreate, xIdempotencyKey?: string, xDryRun?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Zone>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dnsProjectZoneCreate(projectId, locationId, dnsProjectZoneCreate, xIdempotencyKey, xDryRun, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete zone
         * @summary Delete dns/zone
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dnsProjectZoneDelete(projectId: string, locationId: string, zoneId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dnsProjectZoneDelete(projectId, locationId, zoneId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get dns/zone.event
         * @summary Get dns/zone.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dnsProjectZoneEventGet(projectId: string, locationId: string, zoneId: string, eventId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dnsProjectZoneEventGet(projectId, locationId, zoneId, eventId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List dns/zone.event
         * @summary List dns/zone.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dnsProjectZoneEventList(projectId: string, locationId: string, zoneId: string, $limit?: number, $skip?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Event>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dnsProjectZoneEventList(projectId, locationId, zoneId, $limit, $skip, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a single zone
         * @summary Get dns/zone
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dnsProjectZoneGet(projectId: string, locationId: string, zoneId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Zone>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dnsProjectZoneGet(projectId, locationId, zoneId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List zone
         * @summary List dns/zone
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [name] Filter by name
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dnsProjectZoneList(projectId: string, locationId: string, name?: string, tagValue?: string, tagKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Zone>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dnsProjectZoneList(projectId, locationId, name, tagValue, tagKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create dns/zone.recordset
         * @summary Create dns/zone.recordset
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {DnsRecordset} dnsRecordset 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dnsProjectZoneRecordsetCreate(projectId: string, locationId: string, zoneId: string, dnsRecordset: DnsRecordset, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DnsRecordset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dnsProjectZoneRecordsetCreate(projectId, locationId, zoneId, dnsRecordset, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete dns/zone.recordset
         * @summary Delete dns/zone.recordset
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {string} recordsetId recordsetId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dnsProjectZoneRecordsetDelete(projectId: string, locationId: string, zoneId: string, recordsetId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Zone>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dnsProjectZoneRecordsetDelete(projectId, locationId, zoneId, recordsetId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get dns/zone.recordset
         * @summary Get dns/zone.recordset
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {string} recordsetId recordsetId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dnsProjectZoneRecordsetGet(projectId: string, locationId: string, zoneId: string, recordsetId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DnsRecordset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dnsProjectZoneRecordsetGet(projectId, locationId, zoneId, recordsetId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List dns/zone.recordset
         * @summary List dns/zone.recordset
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dnsProjectZoneRecordsetList(projectId: string, locationId: string, zoneId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DnsRecordset>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dnsProjectZoneRecordsetList(projectId, locationId, zoneId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update dns/zone.recordset
         * @summary Update dns/zone.recordset
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {string} recordsetId recordsetId
         * @param {DnsProjectZoneRecordsetPatch} dnsProjectZoneRecordsetPatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dnsProjectZoneRecordsetPatch(projectId: string, locationId: string, zoneId: string, recordsetId: string, dnsProjectZoneRecordsetPatch: DnsProjectZoneRecordsetPatch, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DnsRecordset>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dnsProjectZoneRecordsetPatch(projectId, locationId, zoneId, recordsetId, dnsProjectZoneRecordsetPatch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create dns/zone.record
         * @summary Create dns/zone.record
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {string} recordsetId recordsetId
         * @param {DnsRecord} dnsRecord 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dnsProjectZoneRecordsetRecordCreate(projectId: string, locationId: string, zoneId: string, recordsetId: string, dnsRecord: DnsRecord, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DnsRecord>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dnsProjectZoneRecordsetRecordCreate(projectId, locationId, zoneId, recordsetId, dnsRecord, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete dns/zone.record
         * @summary Delete dns/zone.record
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {string} recordsetId recordsetId
         * @param {string} recordId recordId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dnsProjectZoneRecordsetRecordDelete(projectId: string, locationId: string, zoneId: string, recordsetId: string, recordId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dnsProjectZoneRecordsetRecordDelete(projectId, locationId, zoneId, recordsetId, recordId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get dns/zone.record
         * @summary Get dns/zone.record
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {string} recordsetId recordsetId
         * @param {string} recordId recordId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dnsProjectZoneRecordsetRecordGet(projectId: string, locationId: string, zoneId: string, recordsetId: string, recordId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DnsRecord>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dnsProjectZoneRecordsetRecordGet(projectId, locationId, zoneId, recordsetId, recordId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List dns/zone.record
         * @summary List dns/zone.record
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {string} recordsetId recordsetId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dnsProjectZoneRecordsetRecordList(projectId: string, locationId: string, zoneId: string, recordsetId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DnsRecord>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dnsProjectZoneRecordsetRecordList(projectId, locationId, zoneId, recordsetId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Replace dns/zone.record
         * @summary Replace dns/zone.record
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {string} recordsetId recordsetId
         * @param {Array<DnsRecord>} dnsRecord 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dnsProjectZoneRecordsetRecordPut(projectId: string, locationId: string, zoneId: string, recordsetId: string, dnsRecord: Array<DnsRecord>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<DnsRecord>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dnsProjectZoneRecordsetRecordPut(projectId, locationId, zoneId, recordsetId, dnsRecord, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get dns/zone.service
         * @summary Get dns/zone.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dnsProjectZoneServiceGet(projectId: string, locationId: string, zoneId: string, serviceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceService>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dnsProjectZoneServiceGet(projectId, locationId, zoneId, serviceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List dns/zone.service
         * @summary List dns/zone.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dnsProjectZoneServiceList(projectId: string, locationId: string, zoneId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResourceService>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dnsProjectZoneServiceList(projectId, locationId, zoneId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create dns/zone.tag
         * @summary Create dns/zone.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dnsProjectZoneTagCreate(projectId: string, locationId: string, zoneId: string, tag: Tag, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dnsProjectZoneTagCreate(projectId, locationId, zoneId, tag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete dns/zone.tag
         * @summary Delete dns/zone.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dnsProjectZoneTagDelete(projectId: string, locationId: string, zoneId: string, tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dnsProjectZoneTagDelete(projectId, locationId, zoneId, tagId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get dns/zone.tag
         * @summary Get dns/zone.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dnsProjectZoneTagGet(projectId: string, locationId: string, zoneId: string, tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dnsProjectZoneTagGet(projectId, locationId, zoneId, tagId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List dns/zone.tag
         * @summary List dns/zone.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dnsProjectZoneTagList(projectId: string, locationId: string, zoneId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dnsProjectZoneTagList(projectId, locationId, zoneId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Replace dns/zone.tag
         * @summary Replace dns/zone.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dnsProjectZoneTagPut(projectId: string, locationId: string, zoneId: string, tag: Array<Tag>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dnsProjectZoneTagPut(projectId, locationId, zoneId, tag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns modified zone
         * @summary Update dns/zone
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {DnsProjectZoneUpdate} dnsProjectZoneUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async dnsProjectZoneUpdate(projectId: string, locationId: string, zoneId: string, dnsProjectZoneUpdate: DnsProjectZoneUpdate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Zone>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.dnsProjectZoneUpdate(projectId, locationId, zoneId, dnsProjectZoneUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DnsProjectZoneApi - factory interface
 * @export
 */
export const DnsProjectZoneApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DnsProjectZoneApiFp(configuration)
    return {
        /**
         * Create zone
         * @summary Create dns/zone
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {DnsProjectZoneCreate} dnsProjectZoneCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dnsProjectZoneCreate(projectId: string, locationId: string, dnsProjectZoneCreate: DnsProjectZoneCreate, xIdempotencyKey?: string, xDryRun?: string, options?: any): AxiosPromise<Zone> {
            return localVarFp.dnsProjectZoneCreate(projectId, locationId, dnsProjectZoneCreate, xIdempotencyKey, xDryRun, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete zone
         * @summary Delete dns/zone
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dnsProjectZoneDelete(projectId: string, locationId: string, zoneId: string, options?: any): AxiosPromise<void> {
            return localVarFp.dnsProjectZoneDelete(projectId, locationId, zoneId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get dns/zone.event
         * @summary Get dns/zone.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dnsProjectZoneEventGet(projectId: string, locationId: string, zoneId: string, eventId: string, options?: any): AxiosPromise<Event> {
            return localVarFp.dnsProjectZoneEventGet(projectId, locationId, zoneId, eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * List dns/zone.event
         * @summary List dns/zone.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dnsProjectZoneEventList(projectId: string, locationId: string, zoneId: string, $limit?: number, $skip?: number, options?: any): AxiosPromise<Array<Event>> {
            return localVarFp.dnsProjectZoneEventList(projectId, locationId, zoneId, $limit, $skip, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single zone
         * @summary Get dns/zone
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dnsProjectZoneGet(projectId: string, locationId: string, zoneId: string, options?: any): AxiosPromise<Zone> {
            return localVarFp.dnsProjectZoneGet(projectId, locationId, zoneId, options).then((request) => request(axios, basePath));
        },
        /**
         * List zone
         * @summary List dns/zone
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [name] Filter by name
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dnsProjectZoneList(projectId: string, locationId: string, name?: string, tagValue?: string, tagKey?: string, options?: any): AxiosPromise<Array<Zone>> {
            return localVarFp.dnsProjectZoneList(projectId, locationId, name, tagValue, tagKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Create dns/zone.recordset
         * @summary Create dns/zone.recordset
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {DnsRecordset} dnsRecordset 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dnsProjectZoneRecordsetCreate(projectId: string, locationId: string, zoneId: string, dnsRecordset: DnsRecordset, options?: any): AxiosPromise<DnsRecordset> {
            return localVarFp.dnsProjectZoneRecordsetCreate(projectId, locationId, zoneId, dnsRecordset, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete dns/zone.recordset
         * @summary Delete dns/zone.recordset
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {string} recordsetId recordsetId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dnsProjectZoneRecordsetDelete(projectId: string, locationId: string, zoneId: string, recordsetId: string, options?: any): AxiosPromise<Zone> {
            return localVarFp.dnsProjectZoneRecordsetDelete(projectId, locationId, zoneId, recordsetId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get dns/zone.recordset
         * @summary Get dns/zone.recordset
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {string} recordsetId recordsetId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dnsProjectZoneRecordsetGet(projectId: string, locationId: string, zoneId: string, recordsetId: string, options?: any): AxiosPromise<DnsRecordset> {
            return localVarFp.dnsProjectZoneRecordsetGet(projectId, locationId, zoneId, recordsetId, options).then((request) => request(axios, basePath));
        },
        /**
         * List dns/zone.recordset
         * @summary List dns/zone.recordset
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dnsProjectZoneRecordsetList(projectId: string, locationId: string, zoneId: string, options?: any): AxiosPromise<Array<DnsRecordset>> {
            return localVarFp.dnsProjectZoneRecordsetList(projectId, locationId, zoneId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update dns/zone.recordset
         * @summary Update dns/zone.recordset
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {string} recordsetId recordsetId
         * @param {DnsProjectZoneRecordsetPatch} dnsProjectZoneRecordsetPatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dnsProjectZoneRecordsetPatch(projectId: string, locationId: string, zoneId: string, recordsetId: string, dnsProjectZoneRecordsetPatch: DnsProjectZoneRecordsetPatch, options?: any): AxiosPromise<DnsRecordset> {
            return localVarFp.dnsProjectZoneRecordsetPatch(projectId, locationId, zoneId, recordsetId, dnsProjectZoneRecordsetPatch, options).then((request) => request(axios, basePath));
        },
        /**
         * Create dns/zone.record
         * @summary Create dns/zone.record
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {string} recordsetId recordsetId
         * @param {DnsRecord} dnsRecord 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dnsProjectZoneRecordsetRecordCreate(projectId: string, locationId: string, zoneId: string, recordsetId: string, dnsRecord: DnsRecord, options?: any): AxiosPromise<DnsRecord> {
            return localVarFp.dnsProjectZoneRecordsetRecordCreate(projectId, locationId, zoneId, recordsetId, dnsRecord, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete dns/zone.record
         * @summary Delete dns/zone.record
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {string} recordsetId recordsetId
         * @param {string} recordId recordId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dnsProjectZoneRecordsetRecordDelete(projectId: string, locationId: string, zoneId: string, recordsetId: string, recordId: string, options?: any): AxiosPromise<void> {
            return localVarFp.dnsProjectZoneRecordsetRecordDelete(projectId, locationId, zoneId, recordsetId, recordId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get dns/zone.record
         * @summary Get dns/zone.record
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {string} recordsetId recordsetId
         * @param {string} recordId recordId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dnsProjectZoneRecordsetRecordGet(projectId: string, locationId: string, zoneId: string, recordsetId: string, recordId: string, options?: any): AxiosPromise<DnsRecord> {
            return localVarFp.dnsProjectZoneRecordsetRecordGet(projectId, locationId, zoneId, recordsetId, recordId, options).then((request) => request(axios, basePath));
        },
        /**
         * List dns/zone.record
         * @summary List dns/zone.record
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {string} recordsetId recordsetId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dnsProjectZoneRecordsetRecordList(projectId: string, locationId: string, zoneId: string, recordsetId: string, options?: any): AxiosPromise<Array<DnsRecord>> {
            return localVarFp.dnsProjectZoneRecordsetRecordList(projectId, locationId, zoneId, recordsetId, options).then((request) => request(axios, basePath));
        },
        /**
         * Replace dns/zone.record
         * @summary Replace dns/zone.record
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {string} recordsetId recordsetId
         * @param {Array<DnsRecord>} dnsRecord 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dnsProjectZoneRecordsetRecordPut(projectId: string, locationId: string, zoneId: string, recordsetId: string, dnsRecord: Array<DnsRecord>, options?: any): AxiosPromise<Array<DnsRecord>> {
            return localVarFp.dnsProjectZoneRecordsetRecordPut(projectId, locationId, zoneId, recordsetId, dnsRecord, options).then((request) => request(axios, basePath));
        },
        /**
         * Get dns/zone.service
         * @summary Get dns/zone.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dnsProjectZoneServiceGet(projectId: string, locationId: string, zoneId: string, serviceId: string, options?: any): AxiosPromise<ResourceService> {
            return localVarFp.dnsProjectZoneServiceGet(projectId, locationId, zoneId, serviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * List dns/zone.service
         * @summary List dns/zone.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dnsProjectZoneServiceList(projectId: string, locationId: string, zoneId: string, options?: any): AxiosPromise<Array<ResourceService>> {
            return localVarFp.dnsProjectZoneServiceList(projectId, locationId, zoneId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create dns/zone.tag
         * @summary Create dns/zone.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dnsProjectZoneTagCreate(projectId: string, locationId: string, zoneId: string, tag: Tag, options?: any): AxiosPromise<Tag> {
            return localVarFp.dnsProjectZoneTagCreate(projectId, locationId, zoneId, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete dns/zone.tag
         * @summary Delete dns/zone.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dnsProjectZoneTagDelete(projectId: string, locationId: string, zoneId: string, tagId: string, options?: any): AxiosPromise<void> {
            return localVarFp.dnsProjectZoneTagDelete(projectId, locationId, zoneId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get dns/zone.tag
         * @summary Get dns/zone.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dnsProjectZoneTagGet(projectId: string, locationId: string, zoneId: string, tagId: string, options?: any): AxiosPromise<Tag> {
            return localVarFp.dnsProjectZoneTagGet(projectId, locationId, zoneId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * List dns/zone.tag
         * @summary List dns/zone.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dnsProjectZoneTagList(projectId: string, locationId: string, zoneId: string, options?: any): AxiosPromise<Array<Tag>> {
            return localVarFp.dnsProjectZoneTagList(projectId, locationId, zoneId, options).then((request) => request(axios, basePath));
        },
        /**
         * Replace dns/zone.tag
         * @summary Replace dns/zone.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dnsProjectZoneTagPut(projectId: string, locationId: string, zoneId: string, tag: Array<Tag>, options?: any): AxiosPromise<Array<Tag>> {
            return localVarFp.dnsProjectZoneTagPut(projectId, locationId, zoneId, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns modified zone
         * @summary Update dns/zone
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} zoneId Zone Id
         * @param {DnsProjectZoneUpdate} dnsProjectZoneUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        dnsProjectZoneUpdate(projectId: string, locationId: string, zoneId: string, dnsProjectZoneUpdate: DnsProjectZoneUpdate, options?: any): AxiosPromise<Zone> {
            return localVarFp.dnsProjectZoneUpdate(projectId, locationId, zoneId, dnsProjectZoneUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DnsProjectZoneApi - object-oriented interface
 * @export
 * @class DnsProjectZoneApi
 * @extends {BaseAPI}
 */
export class DnsProjectZoneApi extends BaseAPI {
    /**
     * Create zone
     * @summary Create dns/zone
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {DnsProjectZoneCreate} dnsProjectZoneCreate 
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {string} [xDryRun] Dry run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DnsProjectZoneApi
     */
    public dnsProjectZoneCreate(projectId: string, locationId: string, dnsProjectZoneCreate: DnsProjectZoneCreate, xIdempotencyKey?: string, xDryRun?: string, options?: any) {
        return DnsProjectZoneApiFp(this.configuration).dnsProjectZoneCreate(projectId, locationId, dnsProjectZoneCreate, xIdempotencyKey, xDryRun, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete zone
     * @summary Delete dns/zone
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} zoneId Zone Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DnsProjectZoneApi
     */
    public dnsProjectZoneDelete(projectId: string, locationId: string, zoneId: string, options?: any) {
        return DnsProjectZoneApiFp(this.configuration).dnsProjectZoneDelete(projectId, locationId, zoneId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get dns/zone.event
     * @summary Get dns/zone.event
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} zoneId Zone Id
     * @param {string} eventId eventId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DnsProjectZoneApi
     */
    public dnsProjectZoneEventGet(projectId: string, locationId: string, zoneId: string, eventId: string, options?: any) {
        return DnsProjectZoneApiFp(this.configuration).dnsProjectZoneEventGet(projectId, locationId, zoneId, eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List dns/zone.event
     * @summary List dns/zone.event
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} zoneId Zone Id
     * @param {number} [$limit] $limit
     * @param {number} [$skip] $skip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DnsProjectZoneApi
     */
    public dnsProjectZoneEventList(projectId: string, locationId: string, zoneId: string, $limit?: number, $skip?: number, options?: any) {
        return DnsProjectZoneApiFp(this.configuration).dnsProjectZoneEventList(projectId, locationId, zoneId, $limit, $skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single zone
     * @summary Get dns/zone
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} zoneId Zone Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DnsProjectZoneApi
     */
    public dnsProjectZoneGet(projectId: string, locationId: string, zoneId: string, options?: any) {
        return DnsProjectZoneApiFp(this.configuration).dnsProjectZoneGet(projectId, locationId, zoneId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List zone
     * @summary List dns/zone
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} [name] Filter by name
     * @param {string} [tagValue] Filter by tag.value
     * @param {string} [tagKey] Filter by tag.key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DnsProjectZoneApi
     */
    public dnsProjectZoneList(projectId: string, locationId: string, name?: string, tagValue?: string, tagKey?: string, options?: any) {
        return DnsProjectZoneApiFp(this.configuration).dnsProjectZoneList(projectId, locationId, name, tagValue, tagKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create dns/zone.recordset
     * @summary Create dns/zone.recordset
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} zoneId Zone Id
     * @param {DnsRecordset} dnsRecordset 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DnsProjectZoneApi
     */
    public dnsProjectZoneRecordsetCreate(projectId: string, locationId: string, zoneId: string, dnsRecordset: DnsRecordset, options?: any) {
        return DnsProjectZoneApiFp(this.configuration).dnsProjectZoneRecordsetCreate(projectId, locationId, zoneId, dnsRecordset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete dns/zone.recordset
     * @summary Delete dns/zone.recordset
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} zoneId Zone Id
     * @param {string} recordsetId recordsetId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DnsProjectZoneApi
     */
    public dnsProjectZoneRecordsetDelete(projectId: string, locationId: string, zoneId: string, recordsetId: string, options?: any) {
        return DnsProjectZoneApiFp(this.configuration).dnsProjectZoneRecordsetDelete(projectId, locationId, zoneId, recordsetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get dns/zone.recordset
     * @summary Get dns/zone.recordset
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} zoneId Zone Id
     * @param {string} recordsetId recordsetId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DnsProjectZoneApi
     */
    public dnsProjectZoneRecordsetGet(projectId: string, locationId: string, zoneId: string, recordsetId: string, options?: any) {
        return DnsProjectZoneApiFp(this.configuration).dnsProjectZoneRecordsetGet(projectId, locationId, zoneId, recordsetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List dns/zone.recordset
     * @summary List dns/zone.recordset
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} zoneId Zone Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DnsProjectZoneApi
     */
    public dnsProjectZoneRecordsetList(projectId: string, locationId: string, zoneId: string, options?: any) {
        return DnsProjectZoneApiFp(this.configuration).dnsProjectZoneRecordsetList(projectId, locationId, zoneId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update dns/zone.recordset
     * @summary Update dns/zone.recordset
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} zoneId Zone Id
     * @param {string} recordsetId recordsetId
     * @param {DnsProjectZoneRecordsetPatch} dnsProjectZoneRecordsetPatch 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DnsProjectZoneApi
     */
    public dnsProjectZoneRecordsetPatch(projectId: string, locationId: string, zoneId: string, recordsetId: string, dnsProjectZoneRecordsetPatch: DnsProjectZoneRecordsetPatch, options?: any) {
        return DnsProjectZoneApiFp(this.configuration).dnsProjectZoneRecordsetPatch(projectId, locationId, zoneId, recordsetId, dnsProjectZoneRecordsetPatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create dns/zone.record
     * @summary Create dns/zone.record
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} zoneId Zone Id
     * @param {string} recordsetId recordsetId
     * @param {DnsRecord} dnsRecord 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DnsProjectZoneApi
     */
    public dnsProjectZoneRecordsetRecordCreate(projectId: string, locationId: string, zoneId: string, recordsetId: string, dnsRecord: DnsRecord, options?: any) {
        return DnsProjectZoneApiFp(this.configuration).dnsProjectZoneRecordsetRecordCreate(projectId, locationId, zoneId, recordsetId, dnsRecord, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete dns/zone.record
     * @summary Delete dns/zone.record
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} zoneId Zone Id
     * @param {string} recordsetId recordsetId
     * @param {string} recordId recordId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DnsProjectZoneApi
     */
    public dnsProjectZoneRecordsetRecordDelete(projectId: string, locationId: string, zoneId: string, recordsetId: string, recordId: string, options?: any) {
        return DnsProjectZoneApiFp(this.configuration).dnsProjectZoneRecordsetRecordDelete(projectId, locationId, zoneId, recordsetId, recordId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get dns/zone.record
     * @summary Get dns/zone.record
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} zoneId Zone Id
     * @param {string} recordsetId recordsetId
     * @param {string} recordId recordId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DnsProjectZoneApi
     */
    public dnsProjectZoneRecordsetRecordGet(projectId: string, locationId: string, zoneId: string, recordsetId: string, recordId: string, options?: any) {
        return DnsProjectZoneApiFp(this.configuration).dnsProjectZoneRecordsetRecordGet(projectId, locationId, zoneId, recordsetId, recordId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List dns/zone.record
     * @summary List dns/zone.record
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} zoneId Zone Id
     * @param {string} recordsetId recordsetId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DnsProjectZoneApi
     */
    public dnsProjectZoneRecordsetRecordList(projectId: string, locationId: string, zoneId: string, recordsetId: string, options?: any) {
        return DnsProjectZoneApiFp(this.configuration).dnsProjectZoneRecordsetRecordList(projectId, locationId, zoneId, recordsetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replace dns/zone.record
     * @summary Replace dns/zone.record
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} zoneId Zone Id
     * @param {string} recordsetId recordsetId
     * @param {Array<DnsRecord>} dnsRecord 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DnsProjectZoneApi
     */
    public dnsProjectZoneRecordsetRecordPut(projectId: string, locationId: string, zoneId: string, recordsetId: string, dnsRecord: Array<DnsRecord>, options?: any) {
        return DnsProjectZoneApiFp(this.configuration).dnsProjectZoneRecordsetRecordPut(projectId, locationId, zoneId, recordsetId, dnsRecord, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get dns/zone.service
     * @summary Get dns/zone.service
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} zoneId Zone Id
     * @param {string} serviceId serviceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DnsProjectZoneApi
     */
    public dnsProjectZoneServiceGet(projectId: string, locationId: string, zoneId: string, serviceId: string, options?: any) {
        return DnsProjectZoneApiFp(this.configuration).dnsProjectZoneServiceGet(projectId, locationId, zoneId, serviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List dns/zone.service
     * @summary List dns/zone.service
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} zoneId Zone Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DnsProjectZoneApi
     */
    public dnsProjectZoneServiceList(projectId: string, locationId: string, zoneId: string, options?: any) {
        return DnsProjectZoneApiFp(this.configuration).dnsProjectZoneServiceList(projectId, locationId, zoneId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create dns/zone.tag
     * @summary Create dns/zone.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} zoneId Zone Id
     * @param {Tag} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DnsProjectZoneApi
     */
    public dnsProjectZoneTagCreate(projectId: string, locationId: string, zoneId: string, tag: Tag, options?: any) {
        return DnsProjectZoneApiFp(this.configuration).dnsProjectZoneTagCreate(projectId, locationId, zoneId, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete dns/zone.tag
     * @summary Delete dns/zone.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} zoneId Zone Id
     * @param {string} tagId tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DnsProjectZoneApi
     */
    public dnsProjectZoneTagDelete(projectId: string, locationId: string, zoneId: string, tagId: string, options?: any) {
        return DnsProjectZoneApiFp(this.configuration).dnsProjectZoneTagDelete(projectId, locationId, zoneId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get dns/zone.tag
     * @summary Get dns/zone.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} zoneId Zone Id
     * @param {string} tagId tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DnsProjectZoneApi
     */
    public dnsProjectZoneTagGet(projectId: string, locationId: string, zoneId: string, tagId: string, options?: any) {
        return DnsProjectZoneApiFp(this.configuration).dnsProjectZoneTagGet(projectId, locationId, zoneId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List dns/zone.tag
     * @summary List dns/zone.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} zoneId Zone Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DnsProjectZoneApi
     */
    public dnsProjectZoneTagList(projectId: string, locationId: string, zoneId: string, options?: any) {
        return DnsProjectZoneApiFp(this.configuration).dnsProjectZoneTagList(projectId, locationId, zoneId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replace dns/zone.tag
     * @summary Replace dns/zone.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} zoneId Zone Id
     * @param {Array<Tag>} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DnsProjectZoneApi
     */
    public dnsProjectZoneTagPut(projectId: string, locationId: string, zoneId: string, tag: Array<Tag>, options?: any) {
        return DnsProjectZoneApiFp(this.configuration).dnsProjectZoneTagPut(projectId, locationId, zoneId, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns modified zone
     * @summary Update dns/zone
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} zoneId Zone Id
     * @param {DnsProjectZoneUpdate} dnsProjectZoneUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DnsProjectZoneApi
     */
    public dnsProjectZoneUpdate(projectId: string, locationId: string, zoneId: string, dnsProjectZoneUpdate: DnsProjectZoneUpdate, options?: any) {
        return DnsProjectZoneApiFp(this.configuration).dnsProjectZoneUpdate(projectId, locationId, zoneId, dnsProjectZoneUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * IamOrganisationApi - axios parameter creator
 * @export
 */
export const IamOrganisationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List iam/organisation.billing
         * @summary List iam/organisation.billing
         * @param {string} organisationId Organisation Id
         * @param {string} [start] start
         * @param {string} [end] end
         * @param {string} [resourceType] resource.type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationBillingList: async (organisationId: string, start?: string, end?: string, resourceType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            assertParamExists('iamOrganisationBillingList', 'organisationId', organisationId)
            const localVarPath = `/iam/organisation/{organisationId}/billing`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString() :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString() :
                    end;
            }

            if (resourceType !== undefined) {
                localVarQueryParameter['resource.type'] = resourceType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create organisation
         * @summary Create iam/organisation
         * @param {IamOrganisationCreate} iamOrganisationCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationCreate: async (iamOrganisationCreate: IamOrganisationCreate, xIdempotencyKey?: string, xDryRun?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'iamOrganisationCreate' is not null or undefined
            assertParamExists('iamOrganisationCreate', 'iamOrganisationCreate', iamOrganisationCreate)
            const localVarPath = `/iam/organisation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }

            if (xDryRun !== undefined && xDryRun !== null) {
                localVarHeaderParameter['x-dry-run'] = String(xDryRun);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(iamOrganisationCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete organisation
         * @summary Delete iam/organisation
         * @param {string} organisationId Organisation Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationDelete: async (organisationId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            assertParamExists('iamOrganisationDelete', 'organisationId', organisationId)
            const localVarPath = `/iam/organisation/{organisationId}`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get iam/organisation.event
         * @summary Get iam/organisation.event
         * @param {string} organisationId Organisation Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationEventGet: async (organisationId: string, eventId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            assertParamExists('iamOrganisationEventGet', 'organisationId', organisationId)
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('iamOrganisationEventGet', 'eventId', eventId)
            const localVarPath = `/iam/organisation/{organisationId}/event/{eventId}`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)))
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List iam/organisation.event
         * @summary List iam/organisation.event
         * @param {string} organisationId Organisation Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationEventList: async (organisationId: string, $limit?: number, $skip?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            assertParamExists('iamOrganisationEventList', 'organisationId', organisationId)
            const localVarPath = `/iam/organisation/{organisationId}/event`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if ($limit !== undefined) {
                localVarQueryParameter['$limit'] = $limit;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single organisation
         * @summary Get iam/organisation
         * @param {string} organisationId Organisation Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationGet: async (organisationId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            assertParamExists('iamOrganisationGet', 'organisationId', organisationId)
            const localVarPath = `/iam/organisation/{organisationId}`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * action accept
         * @summary Accept iam/organisation.invitation
         * @param {string} organisationId Organisation Id
         * @param {string} invitationId invitationId
         * @param {IamOrganisationInvitationAccept} iamOrganisationInvitationAccept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationInvitationAccept: async (organisationId: string, invitationId: string, iamOrganisationInvitationAccept: IamOrganisationInvitationAccept, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            assertParamExists('iamOrganisationInvitationAccept', 'organisationId', organisationId)
            // verify required parameter 'invitationId' is not null or undefined
            assertParamExists('iamOrganisationInvitationAccept', 'invitationId', invitationId)
            // verify required parameter 'iamOrganisationInvitationAccept' is not null or undefined
            assertParamExists('iamOrganisationInvitationAccept', 'iamOrganisationInvitationAccept', iamOrganisationInvitationAccept)
            const localVarPath = `/iam/organisation/{organisationId}/invitation/{invitationId}/actions/accept`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)))
                .replace(`{${"invitationId"}}`, encodeURIComponent(String(invitationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(iamOrganisationInvitationAccept, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete iam/organisation.invitation
         * @summary Delete iam/organisation.invitation
         * @param {string} organisationId Organisation Id
         * @param {string} invitationId invitationId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationInvitationDelete: async (organisationId: string, invitationId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            assertParamExists('iamOrganisationInvitationDelete', 'organisationId', organisationId)
            // verify required parameter 'invitationId' is not null or undefined
            assertParamExists('iamOrganisationInvitationDelete', 'invitationId', invitationId)
            const localVarPath = `/iam/organisation/{organisationId}/invitation/{invitationId}`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)))
                .replace(`{${"invitationId"}}`, encodeURIComponent(String(invitationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get iam/organisation.invitation
         * @summary Get iam/organisation.invitation
         * @param {string} organisationId Organisation Id
         * @param {string} invitationId invitationId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationInvitationGet: async (organisationId: string, invitationId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            assertParamExists('iamOrganisationInvitationGet', 'organisationId', organisationId)
            // verify required parameter 'invitationId' is not null or undefined
            assertParamExists('iamOrganisationInvitationGet', 'invitationId', invitationId)
            const localVarPath = `/iam/organisation/{organisationId}/invitation/{invitationId}`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)))
                .replace(`{${"invitationId"}}`, encodeURIComponent(String(invitationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List iam/organisation.invitation
         * @summary List iam/organisation.invitation
         * @param {string} organisationId Organisation Id
         * @param {string} [resource] resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationInvitationList: async (organisationId: string, resource?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            assertParamExists('iamOrganisationInvitationList', 'organisationId', organisationId)
            const localVarPath = `/iam/organisation/{organisationId}/invitation`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (resource !== undefined) {
                localVarQueryParameter['resource'] = resource;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * action download
         * @summary Download iam/organisation.invoice
         * @param {string} organisationId Organisation Id
         * @param {string} invoiceId invoiceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationInvoiceDownload: async (organisationId: string, invoiceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            assertParamExists('iamOrganisationInvoiceDownload', 'organisationId', organisationId)
            // verify required parameter 'invoiceId' is not null or undefined
            assertParamExists('iamOrganisationInvoiceDownload', 'invoiceId', invoiceId)
            const localVarPath = `/iam/organisation/{organisationId}/invoice/{invoiceId}/actions/download`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)))
                .replace(`{${"invoiceId"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get iam/organisation.invoice
         * @summary Get iam/organisation.invoice
         * @param {string} organisationId Organisation Id
         * @param {string} invoiceId invoiceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationInvoiceGet: async (organisationId: string, invoiceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            assertParamExists('iamOrganisationInvoiceGet', 'organisationId', organisationId)
            // verify required parameter 'invoiceId' is not null or undefined
            assertParamExists('iamOrganisationInvoiceGet', 'invoiceId', invoiceId)
            const localVarPath = `/iam/organisation/{organisationId}/invoice/{invoiceId}`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)))
                .replace(`{${"invoiceId"}}`, encodeURIComponent(String(invoiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List iam/organisation.invoice
         * @summary List iam/organisation.invoice
         * @param {string} organisationId Organisation Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationInvoiceList: async (organisationId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            assertParamExists('iamOrganisationInvoiceList', 'organisationId', organisationId)
            const localVarPath = `/iam/organisation/{organisationId}/invoice`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List organisation
         * @summary List iam/organisation
         * @param {string} [name] Filter by name
         * @param {string} [billingCompany] Filter by billing.company
         * @param {number} [$limit] Filter by $limit
         * @param {boolean} [active] Filter by active
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationList: async (name?: string, billingCompany?: string, $limit?: number, active?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/iam/organisation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (billingCompany !== undefined) {
                localVarQueryParameter['billing.company'] = billingCompany;
            }

            if ($limit !== undefined) {
                localVarQueryParameter['$limit'] = $limit;
            }

            if (active !== undefined) {
                localVarQueryParameter['active'] = active;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create iam/organisation.ownership
         * @summary Create iam/organisation.ownership
         * @param {string} organisationId Organisation Id
         * @param {IamOrganisationOwnershipCreate} iamOrganisationOwnershipCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationOwnershipCreate: async (organisationId: string, iamOrganisationOwnershipCreate: IamOrganisationOwnershipCreate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            assertParamExists('iamOrganisationOwnershipCreate', 'organisationId', organisationId)
            // verify required parameter 'iamOrganisationOwnershipCreate' is not null or undefined
            assertParamExists('iamOrganisationOwnershipCreate', 'iamOrganisationOwnershipCreate', iamOrganisationOwnershipCreate)
            const localVarPath = `/iam/organisation/{organisationId}/ownership`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(iamOrganisationOwnershipCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete iam/organisation.ownership
         * @summary Delete iam/organisation.ownership
         * @param {string} organisationId Organisation Id
         * @param {string} ownershipId ownershipId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationOwnershipDelete: async (organisationId: string, ownershipId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            assertParamExists('iamOrganisationOwnershipDelete', 'organisationId', organisationId)
            // verify required parameter 'ownershipId' is not null or undefined
            assertParamExists('iamOrganisationOwnershipDelete', 'ownershipId', ownershipId)
            const localVarPath = `/iam/organisation/{organisationId}/ownership/{ownershipId}`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)))
                .replace(`{${"ownershipId"}}`, encodeURIComponent(String(ownershipId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get iam/organisation.ownership
         * @summary Get iam/organisation.ownership
         * @param {string} organisationId Organisation Id
         * @param {string} ownershipId ownershipId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationOwnershipGet: async (organisationId: string, ownershipId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            assertParamExists('iamOrganisationOwnershipGet', 'organisationId', organisationId)
            // verify required parameter 'ownershipId' is not null or undefined
            assertParamExists('iamOrganisationOwnershipGet', 'ownershipId', ownershipId)
            const localVarPath = `/iam/organisation/{organisationId}/ownership/{ownershipId}`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)))
                .replace(`{${"ownershipId"}}`, encodeURIComponent(String(ownershipId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List iam/organisation.ownership
         * @summary List iam/organisation.ownership
         * @param {string} organisationId Organisation Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationOwnershipList: async (organisationId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            assertParamExists('iamOrganisationOwnershipList', 'organisationId', organisationId)
            const localVarPath = `/iam/organisation/{organisationId}/ownership`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * action allocate
         * @summary Allocate iam/organisation.payment
         * @param {string} organisationId Organisation Id
         * @param {string} paymentId paymentId
         * @param {IamOrganisationPaymentAllocate} iamOrganisationPaymentAllocate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationPaymentAllocate: async (organisationId: string, paymentId: string, iamOrganisationPaymentAllocate: IamOrganisationPaymentAllocate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            assertParamExists('iamOrganisationPaymentAllocate', 'organisationId', organisationId)
            // verify required parameter 'paymentId' is not null or undefined
            assertParamExists('iamOrganisationPaymentAllocate', 'paymentId', paymentId)
            // verify required parameter 'iamOrganisationPaymentAllocate' is not null or undefined
            assertParamExists('iamOrganisationPaymentAllocate', 'iamOrganisationPaymentAllocate', iamOrganisationPaymentAllocate)
            const localVarPath = `/iam/organisation/{organisationId}/payment/{paymentId}/actions/allocate`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)))
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(iamOrganisationPaymentAllocate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get iam/organisation.payment
         * @summary Get iam/organisation.payment
         * @param {string} organisationId Organisation Id
         * @param {string} paymentId paymentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationPaymentGet: async (organisationId: string, paymentId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            assertParamExists('iamOrganisationPaymentGet', 'organisationId', organisationId)
            // verify required parameter 'paymentId' is not null or undefined
            assertParamExists('iamOrganisationPaymentGet', 'paymentId', paymentId)
            const localVarPath = `/iam/organisation/{organisationId}/payment/{paymentId}`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)))
                .replace(`{${"paymentId"}}`, encodeURIComponent(String(paymentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List iam/organisation.payment
         * @summary List iam/organisation.payment
         * @param {string} organisationId Organisation Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationPaymentList: async (organisationId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            assertParamExists('iamOrganisationPaymentList', 'organisationId', organisationId)
            const localVarPath = `/iam/organisation/{organisationId}/payment`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create iam/organisation.proforma
         * @summary Create iam/organisation.proforma
         * @param {string} organisationId Organisation Id
         * @param {IamOrganisationProformaCreate} iamOrganisationProformaCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationProformaCreate: async (organisationId: string, iamOrganisationProformaCreate: IamOrganisationProformaCreate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            assertParamExists('iamOrganisationProformaCreate', 'organisationId', organisationId)
            // verify required parameter 'iamOrganisationProformaCreate' is not null or undefined
            assertParamExists('iamOrganisationProformaCreate', 'iamOrganisationProformaCreate', iamOrganisationProformaCreate)
            const localVarPath = `/iam/organisation/{organisationId}/proforma`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(iamOrganisationProformaCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * action download
         * @summary Download iam/organisation.proforma
         * @param {string} organisationId Organisation Id
         * @param {string} proformaId proformaId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationProformaDownload: async (organisationId: string, proformaId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            assertParamExists('iamOrganisationProformaDownload', 'organisationId', organisationId)
            // verify required parameter 'proformaId' is not null or undefined
            assertParamExists('iamOrganisationProformaDownload', 'proformaId', proformaId)
            const localVarPath = `/iam/organisation/{organisationId}/proforma/{proformaId}/actions/download`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)))
                .replace(`{${"proformaId"}}`, encodeURIComponent(String(proformaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get iam/organisation.proforma
         * @summary Get iam/organisation.proforma
         * @param {string} organisationId Organisation Id
         * @param {string} proformaId proformaId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationProformaGet: async (organisationId: string, proformaId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            assertParamExists('iamOrganisationProformaGet', 'organisationId', organisationId)
            // verify required parameter 'proformaId' is not null or undefined
            assertParamExists('iamOrganisationProformaGet', 'proformaId', proformaId)
            const localVarPath = `/iam/organisation/{organisationId}/proforma/{proformaId}`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)))
                .replace(`{${"proformaId"}}`, encodeURIComponent(String(proformaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List iam/organisation.proforma
         * @summary List iam/organisation.proforma
         * @param {string} organisationId Organisation Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationProformaList: async (organisationId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            assertParamExists('iamOrganisationProformaList', 'organisationId', organisationId)
            const localVarPath = `/iam/organisation/{organisationId}/proforma`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get iam/organisation.service
         * @summary Get iam/organisation.service
         * @param {string} organisationId Organisation Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationServiceGet: async (organisationId: string, serviceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            assertParamExists('iamOrganisationServiceGet', 'organisationId', organisationId)
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('iamOrganisationServiceGet', 'serviceId', serviceId)
            const localVarPath = `/iam/organisation/{organisationId}/service/{serviceId}`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)))
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List iam/organisation.service
         * @summary List iam/organisation.service
         * @param {string} organisationId Organisation Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationServiceList: async (organisationId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            assertParamExists('iamOrganisationServiceList', 'organisationId', organisationId)
            const localVarPath = `/iam/organisation/{organisationId}/service`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * action accept
         * @summary Accept iam/organisation.transfer
         * @param {string} organisationId Organisation Id
         * @param {string} transferId transferId
         * @param {IamOrganisationTransferAccept} iamOrganisationTransferAccept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationTransferAccept: async (organisationId: string, transferId: string, iamOrganisationTransferAccept: IamOrganisationTransferAccept, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            assertParamExists('iamOrganisationTransferAccept', 'organisationId', organisationId)
            // verify required parameter 'transferId' is not null or undefined
            assertParamExists('iamOrganisationTransferAccept', 'transferId', transferId)
            // verify required parameter 'iamOrganisationTransferAccept' is not null or undefined
            assertParamExists('iamOrganisationTransferAccept', 'iamOrganisationTransferAccept', iamOrganisationTransferAccept)
            const localVarPath = `/iam/organisation/{organisationId}/transfer/{transferId}/actions/accept`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)))
                .replace(`{${"transferId"}}`, encodeURIComponent(String(transferId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(iamOrganisationTransferAccept, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get iam/organisation.transfer
         * @summary Get iam/organisation.transfer
         * @param {string} organisationId Organisation Id
         * @param {string} transferId transferId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationTransferGet: async (organisationId: string, transferId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            assertParamExists('iamOrganisationTransferGet', 'organisationId', organisationId)
            // verify required parameter 'transferId' is not null or undefined
            assertParamExists('iamOrganisationTransferGet', 'transferId', transferId)
            const localVarPath = `/iam/organisation/{organisationId}/transfer/{transferId}`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)))
                .replace(`{${"transferId"}}`, encodeURIComponent(String(transferId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List iam/organisation.transfer
         * @summary List iam/organisation.transfer
         * @param {string} organisationId Organisation Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationTransferList: async (organisationId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            assertParamExists('iamOrganisationTransferList', 'organisationId', organisationId)
            const localVarPath = `/iam/organisation/{organisationId}/transfer`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns modified organisation
         * @summary Update iam/organisation
         * @param {string} organisationId Organisation Id
         * @param {IamOrganisationUpdate} iamOrganisationUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationUpdate: async (organisationId: string, iamOrganisationUpdate: IamOrganisationUpdate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            assertParamExists('iamOrganisationUpdate', 'organisationId', organisationId)
            // verify required parameter 'iamOrganisationUpdate' is not null or undefined
            assertParamExists('iamOrganisationUpdate', 'iamOrganisationUpdate', iamOrganisationUpdate)
            const localVarPath = `/iam/organisation/{organisationId}`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(iamOrganisationUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IamOrganisationApi - functional programming interface
 * @export
 */
export const IamOrganisationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IamOrganisationApiAxiosParamCreator(configuration)
    return {
        /**
         * List iam/organisation.billing
         * @summary List iam/organisation.billing
         * @param {string} organisationId Organisation Id
         * @param {string} [start] start
         * @param {string} [end] end
         * @param {string} [resourceType] resource.type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationBillingList(organisationId: string, start?: string, end?: string, resourceType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Billing>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamOrganisationBillingList(organisationId, start, end, resourceType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create organisation
         * @summary Create iam/organisation
         * @param {IamOrganisationCreate} iamOrganisationCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationCreate(iamOrganisationCreate: IamOrganisationCreate, xIdempotencyKey?: string, xDryRun?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Organisation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamOrganisationCreate(iamOrganisationCreate, xIdempotencyKey, xDryRun, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete organisation
         * @summary Delete iam/organisation
         * @param {string} organisationId Organisation Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationDelete(organisationId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamOrganisationDelete(organisationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get iam/organisation.event
         * @summary Get iam/organisation.event
         * @param {string} organisationId Organisation Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationEventGet(organisationId: string, eventId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamOrganisationEventGet(organisationId, eventId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List iam/organisation.event
         * @summary List iam/organisation.event
         * @param {string} organisationId Organisation Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationEventList(organisationId: string, $limit?: number, $skip?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Event>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamOrganisationEventList(organisationId, $limit, $skip, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a single organisation
         * @summary Get iam/organisation
         * @param {string} organisationId Organisation Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationGet(organisationId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Organisation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamOrganisationGet(organisationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * action accept
         * @summary Accept iam/organisation.invitation
         * @param {string} organisationId Organisation Id
         * @param {string} invitationId invitationId
         * @param {IamOrganisationInvitationAccept} iamOrganisationInvitationAccept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationInvitationAccept(organisationId: string, invitationId: string, iamOrganisationInvitationAccept: IamOrganisationInvitationAccept, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Invitation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamOrganisationInvitationAccept(organisationId, invitationId, iamOrganisationInvitationAccept, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete iam/organisation.invitation
         * @summary Delete iam/organisation.invitation
         * @param {string} organisationId Organisation Id
         * @param {string} invitationId invitationId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationInvitationDelete(organisationId: string, invitationId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamOrganisationInvitationDelete(organisationId, invitationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get iam/organisation.invitation
         * @summary Get iam/organisation.invitation
         * @param {string} organisationId Organisation Id
         * @param {string} invitationId invitationId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationInvitationGet(organisationId: string, invitationId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Invitation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamOrganisationInvitationGet(organisationId, invitationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List iam/organisation.invitation
         * @summary List iam/organisation.invitation
         * @param {string} organisationId Organisation Id
         * @param {string} [resource] resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationInvitationList(organisationId: string, resource?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Invitation>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamOrganisationInvitationList(organisationId, resource, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * action download
         * @summary Download iam/organisation.invoice
         * @param {string} organisationId Organisation Id
         * @param {string} invoiceId invoiceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationInvoiceDownload(organisationId: string, invoiceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamOrganisationInvoiceDownload(organisationId, invoiceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get iam/organisation.invoice
         * @summary Get iam/organisation.invoice
         * @param {string} organisationId Organisation Id
         * @param {string} invoiceId invoiceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationInvoiceGet(organisationId: string, invoiceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Invoice>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamOrganisationInvoiceGet(organisationId, invoiceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List iam/organisation.invoice
         * @summary List iam/organisation.invoice
         * @param {string} organisationId Organisation Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationInvoiceList(organisationId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Invoice>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamOrganisationInvoiceList(organisationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List organisation
         * @summary List iam/organisation
         * @param {string} [name] Filter by name
         * @param {string} [billingCompany] Filter by billing.company
         * @param {number} [$limit] Filter by $limit
         * @param {boolean} [active] Filter by active
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationList(name?: string, billingCompany?: string, $limit?: number, active?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Organisation>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamOrganisationList(name, billingCompany, $limit, active, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create iam/organisation.ownership
         * @summary Create iam/organisation.ownership
         * @param {string} organisationId Organisation Id
         * @param {IamOrganisationOwnershipCreate} iamOrganisationOwnershipCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationOwnershipCreate(organisationId: string, iamOrganisationOwnershipCreate: IamOrganisationOwnershipCreate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Organisation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamOrganisationOwnershipCreate(organisationId, iamOrganisationOwnershipCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete iam/organisation.ownership
         * @summary Delete iam/organisation.ownership
         * @param {string} organisationId Organisation Id
         * @param {string} ownershipId ownershipId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationOwnershipDelete(organisationId: string, ownershipId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamOrganisationOwnershipDelete(organisationId, ownershipId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get iam/organisation.ownership
         * @summary Get iam/organisation.ownership
         * @param {string} organisationId Organisation Id
         * @param {string} ownershipId ownershipId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationOwnershipGet(organisationId: string, ownershipId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Ownership>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamOrganisationOwnershipGet(organisationId, ownershipId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List iam/organisation.ownership
         * @summary List iam/organisation.ownership
         * @param {string} organisationId Organisation Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationOwnershipList(organisationId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Ownership>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamOrganisationOwnershipList(organisationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * action allocate
         * @summary Allocate iam/organisation.payment
         * @param {string} organisationId Organisation Id
         * @param {string} paymentId paymentId
         * @param {IamOrganisationPaymentAllocate} iamOrganisationPaymentAllocate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationPaymentAllocate(organisationId: string, paymentId: string, iamOrganisationPaymentAllocate: IamOrganisationPaymentAllocate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamOrganisationPaymentAllocate(organisationId, paymentId, iamOrganisationPaymentAllocate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get iam/organisation.payment
         * @summary Get iam/organisation.payment
         * @param {string} organisationId Organisation Id
         * @param {string} paymentId paymentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationPaymentGet(organisationId: string, paymentId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Payment>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamOrganisationPaymentGet(organisationId, paymentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List iam/organisation.payment
         * @summary List iam/organisation.payment
         * @param {string} organisationId Organisation Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationPaymentList(organisationId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Payment>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamOrganisationPaymentList(organisationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create iam/organisation.proforma
         * @summary Create iam/organisation.proforma
         * @param {string} organisationId Organisation Id
         * @param {IamOrganisationProformaCreate} iamOrganisationProformaCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationProformaCreate(organisationId: string, iamOrganisationProformaCreate: IamOrganisationProformaCreate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Proforma>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamOrganisationProformaCreate(organisationId, iamOrganisationProformaCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * action download
         * @summary Download iam/organisation.proforma
         * @param {string} organisationId Organisation Id
         * @param {string} proformaId proformaId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationProformaDownload(organisationId: string, proformaId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamOrganisationProformaDownload(organisationId, proformaId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get iam/organisation.proforma
         * @summary Get iam/organisation.proforma
         * @param {string} organisationId Organisation Id
         * @param {string} proformaId proformaId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationProformaGet(organisationId: string, proformaId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Proforma>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamOrganisationProformaGet(organisationId, proformaId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List iam/organisation.proforma
         * @summary List iam/organisation.proforma
         * @param {string} organisationId Organisation Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationProformaList(organisationId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Proforma>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamOrganisationProformaList(organisationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get iam/organisation.service
         * @summary Get iam/organisation.service
         * @param {string} organisationId Organisation Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationServiceGet(organisationId: string, serviceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceService>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamOrganisationServiceGet(organisationId, serviceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List iam/organisation.service
         * @summary List iam/organisation.service
         * @param {string} organisationId Organisation Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationServiceList(organisationId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResourceService>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamOrganisationServiceList(organisationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * action accept
         * @summary Accept iam/organisation.transfer
         * @param {string} organisationId Organisation Id
         * @param {string} transferId transferId
         * @param {IamOrganisationTransferAccept} iamOrganisationTransferAccept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationTransferAccept(organisationId: string, transferId: string, iamOrganisationTransferAccept: IamOrganisationTransferAccept, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Transfer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamOrganisationTransferAccept(organisationId, transferId, iamOrganisationTransferAccept, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get iam/organisation.transfer
         * @summary Get iam/organisation.transfer
         * @param {string} organisationId Organisation Id
         * @param {string} transferId transferId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationTransferGet(organisationId: string, transferId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Transfer>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamOrganisationTransferGet(organisationId, transferId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List iam/organisation.transfer
         * @summary List iam/organisation.transfer
         * @param {string} organisationId Organisation Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationTransferList(organisationId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Transfer>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamOrganisationTransferList(organisationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns modified organisation
         * @summary Update iam/organisation
         * @param {string} organisationId Organisation Id
         * @param {IamOrganisationUpdate} iamOrganisationUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationUpdate(organisationId: string, iamOrganisationUpdate: IamOrganisationUpdate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Organisation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamOrganisationUpdate(organisationId, iamOrganisationUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * IamOrganisationApi - factory interface
 * @export
 */
export const IamOrganisationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IamOrganisationApiFp(configuration)
    return {
        /**
         * List iam/organisation.billing
         * @summary List iam/organisation.billing
         * @param {string} organisationId Organisation Id
         * @param {string} [start] start
         * @param {string} [end] end
         * @param {string} [resourceType] resource.type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationBillingList(organisationId: string, start?: string, end?: string, resourceType?: string, options?: any): AxiosPromise<Array<Billing>> {
            return localVarFp.iamOrganisationBillingList(organisationId, start, end, resourceType, options).then((request) => request(axios, basePath));
        },
        /**
         * Create organisation
         * @summary Create iam/organisation
         * @param {IamOrganisationCreate} iamOrganisationCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationCreate(iamOrganisationCreate: IamOrganisationCreate, xIdempotencyKey?: string, xDryRun?: string, options?: any): AxiosPromise<Organisation> {
            return localVarFp.iamOrganisationCreate(iamOrganisationCreate, xIdempotencyKey, xDryRun, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete organisation
         * @summary Delete iam/organisation
         * @param {string} organisationId Organisation Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationDelete(organisationId: string, options?: any): AxiosPromise<void> {
            return localVarFp.iamOrganisationDelete(organisationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get iam/organisation.event
         * @summary Get iam/organisation.event
         * @param {string} organisationId Organisation Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationEventGet(organisationId: string, eventId: string, options?: any): AxiosPromise<Event> {
            return localVarFp.iamOrganisationEventGet(organisationId, eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * List iam/organisation.event
         * @summary List iam/organisation.event
         * @param {string} organisationId Organisation Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationEventList(organisationId: string, $limit?: number, $skip?: number, options?: any): AxiosPromise<Array<Event>> {
            return localVarFp.iamOrganisationEventList(organisationId, $limit, $skip, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single organisation
         * @summary Get iam/organisation
         * @param {string} organisationId Organisation Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationGet(organisationId: string, options?: any): AxiosPromise<Organisation> {
            return localVarFp.iamOrganisationGet(organisationId, options).then((request) => request(axios, basePath));
        },
        /**
         * action accept
         * @summary Accept iam/organisation.invitation
         * @param {string} organisationId Organisation Id
         * @param {string} invitationId invitationId
         * @param {IamOrganisationInvitationAccept} iamOrganisationInvitationAccept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationInvitationAccept(organisationId: string, invitationId: string, iamOrganisationInvitationAccept: IamOrganisationInvitationAccept, options?: any): AxiosPromise<Invitation> {
            return localVarFp.iamOrganisationInvitationAccept(organisationId, invitationId, iamOrganisationInvitationAccept, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete iam/organisation.invitation
         * @summary Delete iam/organisation.invitation
         * @param {string} organisationId Organisation Id
         * @param {string} invitationId invitationId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationInvitationDelete(organisationId: string, invitationId: string, options?: any): AxiosPromise<void> {
            return localVarFp.iamOrganisationInvitationDelete(organisationId, invitationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get iam/organisation.invitation
         * @summary Get iam/organisation.invitation
         * @param {string} organisationId Organisation Id
         * @param {string} invitationId invitationId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationInvitationGet(organisationId: string, invitationId: string, options?: any): AxiosPromise<Invitation> {
            return localVarFp.iamOrganisationInvitationGet(organisationId, invitationId, options).then((request) => request(axios, basePath));
        },
        /**
         * List iam/organisation.invitation
         * @summary List iam/organisation.invitation
         * @param {string} organisationId Organisation Id
         * @param {string} [resource] resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationInvitationList(organisationId: string, resource?: string, options?: any): AxiosPromise<Array<Invitation>> {
            return localVarFp.iamOrganisationInvitationList(organisationId, resource, options).then((request) => request(axios, basePath));
        },
        /**
         * action download
         * @summary Download iam/organisation.invoice
         * @param {string} organisationId Organisation Id
         * @param {string} invoiceId invoiceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationInvoiceDownload(organisationId: string, invoiceId: string, options?: any): AxiosPromise<any> {
            return localVarFp.iamOrganisationInvoiceDownload(organisationId, invoiceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get iam/organisation.invoice
         * @summary Get iam/organisation.invoice
         * @param {string} organisationId Organisation Id
         * @param {string} invoiceId invoiceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationInvoiceGet(organisationId: string, invoiceId: string, options?: any): AxiosPromise<Invoice> {
            return localVarFp.iamOrganisationInvoiceGet(organisationId, invoiceId, options).then((request) => request(axios, basePath));
        },
        /**
         * List iam/organisation.invoice
         * @summary List iam/organisation.invoice
         * @param {string} organisationId Organisation Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationInvoiceList(organisationId: string, options?: any): AxiosPromise<Array<Invoice>> {
            return localVarFp.iamOrganisationInvoiceList(organisationId, options).then((request) => request(axios, basePath));
        },
        /**
         * List organisation
         * @summary List iam/organisation
         * @param {string} [name] Filter by name
         * @param {string} [billingCompany] Filter by billing.company
         * @param {number} [$limit] Filter by $limit
         * @param {boolean} [active] Filter by active
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationList(name?: string, billingCompany?: string, $limit?: number, active?: boolean, options?: any): AxiosPromise<Array<Organisation>> {
            return localVarFp.iamOrganisationList(name, billingCompany, $limit, active, options).then((request) => request(axios, basePath));
        },
        /**
         * Create iam/organisation.ownership
         * @summary Create iam/organisation.ownership
         * @param {string} organisationId Organisation Id
         * @param {IamOrganisationOwnershipCreate} iamOrganisationOwnershipCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationOwnershipCreate(organisationId: string, iamOrganisationOwnershipCreate: IamOrganisationOwnershipCreate, options?: any): AxiosPromise<Organisation> {
            return localVarFp.iamOrganisationOwnershipCreate(organisationId, iamOrganisationOwnershipCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete iam/organisation.ownership
         * @summary Delete iam/organisation.ownership
         * @param {string} organisationId Organisation Id
         * @param {string} ownershipId ownershipId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationOwnershipDelete(organisationId: string, ownershipId: string, options?: any): AxiosPromise<void> {
            return localVarFp.iamOrganisationOwnershipDelete(organisationId, ownershipId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get iam/organisation.ownership
         * @summary Get iam/organisation.ownership
         * @param {string} organisationId Organisation Id
         * @param {string} ownershipId ownershipId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationOwnershipGet(organisationId: string, ownershipId: string, options?: any): AxiosPromise<Ownership> {
            return localVarFp.iamOrganisationOwnershipGet(organisationId, ownershipId, options).then((request) => request(axios, basePath));
        },
        /**
         * List iam/organisation.ownership
         * @summary List iam/organisation.ownership
         * @param {string} organisationId Organisation Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationOwnershipList(organisationId: string, options?: any): AxiosPromise<Array<Ownership>> {
            return localVarFp.iamOrganisationOwnershipList(organisationId, options).then((request) => request(axios, basePath));
        },
        /**
         * action allocate
         * @summary Allocate iam/organisation.payment
         * @param {string} organisationId Organisation Id
         * @param {string} paymentId paymentId
         * @param {IamOrganisationPaymentAllocate} iamOrganisationPaymentAllocate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationPaymentAllocate(organisationId: string, paymentId: string, iamOrganisationPaymentAllocate: IamOrganisationPaymentAllocate, options?: any): AxiosPromise<Payment> {
            return localVarFp.iamOrganisationPaymentAllocate(organisationId, paymentId, iamOrganisationPaymentAllocate, options).then((request) => request(axios, basePath));
        },
        /**
         * Get iam/organisation.payment
         * @summary Get iam/organisation.payment
         * @param {string} organisationId Organisation Id
         * @param {string} paymentId paymentId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationPaymentGet(organisationId: string, paymentId: string, options?: any): AxiosPromise<Payment> {
            return localVarFp.iamOrganisationPaymentGet(organisationId, paymentId, options).then((request) => request(axios, basePath));
        },
        /**
         * List iam/organisation.payment
         * @summary List iam/organisation.payment
         * @param {string} organisationId Organisation Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationPaymentList(organisationId: string, options?: any): AxiosPromise<Array<Payment>> {
            return localVarFp.iamOrganisationPaymentList(organisationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create iam/organisation.proforma
         * @summary Create iam/organisation.proforma
         * @param {string} organisationId Organisation Id
         * @param {IamOrganisationProformaCreate} iamOrganisationProformaCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationProformaCreate(organisationId: string, iamOrganisationProformaCreate: IamOrganisationProformaCreate, options?: any): AxiosPromise<Proforma> {
            return localVarFp.iamOrganisationProformaCreate(organisationId, iamOrganisationProformaCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * action download
         * @summary Download iam/organisation.proforma
         * @param {string} organisationId Organisation Id
         * @param {string} proformaId proformaId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationProformaDownload(organisationId: string, proformaId: string, options?: any): AxiosPromise<any> {
            return localVarFp.iamOrganisationProformaDownload(organisationId, proformaId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get iam/organisation.proforma
         * @summary Get iam/organisation.proforma
         * @param {string} organisationId Organisation Id
         * @param {string} proformaId proformaId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationProformaGet(organisationId: string, proformaId: string, options?: any): AxiosPromise<Proforma> {
            return localVarFp.iamOrganisationProformaGet(organisationId, proformaId, options).then((request) => request(axios, basePath));
        },
        /**
         * List iam/organisation.proforma
         * @summary List iam/organisation.proforma
         * @param {string} organisationId Organisation Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationProformaList(organisationId: string, options?: any): AxiosPromise<Array<Proforma>> {
            return localVarFp.iamOrganisationProformaList(organisationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get iam/organisation.service
         * @summary Get iam/organisation.service
         * @param {string} organisationId Organisation Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationServiceGet(organisationId: string, serviceId: string, options?: any): AxiosPromise<ResourceService> {
            return localVarFp.iamOrganisationServiceGet(organisationId, serviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * List iam/organisation.service
         * @summary List iam/organisation.service
         * @param {string} organisationId Organisation Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationServiceList(organisationId: string, options?: any): AxiosPromise<Array<ResourceService>> {
            return localVarFp.iamOrganisationServiceList(organisationId, options).then((request) => request(axios, basePath));
        },
        /**
         * action accept
         * @summary Accept iam/organisation.transfer
         * @param {string} organisationId Organisation Id
         * @param {string} transferId transferId
         * @param {IamOrganisationTransferAccept} iamOrganisationTransferAccept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationTransferAccept(organisationId: string, transferId: string, iamOrganisationTransferAccept: IamOrganisationTransferAccept, options?: any): AxiosPromise<Transfer> {
            return localVarFp.iamOrganisationTransferAccept(organisationId, transferId, iamOrganisationTransferAccept, options).then((request) => request(axios, basePath));
        },
        /**
         * Get iam/organisation.transfer
         * @summary Get iam/organisation.transfer
         * @param {string} organisationId Organisation Id
         * @param {string} transferId transferId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationTransferGet(organisationId: string, transferId: string, options?: any): AxiosPromise<Transfer> {
            return localVarFp.iamOrganisationTransferGet(organisationId, transferId, options).then((request) => request(axios, basePath));
        },
        /**
         * List iam/organisation.transfer
         * @summary List iam/organisation.transfer
         * @param {string} organisationId Organisation Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationTransferList(organisationId: string, options?: any): AxiosPromise<Array<Transfer>> {
            return localVarFp.iamOrganisationTransferList(organisationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns modified organisation
         * @summary Update iam/organisation
         * @param {string} organisationId Organisation Id
         * @param {IamOrganisationUpdate} iamOrganisationUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationUpdate(organisationId: string, iamOrganisationUpdate: IamOrganisationUpdate, options?: any): AxiosPromise<Organisation> {
            return localVarFp.iamOrganisationUpdate(organisationId, iamOrganisationUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IamOrganisationApi - object-oriented interface
 * @export
 * @class IamOrganisationApi
 * @extends {BaseAPI}
 */
export class IamOrganisationApi extends BaseAPI {
    /**
     * List iam/organisation.billing
     * @summary List iam/organisation.billing
     * @param {string} organisationId Organisation Id
     * @param {string} [start] start
     * @param {string} [end] end
     * @param {string} [resourceType] resource.type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationApi
     */
    public iamOrganisationBillingList(organisationId: string, start?: string, end?: string, resourceType?: string, options?: any) {
        return IamOrganisationApiFp(this.configuration).iamOrganisationBillingList(organisationId, start, end, resourceType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create organisation
     * @summary Create iam/organisation
     * @param {IamOrganisationCreate} iamOrganisationCreate 
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {string} [xDryRun] Dry run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationApi
     */
    public iamOrganisationCreate(iamOrganisationCreate: IamOrganisationCreate, xIdempotencyKey?: string, xDryRun?: string, options?: any) {
        return IamOrganisationApiFp(this.configuration).iamOrganisationCreate(iamOrganisationCreate, xIdempotencyKey, xDryRun, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete organisation
     * @summary Delete iam/organisation
     * @param {string} organisationId Organisation Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationApi
     */
    public iamOrganisationDelete(organisationId: string, options?: any) {
        return IamOrganisationApiFp(this.configuration).iamOrganisationDelete(organisationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get iam/organisation.event
     * @summary Get iam/organisation.event
     * @param {string} organisationId Organisation Id
     * @param {string} eventId eventId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationApi
     */
    public iamOrganisationEventGet(organisationId: string, eventId: string, options?: any) {
        return IamOrganisationApiFp(this.configuration).iamOrganisationEventGet(organisationId, eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List iam/organisation.event
     * @summary List iam/organisation.event
     * @param {string} organisationId Organisation Id
     * @param {number} [$limit] $limit
     * @param {number} [$skip] $skip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationApi
     */
    public iamOrganisationEventList(organisationId: string, $limit?: number, $skip?: number, options?: any) {
        return IamOrganisationApiFp(this.configuration).iamOrganisationEventList(organisationId, $limit, $skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single organisation
     * @summary Get iam/organisation
     * @param {string} organisationId Organisation Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationApi
     */
    public iamOrganisationGet(organisationId: string, options?: any) {
        return IamOrganisationApiFp(this.configuration).iamOrganisationGet(organisationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * action accept
     * @summary Accept iam/organisation.invitation
     * @param {string} organisationId Organisation Id
     * @param {string} invitationId invitationId
     * @param {IamOrganisationInvitationAccept} iamOrganisationInvitationAccept 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationApi
     */
    public iamOrganisationInvitationAccept(organisationId: string, invitationId: string, iamOrganisationInvitationAccept: IamOrganisationInvitationAccept, options?: any) {
        return IamOrganisationApiFp(this.configuration).iamOrganisationInvitationAccept(organisationId, invitationId, iamOrganisationInvitationAccept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete iam/organisation.invitation
     * @summary Delete iam/organisation.invitation
     * @param {string} organisationId Organisation Id
     * @param {string} invitationId invitationId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationApi
     */
    public iamOrganisationInvitationDelete(organisationId: string, invitationId: string, options?: any) {
        return IamOrganisationApiFp(this.configuration).iamOrganisationInvitationDelete(organisationId, invitationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get iam/organisation.invitation
     * @summary Get iam/organisation.invitation
     * @param {string} organisationId Organisation Id
     * @param {string} invitationId invitationId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationApi
     */
    public iamOrganisationInvitationGet(organisationId: string, invitationId: string, options?: any) {
        return IamOrganisationApiFp(this.configuration).iamOrganisationInvitationGet(organisationId, invitationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List iam/organisation.invitation
     * @summary List iam/organisation.invitation
     * @param {string} organisationId Organisation Id
     * @param {string} [resource] resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationApi
     */
    public iamOrganisationInvitationList(organisationId: string, resource?: string, options?: any) {
        return IamOrganisationApiFp(this.configuration).iamOrganisationInvitationList(organisationId, resource, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * action download
     * @summary Download iam/organisation.invoice
     * @param {string} organisationId Organisation Id
     * @param {string} invoiceId invoiceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationApi
     */
    public iamOrganisationInvoiceDownload(organisationId: string, invoiceId: string, options?: any) {
        return IamOrganisationApiFp(this.configuration).iamOrganisationInvoiceDownload(organisationId, invoiceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get iam/organisation.invoice
     * @summary Get iam/organisation.invoice
     * @param {string} organisationId Organisation Id
     * @param {string} invoiceId invoiceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationApi
     */
    public iamOrganisationInvoiceGet(organisationId: string, invoiceId: string, options?: any) {
        return IamOrganisationApiFp(this.configuration).iamOrganisationInvoiceGet(organisationId, invoiceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List iam/organisation.invoice
     * @summary List iam/organisation.invoice
     * @param {string} organisationId Organisation Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationApi
     */
    public iamOrganisationInvoiceList(organisationId: string, options?: any) {
        return IamOrganisationApiFp(this.configuration).iamOrganisationInvoiceList(organisationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List organisation
     * @summary List iam/organisation
     * @param {string} [name] Filter by name
     * @param {string} [billingCompany] Filter by billing.company
     * @param {number} [$limit] Filter by $limit
     * @param {boolean} [active] Filter by active
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationApi
     */
    public iamOrganisationList(name?: string, billingCompany?: string, $limit?: number, active?: boolean, options?: any) {
        return IamOrganisationApiFp(this.configuration).iamOrganisationList(name, billingCompany, $limit, active, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create iam/organisation.ownership
     * @summary Create iam/organisation.ownership
     * @param {string} organisationId Organisation Id
     * @param {IamOrganisationOwnershipCreate} iamOrganisationOwnershipCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationApi
     */
    public iamOrganisationOwnershipCreate(organisationId: string, iamOrganisationOwnershipCreate: IamOrganisationOwnershipCreate, options?: any) {
        return IamOrganisationApiFp(this.configuration).iamOrganisationOwnershipCreate(organisationId, iamOrganisationOwnershipCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete iam/organisation.ownership
     * @summary Delete iam/organisation.ownership
     * @param {string} organisationId Organisation Id
     * @param {string} ownershipId ownershipId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationApi
     */
    public iamOrganisationOwnershipDelete(organisationId: string, ownershipId: string, options?: any) {
        return IamOrganisationApiFp(this.configuration).iamOrganisationOwnershipDelete(organisationId, ownershipId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get iam/organisation.ownership
     * @summary Get iam/organisation.ownership
     * @param {string} organisationId Organisation Id
     * @param {string} ownershipId ownershipId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationApi
     */
    public iamOrganisationOwnershipGet(organisationId: string, ownershipId: string, options?: any) {
        return IamOrganisationApiFp(this.configuration).iamOrganisationOwnershipGet(organisationId, ownershipId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List iam/organisation.ownership
     * @summary List iam/organisation.ownership
     * @param {string} organisationId Organisation Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationApi
     */
    public iamOrganisationOwnershipList(organisationId: string, options?: any) {
        return IamOrganisationApiFp(this.configuration).iamOrganisationOwnershipList(organisationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * action allocate
     * @summary Allocate iam/organisation.payment
     * @param {string} organisationId Organisation Id
     * @param {string} paymentId paymentId
     * @param {IamOrganisationPaymentAllocate} iamOrganisationPaymentAllocate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationApi
     */
    public iamOrganisationPaymentAllocate(organisationId: string, paymentId: string, iamOrganisationPaymentAllocate: IamOrganisationPaymentAllocate, options?: any) {
        return IamOrganisationApiFp(this.configuration).iamOrganisationPaymentAllocate(organisationId, paymentId, iamOrganisationPaymentAllocate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get iam/organisation.payment
     * @summary Get iam/organisation.payment
     * @param {string} organisationId Organisation Id
     * @param {string} paymentId paymentId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationApi
     */
    public iamOrganisationPaymentGet(organisationId: string, paymentId: string, options?: any) {
        return IamOrganisationApiFp(this.configuration).iamOrganisationPaymentGet(organisationId, paymentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List iam/organisation.payment
     * @summary List iam/organisation.payment
     * @param {string} organisationId Organisation Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationApi
     */
    public iamOrganisationPaymentList(organisationId: string, options?: any) {
        return IamOrganisationApiFp(this.configuration).iamOrganisationPaymentList(organisationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create iam/organisation.proforma
     * @summary Create iam/organisation.proforma
     * @param {string} organisationId Organisation Id
     * @param {IamOrganisationProformaCreate} iamOrganisationProformaCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationApi
     */
    public iamOrganisationProformaCreate(organisationId: string, iamOrganisationProformaCreate: IamOrganisationProformaCreate, options?: any) {
        return IamOrganisationApiFp(this.configuration).iamOrganisationProformaCreate(organisationId, iamOrganisationProformaCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * action download
     * @summary Download iam/organisation.proforma
     * @param {string} organisationId Organisation Id
     * @param {string} proformaId proformaId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationApi
     */
    public iamOrganisationProformaDownload(organisationId: string, proformaId: string, options?: any) {
        return IamOrganisationApiFp(this.configuration).iamOrganisationProformaDownload(organisationId, proformaId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get iam/organisation.proforma
     * @summary Get iam/organisation.proforma
     * @param {string} organisationId Organisation Id
     * @param {string} proformaId proformaId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationApi
     */
    public iamOrganisationProformaGet(organisationId: string, proformaId: string, options?: any) {
        return IamOrganisationApiFp(this.configuration).iamOrganisationProformaGet(organisationId, proformaId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List iam/organisation.proforma
     * @summary List iam/organisation.proforma
     * @param {string} organisationId Organisation Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationApi
     */
    public iamOrganisationProformaList(organisationId: string, options?: any) {
        return IamOrganisationApiFp(this.configuration).iamOrganisationProformaList(organisationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get iam/organisation.service
     * @summary Get iam/organisation.service
     * @param {string} organisationId Organisation Id
     * @param {string} serviceId serviceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationApi
     */
    public iamOrganisationServiceGet(organisationId: string, serviceId: string, options?: any) {
        return IamOrganisationApiFp(this.configuration).iamOrganisationServiceGet(organisationId, serviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List iam/organisation.service
     * @summary List iam/organisation.service
     * @param {string} organisationId Organisation Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationApi
     */
    public iamOrganisationServiceList(organisationId: string, options?: any) {
        return IamOrganisationApiFp(this.configuration).iamOrganisationServiceList(organisationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * action accept
     * @summary Accept iam/organisation.transfer
     * @param {string} organisationId Organisation Id
     * @param {string} transferId transferId
     * @param {IamOrganisationTransferAccept} iamOrganisationTransferAccept 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationApi
     */
    public iamOrganisationTransferAccept(organisationId: string, transferId: string, iamOrganisationTransferAccept: IamOrganisationTransferAccept, options?: any) {
        return IamOrganisationApiFp(this.configuration).iamOrganisationTransferAccept(organisationId, transferId, iamOrganisationTransferAccept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get iam/organisation.transfer
     * @summary Get iam/organisation.transfer
     * @param {string} organisationId Organisation Id
     * @param {string} transferId transferId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationApi
     */
    public iamOrganisationTransferGet(organisationId: string, transferId: string, options?: any) {
        return IamOrganisationApiFp(this.configuration).iamOrganisationTransferGet(organisationId, transferId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List iam/organisation.transfer
     * @summary List iam/organisation.transfer
     * @param {string} organisationId Organisation Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationApi
     */
    public iamOrganisationTransferList(organisationId: string, options?: any) {
        return IamOrganisationApiFp(this.configuration).iamOrganisationTransferList(organisationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns modified organisation
     * @summary Update iam/organisation
     * @param {string} organisationId Organisation Id
     * @param {IamOrganisationUpdate} iamOrganisationUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationApi
     */
    public iamOrganisationUpdate(organisationId: string, iamOrganisationUpdate: IamOrganisationUpdate, options?: any) {
        return IamOrganisationApiFp(this.configuration).iamOrganisationUpdate(organisationId, iamOrganisationUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * IamOrganisationPolicyApi - axios parameter creator
 * @export
 */
export const IamOrganisationPolicyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create iam/policy.actor
         * @summary Create iam/policy.actor
         * @param {string} organisationId Organisation Id
         * @param {string} policyId Policy Id
         * @param {IamActor} iamActor 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationPolicyActorCreate: async (organisationId: string, policyId: string, iamActor: IamActor, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            assertParamExists('iamOrganisationPolicyActorCreate', 'organisationId', organisationId)
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('iamOrganisationPolicyActorCreate', 'policyId', policyId)
            // verify required parameter 'iamActor' is not null or undefined
            assertParamExists('iamOrganisationPolicyActorCreate', 'iamActor', iamActor)
            const localVarPath = `/iam/organisation/{organisationId}/policy/{policyId}/actor`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)))
                .replace(`{${"policyId"}}`, encodeURIComponent(String(policyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(iamActor, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete iam/policy.actor
         * @summary Delete iam/policy.actor
         * @param {string} organisationId Organisation Id
         * @param {string} policyId Policy Id
         * @param {string} actorId actorId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationPolicyActorDelete: async (organisationId: string, policyId: string, actorId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            assertParamExists('iamOrganisationPolicyActorDelete', 'organisationId', organisationId)
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('iamOrganisationPolicyActorDelete', 'policyId', policyId)
            // verify required parameter 'actorId' is not null or undefined
            assertParamExists('iamOrganisationPolicyActorDelete', 'actorId', actorId)
            const localVarPath = `/iam/organisation/{organisationId}/policy/{policyId}/actor/{actorId}`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)))
                .replace(`{${"policyId"}}`, encodeURIComponent(String(policyId)))
                .replace(`{${"actorId"}}`, encodeURIComponent(String(actorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get iam/policy.actor
         * @summary Get iam/policy.actor
         * @param {string} organisationId Organisation Id
         * @param {string} policyId Policy Id
         * @param {string} actorId actorId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationPolicyActorGet: async (organisationId: string, policyId: string, actorId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            assertParamExists('iamOrganisationPolicyActorGet', 'organisationId', organisationId)
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('iamOrganisationPolicyActorGet', 'policyId', policyId)
            // verify required parameter 'actorId' is not null or undefined
            assertParamExists('iamOrganisationPolicyActorGet', 'actorId', actorId)
            const localVarPath = `/iam/organisation/{organisationId}/policy/{policyId}/actor/{actorId}`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)))
                .replace(`{${"policyId"}}`, encodeURIComponent(String(policyId)))
                .replace(`{${"actorId"}}`, encodeURIComponent(String(actorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List iam/policy.actor
         * @summary List iam/policy.actor
         * @param {string} organisationId Organisation Id
         * @param {string} policyId Policy Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationPolicyActorList: async (organisationId: string, policyId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            assertParamExists('iamOrganisationPolicyActorList', 'organisationId', organisationId)
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('iamOrganisationPolicyActorList', 'policyId', policyId)
            const localVarPath = `/iam/organisation/{organisationId}/policy/{policyId}/actor`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)))
                .replace(`{${"policyId"}}`, encodeURIComponent(String(policyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create policy
         * @summary Create iam/policy
         * @param {string} organisationId Organisation Id
         * @param {IamProjectPolicyCreate} iamProjectPolicyCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationPolicyCreate: async (organisationId: string, iamProjectPolicyCreate: IamProjectPolicyCreate, xIdempotencyKey?: string, xDryRun?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            assertParamExists('iamOrganisationPolicyCreate', 'organisationId', organisationId)
            // verify required parameter 'iamProjectPolicyCreate' is not null or undefined
            assertParamExists('iamOrganisationPolicyCreate', 'iamProjectPolicyCreate', iamProjectPolicyCreate)
            const localVarPath = `/iam/organisation/{organisationId}/policy`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }

            if (xDryRun !== undefined && xDryRun !== null) {
                localVarHeaderParameter['x-dry-run'] = String(xDryRun);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(iamProjectPolicyCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete policy
         * @summary Delete iam/policy
         * @param {string} organisationId Organisation Id
         * @param {string} policyId Policy Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationPolicyDelete: async (organisationId: string, policyId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            assertParamExists('iamOrganisationPolicyDelete', 'organisationId', organisationId)
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('iamOrganisationPolicyDelete', 'policyId', policyId)
            const localVarPath = `/iam/organisation/{organisationId}/policy/{policyId}`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)))
                .replace(`{${"policyId"}}`, encodeURIComponent(String(policyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get iam/policy.event
         * @summary Get iam/policy.event
         * @param {string} organisationId Organisation Id
         * @param {string} policyId Policy Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationPolicyEventGet: async (organisationId: string, policyId: string, eventId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            assertParamExists('iamOrganisationPolicyEventGet', 'organisationId', organisationId)
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('iamOrganisationPolicyEventGet', 'policyId', policyId)
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('iamOrganisationPolicyEventGet', 'eventId', eventId)
            const localVarPath = `/iam/organisation/{organisationId}/policy/{policyId}/event/{eventId}`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)))
                .replace(`{${"policyId"}}`, encodeURIComponent(String(policyId)))
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List iam/policy.event
         * @summary List iam/policy.event
         * @param {string} organisationId Organisation Id
         * @param {string} policyId Policy Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationPolicyEventList: async (organisationId: string, policyId: string, $limit?: number, $skip?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            assertParamExists('iamOrganisationPolicyEventList', 'organisationId', organisationId)
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('iamOrganisationPolicyEventList', 'policyId', policyId)
            const localVarPath = `/iam/organisation/{organisationId}/policy/{policyId}/event`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)))
                .replace(`{${"policyId"}}`, encodeURIComponent(String(policyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if ($limit !== undefined) {
                localVarQueryParameter['$limit'] = $limit;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single policy
         * @summary Get iam/policy
         * @param {string} organisationId Organisation Id
         * @param {string} policyId Policy Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationPolicyGet: async (organisationId: string, policyId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            assertParamExists('iamOrganisationPolicyGet', 'organisationId', organisationId)
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('iamOrganisationPolicyGet', 'policyId', policyId)
            const localVarPath = `/iam/organisation/{organisationId}/policy/{policyId}`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)))
                .replace(`{${"policyId"}}`, encodeURIComponent(String(policyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List policy
         * @summary List iam/policy
         * @param {string} organisationId Organisation Id
         * @param {string} [name] Filter by name
         * @param {string} [resource] Filter by resource
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationPolicyList: async (organisationId: string, name?: string, resource?: string, tagValue?: string, tagKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            assertParamExists('iamOrganisationPolicyList', 'organisationId', organisationId)
            const localVarPath = `/iam/organisation/{organisationId}/policy`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (resource !== undefined) {
                localVarQueryParameter['resource'] = resource;
            }

            if (tagValue !== undefined) {
                localVarQueryParameter['tag.value'] = tagValue;
            }

            if (tagKey !== undefined) {
                localVarQueryParameter['tag.key'] = tagKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get iam/policy.service
         * @summary Get iam/policy.service
         * @param {string} organisationId Organisation Id
         * @param {string} policyId Policy Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationPolicyServiceGet: async (organisationId: string, policyId: string, serviceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            assertParamExists('iamOrganisationPolicyServiceGet', 'organisationId', organisationId)
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('iamOrganisationPolicyServiceGet', 'policyId', policyId)
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('iamOrganisationPolicyServiceGet', 'serviceId', serviceId)
            const localVarPath = `/iam/organisation/{organisationId}/policy/{policyId}/service/{serviceId}`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)))
                .replace(`{${"policyId"}}`, encodeURIComponent(String(policyId)))
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List iam/policy.service
         * @summary List iam/policy.service
         * @param {string} organisationId Organisation Id
         * @param {string} policyId Policy Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationPolicyServiceList: async (organisationId: string, policyId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            assertParamExists('iamOrganisationPolicyServiceList', 'organisationId', organisationId)
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('iamOrganisationPolicyServiceList', 'policyId', policyId)
            const localVarPath = `/iam/organisation/{organisationId}/policy/{policyId}/service`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)))
                .replace(`{${"policyId"}}`, encodeURIComponent(String(policyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create iam/policy.tag
         * @summary Create iam/policy.tag
         * @param {string} organisationId Organisation Id
         * @param {string} policyId Policy Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationPolicyTagCreate: async (organisationId: string, policyId: string, tag: Tag, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            assertParamExists('iamOrganisationPolicyTagCreate', 'organisationId', organisationId)
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('iamOrganisationPolicyTagCreate', 'policyId', policyId)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('iamOrganisationPolicyTagCreate', 'tag', tag)
            const localVarPath = `/iam/organisation/{organisationId}/policy/{policyId}/tag`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)))
                .replace(`{${"policyId"}}`, encodeURIComponent(String(policyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tag, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete iam/policy.tag
         * @summary Delete iam/policy.tag
         * @param {string} organisationId Organisation Id
         * @param {string} policyId Policy Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationPolicyTagDelete: async (organisationId: string, policyId: string, tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            assertParamExists('iamOrganisationPolicyTagDelete', 'organisationId', organisationId)
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('iamOrganisationPolicyTagDelete', 'policyId', policyId)
            // verify required parameter 'tagId' is not null or undefined
            assertParamExists('iamOrganisationPolicyTagDelete', 'tagId', tagId)
            const localVarPath = `/iam/organisation/{organisationId}/policy/{policyId}/tag/{tagId}`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)))
                .replace(`{${"policyId"}}`, encodeURIComponent(String(policyId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get iam/policy.tag
         * @summary Get iam/policy.tag
         * @param {string} organisationId Organisation Id
         * @param {string} policyId Policy Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationPolicyTagGet: async (organisationId: string, policyId: string, tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            assertParamExists('iamOrganisationPolicyTagGet', 'organisationId', organisationId)
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('iamOrganisationPolicyTagGet', 'policyId', policyId)
            // verify required parameter 'tagId' is not null or undefined
            assertParamExists('iamOrganisationPolicyTagGet', 'tagId', tagId)
            const localVarPath = `/iam/organisation/{organisationId}/policy/{policyId}/tag/{tagId}`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)))
                .replace(`{${"policyId"}}`, encodeURIComponent(String(policyId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List iam/policy.tag
         * @summary List iam/policy.tag
         * @param {string} organisationId Organisation Id
         * @param {string} policyId Policy Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationPolicyTagList: async (organisationId: string, policyId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            assertParamExists('iamOrganisationPolicyTagList', 'organisationId', organisationId)
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('iamOrganisationPolicyTagList', 'policyId', policyId)
            const localVarPath = `/iam/organisation/{organisationId}/policy/{policyId}/tag`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)))
                .replace(`{${"policyId"}}`, encodeURIComponent(String(policyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replace iam/policy.tag
         * @summary Replace iam/policy.tag
         * @param {string} organisationId Organisation Id
         * @param {string} policyId Policy Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationPolicyTagPut: async (organisationId: string, policyId: string, tag: Array<Tag>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            assertParamExists('iamOrganisationPolicyTagPut', 'organisationId', organisationId)
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('iamOrganisationPolicyTagPut', 'policyId', policyId)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('iamOrganisationPolicyTagPut', 'tag', tag)
            const localVarPath = `/iam/organisation/{organisationId}/policy/{policyId}/tag`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)))
                .replace(`{${"policyId"}}`, encodeURIComponent(String(policyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tag, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns modified policy
         * @summary Update iam/policy
         * @param {string} organisationId Organisation Id
         * @param {string} policyId Policy Id
         * @param {IamProjectPolicyUpdate} iamProjectPolicyUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationPolicyUpdate: async (organisationId: string, policyId: string, iamProjectPolicyUpdate: IamProjectPolicyUpdate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            assertParamExists('iamOrganisationPolicyUpdate', 'organisationId', organisationId)
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('iamOrganisationPolicyUpdate', 'policyId', policyId)
            // verify required parameter 'iamProjectPolicyUpdate' is not null or undefined
            assertParamExists('iamOrganisationPolicyUpdate', 'iamProjectPolicyUpdate', iamProjectPolicyUpdate)
            const localVarPath = `/iam/organisation/{organisationId}/policy/{policyId}`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)))
                .replace(`{${"policyId"}}`, encodeURIComponent(String(policyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(iamProjectPolicyUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IamOrganisationPolicyApi - functional programming interface
 * @export
 */
export const IamOrganisationPolicyApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IamOrganisationPolicyApiAxiosParamCreator(configuration)
    return {
        /**
         * Create iam/policy.actor
         * @summary Create iam/policy.actor
         * @param {string} organisationId Organisation Id
         * @param {string} policyId Policy Id
         * @param {IamActor} iamActor 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationPolicyActorCreate(organisationId: string, policyId: string, iamActor: IamActor, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IamActor>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamOrganisationPolicyActorCreate(organisationId, policyId, iamActor, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete iam/policy.actor
         * @summary Delete iam/policy.actor
         * @param {string} organisationId Organisation Id
         * @param {string} policyId Policy Id
         * @param {string} actorId actorId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationPolicyActorDelete(organisationId: string, policyId: string, actorId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IamActor>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamOrganisationPolicyActorDelete(organisationId, policyId, actorId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get iam/policy.actor
         * @summary Get iam/policy.actor
         * @param {string} organisationId Organisation Id
         * @param {string} policyId Policy Id
         * @param {string} actorId actorId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationPolicyActorGet(organisationId: string, policyId: string, actorId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IamActor>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamOrganisationPolicyActorGet(organisationId, policyId, actorId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List iam/policy.actor
         * @summary List iam/policy.actor
         * @param {string} organisationId Organisation Id
         * @param {string} policyId Policy Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationPolicyActorList(organisationId: string, policyId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<IamActor>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamOrganisationPolicyActorList(organisationId, policyId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create policy
         * @summary Create iam/policy
         * @param {string} organisationId Organisation Id
         * @param {IamProjectPolicyCreate} iamProjectPolicyCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationPolicyCreate(organisationId: string, iamProjectPolicyCreate: IamProjectPolicyCreate, xIdempotencyKey?: string, xDryRun?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Policy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamOrganisationPolicyCreate(organisationId, iamProjectPolicyCreate, xIdempotencyKey, xDryRun, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete policy
         * @summary Delete iam/policy
         * @param {string} organisationId Organisation Id
         * @param {string} policyId Policy Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationPolicyDelete(organisationId: string, policyId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamOrganisationPolicyDelete(organisationId, policyId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get iam/policy.event
         * @summary Get iam/policy.event
         * @param {string} organisationId Organisation Id
         * @param {string} policyId Policy Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationPolicyEventGet(organisationId: string, policyId: string, eventId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamOrganisationPolicyEventGet(organisationId, policyId, eventId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List iam/policy.event
         * @summary List iam/policy.event
         * @param {string} organisationId Organisation Id
         * @param {string} policyId Policy Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationPolicyEventList(organisationId: string, policyId: string, $limit?: number, $skip?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Event>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamOrganisationPolicyEventList(organisationId, policyId, $limit, $skip, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a single policy
         * @summary Get iam/policy
         * @param {string} organisationId Organisation Id
         * @param {string} policyId Policy Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationPolicyGet(organisationId: string, policyId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Policy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamOrganisationPolicyGet(organisationId, policyId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List policy
         * @summary List iam/policy
         * @param {string} organisationId Organisation Id
         * @param {string} [name] Filter by name
         * @param {string} [resource] Filter by resource
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationPolicyList(organisationId: string, name?: string, resource?: string, tagValue?: string, tagKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Policy>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamOrganisationPolicyList(organisationId, name, resource, tagValue, tagKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get iam/policy.service
         * @summary Get iam/policy.service
         * @param {string} organisationId Organisation Id
         * @param {string} policyId Policy Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationPolicyServiceGet(organisationId: string, policyId: string, serviceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceService>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamOrganisationPolicyServiceGet(organisationId, policyId, serviceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List iam/policy.service
         * @summary List iam/policy.service
         * @param {string} organisationId Organisation Id
         * @param {string} policyId Policy Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationPolicyServiceList(organisationId: string, policyId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResourceService>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamOrganisationPolicyServiceList(organisationId, policyId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create iam/policy.tag
         * @summary Create iam/policy.tag
         * @param {string} organisationId Organisation Id
         * @param {string} policyId Policy Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationPolicyTagCreate(organisationId: string, policyId: string, tag: Tag, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamOrganisationPolicyTagCreate(organisationId, policyId, tag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete iam/policy.tag
         * @summary Delete iam/policy.tag
         * @param {string} organisationId Organisation Id
         * @param {string} policyId Policy Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationPolicyTagDelete(organisationId: string, policyId: string, tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamOrganisationPolicyTagDelete(organisationId, policyId, tagId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get iam/policy.tag
         * @summary Get iam/policy.tag
         * @param {string} organisationId Organisation Id
         * @param {string} policyId Policy Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationPolicyTagGet(organisationId: string, policyId: string, tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamOrganisationPolicyTagGet(organisationId, policyId, tagId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List iam/policy.tag
         * @summary List iam/policy.tag
         * @param {string} organisationId Organisation Id
         * @param {string} policyId Policy Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationPolicyTagList(organisationId: string, policyId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamOrganisationPolicyTagList(organisationId, policyId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Replace iam/policy.tag
         * @summary Replace iam/policy.tag
         * @param {string} organisationId Organisation Id
         * @param {string} policyId Policy Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationPolicyTagPut(organisationId: string, policyId: string, tag: Array<Tag>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamOrganisationPolicyTagPut(organisationId, policyId, tag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns modified policy
         * @summary Update iam/policy
         * @param {string} organisationId Organisation Id
         * @param {string} policyId Policy Id
         * @param {IamProjectPolicyUpdate} iamProjectPolicyUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationPolicyUpdate(organisationId: string, policyId: string, iamProjectPolicyUpdate: IamProjectPolicyUpdate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Policy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamOrganisationPolicyUpdate(organisationId, policyId, iamProjectPolicyUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * IamOrganisationPolicyApi - factory interface
 * @export
 */
export const IamOrganisationPolicyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IamOrganisationPolicyApiFp(configuration)
    return {
        /**
         * Create iam/policy.actor
         * @summary Create iam/policy.actor
         * @param {string} organisationId Organisation Id
         * @param {string} policyId Policy Id
         * @param {IamActor} iamActor 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationPolicyActorCreate(organisationId: string, policyId: string, iamActor: IamActor, options?: any): AxiosPromise<IamActor> {
            return localVarFp.iamOrganisationPolicyActorCreate(organisationId, policyId, iamActor, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete iam/policy.actor
         * @summary Delete iam/policy.actor
         * @param {string} organisationId Organisation Id
         * @param {string} policyId Policy Id
         * @param {string} actorId actorId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationPolicyActorDelete(organisationId: string, policyId: string, actorId: string, options?: any): AxiosPromise<IamActor> {
            return localVarFp.iamOrganisationPolicyActorDelete(organisationId, policyId, actorId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get iam/policy.actor
         * @summary Get iam/policy.actor
         * @param {string} organisationId Organisation Id
         * @param {string} policyId Policy Id
         * @param {string} actorId actorId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationPolicyActorGet(organisationId: string, policyId: string, actorId: string, options?: any): AxiosPromise<IamActor> {
            return localVarFp.iamOrganisationPolicyActorGet(organisationId, policyId, actorId, options).then((request) => request(axios, basePath));
        },
        /**
         * List iam/policy.actor
         * @summary List iam/policy.actor
         * @param {string} organisationId Organisation Id
         * @param {string} policyId Policy Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationPolicyActorList(organisationId: string, policyId: string, options?: any): AxiosPromise<Array<IamActor>> {
            return localVarFp.iamOrganisationPolicyActorList(organisationId, policyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create policy
         * @summary Create iam/policy
         * @param {string} organisationId Organisation Id
         * @param {IamProjectPolicyCreate} iamProjectPolicyCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationPolicyCreate(organisationId: string, iamProjectPolicyCreate: IamProjectPolicyCreate, xIdempotencyKey?: string, xDryRun?: string, options?: any): AxiosPromise<Policy> {
            return localVarFp.iamOrganisationPolicyCreate(organisationId, iamProjectPolicyCreate, xIdempotencyKey, xDryRun, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete policy
         * @summary Delete iam/policy
         * @param {string} organisationId Organisation Id
         * @param {string} policyId Policy Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationPolicyDelete(organisationId: string, policyId: string, options?: any): AxiosPromise<void> {
            return localVarFp.iamOrganisationPolicyDelete(organisationId, policyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get iam/policy.event
         * @summary Get iam/policy.event
         * @param {string} organisationId Organisation Id
         * @param {string} policyId Policy Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationPolicyEventGet(organisationId: string, policyId: string, eventId: string, options?: any): AxiosPromise<Event> {
            return localVarFp.iamOrganisationPolicyEventGet(organisationId, policyId, eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * List iam/policy.event
         * @summary List iam/policy.event
         * @param {string} organisationId Organisation Id
         * @param {string} policyId Policy Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationPolicyEventList(organisationId: string, policyId: string, $limit?: number, $skip?: number, options?: any): AxiosPromise<Array<Event>> {
            return localVarFp.iamOrganisationPolicyEventList(organisationId, policyId, $limit, $skip, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single policy
         * @summary Get iam/policy
         * @param {string} organisationId Organisation Id
         * @param {string} policyId Policy Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationPolicyGet(organisationId: string, policyId: string, options?: any): AxiosPromise<Policy> {
            return localVarFp.iamOrganisationPolicyGet(organisationId, policyId, options).then((request) => request(axios, basePath));
        },
        /**
         * List policy
         * @summary List iam/policy
         * @param {string} organisationId Organisation Id
         * @param {string} [name] Filter by name
         * @param {string} [resource] Filter by resource
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationPolicyList(organisationId: string, name?: string, resource?: string, tagValue?: string, tagKey?: string, options?: any): AxiosPromise<Array<Policy>> {
            return localVarFp.iamOrganisationPolicyList(organisationId, name, resource, tagValue, tagKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get iam/policy.service
         * @summary Get iam/policy.service
         * @param {string} organisationId Organisation Id
         * @param {string} policyId Policy Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationPolicyServiceGet(organisationId: string, policyId: string, serviceId: string, options?: any): AxiosPromise<ResourceService> {
            return localVarFp.iamOrganisationPolicyServiceGet(organisationId, policyId, serviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * List iam/policy.service
         * @summary List iam/policy.service
         * @param {string} organisationId Organisation Id
         * @param {string} policyId Policy Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationPolicyServiceList(organisationId: string, policyId: string, options?: any): AxiosPromise<Array<ResourceService>> {
            return localVarFp.iamOrganisationPolicyServiceList(organisationId, policyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create iam/policy.tag
         * @summary Create iam/policy.tag
         * @param {string} organisationId Organisation Id
         * @param {string} policyId Policy Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationPolicyTagCreate(organisationId: string, policyId: string, tag: Tag, options?: any): AxiosPromise<Tag> {
            return localVarFp.iamOrganisationPolicyTagCreate(organisationId, policyId, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete iam/policy.tag
         * @summary Delete iam/policy.tag
         * @param {string} organisationId Organisation Id
         * @param {string} policyId Policy Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationPolicyTagDelete(organisationId: string, policyId: string, tagId: string, options?: any): AxiosPromise<void> {
            return localVarFp.iamOrganisationPolicyTagDelete(organisationId, policyId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get iam/policy.tag
         * @summary Get iam/policy.tag
         * @param {string} organisationId Organisation Id
         * @param {string} policyId Policy Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationPolicyTagGet(organisationId: string, policyId: string, tagId: string, options?: any): AxiosPromise<Tag> {
            return localVarFp.iamOrganisationPolicyTagGet(organisationId, policyId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * List iam/policy.tag
         * @summary List iam/policy.tag
         * @param {string} organisationId Organisation Id
         * @param {string} policyId Policy Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationPolicyTagList(organisationId: string, policyId: string, options?: any): AxiosPromise<Array<Tag>> {
            return localVarFp.iamOrganisationPolicyTagList(organisationId, policyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Replace iam/policy.tag
         * @summary Replace iam/policy.tag
         * @param {string} organisationId Organisation Id
         * @param {string} policyId Policy Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationPolicyTagPut(organisationId: string, policyId: string, tag: Array<Tag>, options?: any): AxiosPromise<Array<Tag>> {
            return localVarFp.iamOrganisationPolicyTagPut(organisationId, policyId, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns modified policy
         * @summary Update iam/policy
         * @param {string} organisationId Organisation Id
         * @param {string} policyId Policy Id
         * @param {IamProjectPolicyUpdate} iamProjectPolicyUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationPolicyUpdate(organisationId: string, policyId: string, iamProjectPolicyUpdate: IamProjectPolicyUpdate, options?: any): AxiosPromise<Policy> {
            return localVarFp.iamOrganisationPolicyUpdate(organisationId, policyId, iamProjectPolicyUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IamOrganisationPolicyApi - object-oriented interface
 * @export
 * @class IamOrganisationPolicyApi
 * @extends {BaseAPI}
 */
export class IamOrganisationPolicyApi extends BaseAPI {
    /**
     * Create iam/policy.actor
     * @summary Create iam/policy.actor
     * @param {string} organisationId Organisation Id
     * @param {string} policyId Policy Id
     * @param {IamActor} iamActor 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationPolicyApi
     */
    public iamOrganisationPolicyActorCreate(organisationId: string, policyId: string, iamActor: IamActor, options?: any) {
        return IamOrganisationPolicyApiFp(this.configuration).iamOrganisationPolicyActorCreate(organisationId, policyId, iamActor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete iam/policy.actor
     * @summary Delete iam/policy.actor
     * @param {string} organisationId Organisation Id
     * @param {string} policyId Policy Id
     * @param {string} actorId actorId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationPolicyApi
     */
    public iamOrganisationPolicyActorDelete(organisationId: string, policyId: string, actorId: string, options?: any) {
        return IamOrganisationPolicyApiFp(this.configuration).iamOrganisationPolicyActorDelete(organisationId, policyId, actorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get iam/policy.actor
     * @summary Get iam/policy.actor
     * @param {string} organisationId Organisation Id
     * @param {string} policyId Policy Id
     * @param {string} actorId actorId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationPolicyApi
     */
    public iamOrganisationPolicyActorGet(organisationId: string, policyId: string, actorId: string, options?: any) {
        return IamOrganisationPolicyApiFp(this.configuration).iamOrganisationPolicyActorGet(organisationId, policyId, actorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List iam/policy.actor
     * @summary List iam/policy.actor
     * @param {string} organisationId Organisation Id
     * @param {string} policyId Policy Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationPolicyApi
     */
    public iamOrganisationPolicyActorList(organisationId: string, policyId: string, options?: any) {
        return IamOrganisationPolicyApiFp(this.configuration).iamOrganisationPolicyActorList(organisationId, policyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create policy
     * @summary Create iam/policy
     * @param {string} organisationId Organisation Id
     * @param {IamProjectPolicyCreate} iamProjectPolicyCreate 
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {string} [xDryRun] Dry run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationPolicyApi
     */
    public iamOrganisationPolicyCreate(organisationId: string, iamProjectPolicyCreate: IamProjectPolicyCreate, xIdempotencyKey?: string, xDryRun?: string, options?: any) {
        return IamOrganisationPolicyApiFp(this.configuration).iamOrganisationPolicyCreate(organisationId, iamProjectPolicyCreate, xIdempotencyKey, xDryRun, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete policy
     * @summary Delete iam/policy
     * @param {string} organisationId Organisation Id
     * @param {string} policyId Policy Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationPolicyApi
     */
    public iamOrganisationPolicyDelete(organisationId: string, policyId: string, options?: any) {
        return IamOrganisationPolicyApiFp(this.configuration).iamOrganisationPolicyDelete(organisationId, policyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get iam/policy.event
     * @summary Get iam/policy.event
     * @param {string} organisationId Organisation Id
     * @param {string} policyId Policy Id
     * @param {string} eventId eventId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationPolicyApi
     */
    public iamOrganisationPolicyEventGet(organisationId: string, policyId: string, eventId: string, options?: any) {
        return IamOrganisationPolicyApiFp(this.configuration).iamOrganisationPolicyEventGet(organisationId, policyId, eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List iam/policy.event
     * @summary List iam/policy.event
     * @param {string} organisationId Organisation Id
     * @param {string} policyId Policy Id
     * @param {number} [$limit] $limit
     * @param {number} [$skip] $skip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationPolicyApi
     */
    public iamOrganisationPolicyEventList(organisationId: string, policyId: string, $limit?: number, $skip?: number, options?: any) {
        return IamOrganisationPolicyApiFp(this.configuration).iamOrganisationPolicyEventList(organisationId, policyId, $limit, $skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single policy
     * @summary Get iam/policy
     * @param {string} organisationId Organisation Id
     * @param {string} policyId Policy Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationPolicyApi
     */
    public iamOrganisationPolicyGet(organisationId: string, policyId: string, options?: any) {
        return IamOrganisationPolicyApiFp(this.configuration).iamOrganisationPolicyGet(organisationId, policyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List policy
     * @summary List iam/policy
     * @param {string} organisationId Organisation Id
     * @param {string} [name] Filter by name
     * @param {string} [resource] Filter by resource
     * @param {string} [tagValue] Filter by tag.value
     * @param {string} [tagKey] Filter by tag.key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationPolicyApi
     */
    public iamOrganisationPolicyList(organisationId: string, name?: string, resource?: string, tagValue?: string, tagKey?: string, options?: any) {
        return IamOrganisationPolicyApiFp(this.configuration).iamOrganisationPolicyList(organisationId, name, resource, tagValue, tagKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get iam/policy.service
     * @summary Get iam/policy.service
     * @param {string} organisationId Organisation Id
     * @param {string} policyId Policy Id
     * @param {string} serviceId serviceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationPolicyApi
     */
    public iamOrganisationPolicyServiceGet(organisationId: string, policyId: string, serviceId: string, options?: any) {
        return IamOrganisationPolicyApiFp(this.configuration).iamOrganisationPolicyServiceGet(organisationId, policyId, serviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List iam/policy.service
     * @summary List iam/policy.service
     * @param {string} organisationId Organisation Id
     * @param {string} policyId Policy Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationPolicyApi
     */
    public iamOrganisationPolicyServiceList(organisationId: string, policyId: string, options?: any) {
        return IamOrganisationPolicyApiFp(this.configuration).iamOrganisationPolicyServiceList(organisationId, policyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create iam/policy.tag
     * @summary Create iam/policy.tag
     * @param {string} organisationId Organisation Id
     * @param {string} policyId Policy Id
     * @param {Tag} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationPolicyApi
     */
    public iamOrganisationPolicyTagCreate(organisationId: string, policyId: string, tag: Tag, options?: any) {
        return IamOrganisationPolicyApiFp(this.configuration).iamOrganisationPolicyTagCreate(organisationId, policyId, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete iam/policy.tag
     * @summary Delete iam/policy.tag
     * @param {string} organisationId Organisation Id
     * @param {string} policyId Policy Id
     * @param {string} tagId tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationPolicyApi
     */
    public iamOrganisationPolicyTagDelete(organisationId: string, policyId: string, tagId: string, options?: any) {
        return IamOrganisationPolicyApiFp(this.configuration).iamOrganisationPolicyTagDelete(organisationId, policyId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get iam/policy.tag
     * @summary Get iam/policy.tag
     * @param {string} organisationId Organisation Id
     * @param {string} policyId Policy Id
     * @param {string} tagId tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationPolicyApi
     */
    public iamOrganisationPolicyTagGet(organisationId: string, policyId: string, tagId: string, options?: any) {
        return IamOrganisationPolicyApiFp(this.configuration).iamOrganisationPolicyTagGet(organisationId, policyId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List iam/policy.tag
     * @summary List iam/policy.tag
     * @param {string} organisationId Organisation Id
     * @param {string} policyId Policy Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationPolicyApi
     */
    public iamOrganisationPolicyTagList(organisationId: string, policyId: string, options?: any) {
        return IamOrganisationPolicyApiFp(this.configuration).iamOrganisationPolicyTagList(organisationId, policyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replace iam/policy.tag
     * @summary Replace iam/policy.tag
     * @param {string} organisationId Organisation Id
     * @param {string} policyId Policy Id
     * @param {Array<Tag>} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationPolicyApi
     */
    public iamOrganisationPolicyTagPut(organisationId: string, policyId: string, tag: Array<Tag>, options?: any) {
        return IamOrganisationPolicyApiFp(this.configuration).iamOrganisationPolicyTagPut(organisationId, policyId, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns modified policy
     * @summary Update iam/policy
     * @param {string} organisationId Organisation Id
     * @param {string} policyId Policy Id
     * @param {IamProjectPolicyUpdate} iamProjectPolicyUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationPolicyApi
     */
    public iamOrganisationPolicyUpdate(organisationId: string, policyId: string, iamProjectPolicyUpdate: IamProjectPolicyUpdate, options?: any) {
        return IamOrganisationPolicyApiFp(this.configuration).iamOrganisationPolicyUpdate(organisationId, policyId, iamProjectPolicyUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * IamOrganisationRoleApi - axios parameter creator
 * @export
 */
export const IamOrganisationRoleApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create role
         * @summary Create iam/role
         * @param {string} organisationId Organisation Id
         * @param {IamProjectRoleCreate} iamProjectRoleCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationRoleCreate: async (organisationId: string, iamProjectRoleCreate: IamProjectRoleCreate, xIdempotencyKey?: string, xDryRun?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            assertParamExists('iamOrganisationRoleCreate', 'organisationId', organisationId)
            // verify required parameter 'iamProjectRoleCreate' is not null or undefined
            assertParamExists('iamOrganisationRoleCreate', 'iamProjectRoleCreate', iamProjectRoleCreate)
            const localVarPath = `/iam/organisation/{organisationId}/role`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }

            if (xDryRun !== undefined && xDryRun !== null) {
                localVarHeaderParameter['x-dry-run'] = String(xDryRun);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(iamProjectRoleCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete role
         * @summary Delete iam/role
         * @param {string} organisationId Organisation Id
         * @param {string} roleId Role Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationRoleDelete: async (organisationId: string, roleId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            assertParamExists('iamOrganisationRoleDelete', 'organisationId', organisationId)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('iamOrganisationRoleDelete', 'roleId', roleId)
            const localVarPath = `/iam/organisation/{organisationId}/role/{roleId}`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)))
                .replace(`{${"roleId"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get iam/role.event
         * @summary Get iam/role.event
         * @param {string} organisationId Organisation Id
         * @param {string} roleId Role Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationRoleEventGet: async (organisationId: string, roleId: string, eventId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            assertParamExists('iamOrganisationRoleEventGet', 'organisationId', organisationId)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('iamOrganisationRoleEventGet', 'roleId', roleId)
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('iamOrganisationRoleEventGet', 'eventId', eventId)
            const localVarPath = `/iam/organisation/{organisationId}/role/{roleId}/event/{eventId}`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)))
                .replace(`{${"roleId"}}`, encodeURIComponent(String(roleId)))
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List iam/role.event
         * @summary List iam/role.event
         * @param {string} organisationId Organisation Id
         * @param {string} roleId Role Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationRoleEventList: async (organisationId: string, roleId: string, $limit?: number, $skip?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            assertParamExists('iamOrganisationRoleEventList', 'organisationId', organisationId)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('iamOrganisationRoleEventList', 'roleId', roleId)
            const localVarPath = `/iam/organisation/{organisationId}/role/{roleId}/event`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)))
                .replace(`{${"roleId"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if ($limit !== undefined) {
                localVarQueryParameter['$limit'] = $limit;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single role
         * @summary Get iam/role
         * @param {string} organisationId Organisation Id
         * @param {string} roleId Role Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationRoleGet: async (organisationId: string, roleId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            assertParamExists('iamOrganisationRoleGet', 'organisationId', organisationId)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('iamOrganisationRoleGet', 'roleId', roleId)
            const localVarPath = `/iam/organisation/{organisationId}/role/{roleId}`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)))
                .replace(`{${"roleId"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List role
         * @summary List iam/role
         * @param {string} organisationId Organisation Id
         * @param {string} [name] Filter by name
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationRoleList: async (organisationId: string, name?: string, tagValue?: string, tagKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            assertParamExists('iamOrganisationRoleList', 'organisationId', organisationId)
            const localVarPath = `/iam/organisation/{organisationId}/role`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (tagValue !== undefined) {
                localVarQueryParameter['tag.value'] = tagValue;
            }

            if (tagKey !== undefined) {
                localVarQueryParameter['tag.key'] = tagKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create iam/role.permission
         * @summary Create iam/role.permission
         * @param {string} organisationId Organisation Id
         * @param {string} roleId Role Id
         * @param {IamPermission} iamPermission 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationRolePermissionCreate: async (organisationId: string, roleId: string, iamPermission: IamPermission, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            assertParamExists('iamOrganisationRolePermissionCreate', 'organisationId', organisationId)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('iamOrganisationRolePermissionCreate', 'roleId', roleId)
            // verify required parameter 'iamPermission' is not null or undefined
            assertParamExists('iamOrganisationRolePermissionCreate', 'iamPermission', iamPermission)
            const localVarPath = `/iam/organisation/{organisationId}/role/{roleId}/permission`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)))
                .replace(`{${"roleId"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(iamPermission, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete iam/role.permission
         * @summary Delete iam/role.permission
         * @param {string} organisationId Organisation Id
         * @param {string} roleId Role Id
         * @param {string} permissionId permissionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationRolePermissionDelete: async (organisationId: string, roleId: string, permissionId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            assertParamExists('iamOrganisationRolePermissionDelete', 'organisationId', organisationId)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('iamOrganisationRolePermissionDelete', 'roleId', roleId)
            // verify required parameter 'permissionId' is not null or undefined
            assertParamExists('iamOrganisationRolePermissionDelete', 'permissionId', permissionId)
            const localVarPath = `/iam/organisation/{organisationId}/role/{roleId}/permission/{permissionId}`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)))
                .replace(`{${"roleId"}}`, encodeURIComponent(String(roleId)))
                .replace(`{${"permissionId"}}`, encodeURIComponent(String(permissionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get iam/role.permission
         * @summary Get iam/role.permission
         * @param {string} organisationId Organisation Id
         * @param {string} roleId Role Id
         * @param {string} permissionId permissionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationRolePermissionGet: async (organisationId: string, roleId: string, permissionId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            assertParamExists('iamOrganisationRolePermissionGet', 'organisationId', organisationId)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('iamOrganisationRolePermissionGet', 'roleId', roleId)
            // verify required parameter 'permissionId' is not null or undefined
            assertParamExists('iamOrganisationRolePermissionGet', 'permissionId', permissionId)
            const localVarPath = `/iam/organisation/{organisationId}/role/{roleId}/permission/{permissionId}`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)))
                .replace(`{${"roleId"}}`, encodeURIComponent(String(roleId)))
                .replace(`{${"permissionId"}}`, encodeURIComponent(String(permissionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List iam/role.permission
         * @summary List iam/role.permission
         * @param {string} organisationId Organisation Id
         * @param {string} roleId Role Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationRolePermissionList: async (organisationId: string, roleId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            assertParamExists('iamOrganisationRolePermissionList', 'organisationId', organisationId)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('iamOrganisationRolePermissionList', 'roleId', roleId)
            const localVarPath = `/iam/organisation/{organisationId}/role/{roleId}/permission`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)))
                .replace(`{${"roleId"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replace iam/role.permission
         * @summary Replace iam/role.permission
         * @param {string} organisationId Organisation Id
         * @param {string} roleId Role Id
         * @param {Array<IamPermission>} iamPermission 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationRolePermissionPut: async (organisationId: string, roleId: string, iamPermission: Array<IamPermission>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            assertParamExists('iamOrganisationRolePermissionPut', 'organisationId', organisationId)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('iamOrganisationRolePermissionPut', 'roleId', roleId)
            // verify required parameter 'iamPermission' is not null or undefined
            assertParamExists('iamOrganisationRolePermissionPut', 'iamPermission', iamPermission)
            const localVarPath = `/iam/organisation/{organisationId}/role/{roleId}/permission`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)))
                .replace(`{${"roleId"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(iamPermission, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get iam/role.service
         * @summary Get iam/role.service
         * @param {string} organisationId Organisation Id
         * @param {string} roleId Role Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationRoleServiceGet: async (organisationId: string, roleId: string, serviceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            assertParamExists('iamOrganisationRoleServiceGet', 'organisationId', organisationId)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('iamOrganisationRoleServiceGet', 'roleId', roleId)
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('iamOrganisationRoleServiceGet', 'serviceId', serviceId)
            const localVarPath = `/iam/organisation/{organisationId}/role/{roleId}/service/{serviceId}`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)))
                .replace(`{${"roleId"}}`, encodeURIComponent(String(roleId)))
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List iam/role.service
         * @summary List iam/role.service
         * @param {string} organisationId Organisation Id
         * @param {string} roleId Role Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationRoleServiceList: async (organisationId: string, roleId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            assertParamExists('iamOrganisationRoleServiceList', 'organisationId', organisationId)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('iamOrganisationRoleServiceList', 'roleId', roleId)
            const localVarPath = `/iam/organisation/{organisationId}/role/{roleId}/service`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)))
                .replace(`{${"roleId"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create iam/role.tag
         * @summary Create iam/role.tag
         * @param {string} organisationId Organisation Id
         * @param {string} roleId Role Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationRoleTagCreate: async (organisationId: string, roleId: string, tag: Tag, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            assertParamExists('iamOrganisationRoleTagCreate', 'organisationId', organisationId)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('iamOrganisationRoleTagCreate', 'roleId', roleId)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('iamOrganisationRoleTagCreate', 'tag', tag)
            const localVarPath = `/iam/organisation/{organisationId}/role/{roleId}/tag`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)))
                .replace(`{${"roleId"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tag, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete iam/role.tag
         * @summary Delete iam/role.tag
         * @param {string} organisationId Organisation Id
         * @param {string} roleId Role Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationRoleTagDelete: async (organisationId: string, roleId: string, tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            assertParamExists('iamOrganisationRoleTagDelete', 'organisationId', organisationId)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('iamOrganisationRoleTagDelete', 'roleId', roleId)
            // verify required parameter 'tagId' is not null or undefined
            assertParamExists('iamOrganisationRoleTagDelete', 'tagId', tagId)
            const localVarPath = `/iam/organisation/{organisationId}/role/{roleId}/tag/{tagId}`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)))
                .replace(`{${"roleId"}}`, encodeURIComponent(String(roleId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get iam/role.tag
         * @summary Get iam/role.tag
         * @param {string} organisationId Organisation Id
         * @param {string} roleId Role Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationRoleTagGet: async (organisationId: string, roleId: string, tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            assertParamExists('iamOrganisationRoleTagGet', 'organisationId', organisationId)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('iamOrganisationRoleTagGet', 'roleId', roleId)
            // verify required parameter 'tagId' is not null or undefined
            assertParamExists('iamOrganisationRoleTagGet', 'tagId', tagId)
            const localVarPath = `/iam/organisation/{organisationId}/role/{roleId}/tag/{tagId}`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)))
                .replace(`{${"roleId"}}`, encodeURIComponent(String(roleId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List iam/role.tag
         * @summary List iam/role.tag
         * @param {string} organisationId Organisation Id
         * @param {string} roleId Role Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationRoleTagList: async (organisationId: string, roleId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            assertParamExists('iamOrganisationRoleTagList', 'organisationId', organisationId)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('iamOrganisationRoleTagList', 'roleId', roleId)
            const localVarPath = `/iam/organisation/{organisationId}/role/{roleId}/tag`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)))
                .replace(`{${"roleId"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replace iam/role.tag
         * @summary Replace iam/role.tag
         * @param {string} organisationId Organisation Id
         * @param {string} roleId Role Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationRoleTagPut: async (organisationId: string, roleId: string, tag: Array<Tag>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            assertParamExists('iamOrganisationRoleTagPut', 'organisationId', organisationId)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('iamOrganisationRoleTagPut', 'roleId', roleId)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('iamOrganisationRoleTagPut', 'tag', tag)
            const localVarPath = `/iam/organisation/{organisationId}/role/{roleId}/tag`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)))
                .replace(`{${"roleId"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tag, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns modified role
         * @summary Update iam/role
         * @param {string} organisationId Organisation Id
         * @param {string} roleId Role Id
         * @param {IamProjectRoleUpdate} iamProjectRoleUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationRoleUpdate: async (organisationId: string, roleId: string, iamProjectRoleUpdate: IamProjectRoleUpdate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'organisationId' is not null or undefined
            assertParamExists('iamOrganisationRoleUpdate', 'organisationId', organisationId)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('iamOrganisationRoleUpdate', 'roleId', roleId)
            // verify required parameter 'iamProjectRoleUpdate' is not null or undefined
            assertParamExists('iamOrganisationRoleUpdate', 'iamProjectRoleUpdate', iamProjectRoleUpdate)
            const localVarPath = `/iam/organisation/{organisationId}/role/{roleId}`
                .replace(`{${"organisationId"}}`, encodeURIComponent(String(organisationId)))
                .replace(`{${"roleId"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(iamProjectRoleUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IamOrganisationRoleApi - functional programming interface
 * @export
 */
export const IamOrganisationRoleApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IamOrganisationRoleApiAxiosParamCreator(configuration)
    return {
        /**
         * Create role
         * @summary Create iam/role
         * @param {string} organisationId Organisation Id
         * @param {IamProjectRoleCreate} iamProjectRoleCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationRoleCreate(organisationId: string, iamProjectRoleCreate: IamProjectRoleCreate, xIdempotencyKey?: string, xDryRun?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Role>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamOrganisationRoleCreate(organisationId, iamProjectRoleCreate, xIdempotencyKey, xDryRun, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete role
         * @summary Delete iam/role
         * @param {string} organisationId Organisation Id
         * @param {string} roleId Role Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationRoleDelete(organisationId: string, roleId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamOrganisationRoleDelete(organisationId, roleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get iam/role.event
         * @summary Get iam/role.event
         * @param {string} organisationId Organisation Id
         * @param {string} roleId Role Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationRoleEventGet(organisationId: string, roleId: string, eventId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamOrganisationRoleEventGet(organisationId, roleId, eventId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List iam/role.event
         * @summary List iam/role.event
         * @param {string} organisationId Organisation Id
         * @param {string} roleId Role Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationRoleEventList(organisationId: string, roleId: string, $limit?: number, $skip?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Event>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamOrganisationRoleEventList(organisationId, roleId, $limit, $skip, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a single role
         * @summary Get iam/role
         * @param {string} organisationId Organisation Id
         * @param {string} roleId Role Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationRoleGet(organisationId: string, roleId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Role>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamOrganisationRoleGet(organisationId, roleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List role
         * @summary List iam/role
         * @param {string} organisationId Organisation Id
         * @param {string} [name] Filter by name
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationRoleList(organisationId: string, name?: string, tagValue?: string, tagKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Role>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamOrganisationRoleList(organisationId, name, tagValue, tagKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create iam/role.permission
         * @summary Create iam/role.permission
         * @param {string} organisationId Organisation Id
         * @param {string} roleId Role Id
         * @param {IamPermission} iamPermission 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationRolePermissionCreate(organisationId: string, roleId: string, iamPermission: IamPermission, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IamPermission>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamOrganisationRolePermissionCreate(organisationId, roleId, iamPermission, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete iam/role.permission
         * @summary Delete iam/role.permission
         * @param {string} organisationId Organisation Id
         * @param {string} roleId Role Id
         * @param {string} permissionId permissionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationRolePermissionDelete(organisationId: string, roleId: string, permissionId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IamPermission>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamOrganisationRolePermissionDelete(organisationId, roleId, permissionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get iam/role.permission
         * @summary Get iam/role.permission
         * @param {string} organisationId Organisation Id
         * @param {string} roleId Role Id
         * @param {string} permissionId permissionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationRolePermissionGet(organisationId: string, roleId: string, permissionId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IamPermission>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamOrganisationRolePermissionGet(organisationId, roleId, permissionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List iam/role.permission
         * @summary List iam/role.permission
         * @param {string} organisationId Organisation Id
         * @param {string} roleId Role Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationRolePermissionList(organisationId: string, roleId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<IamPermission>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamOrganisationRolePermissionList(organisationId, roleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Replace iam/role.permission
         * @summary Replace iam/role.permission
         * @param {string} organisationId Organisation Id
         * @param {string} roleId Role Id
         * @param {Array<IamPermission>} iamPermission 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationRolePermissionPut(organisationId: string, roleId: string, iamPermission: Array<IamPermission>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<IamPermission>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamOrganisationRolePermissionPut(organisationId, roleId, iamPermission, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get iam/role.service
         * @summary Get iam/role.service
         * @param {string} organisationId Organisation Id
         * @param {string} roleId Role Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationRoleServiceGet(organisationId: string, roleId: string, serviceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceService>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamOrganisationRoleServiceGet(organisationId, roleId, serviceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List iam/role.service
         * @summary List iam/role.service
         * @param {string} organisationId Organisation Id
         * @param {string} roleId Role Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationRoleServiceList(organisationId: string, roleId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResourceService>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamOrganisationRoleServiceList(organisationId, roleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create iam/role.tag
         * @summary Create iam/role.tag
         * @param {string} organisationId Organisation Id
         * @param {string} roleId Role Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationRoleTagCreate(organisationId: string, roleId: string, tag: Tag, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamOrganisationRoleTagCreate(organisationId, roleId, tag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete iam/role.tag
         * @summary Delete iam/role.tag
         * @param {string} organisationId Organisation Id
         * @param {string} roleId Role Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationRoleTagDelete(organisationId: string, roleId: string, tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamOrganisationRoleTagDelete(organisationId, roleId, tagId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get iam/role.tag
         * @summary Get iam/role.tag
         * @param {string} organisationId Organisation Id
         * @param {string} roleId Role Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationRoleTagGet(organisationId: string, roleId: string, tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamOrganisationRoleTagGet(organisationId, roleId, tagId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List iam/role.tag
         * @summary List iam/role.tag
         * @param {string} organisationId Organisation Id
         * @param {string} roleId Role Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationRoleTagList(organisationId: string, roleId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamOrganisationRoleTagList(organisationId, roleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Replace iam/role.tag
         * @summary Replace iam/role.tag
         * @param {string} organisationId Organisation Id
         * @param {string} roleId Role Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationRoleTagPut(organisationId: string, roleId: string, tag: Array<Tag>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamOrganisationRoleTagPut(organisationId, roleId, tag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns modified role
         * @summary Update iam/role
         * @param {string} organisationId Organisation Id
         * @param {string} roleId Role Id
         * @param {IamProjectRoleUpdate} iamProjectRoleUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamOrganisationRoleUpdate(organisationId: string, roleId: string, iamProjectRoleUpdate: IamProjectRoleUpdate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Role>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamOrganisationRoleUpdate(organisationId, roleId, iamProjectRoleUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * IamOrganisationRoleApi - factory interface
 * @export
 */
export const IamOrganisationRoleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IamOrganisationRoleApiFp(configuration)
    return {
        /**
         * Create role
         * @summary Create iam/role
         * @param {string} organisationId Organisation Id
         * @param {IamProjectRoleCreate} iamProjectRoleCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationRoleCreate(organisationId: string, iamProjectRoleCreate: IamProjectRoleCreate, xIdempotencyKey?: string, xDryRun?: string, options?: any): AxiosPromise<Role> {
            return localVarFp.iamOrganisationRoleCreate(organisationId, iamProjectRoleCreate, xIdempotencyKey, xDryRun, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete role
         * @summary Delete iam/role
         * @param {string} organisationId Organisation Id
         * @param {string} roleId Role Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationRoleDelete(organisationId: string, roleId: string, options?: any): AxiosPromise<void> {
            return localVarFp.iamOrganisationRoleDelete(organisationId, roleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get iam/role.event
         * @summary Get iam/role.event
         * @param {string} organisationId Organisation Id
         * @param {string} roleId Role Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationRoleEventGet(organisationId: string, roleId: string, eventId: string, options?: any): AxiosPromise<Event> {
            return localVarFp.iamOrganisationRoleEventGet(organisationId, roleId, eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * List iam/role.event
         * @summary List iam/role.event
         * @param {string} organisationId Organisation Id
         * @param {string} roleId Role Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationRoleEventList(organisationId: string, roleId: string, $limit?: number, $skip?: number, options?: any): AxiosPromise<Array<Event>> {
            return localVarFp.iamOrganisationRoleEventList(organisationId, roleId, $limit, $skip, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single role
         * @summary Get iam/role
         * @param {string} organisationId Organisation Id
         * @param {string} roleId Role Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationRoleGet(organisationId: string, roleId: string, options?: any): AxiosPromise<Role> {
            return localVarFp.iamOrganisationRoleGet(organisationId, roleId, options).then((request) => request(axios, basePath));
        },
        /**
         * List role
         * @summary List iam/role
         * @param {string} organisationId Organisation Id
         * @param {string} [name] Filter by name
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationRoleList(organisationId: string, name?: string, tagValue?: string, tagKey?: string, options?: any): AxiosPromise<Array<Role>> {
            return localVarFp.iamOrganisationRoleList(organisationId, name, tagValue, tagKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Create iam/role.permission
         * @summary Create iam/role.permission
         * @param {string} organisationId Organisation Id
         * @param {string} roleId Role Id
         * @param {IamPermission} iamPermission 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationRolePermissionCreate(organisationId: string, roleId: string, iamPermission: IamPermission, options?: any): AxiosPromise<IamPermission> {
            return localVarFp.iamOrganisationRolePermissionCreate(organisationId, roleId, iamPermission, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete iam/role.permission
         * @summary Delete iam/role.permission
         * @param {string} organisationId Organisation Id
         * @param {string} roleId Role Id
         * @param {string} permissionId permissionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationRolePermissionDelete(organisationId: string, roleId: string, permissionId: string, options?: any): AxiosPromise<IamPermission> {
            return localVarFp.iamOrganisationRolePermissionDelete(organisationId, roleId, permissionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get iam/role.permission
         * @summary Get iam/role.permission
         * @param {string} organisationId Organisation Id
         * @param {string} roleId Role Id
         * @param {string} permissionId permissionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationRolePermissionGet(organisationId: string, roleId: string, permissionId: string, options?: any): AxiosPromise<IamPermission> {
            return localVarFp.iamOrganisationRolePermissionGet(organisationId, roleId, permissionId, options).then((request) => request(axios, basePath));
        },
        /**
         * List iam/role.permission
         * @summary List iam/role.permission
         * @param {string} organisationId Organisation Id
         * @param {string} roleId Role Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationRolePermissionList(organisationId: string, roleId: string, options?: any): AxiosPromise<Array<IamPermission>> {
            return localVarFp.iamOrganisationRolePermissionList(organisationId, roleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Replace iam/role.permission
         * @summary Replace iam/role.permission
         * @param {string} organisationId Organisation Id
         * @param {string} roleId Role Id
         * @param {Array<IamPermission>} iamPermission 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationRolePermissionPut(organisationId: string, roleId: string, iamPermission: Array<IamPermission>, options?: any): AxiosPromise<Array<IamPermission>> {
            return localVarFp.iamOrganisationRolePermissionPut(organisationId, roleId, iamPermission, options).then((request) => request(axios, basePath));
        },
        /**
         * Get iam/role.service
         * @summary Get iam/role.service
         * @param {string} organisationId Organisation Id
         * @param {string} roleId Role Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationRoleServiceGet(organisationId: string, roleId: string, serviceId: string, options?: any): AxiosPromise<ResourceService> {
            return localVarFp.iamOrganisationRoleServiceGet(organisationId, roleId, serviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * List iam/role.service
         * @summary List iam/role.service
         * @param {string} organisationId Organisation Id
         * @param {string} roleId Role Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationRoleServiceList(organisationId: string, roleId: string, options?: any): AxiosPromise<Array<ResourceService>> {
            return localVarFp.iamOrganisationRoleServiceList(organisationId, roleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create iam/role.tag
         * @summary Create iam/role.tag
         * @param {string} organisationId Organisation Id
         * @param {string} roleId Role Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationRoleTagCreate(organisationId: string, roleId: string, tag: Tag, options?: any): AxiosPromise<Tag> {
            return localVarFp.iamOrganisationRoleTagCreate(organisationId, roleId, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete iam/role.tag
         * @summary Delete iam/role.tag
         * @param {string} organisationId Organisation Id
         * @param {string} roleId Role Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationRoleTagDelete(organisationId: string, roleId: string, tagId: string, options?: any): AxiosPromise<void> {
            return localVarFp.iamOrganisationRoleTagDelete(organisationId, roleId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get iam/role.tag
         * @summary Get iam/role.tag
         * @param {string} organisationId Organisation Id
         * @param {string} roleId Role Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationRoleTagGet(organisationId: string, roleId: string, tagId: string, options?: any): AxiosPromise<Tag> {
            return localVarFp.iamOrganisationRoleTagGet(organisationId, roleId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * List iam/role.tag
         * @summary List iam/role.tag
         * @param {string} organisationId Organisation Id
         * @param {string} roleId Role Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationRoleTagList(organisationId: string, roleId: string, options?: any): AxiosPromise<Array<Tag>> {
            return localVarFp.iamOrganisationRoleTagList(organisationId, roleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Replace iam/role.tag
         * @summary Replace iam/role.tag
         * @param {string} organisationId Organisation Id
         * @param {string} roleId Role Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationRoleTagPut(organisationId: string, roleId: string, tag: Array<Tag>, options?: any): AxiosPromise<Array<Tag>> {
            return localVarFp.iamOrganisationRoleTagPut(organisationId, roleId, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns modified role
         * @summary Update iam/role
         * @param {string} organisationId Organisation Id
         * @param {string} roleId Role Id
         * @param {IamProjectRoleUpdate} iamProjectRoleUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamOrganisationRoleUpdate(organisationId: string, roleId: string, iamProjectRoleUpdate: IamProjectRoleUpdate, options?: any): AxiosPromise<Role> {
            return localVarFp.iamOrganisationRoleUpdate(organisationId, roleId, iamProjectRoleUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IamOrganisationRoleApi - object-oriented interface
 * @export
 * @class IamOrganisationRoleApi
 * @extends {BaseAPI}
 */
export class IamOrganisationRoleApi extends BaseAPI {
    /**
     * Create role
     * @summary Create iam/role
     * @param {string} organisationId Organisation Id
     * @param {IamProjectRoleCreate} iamProjectRoleCreate 
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {string} [xDryRun] Dry run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationRoleApi
     */
    public iamOrganisationRoleCreate(organisationId: string, iamProjectRoleCreate: IamProjectRoleCreate, xIdempotencyKey?: string, xDryRun?: string, options?: any) {
        return IamOrganisationRoleApiFp(this.configuration).iamOrganisationRoleCreate(organisationId, iamProjectRoleCreate, xIdempotencyKey, xDryRun, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete role
     * @summary Delete iam/role
     * @param {string} organisationId Organisation Id
     * @param {string} roleId Role Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationRoleApi
     */
    public iamOrganisationRoleDelete(organisationId: string, roleId: string, options?: any) {
        return IamOrganisationRoleApiFp(this.configuration).iamOrganisationRoleDelete(organisationId, roleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get iam/role.event
     * @summary Get iam/role.event
     * @param {string} organisationId Organisation Id
     * @param {string} roleId Role Id
     * @param {string} eventId eventId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationRoleApi
     */
    public iamOrganisationRoleEventGet(organisationId: string, roleId: string, eventId: string, options?: any) {
        return IamOrganisationRoleApiFp(this.configuration).iamOrganisationRoleEventGet(organisationId, roleId, eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List iam/role.event
     * @summary List iam/role.event
     * @param {string} organisationId Organisation Id
     * @param {string} roleId Role Id
     * @param {number} [$limit] $limit
     * @param {number} [$skip] $skip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationRoleApi
     */
    public iamOrganisationRoleEventList(organisationId: string, roleId: string, $limit?: number, $skip?: number, options?: any) {
        return IamOrganisationRoleApiFp(this.configuration).iamOrganisationRoleEventList(organisationId, roleId, $limit, $skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single role
     * @summary Get iam/role
     * @param {string} organisationId Organisation Id
     * @param {string} roleId Role Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationRoleApi
     */
    public iamOrganisationRoleGet(organisationId: string, roleId: string, options?: any) {
        return IamOrganisationRoleApiFp(this.configuration).iamOrganisationRoleGet(organisationId, roleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List role
     * @summary List iam/role
     * @param {string} organisationId Organisation Id
     * @param {string} [name] Filter by name
     * @param {string} [tagValue] Filter by tag.value
     * @param {string} [tagKey] Filter by tag.key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationRoleApi
     */
    public iamOrganisationRoleList(organisationId: string, name?: string, tagValue?: string, tagKey?: string, options?: any) {
        return IamOrganisationRoleApiFp(this.configuration).iamOrganisationRoleList(organisationId, name, tagValue, tagKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create iam/role.permission
     * @summary Create iam/role.permission
     * @param {string} organisationId Organisation Id
     * @param {string} roleId Role Id
     * @param {IamPermission} iamPermission 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationRoleApi
     */
    public iamOrganisationRolePermissionCreate(organisationId: string, roleId: string, iamPermission: IamPermission, options?: any) {
        return IamOrganisationRoleApiFp(this.configuration).iamOrganisationRolePermissionCreate(organisationId, roleId, iamPermission, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete iam/role.permission
     * @summary Delete iam/role.permission
     * @param {string} organisationId Organisation Id
     * @param {string} roleId Role Id
     * @param {string} permissionId permissionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationRoleApi
     */
    public iamOrganisationRolePermissionDelete(organisationId: string, roleId: string, permissionId: string, options?: any) {
        return IamOrganisationRoleApiFp(this.configuration).iamOrganisationRolePermissionDelete(organisationId, roleId, permissionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get iam/role.permission
     * @summary Get iam/role.permission
     * @param {string} organisationId Organisation Id
     * @param {string} roleId Role Id
     * @param {string} permissionId permissionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationRoleApi
     */
    public iamOrganisationRolePermissionGet(organisationId: string, roleId: string, permissionId: string, options?: any) {
        return IamOrganisationRoleApiFp(this.configuration).iamOrganisationRolePermissionGet(organisationId, roleId, permissionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List iam/role.permission
     * @summary List iam/role.permission
     * @param {string} organisationId Organisation Id
     * @param {string} roleId Role Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationRoleApi
     */
    public iamOrganisationRolePermissionList(organisationId: string, roleId: string, options?: any) {
        return IamOrganisationRoleApiFp(this.configuration).iamOrganisationRolePermissionList(organisationId, roleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replace iam/role.permission
     * @summary Replace iam/role.permission
     * @param {string} organisationId Organisation Id
     * @param {string} roleId Role Id
     * @param {Array<IamPermission>} iamPermission 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationRoleApi
     */
    public iamOrganisationRolePermissionPut(organisationId: string, roleId: string, iamPermission: Array<IamPermission>, options?: any) {
        return IamOrganisationRoleApiFp(this.configuration).iamOrganisationRolePermissionPut(organisationId, roleId, iamPermission, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get iam/role.service
     * @summary Get iam/role.service
     * @param {string} organisationId Organisation Id
     * @param {string} roleId Role Id
     * @param {string} serviceId serviceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationRoleApi
     */
    public iamOrganisationRoleServiceGet(organisationId: string, roleId: string, serviceId: string, options?: any) {
        return IamOrganisationRoleApiFp(this.configuration).iamOrganisationRoleServiceGet(organisationId, roleId, serviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List iam/role.service
     * @summary List iam/role.service
     * @param {string} organisationId Organisation Id
     * @param {string} roleId Role Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationRoleApi
     */
    public iamOrganisationRoleServiceList(organisationId: string, roleId: string, options?: any) {
        return IamOrganisationRoleApiFp(this.configuration).iamOrganisationRoleServiceList(organisationId, roleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create iam/role.tag
     * @summary Create iam/role.tag
     * @param {string} organisationId Organisation Id
     * @param {string} roleId Role Id
     * @param {Tag} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationRoleApi
     */
    public iamOrganisationRoleTagCreate(organisationId: string, roleId: string, tag: Tag, options?: any) {
        return IamOrganisationRoleApiFp(this.configuration).iamOrganisationRoleTagCreate(organisationId, roleId, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete iam/role.tag
     * @summary Delete iam/role.tag
     * @param {string} organisationId Organisation Id
     * @param {string} roleId Role Id
     * @param {string} tagId tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationRoleApi
     */
    public iamOrganisationRoleTagDelete(organisationId: string, roleId: string, tagId: string, options?: any) {
        return IamOrganisationRoleApiFp(this.configuration).iamOrganisationRoleTagDelete(organisationId, roleId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get iam/role.tag
     * @summary Get iam/role.tag
     * @param {string} organisationId Organisation Id
     * @param {string} roleId Role Id
     * @param {string} tagId tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationRoleApi
     */
    public iamOrganisationRoleTagGet(organisationId: string, roleId: string, tagId: string, options?: any) {
        return IamOrganisationRoleApiFp(this.configuration).iamOrganisationRoleTagGet(organisationId, roleId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List iam/role.tag
     * @summary List iam/role.tag
     * @param {string} organisationId Organisation Id
     * @param {string} roleId Role Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationRoleApi
     */
    public iamOrganisationRoleTagList(organisationId: string, roleId: string, options?: any) {
        return IamOrganisationRoleApiFp(this.configuration).iamOrganisationRoleTagList(organisationId, roleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replace iam/role.tag
     * @summary Replace iam/role.tag
     * @param {string} organisationId Organisation Id
     * @param {string} roleId Role Id
     * @param {Array<Tag>} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationRoleApi
     */
    public iamOrganisationRoleTagPut(organisationId: string, roleId: string, tag: Array<Tag>, options?: any) {
        return IamOrganisationRoleApiFp(this.configuration).iamOrganisationRoleTagPut(organisationId, roleId, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns modified role
     * @summary Update iam/role
     * @param {string} organisationId Organisation Id
     * @param {string} roleId Role Id
     * @param {IamProjectRoleUpdate} iamProjectRoleUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamOrganisationRoleApi
     */
    public iamOrganisationRoleUpdate(organisationId: string, roleId: string, iamProjectRoleUpdate: IamProjectRoleUpdate, options?: any) {
        return IamOrganisationRoleApiFp(this.configuration).iamOrganisationRoleUpdate(organisationId, roleId, iamProjectRoleUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * IamProjectApi - axios parameter creator
 * @export
 */
export const IamProjectApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List iam/project.billing
         * @summary List iam/project.billing
         * @param {string} projectId Project Id
         * @param {string} [start] start
         * @param {string} [end] end
         * @param {string} [resourceType] resource.type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectBillingList: async (projectId: string, start?: string, end?: string, resourceType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('iamProjectBillingList', 'projectId', projectId)
            const localVarPath = `/iam/project/{projectId}/billing`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = (start as any instanceof Date) ?
                    (start as any).toISOString() :
                    start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = (end as any instanceof Date) ?
                    (end as any).toISOString() :
                    end;
            }

            if (resourceType !== undefined) {
                localVarQueryParameter['resource.type'] = resourceType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create project
         * @summary Create iam/project
         * @param {IamProjectCreate} iamProjectCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectCreate: async (iamProjectCreate: IamProjectCreate, xIdempotencyKey?: string, xDryRun?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'iamProjectCreate' is not null or undefined
            assertParamExists('iamProjectCreate', 'iamProjectCreate', iamProjectCreate)
            const localVarPath = `/iam/project`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }

            if (xDryRun !== undefined && xDryRun !== null) {
                localVarHeaderParameter['x-dry-run'] = String(xDryRun);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(iamProjectCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create iam/project.credentialStore
         * @summary Create iam/project.credentialStore
         * @param {string} projectId Project Id
         * @param {ProjectCredential} projectCredential 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectCredentialStoreCreate: async (projectId: string, projectCredential: ProjectCredential, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('iamProjectCredentialStoreCreate', 'projectId', projectId)
            // verify required parameter 'projectCredential' is not null or undefined
            assertParamExists('iamProjectCredentialStoreCreate', 'projectCredential', projectCredential)
            const localVarPath = `/iam/project/{projectId}/credentialStore`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(projectCredential, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete iam/project.credentialStore
         * @summary Delete iam/project.credentialStore
         * @param {string} projectId Project Id
         * @param {string} credentialStoreId credentialStoreId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectCredentialStoreDelete: async (projectId: string, credentialStoreId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('iamProjectCredentialStoreDelete', 'projectId', projectId)
            // verify required parameter 'credentialStoreId' is not null or undefined
            assertParamExists('iamProjectCredentialStoreDelete', 'credentialStoreId', credentialStoreId)
            const localVarPath = `/iam/project/{projectId}/credentialStore/{credentialStoreId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"credentialStoreId"}}`, encodeURIComponent(String(credentialStoreId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get iam/project.credentialStore
         * @summary Get iam/project.credentialStore
         * @param {string} projectId Project Id
         * @param {string} credentialStoreId credentialStoreId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectCredentialStoreGet: async (projectId: string, credentialStoreId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('iamProjectCredentialStoreGet', 'projectId', projectId)
            // verify required parameter 'credentialStoreId' is not null or undefined
            assertParamExists('iamProjectCredentialStoreGet', 'credentialStoreId', credentialStoreId)
            const localVarPath = `/iam/project/{projectId}/credentialStore/{credentialStoreId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"credentialStoreId"}}`, encodeURIComponent(String(credentialStoreId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List iam/project.credentialStore
         * @summary List iam/project.credentialStore
         * @param {string} projectId Project Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectCredentialStoreList: async (projectId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('iamProjectCredentialStoreList', 'projectId', projectId)
            const localVarPath = `/iam/project/{projectId}/credentialStore`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update iam/project.credentialStore
         * @summary Update iam/project.credentialStore
         * @param {string} projectId Project Id
         * @param {string} credentialStoreId credentialStoreId
         * @param {IamProjectCredentialStorePatch} iamProjectCredentialStorePatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectCredentialStorePatch: async (projectId: string, credentialStoreId: string, iamProjectCredentialStorePatch: IamProjectCredentialStorePatch, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('iamProjectCredentialStorePatch', 'projectId', projectId)
            // verify required parameter 'credentialStoreId' is not null or undefined
            assertParamExists('iamProjectCredentialStorePatch', 'credentialStoreId', credentialStoreId)
            // verify required parameter 'iamProjectCredentialStorePatch' is not null or undefined
            assertParamExists('iamProjectCredentialStorePatch', 'iamProjectCredentialStorePatch', iamProjectCredentialStorePatch)
            const localVarPath = `/iam/project/{projectId}/credentialStore/{credentialStoreId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"credentialStoreId"}}`, encodeURIComponent(String(credentialStoreId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(iamProjectCredentialStorePatch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete project
         * @summary Delete iam/project
         * @param {string} projectId Project Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectDelete: async (projectId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('iamProjectDelete', 'projectId', projectId)
            const localVarPath = `/iam/project/{projectId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get iam/project.event
         * @summary Get iam/project.event
         * @param {string} projectId Project Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectEventGet: async (projectId: string, eventId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('iamProjectEventGet', 'projectId', projectId)
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('iamProjectEventGet', 'eventId', eventId)
            const localVarPath = `/iam/project/{projectId}/event/{eventId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List iam/project.event
         * @summary List iam/project.event
         * @param {string} projectId Project Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectEventList: async (projectId: string, $limit?: number, $skip?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('iamProjectEventList', 'projectId', projectId)
            const localVarPath = `/iam/project/{projectId}/event`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if ($limit !== undefined) {
                localVarQueryParameter['$limit'] = $limit;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single project
         * @summary Get iam/project
         * @param {string} projectId Project Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectGet: async (projectId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('iamProjectGet', 'projectId', projectId)
            const localVarPath = `/iam/project/{projectId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * action accept
         * @summary Accept iam/project.invitation
         * @param {string} projectId Project Id
         * @param {string} invitationId invitationId
         * @param {IamProjectInvitationAccept} iamProjectInvitationAccept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectInvitationAccept: async (projectId: string, invitationId: string, iamProjectInvitationAccept: IamProjectInvitationAccept, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('iamProjectInvitationAccept', 'projectId', projectId)
            // verify required parameter 'invitationId' is not null or undefined
            assertParamExists('iamProjectInvitationAccept', 'invitationId', invitationId)
            // verify required parameter 'iamProjectInvitationAccept' is not null or undefined
            assertParamExists('iamProjectInvitationAccept', 'iamProjectInvitationAccept', iamProjectInvitationAccept)
            const localVarPath = `/iam/project/{projectId}/invitation/{invitationId}/actions/accept`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"invitationId"}}`, encodeURIComponent(String(invitationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(iamProjectInvitationAccept, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete iam/project.invitation
         * @summary Delete iam/project.invitation
         * @param {string} projectId Project Id
         * @param {string} invitationId invitationId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectInvitationDelete: async (projectId: string, invitationId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('iamProjectInvitationDelete', 'projectId', projectId)
            // verify required parameter 'invitationId' is not null or undefined
            assertParamExists('iamProjectInvitationDelete', 'invitationId', invitationId)
            const localVarPath = `/iam/project/{projectId}/invitation/{invitationId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"invitationId"}}`, encodeURIComponent(String(invitationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get iam/project.invitation
         * @summary Get iam/project.invitation
         * @param {string} projectId Project Id
         * @param {string} invitationId invitationId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectInvitationGet: async (projectId: string, invitationId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('iamProjectInvitationGet', 'projectId', projectId)
            // verify required parameter 'invitationId' is not null or undefined
            assertParamExists('iamProjectInvitationGet', 'invitationId', invitationId)
            const localVarPath = `/iam/project/{projectId}/invitation/{invitationId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"invitationId"}}`, encodeURIComponent(String(invitationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List iam/project.invitation
         * @summary List iam/project.invitation
         * @param {string} projectId Project Id
         * @param {string} [resource] resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectInvitationList: async (projectId: string, resource?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('iamProjectInvitationList', 'projectId', projectId)
            const localVarPath = `/iam/project/{projectId}/invitation`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (resource !== undefined) {
                localVarQueryParameter['resource'] = resource;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List iam/project.invoice
         * @summary List iam/project.invoice
         * @param {string} projectId Project Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectInvoiceList: async (projectId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('iamProjectInvoiceList', 'projectId', projectId)
            const localVarPath = `/iam/project/{projectId}/invoice`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List project
         * @summary List iam/project
         * @param {string} [name] Filter by name
         * @param {number} [$limit] Filter by $limit
         * @param {boolean} [active] Filter by active
         * @param {string} [organisation] Filter by organisation
         * @param {boolean} [$lean] return a lightweight version of the resource
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectList: async (name?: string, $limit?: number, active?: boolean, organisation?: string, $lean?: boolean, tagValue?: string, tagKey?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/iam/project`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if ($limit !== undefined) {
                localVarQueryParameter['$limit'] = $limit;
            }

            if (active !== undefined) {
                localVarQueryParameter['active'] = active;
            }

            if (organisation !== undefined) {
                localVarQueryParameter['organisation'] = organisation;
            }

            if ($lean !== undefined) {
                localVarQueryParameter['$lean'] = $lean;
            }

            if (tagValue !== undefined) {
                localVarQueryParameter['tag.value'] = tagValue;
            }

            if (tagKey !== undefined) {
                localVarQueryParameter['tag.key'] = tagKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create iam/project.ownership
         * @summary Create iam/project.ownership
         * @param {string} projectId Project Id
         * @param {IamProjectOwnershipCreate} iamProjectOwnershipCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectOwnershipCreate: async (projectId: string, iamProjectOwnershipCreate: IamProjectOwnershipCreate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('iamProjectOwnershipCreate', 'projectId', projectId)
            // verify required parameter 'iamProjectOwnershipCreate' is not null or undefined
            assertParamExists('iamProjectOwnershipCreate', 'iamProjectOwnershipCreate', iamProjectOwnershipCreate)
            const localVarPath = `/iam/project/{projectId}/ownership`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(iamProjectOwnershipCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete iam/project.ownership
         * @summary Delete iam/project.ownership
         * @param {string} projectId Project Id
         * @param {string} ownershipId ownershipId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectOwnershipDelete: async (projectId: string, ownershipId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('iamProjectOwnershipDelete', 'projectId', projectId)
            // verify required parameter 'ownershipId' is not null or undefined
            assertParamExists('iamProjectOwnershipDelete', 'ownershipId', ownershipId)
            const localVarPath = `/iam/project/{projectId}/ownership/{ownershipId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"ownershipId"}}`, encodeURIComponent(String(ownershipId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get iam/project.ownership
         * @summary Get iam/project.ownership
         * @param {string} projectId Project Id
         * @param {string} ownershipId ownershipId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectOwnershipGet: async (projectId: string, ownershipId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('iamProjectOwnershipGet', 'projectId', projectId)
            // verify required parameter 'ownershipId' is not null or undefined
            assertParamExists('iamProjectOwnershipGet', 'ownershipId', ownershipId)
            const localVarPath = `/iam/project/{projectId}/ownership/{ownershipId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"ownershipId"}}`, encodeURIComponent(String(ownershipId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List iam/project.ownership
         * @summary List iam/project.ownership
         * @param {string} projectId Project Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectOwnershipList: async (projectId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('iamProjectOwnershipList', 'projectId', projectId)
            const localVarPath = `/iam/project/{projectId}/ownership`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List iam/project.payment
         * @summary List iam/project.payment
         * @param {string} projectId Project Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectPaymentList: async (projectId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('iamProjectPaymentList', 'projectId', projectId)
            const localVarPath = `/iam/project/{projectId}/payment`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List iam/project.proforma
         * @summary List iam/project.proforma
         * @param {string} projectId Project Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectProformaList: async (projectId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('iamProjectProformaList', 'projectId', projectId)
            const localVarPath = `/iam/project/{projectId}/proforma`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get iam/project.quota
         * @summary Get iam/project.quota
         * @param {string} projectId Project Id
         * @param {string} quotaId quotaId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectQuotaGet: async (projectId: string, quotaId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('iamProjectQuotaGet', 'projectId', projectId)
            // verify required parameter 'quotaId' is not null or undefined
            assertParamExists('iamProjectQuotaGet', 'quotaId', quotaId)
            const localVarPath = `/iam/project/{projectId}/quota/{quotaId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"quotaId"}}`, encodeURIComponent(String(quotaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update iam/project.limit
         * @summary Update iam/project.limit
         * @param {string} projectId Project Id
         * @param {string} quotaId quotaId
         * @param {IamProjectQuotaLimitPatch} iamProjectQuotaLimitPatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectQuotaLimitPatch: async (projectId: string, quotaId: string, iamProjectQuotaLimitPatch: IamProjectQuotaLimitPatch, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('iamProjectQuotaLimitPatch', 'projectId', projectId)
            // verify required parameter 'quotaId' is not null or undefined
            assertParamExists('iamProjectQuotaLimitPatch', 'quotaId', quotaId)
            // verify required parameter 'iamProjectQuotaLimitPatch' is not null or undefined
            assertParamExists('iamProjectQuotaLimitPatch', 'iamProjectQuotaLimitPatch', iamProjectQuotaLimitPatch)
            const localVarPath = `/iam/project/{projectId}/quota/{quotaId}/limit`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"quotaId"}}`, encodeURIComponent(String(quotaId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(iamProjectQuotaLimitPatch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List iam/project.quota
         * @summary List iam/project.quota
         * @param {string} projectId Project Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectQuotaList: async (projectId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('iamProjectQuotaList', 'projectId', projectId)
            const localVarPath = `/iam/project/{projectId}/quota`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get iam/project.service
         * @summary Get iam/project.service
         * @param {string} projectId Project Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectServiceGet: async (projectId: string, serviceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('iamProjectServiceGet', 'projectId', projectId)
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('iamProjectServiceGet', 'serviceId', serviceId)
            const localVarPath = `/iam/project/{projectId}/service/{serviceId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List iam/project.service
         * @summary List iam/project.service
         * @param {string} projectId Project Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectServiceList: async (projectId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('iamProjectServiceList', 'projectId', projectId)
            const localVarPath = `/iam/project/{projectId}/service`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create iam/project.tag
         * @summary Create iam/project.tag
         * @param {string} projectId Project Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectTagCreate: async (projectId: string, tag: Tag, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('iamProjectTagCreate', 'projectId', projectId)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('iamProjectTagCreate', 'tag', tag)
            const localVarPath = `/iam/project/{projectId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tag, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete iam/project.tag
         * @summary Delete iam/project.tag
         * @param {string} projectId Project Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectTagDelete: async (projectId: string, tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('iamProjectTagDelete', 'projectId', projectId)
            // verify required parameter 'tagId' is not null or undefined
            assertParamExists('iamProjectTagDelete', 'tagId', tagId)
            const localVarPath = `/iam/project/{projectId}/tag/{tagId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get iam/project.tag
         * @summary Get iam/project.tag
         * @param {string} projectId Project Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectTagGet: async (projectId: string, tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('iamProjectTagGet', 'projectId', projectId)
            // verify required parameter 'tagId' is not null or undefined
            assertParamExists('iamProjectTagGet', 'tagId', tagId)
            const localVarPath = `/iam/project/{projectId}/tag/{tagId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List iam/project.tag
         * @summary List iam/project.tag
         * @param {string} projectId Project Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectTagList: async (projectId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('iamProjectTagList', 'projectId', projectId)
            const localVarPath = `/iam/project/{projectId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replace iam/project.tag
         * @summary Replace iam/project.tag
         * @param {string} projectId Project Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectTagPut: async (projectId: string, tag: Array<Tag>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('iamProjectTagPut', 'projectId', projectId)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('iamProjectTagPut', 'tag', tag)
            const localVarPath = `/iam/project/{projectId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tag, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create iam/project.threshold
         * @summary Create iam/project.threshold
         * @param {string} projectId Project Id
         * @param {IamProjectThresholdCreate} iamProjectThresholdCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectThresholdCreate: async (projectId: string, iamProjectThresholdCreate: IamProjectThresholdCreate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('iamProjectThresholdCreate', 'projectId', projectId)
            // verify required parameter 'iamProjectThresholdCreate' is not null or undefined
            assertParamExists('iamProjectThresholdCreate', 'iamProjectThresholdCreate', iamProjectThresholdCreate)
            const localVarPath = `/iam/project/{projectId}/threshold`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(iamProjectThresholdCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete iam/project.threshold
         * @summary Delete iam/project.threshold
         * @param {string} projectId Project Id
         * @param {string} thresholdId thresholdId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectThresholdDelete: async (projectId: string, thresholdId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('iamProjectThresholdDelete', 'projectId', projectId)
            // verify required parameter 'thresholdId' is not null or undefined
            assertParamExists('iamProjectThresholdDelete', 'thresholdId', thresholdId)
            const localVarPath = `/iam/project/{projectId}/threshold/{thresholdId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"thresholdId"}}`, encodeURIComponent(String(thresholdId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get iam/project.threshold
         * @summary Get iam/project.threshold
         * @param {string} projectId Project Id
         * @param {string} thresholdId thresholdId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectThresholdGet: async (projectId: string, thresholdId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('iamProjectThresholdGet', 'projectId', projectId)
            // verify required parameter 'thresholdId' is not null or undefined
            assertParamExists('iamProjectThresholdGet', 'thresholdId', thresholdId)
            const localVarPath = `/iam/project/{projectId}/threshold/{thresholdId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"thresholdId"}}`, encodeURIComponent(String(thresholdId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List iam/project.threshold
         * @summary List iam/project.threshold
         * @param {string} projectId Project Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectThresholdList: async (projectId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('iamProjectThresholdList', 'projectId', projectId)
            const localVarPath = `/iam/project/{projectId}/threshold`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * action transfer
         * @summary Transfer iam/project
         * @param {string} projectId Project Id
         * @param {IamProjectTransfer} iamProjectTransfer 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectTransfer: async (projectId: string, iamProjectTransfer: IamProjectTransfer, xIdempotencyKey?: string, xDryRun?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('iamProjectTransfer', 'projectId', projectId)
            // verify required parameter 'iamProjectTransfer' is not null or undefined
            assertParamExists('iamProjectTransfer', 'iamProjectTransfer', iamProjectTransfer)
            const localVarPath = `/iam/project/{projectId}/actions/transfer`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }

            if (xDryRun !== undefined && xDryRun !== null) {
                localVarHeaderParameter['x-dry-run'] = String(xDryRun);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(iamProjectTransfer, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns modified project
         * @summary Update iam/project
         * @param {string} projectId Project Id
         * @param {IamProjectUpdate} iamProjectUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectUpdate: async (projectId: string, iamProjectUpdate: IamProjectUpdate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('iamProjectUpdate', 'projectId', projectId)
            // verify required parameter 'iamProjectUpdate' is not null or undefined
            assertParamExists('iamProjectUpdate', 'iamProjectUpdate', iamProjectUpdate)
            const localVarPath = `/iam/project/{projectId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(iamProjectUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IamProjectApi - functional programming interface
 * @export
 */
export const IamProjectApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IamProjectApiAxiosParamCreator(configuration)
    return {
        /**
         * List iam/project.billing
         * @summary List iam/project.billing
         * @param {string} projectId Project Id
         * @param {string} [start] start
         * @param {string} [end] end
         * @param {string} [resourceType] resource.type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectBillingList(projectId: string, start?: string, end?: string, resourceType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Billing>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamProjectBillingList(projectId, start, end, resourceType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create project
         * @summary Create iam/project
         * @param {IamProjectCreate} iamProjectCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectCreate(iamProjectCreate: IamProjectCreate, xIdempotencyKey?: string, xDryRun?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Project>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamProjectCreate(iamProjectCreate, xIdempotencyKey, xDryRun, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create iam/project.credentialStore
         * @summary Create iam/project.credentialStore
         * @param {string} projectId Project Id
         * @param {ProjectCredential} projectCredential 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectCredentialStoreCreate(projectId: string, projectCredential: ProjectCredential, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectCredential>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamProjectCredentialStoreCreate(projectId, projectCredential, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete iam/project.credentialStore
         * @summary Delete iam/project.credentialStore
         * @param {string} projectId Project Id
         * @param {string} credentialStoreId credentialStoreId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectCredentialStoreDelete(projectId: string, credentialStoreId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Project>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamProjectCredentialStoreDelete(projectId, credentialStoreId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get iam/project.credentialStore
         * @summary Get iam/project.credentialStore
         * @param {string} projectId Project Id
         * @param {string} credentialStoreId credentialStoreId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectCredentialStoreGet(projectId: string, credentialStoreId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectCredential>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamProjectCredentialStoreGet(projectId, credentialStoreId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List iam/project.credentialStore
         * @summary List iam/project.credentialStore
         * @param {string} projectId Project Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectCredentialStoreList(projectId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProjectCredential>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamProjectCredentialStoreList(projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update iam/project.credentialStore
         * @summary Update iam/project.credentialStore
         * @param {string} projectId Project Id
         * @param {string} credentialStoreId credentialStoreId
         * @param {IamProjectCredentialStorePatch} iamProjectCredentialStorePatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectCredentialStorePatch(projectId: string, credentialStoreId: string, iamProjectCredentialStorePatch: IamProjectCredentialStorePatch, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectCredential>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamProjectCredentialStorePatch(projectId, credentialStoreId, iamProjectCredentialStorePatch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete project
         * @summary Delete iam/project
         * @param {string} projectId Project Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectDelete(projectId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamProjectDelete(projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get iam/project.event
         * @summary Get iam/project.event
         * @param {string} projectId Project Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectEventGet(projectId: string, eventId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamProjectEventGet(projectId, eventId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List iam/project.event
         * @summary List iam/project.event
         * @param {string} projectId Project Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectEventList(projectId: string, $limit?: number, $skip?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Event>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamProjectEventList(projectId, $limit, $skip, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a single project
         * @summary Get iam/project
         * @param {string} projectId Project Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectGet(projectId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Project>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamProjectGet(projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * action accept
         * @summary Accept iam/project.invitation
         * @param {string} projectId Project Id
         * @param {string} invitationId invitationId
         * @param {IamProjectInvitationAccept} iamProjectInvitationAccept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectInvitationAccept(projectId: string, invitationId: string, iamProjectInvitationAccept: IamProjectInvitationAccept, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Invitation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamProjectInvitationAccept(projectId, invitationId, iamProjectInvitationAccept, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete iam/project.invitation
         * @summary Delete iam/project.invitation
         * @param {string} projectId Project Id
         * @param {string} invitationId invitationId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectInvitationDelete(projectId: string, invitationId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamProjectInvitationDelete(projectId, invitationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get iam/project.invitation
         * @summary Get iam/project.invitation
         * @param {string} projectId Project Id
         * @param {string} invitationId invitationId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectInvitationGet(projectId: string, invitationId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Invitation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamProjectInvitationGet(projectId, invitationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List iam/project.invitation
         * @summary List iam/project.invitation
         * @param {string} projectId Project Id
         * @param {string} [resource] resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectInvitationList(projectId: string, resource?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Invitation>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamProjectInvitationList(projectId, resource, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List iam/project.invoice
         * @summary List iam/project.invoice
         * @param {string} projectId Project Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectInvoiceList(projectId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Invoice>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamProjectInvoiceList(projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List project
         * @summary List iam/project
         * @param {string} [name] Filter by name
         * @param {number} [$limit] Filter by $limit
         * @param {boolean} [active] Filter by active
         * @param {string} [organisation] Filter by organisation
         * @param {boolean} [$lean] return a lightweight version of the resource
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectList(name?: string, $limit?: number, active?: boolean, organisation?: string, $lean?: boolean, tagValue?: string, tagKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Project>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamProjectList(name, $limit, active, organisation, $lean, tagValue, tagKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create iam/project.ownership
         * @summary Create iam/project.ownership
         * @param {string} projectId Project Id
         * @param {IamProjectOwnershipCreate} iamProjectOwnershipCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectOwnershipCreate(projectId: string, iamProjectOwnershipCreate: IamProjectOwnershipCreate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Project>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamProjectOwnershipCreate(projectId, iamProjectOwnershipCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete iam/project.ownership
         * @summary Delete iam/project.ownership
         * @param {string} projectId Project Id
         * @param {string} ownershipId ownershipId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectOwnershipDelete(projectId: string, ownershipId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamProjectOwnershipDelete(projectId, ownershipId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get iam/project.ownership
         * @summary Get iam/project.ownership
         * @param {string} projectId Project Id
         * @param {string} ownershipId ownershipId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectOwnershipGet(projectId: string, ownershipId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Ownership>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamProjectOwnershipGet(projectId, ownershipId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List iam/project.ownership
         * @summary List iam/project.ownership
         * @param {string} projectId Project Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectOwnershipList(projectId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Ownership>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamProjectOwnershipList(projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List iam/project.payment
         * @summary List iam/project.payment
         * @param {string} projectId Project Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectPaymentList(projectId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Payment>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamProjectPaymentList(projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List iam/project.proforma
         * @summary List iam/project.proforma
         * @param {string} projectId Project Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectProformaList(projectId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Proforma>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamProjectProformaList(projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get iam/project.quota
         * @summary Get iam/project.quota
         * @param {string} projectId Project Id
         * @param {string} quotaId quotaId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectQuotaGet(projectId: string, quotaId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Quota>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamProjectQuotaGet(projectId, quotaId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update iam/project.limit
         * @summary Update iam/project.limit
         * @param {string} projectId Project Id
         * @param {string} quotaId quotaId
         * @param {IamProjectQuotaLimitPatch} iamProjectQuotaLimitPatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectQuotaLimitPatch(projectId: string, quotaId: string, iamProjectQuotaLimitPatch: IamProjectQuotaLimitPatch, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QuotaLimit>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamProjectQuotaLimitPatch(projectId, quotaId, iamProjectQuotaLimitPatch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List iam/project.quota
         * @summary List iam/project.quota
         * @param {string} projectId Project Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectQuotaList(projectId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Quota>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamProjectQuotaList(projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get iam/project.service
         * @summary Get iam/project.service
         * @param {string} projectId Project Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectServiceGet(projectId: string, serviceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceService>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamProjectServiceGet(projectId, serviceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List iam/project.service
         * @summary List iam/project.service
         * @param {string} projectId Project Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectServiceList(projectId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResourceService>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamProjectServiceList(projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create iam/project.tag
         * @summary Create iam/project.tag
         * @param {string} projectId Project Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectTagCreate(projectId: string, tag: Tag, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamProjectTagCreate(projectId, tag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete iam/project.tag
         * @summary Delete iam/project.tag
         * @param {string} projectId Project Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectTagDelete(projectId: string, tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamProjectTagDelete(projectId, tagId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get iam/project.tag
         * @summary Get iam/project.tag
         * @param {string} projectId Project Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectTagGet(projectId: string, tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamProjectTagGet(projectId, tagId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List iam/project.tag
         * @summary List iam/project.tag
         * @param {string} projectId Project Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectTagList(projectId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamProjectTagList(projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Replace iam/project.tag
         * @summary Replace iam/project.tag
         * @param {string} projectId Project Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectTagPut(projectId: string, tag: Array<Tag>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamProjectTagPut(projectId, tag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create iam/project.threshold
         * @summary Create iam/project.threshold
         * @param {string} projectId Project Id
         * @param {IamProjectThresholdCreate} iamProjectThresholdCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectThresholdCreate(projectId: string, iamProjectThresholdCreate: IamProjectThresholdCreate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectThreshold>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamProjectThresholdCreate(projectId, iamProjectThresholdCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete iam/project.threshold
         * @summary Delete iam/project.threshold
         * @param {string} projectId Project Id
         * @param {string} thresholdId thresholdId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectThresholdDelete(projectId: string, thresholdId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamProjectThresholdDelete(projectId, thresholdId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get iam/project.threshold
         * @summary Get iam/project.threshold
         * @param {string} projectId Project Id
         * @param {string} thresholdId thresholdId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectThresholdGet(projectId: string, thresholdId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectThreshold>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamProjectThresholdGet(projectId, thresholdId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List iam/project.threshold
         * @summary List iam/project.threshold
         * @param {string} projectId Project Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectThresholdList(projectId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProjectThreshold>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamProjectThresholdList(projectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * action transfer
         * @summary Transfer iam/project
         * @param {string} projectId Project Id
         * @param {IamProjectTransfer} iamProjectTransfer 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectTransfer(projectId: string, iamProjectTransfer: IamProjectTransfer, xIdempotencyKey?: string, xDryRun?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Project>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamProjectTransfer(projectId, iamProjectTransfer, xIdempotencyKey, xDryRun, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns modified project
         * @summary Update iam/project
         * @param {string} projectId Project Id
         * @param {IamProjectUpdate} iamProjectUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectUpdate(projectId: string, iamProjectUpdate: IamProjectUpdate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Project>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamProjectUpdate(projectId, iamProjectUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * IamProjectApi - factory interface
 * @export
 */
export const IamProjectApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IamProjectApiFp(configuration)
    return {
        /**
         * List iam/project.billing
         * @summary List iam/project.billing
         * @param {string} projectId Project Id
         * @param {string} [start] start
         * @param {string} [end] end
         * @param {string} [resourceType] resource.type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectBillingList(projectId: string, start?: string, end?: string, resourceType?: string, options?: any): AxiosPromise<Array<Billing>> {
            return localVarFp.iamProjectBillingList(projectId, start, end, resourceType, options).then((request) => request(axios, basePath));
        },
        /**
         * Create project
         * @summary Create iam/project
         * @param {IamProjectCreate} iamProjectCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectCreate(iamProjectCreate: IamProjectCreate, xIdempotencyKey?: string, xDryRun?: string, options?: any): AxiosPromise<Project> {
            return localVarFp.iamProjectCreate(iamProjectCreate, xIdempotencyKey, xDryRun, options).then((request) => request(axios, basePath));
        },
        /**
         * Create iam/project.credentialStore
         * @summary Create iam/project.credentialStore
         * @param {string} projectId Project Id
         * @param {ProjectCredential} projectCredential 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectCredentialStoreCreate(projectId: string, projectCredential: ProjectCredential, options?: any): AxiosPromise<ProjectCredential> {
            return localVarFp.iamProjectCredentialStoreCreate(projectId, projectCredential, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete iam/project.credentialStore
         * @summary Delete iam/project.credentialStore
         * @param {string} projectId Project Id
         * @param {string} credentialStoreId credentialStoreId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectCredentialStoreDelete(projectId: string, credentialStoreId: string, options?: any): AxiosPromise<Project> {
            return localVarFp.iamProjectCredentialStoreDelete(projectId, credentialStoreId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get iam/project.credentialStore
         * @summary Get iam/project.credentialStore
         * @param {string} projectId Project Id
         * @param {string} credentialStoreId credentialStoreId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectCredentialStoreGet(projectId: string, credentialStoreId: string, options?: any): AxiosPromise<ProjectCredential> {
            return localVarFp.iamProjectCredentialStoreGet(projectId, credentialStoreId, options).then((request) => request(axios, basePath));
        },
        /**
         * List iam/project.credentialStore
         * @summary List iam/project.credentialStore
         * @param {string} projectId Project Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectCredentialStoreList(projectId: string, options?: any): AxiosPromise<Array<ProjectCredential>> {
            return localVarFp.iamProjectCredentialStoreList(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update iam/project.credentialStore
         * @summary Update iam/project.credentialStore
         * @param {string} projectId Project Id
         * @param {string} credentialStoreId credentialStoreId
         * @param {IamProjectCredentialStorePatch} iamProjectCredentialStorePatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectCredentialStorePatch(projectId: string, credentialStoreId: string, iamProjectCredentialStorePatch: IamProjectCredentialStorePatch, options?: any): AxiosPromise<ProjectCredential> {
            return localVarFp.iamProjectCredentialStorePatch(projectId, credentialStoreId, iamProjectCredentialStorePatch, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete project
         * @summary Delete iam/project
         * @param {string} projectId Project Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectDelete(projectId: string, options?: any): AxiosPromise<void> {
            return localVarFp.iamProjectDelete(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get iam/project.event
         * @summary Get iam/project.event
         * @param {string} projectId Project Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectEventGet(projectId: string, eventId: string, options?: any): AxiosPromise<Event> {
            return localVarFp.iamProjectEventGet(projectId, eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * List iam/project.event
         * @summary List iam/project.event
         * @param {string} projectId Project Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectEventList(projectId: string, $limit?: number, $skip?: number, options?: any): AxiosPromise<Array<Event>> {
            return localVarFp.iamProjectEventList(projectId, $limit, $skip, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single project
         * @summary Get iam/project
         * @param {string} projectId Project Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectGet(projectId: string, options?: any): AxiosPromise<Project> {
            return localVarFp.iamProjectGet(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * action accept
         * @summary Accept iam/project.invitation
         * @param {string} projectId Project Id
         * @param {string} invitationId invitationId
         * @param {IamProjectInvitationAccept} iamProjectInvitationAccept 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectInvitationAccept(projectId: string, invitationId: string, iamProjectInvitationAccept: IamProjectInvitationAccept, options?: any): AxiosPromise<Invitation> {
            return localVarFp.iamProjectInvitationAccept(projectId, invitationId, iamProjectInvitationAccept, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete iam/project.invitation
         * @summary Delete iam/project.invitation
         * @param {string} projectId Project Id
         * @param {string} invitationId invitationId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectInvitationDelete(projectId: string, invitationId: string, options?: any): AxiosPromise<void> {
            return localVarFp.iamProjectInvitationDelete(projectId, invitationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get iam/project.invitation
         * @summary Get iam/project.invitation
         * @param {string} projectId Project Id
         * @param {string} invitationId invitationId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectInvitationGet(projectId: string, invitationId: string, options?: any): AxiosPromise<Invitation> {
            return localVarFp.iamProjectInvitationGet(projectId, invitationId, options).then((request) => request(axios, basePath));
        },
        /**
         * List iam/project.invitation
         * @summary List iam/project.invitation
         * @param {string} projectId Project Id
         * @param {string} [resource] resource
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectInvitationList(projectId: string, resource?: string, options?: any): AxiosPromise<Array<Invitation>> {
            return localVarFp.iamProjectInvitationList(projectId, resource, options).then((request) => request(axios, basePath));
        },
        /**
         * List iam/project.invoice
         * @summary List iam/project.invoice
         * @param {string} projectId Project Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectInvoiceList(projectId: string, options?: any): AxiosPromise<Array<Invoice>> {
            return localVarFp.iamProjectInvoiceList(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * List project
         * @summary List iam/project
         * @param {string} [name] Filter by name
         * @param {number} [$limit] Filter by $limit
         * @param {boolean} [active] Filter by active
         * @param {string} [organisation] Filter by organisation
         * @param {boolean} [$lean] return a lightweight version of the resource
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectList(name?: string, $limit?: number, active?: boolean, organisation?: string, $lean?: boolean, tagValue?: string, tagKey?: string, options?: any): AxiosPromise<Array<Project>> {
            return localVarFp.iamProjectList(name, $limit, active, organisation, $lean, tagValue, tagKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Create iam/project.ownership
         * @summary Create iam/project.ownership
         * @param {string} projectId Project Id
         * @param {IamProjectOwnershipCreate} iamProjectOwnershipCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectOwnershipCreate(projectId: string, iamProjectOwnershipCreate: IamProjectOwnershipCreate, options?: any): AxiosPromise<Project> {
            return localVarFp.iamProjectOwnershipCreate(projectId, iamProjectOwnershipCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete iam/project.ownership
         * @summary Delete iam/project.ownership
         * @param {string} projectId Project Id
         * @param {string} ownershipId ownershipId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectOwnershipDelete(projectId: string, ownershipId: string, options?: any): AxiosPromise<void> {
            return localVarFp.iamProjectOwnershipDelete(projectId, ownershipId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get iam/project.ownership
         * @summary Get iam/project.ownership
         * @param {string} projectId Project Id
         * @param {string} ownershipId ownershipId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectOwnershipGet(projectId: string, ownershipId: string, options?: any): AxiosPromise<Ownership> {
            return localVarFp.iamProjectOwnershipGet(projectId, ownershipId, options).then((request) => request(axios, basePath));
        },
        /**
         * List iam/project.ownership
         * @summary List iam/project.ownership
         * @param {string} projectId Project Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectOwnershipList(projectId: string, options?: any): AxiosPromise<Array<Ownership>> {
            return localVarFp.iamProjectOwnershipList(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * List iam/project.payment
         * @summary List iam/project.payment
         * @param {string} projectId Project Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectPaymentList(projectId: string, options?: any): AxiosPromise<Array<Payment>> {
            return localVarFp.iamProjectPaymentList(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * List iam/project.proforma
         * @summary List iam/project.proforma
         * @param {string} projectId Project Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectProformaList(projectId: string, options?: any): AxiosPromise<Array<Proforma>> {
            return localVarFp.iamProjectProformaList(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get iam/project.quota
         * @summary Get iam/project.quota
         * @param {string} projectId Project Id
         * @param {string} quotaId quotaId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectQuotaGet(projectId: string, quotaId: string, options?: any): AxiosPromise<Quota> {
            return localVarFp.iamProjectQuotaGet(projectId, quotaId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update iam/project.limit
         * @summary Update iam/project.limit
         * @param {string} projectId Project Id
         * @param {string} quotaId quotaId
         * @param {IamProjectQuotaLimitPatch} iamProjectQuotaLimitPatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectQuotaLimitPatch(projectId: string, quotaId: string, iamProjectQuotaLimitPatch: IamProjectQuotaLimitPatch, options?: any): AxiosPromise<QuotaLimit> {
            return localVarFp.iamProjectQuotaLimitPatch(projectId, quotaId, iamProjectQuotaLimitPatch, options).then((request) => request(axios, basePath));
        },
        /**
         * List iam/project.quota
         * @summary List iam/project.quota
         * @param {string} projectId Project Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectQuotaList(projectId: string, options?: any): AxiosPromise<Array<Quota>> {
            return localVarFp.iamProjectQuotaList(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get iam/project.service
         * @summary Get iam/project.service
         * @param {string} projectId Project Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectServiceGet(projectId: string, serviceId: string, options?: any): AxiosPromise<ResourceService> {
            return localVarFp.iamProjectServiceGet(projectId, serviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * List iam/project.service
         * @summary List iam/project.service
         * @param {string} projectId Project Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectServiceList(projectId: string, options?: any): AxiosPromise<Array<ResourceService>> {
            return localVarFp.iamProjectServiceList(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create iam/project.tag
         * @summary Create iam/project.tag
         * @param {string} projectId Project Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectTagCreate(projectId: string, tag: Tag, options?: any): AxiosPromise<Tag> {
            return localVarFp.iamProjectTagCreate(projectId, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete iam/project.tag
         * @summary Delete iam/project.tag
         * @param {string} projectId Project Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectTagDelete(projectId: string, tagId: string, options?: any): AxiosPromise<void> {
            return localVarFp.iamProjectTagDelete(projectId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get iam/project.tag
         * @summary Get iam/project.tag
         * @param {string} projectId Project Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectTagGet(projectId: string, tagId: string, options?: any): AxiosPromise<Tag> {
            return localVarFp.iamProjectTagGet(projectId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * List iam/project.tag
         * @summary List iam/project.tag
         * @param {string} projectId Project Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectTagList(projectId: string, options?: any): AxiosPromise<Array<Tag>> {
            return localVarFp.iamProjectTagList(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * Replace iam/project.tag
         * @summary Replace iam/project.tag
         * @param {string} projectId Project Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectTagPut(projectId: string, tag: Array<Tag>, options?: any): AxiosPromise<Array<Tag>> {
            return localVarFp.iamProjectTagPut(projectId, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * Create iam/project.threshold
         * @summary Create iam/project.threshold
         * @param {string} projectId Project Id
         * @param {IamProjectThresholdCreate} iamProjectThresholdCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectThresholdCreate(projectId: string, iamProjectThresholdCreate: IamProjectThresholdCreate, options?: any): AxiosPromise<ProjectThreshold> {
            return localVarFp.iamProjectThresholdCreate(projectId, iamProjectThresholdCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete iam/project.threshold
         * @summary Delete iam/project.threshold
         * @param {string} projectId Project Id
         * @param {string} thresholdId thresholdId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectThresholdDelete(projectId: string, thresholdId: string, options?: any): AxiosPromise<void> {
            return localVarFp.iamProjectThresholdDelete(projectId, thresholdId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get iam/project.threshold
         * @summary Get iam/project.threshold
         * @param {string} projectId Project Id
         * @param {string} thresholdId thresholdId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectThresholdGet(projectId: string, thresholdId: string, options?: any): AxiosPromise<ProjectThreshold> {
            return localVarFp.iamProjectThresholdGet(projectId, thresholdId, options).then((request) => request(axios, basePath));
        },
        /**
         * List iam/project.threshold
         * @summary List iam/project.threshold
         * @param {string} projectId Project Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectThresholdList(projectId: string, options?: any): AxiosPromise<Array<ProjectThreshold>> {
            return localVarFp.iamProjectThresholdList(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * action transfer
         * @summary Transfer iam/project
         * @param {string} projectId Project Id
         * @param {IamProjectTransfer} iamProjectTransfer 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectTransfer(projectId: string, iamProjectTransfer: IamProjectTransfer, xIdempotencyKey?: string, xDryRun?: string, options?: any): AxiosPromise<Project> {
            return localVarFp.iamProjectTransfer(projectId, iamProjectTransfer, xIdempotencyKey, xDryRun, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns modified project
         * @summary Update iam/project
         * @param {string} projectId Project Id
         * @param {IamProjectUpdate} iamProjectUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectUpdate(projectId: string, iamProjectUpdate: IamProjectUpdate, options?: any): AxiosPromise<Project> {
            return localVarFp.iamProjectUpdate(projectId, iamProjectUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IamProjectApi - object-oriented interface
 * @export
 * @class IamProjectApi
 * @extends {BaseAPI}
 */
export class IamProjectApi extends BaseAPI {
    /**
     * List iam/project.billing
     * @summary List iam/project.billing
     * @param {string} projectId Project Id
     * @param {string} [start] start
     * @param {string} [end] end
     * @param {string} [resourceType] resource.type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectApi
     */
    public iamProjectBillingList(projectId: string, start?: string, end?: string, resourceType?: string, options?: any) {
        return IamProjectApiFp(this.configuration).iamProjectBillingList(projectId, start, end, resourceType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create project
     * @summary Create iam/project
     * @param {IamProjectCreate} iamProjectCreate 
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {string} [xDryRun] Dry run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectApi
     */
    public iamProjectCreate(iamProjectCreate: IamProjectCreate, xIdempotencyKey?: string, xDryRun?: string, options?: any) {
        return IamProjectApiFp(this.configuration).iamProjectCreate(iamProjectCreate, xIdempotencyKey, xDryRun, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create iam/project.credentialStore
     * @summary Create iam/project.credentialStore
     * @param {string} projectId Project Id
     * @param {ProjectCredential} projectCredential 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectApi
     */
    public iamProjectCredentialStoreCreate(projectId: string, projectCredential: ProjectCredential, options?: any) {
        return IamProjectApiFp(this.configuration).iamProjectCredentialStoreCreate(projectId, projectCredential, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete iam/project.credentialStore
     * @summary Delete iam/project.credentialStore
     * @param {string} projectId Project Id
     * @param {string} credentialStoreId credentialStoreId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectApi
     */
    public iamProjectCredentialStoreDelete(projectId: string, credentialStoreId: string, options?: any) {
        return IamProjectApiFp(this.configuration).iamProjectCredentialStoreDelete(projectId, credentialStoreId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get iam/project.credentialStore
     * @summary Get iam/project.credentialStore
     * @param {string} projectId Project Id
     * @param {string} credentialStoreId credentialStoreId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectApi
     */
    public iamProjectCredentialStoreGet(projectId: string, credentialStoreId: string, options?: any) {
        return IamProjectApiFp(this.configuration).iamProjectCredentialStoreGet(projectId, credentialStoreId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List iam/project.credentialStore
     * @summary List iam/project.credentialStore
     * @param {string} projectId Project Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectApi
     */
    public iamProjectCredentialStoreList(projectId: string, options?: any) {
        return IamProjectApiFp(this.configuration).iamProjectCredentialStoreList(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update iam/project.credentialStore
     * @summary Update iam/project.credentialStore
     * @param {string} projectId Project Id
     * @param {string} credentialStoreId credentialStoreId
     * @param {IamProjectCredentialStorePatch} iamProjectCredentialStorePatch 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectApi
     */
    public iamProjectCredentialStorePatch(projectId: string, credentialStoreId: string, iamProjectCredentialStorePatch: IamProjectCredentialStorePatch, options?: any) {
        return IamProjectApiFp(this.configuration).iamProjectCredentialStorePatch(projectId, credentialStoreId, iamProjectCredentialStorePatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete project
     * @summary Delete iam/project
     * @param {string} projectId Project Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectApi
     */
    public iamProjectDelete(projectId: string, options?: any) {
        return IamProjectApiFp(this.configuration).iamProjectDelete(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get iam/project.event
     * @summary Get iam/project.event
     * @param {string} projectId Project Id
     * @param {string} eventId eventId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectApi
     */
    public iamProjectEventGet(projectId: string, eventId: string, options?: any) {
        return IamProjectApiFp(this.configuration).iamProjectEventGet(projectId, eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List iam/project.event
     * @summary List iam/project.event
     * @param {string} projectId Project Id
     * @param {number} [$limit] $limit
     * @param {number} [$skip] $skip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectApi
     */
    public iamProjectEventList(projectId: string, $limit?: number, $skip?: number, options?: any) {
        return IamProjectApiFp(this.configuration).iamProjectEventList(projectId, $limit, $skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single project
     * @summary Get iam/project
     * @param {string} projectId Project Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectApi
     */
    public iamProjectGet(projectId: string, options?: any) {
        return IamProjectApiFp(this.configuration).iamProjectGet(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * action accept
     * @summary Accept iam/project.invitation
     * @param {string} projectId Project Id
     * @param {string} invitationId invitationId
     * @param {IamProjectInvitationAccept} iamProjectInvitationAccept 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectApi
     */
    public iamProjectInvitationAccept(projectId: string, invitationId: string, iamProjectInvitationAccept: IamProjectInvitationAccept, options?: any) {
        return IamProjectApiFp(this.configuration).iamProjectInvitationAccept(projectId, invitationId, iamProjectInvitationAccept, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete iam/project.invitation
     * @summary Delete iam/project.invitation
     * @param {string} projectId Project Id
     * @param {string} invitationId invitationId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectApi
     */
    public iamProjectInvitationDelete(projectId: string, invitationId: string, options?: any) {
        return IamProjectApiFp(this.configuration).iamProjectInvitationDelete(projectId, invitationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get iam/project.invitation
     * @summary Get iam/project.invitation
     * @param {string} projectId Project Id
     * @param {string} invitationId invitationId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectApi
     */
    public iamProjectInvitationGet(projectId: string, invitationId: string, options?: any) {
        return IamProjectApiFp(this.configuration).iamProjectInvitationGet(projectId, invitationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List iam/project.invitation
     * @summary List iam/project.invitation
     * @param {string} projectId Project Id
     * @param {string} [resource] resource
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectApi
     */
    public iamProjectInvitationList(projectId: string, resource?: string, options?: any) {
        return IamProjectApiFp(this.configuration).iamProjectInvitationList(projectId, resource, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List iam/project.invoice
     * @summary List iam/project.invoice
     * @param {string} projectId Project Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectApi
     */
    public iamProjectInvoiceList(projectId: string, options?: any) {
        return IamProjectApiFp(this.configuration).iamProjectInvoiceList(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List project
     * @summary List iam/project
     * @param {string} [name] Filter by name
     * @param {number} [$limit] Filter by $limit
     * @param {boolean} [active] Filter by active
     * @param {string} [organisation] Filter by organisation
     * @param {boolean} [$lean] return a lightweight version of the resource
     * @param {string} [tagValue] Filter by tag.value
     * @param {string} [tagKey] Filter by tag.key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectApi
     */
    public iamProjectList(name?: string, $limit?: number, active?: boolean, organisation?: string, $lean?: boolean, tagValue?: string, tagKey?: string, options?: any) {
        return IamProjectApiFp(this.configuration).iamProjectList(name, $limit, active, organisation, $lean, tagValue, tagKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create iam/project.ownership
     * @summary Create iam/project.ownership
     * @param {string} projectId Project Id
     * @param {IamProjectOwnershipCreate} iamProjectOwnershipCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectApi
     */
    public iamProjectOwnershipCreate(projectId: string, iamProjectOwnershipCreate: IamProjectOwnershipCreate, options?: any) {
        return IamProjectApiFp(this.configuration).iamProjectOwnershipCreate(projectId, iamProjectOwnershipCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete iam/project.ownership
     * @summary Delete iam/project.ownership
     * @param {string} projectId Project Id
     * @param {string} ownershipId ownershipId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectApi
     */
    public iamProjectOwnershipDelete(projectId: string, ownershipId: string, options?: any) {
        return IamProjectApiFp(this.configuration).iamProjectOwnershipDelete(projectId, ownershipId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get iam/project.ownership
     * @summary Get iam/project.ownership
     * @param {string} projectId Project Id
     * @param {string} ownershipId ownershipId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectApi
     */
    public iamProjectOwnershipGet(projectId: string, ownershipId: string, options?: any) {
        return IamProjectApiFp(this.configuration).iamProjectOwnershipGet(projectId, ownershipId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List iam/project.ownership
     * @summary List iam/project.ownership
     * @param {string} projectId Project Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectApi
     */
    public iamProjectOwnershipList(projectId: string, options?: any) {
        return IamProjectApiFp(this.configuration).iamProjectOwnershipList(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List iam/project.payment
     * @summary List iam/project.payment
     * @param {string} projectId Project Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectApi
     */
    public iamProjectPaymentList(projectId: string, options?: any) {
        return IamProjectApiFp(this.configuration).iamProjectPaymentList(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List iam/project.proforma
     * @summary List iam/project.proforma
     * @param {string} projectId Project Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectApi
     */
    public iamProjectProformaList(projectId: string, options?: any) {
        return IamProjectApiFp(this.configuration).iamProjectProformaList(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get iam/project.quota
     * @summary Get iam/project.quota
     * @param {string} projectId Project Id
     * @param {string} quotaId quotaId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectApi
     */
    public iamProjectQuotaGet(projectId: string, quotaId: string, options?: any) {
        return IamProjectApiFp(this.configuration).iamProjectQuotaGet(projectId, quotaId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update iam/project.limit
     * @summary Update iam/project.limit
     * @param {string} projectId Project Id
     * @param {string} quotaId quotaId
     * @param {IamProjectQuotaLimitPatch} iamProjectQuotaLimitPatch 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectApi
     */
    public iamProjectQuotaLimitPatch(projectId: string, quotaId: string, iamProjectQuotaLimitPatch: IamProjectQuotaLimitPatch, options?: any) {
        return IamProjectApiFp(this.configuration).iamProjectQuotaLimitPatch(projectId, quotaId, iamProjectQuotaLimitPatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List iam/project.quota
     * @summary List iam/project.quota
     * @param {string} projectId Project Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectApi
     */
    public iamProjectQuotaList(projectId: string, options?: any) {
        return IamProjectApiFp(this.configuration).iamProjectQuotaList(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get iam/project.service
     * @summary Get iam/project.service
     * @param {string} projectId Project Id
     * @param {string} serviceId serviceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectApi
     */
    public iamProjectServiceGet(projectId: string, serviceId: string, options?: any) {
        return IamProjectApiFp(this.configuration).iamProjectServiceGet(projectId, serviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List iam/project.service
     * @summary List iam/project.service
     * @param {string} projectId Project Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectApi
     */
    public iamProjectServiceList(projectId: string, options?: any) {
        return IamProjectApiFp(this.configuration).iamProjectServiceList(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create iam/project.tag
     * @summary Create iam/project.tag
     * @param {string} projectId Project Id
     * @param {Tag} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectApi
     */
    public iamProjectTagCreate(projectId: string, tag: Tag, options?: any) {
        return IamProjectApiFp(this.configuration).iamProjectTagCreate(projectId, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete iam/project.tag
     * @summary Delete iam/project.tag
     * @param {string} projectId Project Id
     * @param {string} tagId tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectApi
     */
    public iamProjectTagDelete(projectId: string, tagId: string, options?: any) {
        return IamProjectApiFp(this.configuration).iamProjectTagDelete(projectId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get iam/project.tag
     * @summary Get iam/project.tag
     * @param {string} projectId Project Id
     * @param {string} tagId tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectApi
     */
    public iamProjectTagGet(projectId: string, tagId: string, options?: any) {
        return IamProjectApiFp(this.configuration).iamProjectTagGet(projectId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List iam/project.tag
     * @summary List iam/project.tag
     * @param {string} projectId Project Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectApi
     */
    public iamProjectTagList(projectId: string, options?: any) {
        return IamProjectApiFp(this.configuration).iamProjectTagList(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replace iam/project.tag
     * @summary Replace iam/project.tag
     * @param {string} projectId Project Id
     * @param {Array<Tag>} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectApi
     */
    public iamProjectTagPut(projectId: string, tag: Array<Tag>, options?: any) {
        return IamProjectApiFp(this.configuration).iamProjectTagPut(projectId, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create iam/project.threshold
     * @summary Create iam/project.threshold
     * @param {string} projectId Project Id
     * @param {IamProjectThresholdCreate} iamProjectThresholdCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectApi
     */
    public iamProjectThresholdCreate(projectId: string, iamProjectThresholdCreate: IamProjectThresholdCreate, options?: any) {
        return IamProjectApiFp(this.configuration).iamProjectThresholdCreate(projectId, iamProjectThresholdCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete iam/project.threshold
     * @summary Delete iam/project.threshold
     * @param {string} projectId Project Id
     * @param {string} thresholdId thresholdId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectApi
     */
    public iamProjectThresholdDelete(projectId: string, thresholdId: string, options?: any) {
        return IamProjectApiFp(this.configuration).iamProjectThresholdDelete(projectId, thresholdId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get iam/project.threshold
     * @summary Get iam/project.threshold
     * @param {string} projectId Project Id
     * @param {string} thresholdId thresholdId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectApi
     */
    public iamProjectThresholdGet(projectId: string, thresholdId: string, options?: any) {
        return IamProjectApiFp(this.configuration).iamProjectThresholdGet(projectId, thresholdId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List iam/project.threshold
     * @summary List iam/project.threshold
     * @param {string} projectId Project Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectApi
     */
    public iamProjectThresholdList(projectId: string, options?: any) {
        return IamProjectApiFp(this.configuration).iamProjectThresholdList(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * action transfer
     * @summary Transfer iam/project
     * @param {string} projectId Project Id
     * @param {IamProjectTransfer} iamProjectTransfer 
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {string} [xDryRun] Dry run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectApi
     */
    public iamProjectTransfer(projectId: string, iamProjectTransfer: IamProjectTransfer, xIdempotencyKey?: string, xDryRun?: string, options?: any) {
        return IamProjectApiFp(this.configuration).iamProjectTransfer(projectId, iamProjectTransfer, xIdempotencyKey, xDryRun, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns modified project
     * @summary Update iam/project
     * @param {string} projectId Project Id
     * @param {IamProjectUpdate} iamProjectUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectApi
     */
    public iamProjectUpdate(projectId: string, iamProjectUpdate: IamProjectUpdate, options?: any) {
        return IamProjectApiFp(this.configuration).iamProjectUpdate(projectId, iamProjectUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * IamProjectPolicyApi - axios parameter creator
 * @export
 */
export const IamProjectPolicyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create iam/policy.actor
         * @summary Create iam/policy.actor
         * @param {string} projectId Project Id
         * @param {string} policyId Policy Id
         * @param {IamActor} iamActor 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectPolicyActorCreate: async (projectId: string, policyId: string, iamActor: IamActor, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('iamProjectPolicyActorCreate', 'projectId', projectId)
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('iamProjectPolicyActorCreate', 'policyId', policyId)
            // verify required parameter 'iamActor' is not null or undefined
            assertParamExists('iamProjectPolicyActorCreate', 'iamActor', iamActor)
            const localVarPath = `/iam/project/{projectId}/policy/{policyId}/actor`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"policyId"}}`, encodeURIComponent(String(policyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(iamActor, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete iam/policy.actor
         * @summary Delete iam/policy.actor
         * @param {string} projectId Project Id
         * @param {string} policyId Policy Id
         * @param {string} actorId actorId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectPolicyActorDelete: async (projectId: string, policyId: string, actorId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('iamProjectPolicyActorDelete', 'projectId', projectId)
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('iamProjectPolicyActorDelete', 'policyId', policyId)
            // verify required parameter 'actorId' is not null or undefined
            assertParamExists('iamProjectPolicyActorDelete', 'actorId', actorId)
            const localVarPath = `/iam/project/{projectId}/policy/{policyId}/actor/{actorId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"policyId"}}`, encodeURIComponent(String(policyId)))
                .replace(`{${"actorId"}}`, encodeURIComponent(String(actorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get iam/policy.actor
         * @summary Get iam/policy.actor
         * @param {string} projectId Project Id
         * @param {string} policyId Policy Id
         * @param {string} actorId actorId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectPolicyActorGet: async (projectId: string, policyId: string, actorId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('iamProjectPolicyActorGet', 'projectId', projectId)
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('iamProjectPolicyActorGet', 'policyId', policyId)
            // verify required parameter 'actorId' is not null or undefined
            assertParamExists('iamProjectPolicyActorGet', 'actorId', actorId)
            const localVarPath = `/iam/project/{projectId}/policy/{policyId}/actor/{actorId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"policyId"}}`, encodeURIComponent(String(policyId)))
                .replace(`{${"actorId"}}`, encodeURIComponent(String(actorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List iam/policy.actor
         * @summary List iam/policy.actor
         * @param {string} projectId Project Id
         * @param {string} policyId Policy Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectPolicyActorList: async (projectId: string, policyId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('iamProjectPolicyActorList', 'projectId', projectId)
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('iamProjectPolicyActorList', 'policyId', policyId)
            const localVarPath = `/iam/project/{projectId}/policy/{policyId}/actor`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"policyId"}}`, encodeURIComponent(String(policyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create policy
         * @summary Create iam/policy
         * @param {string} projectId Project Id
         * @param {IamProjectPolicyCreate} iamProjectPolicyCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectPolicyCreate: async (projectId: string, iamProjectPolicyCreate: IamProjectPolicyCreate, xIdempotencyKey?: string, xDryRun?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('iamProjectPolicyCreate', 'projectId', projectId)
            // verify required parameter 'iamProjectPolicyCreate' is not null or undefined
            assertParamExists('iamProjectPolicyCreate', 'iamProjectPolicyCreate', iamProjectPolicyCreate)
            const localVarPath = `/iam/project/{projectId}/policy`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }

            if (xDryRun !== undefined && xDryRun !== null) {
                localVarHeaderParameter['x-dry-run'] = String(xDryRun);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(iamProjectPolicyCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete policy
         * @summary Delete iam/policy
         * @param {string} projectId Project Id
         * @param {string} policyId Policy Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectPolicyDelete: async (projectId: string, policyId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('iamProjectPolicyDelete', 'projectId', projectId)
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('iamProjectPolicyDelete', 'policyId', policyId)
            const localVarPath = `/iam/project/{projectId}/policy/{policyId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"policyId"}}`, encodeURIComponent(String(policyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get iam/policy.event
         * @summary Get iam/policy.event
         * @param {string} projectId Project Id
         * @param {string} policyId Policy Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectPolicyEventGet: async (projectId: string, policyId: string, eventId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('iamProjectPolicyEventGet', 'projectId', projectId)
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('iamProjectPolicyEventGet', 'policyId', policyId)
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('iamProjectPolicyEventGet', 'eventId', eventId)
            const localVarPath = `/iam/project/{projectId}/policy/{policyId}/event/{eventId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"policyId"}}`, encodeURIComponent(String(policyId)))
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List iam/policy.event
         * @summary List iam/policy.event
         * @param {string} projectId Project Id
         * @param {string} policyId Policy Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectPolicyEventList: async (projectId: string, policyId: string, $limit?: number, $skip?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('iamProjectPolicyEventList', 'projectId', projectId)
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('iamProjectPolicyEventList', 'policyId', policyId)
            const localVarPath = `/iam/project/{projectId}/policy/{policyId}/event`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"policyId"}}`, encodeURIComponent(String(policyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if ($limit !== undefined) {
                localVarQueryParameter['$limit'] = $limit;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single policy
         * @summary Get iam/policy
         * @param {string} projectId Project Id
         * @param {string} policyId Policy Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectPolicyGet: async (projectId: string, policyId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('iamProjectPolicyGet', 'projectId', projectId)
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('iamProjectPolicyGet', 'policyId', policyId)
            const localVarPath = `/iam/project/{projectId}/policy/{policyId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"policyId"}}`, encodeURIComponent(String(policyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List policy
         * @summary List iam/policy
         * @param {string} projectId Project Id
         * @param {string} [name] Filter by name
         * @param {string} [resource] Filter by resource
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectPolicyList: async (projectId: string, name?: string, resource?: string, tagValue?: string, tagKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('iamProjectPolicyList', 'projectId', projectId)
            const localVarPath = `/iam/project/{projectId}/policy`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (resource !== undefined) {
                localVarQueryParameter['resource'] = resource;
            }

            if (tagValue !== undefined) {
                localVarQueryParameter['tag.value'] = tagValue;
            }

            if (tagKey !== undefined) {
                localVarQueryParameter['tag.key'] = tagKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get iam/policy.service
         * @summary Get iam/policy.service
         * @param {string} projectId Project Id
         * @param {string} policyId Policy Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectPolicyServiceGet: async (projectId: string, policyId: string, serviceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('iamProjectPolicyServiceGet', 'projectId', projectId)
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('iamProjectPolicyServiceGet', 'policyId', policyId)
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('iamProjectPolicyServiceGet', 'serviceId', serviceId)
            const localVarPath = `/iam/project/{projectId}/policy/{policyId}/service/{serviceId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"policyId"}}`, encodeURIComponent(String(policyId)))
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List iam/policy.service
         * @summary List iam/policy.service
         * @param {string} projectId Project Id
         * @param {string} policyId Policy Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectPolicyServiceList: async (projectId: string, policyId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('iamProjectPolicyServiceList', 'projectId', projectId)
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('iamProjectPolicyServiceList', 'policyId', policyId)
            const localVarPath = `/iam/project/{projectId}/policy/{policyId}/service`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"policyId"}}`, encodeURIComponent(String(policyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create iam/policy.tag
         * @summary Create iam/policy.tag
         * @param {string} projectId Project Id
         * @param {string} policyId Policy Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectPolicyTagCreate: async (projectId: string, policyId: string, tag: Tag, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('iamProjectPolicyTagCreate', 'projectId', projectId)
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('iamProjectPolicyTagCreate', 'policyId', policyId)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('iamProjectPolicyTagCreate', 'tag', tag)
            const localVarPath = `/iam/project/{projectId}/policy/{policyId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"policyId"}}`, encodeURIComponent(String(policyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tag, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete iam/policy.tag
         * @summary Delete iam/policy.tag
         * @param {string} projectId Project Id
         * @param {string} policyId Policy Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectPolicyTagDelete: async (projectId: string, policyId: string, tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('iamProjectPolicyTagDelete', 'projectId', projectId)
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('iamProjectPolicyTagDelete', 'policyId', policyId)
            // verify required parameter 'tagId' is not null or undefined
            assertParamExists('iamProjectPolicyTagDelete', 'tagId', tagId)
            const localVarPath = `/iam/project/{projectId}/policy/{policyId}/tag/{tagId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"policyId"}}`, encodeURIComponent(String(policyId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get iam/policy.tag
         * @summary Get iam/policy.tag
         * @param {string} projectId Project Id
         * @param {string} policyId Policy Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectPolicyTagGet: async (projectId: string, policyId: string, tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('iamProjectPolicyTagGet', 'projectId', projectId)
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('iamProjectPolicyTagGet', 'policyId', policyId)
            // verify required parameter 'tagId' is not null or undefined
            assertParamExists('iamProjectPolicyTagGet', 'tagId', tagId)
            const localVarPath = `/iam/project/{projectId}/policy/{policyId}/tag/{tagId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"policyId"}}`, encodeURIComponent(String(policyId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List iam/policy.tag
         * @summary List iam/policy.tag
         * @param {string} projectId Project Id
         * @param {string} policyId Policy Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectPolicyTagList: async (projectId: string, policyId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('iamProjectPolicyTagList', 'projectId', projectId)
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('iamProjectPolicyTagList', 'policyId', policyId)
            const localVarPath = `/iam/project/{projectId}/policy/{policyId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"policyId"}}`, encodeURIComponent(String(policyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replace iam/policy.tag
         * @summary Replace iam/policy.tag
         * @param {string} projectId Project Id
         * @param {string} policyId Policy Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectPolicyTagPut: async (projectId: string, policyId: string, tag: Array<Tag>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('iamProjectPolicyTagPut', 'projectId', projectId)
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('iamProjectPolicyTagPut', 'policyId', policyId)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('iamProjectPolicyTagPut', 'tag', tag)
            const localVarPath = `/iam/project/{projectId}/policy/{policyId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"policyId"}}`, encodeURIComponent(String(policyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tag, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns modified policy
         * @summary Update iam/policy
         * @param {string} projectId Project Id
         * @param {string} policyId Policy Id
         * @param {IamProjectPolicyUpdate} iamProjectPolicyUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectPolicyUpdate: async (projectId: string, policyId: string, iamProjectPolicyUpdate: IamProjectPolicyUpdate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('iamProjectPolicyUpdate', 'projectId', projectId)
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('iamProjectPolicyUpdate', 'policyId', policyId)
            // verify required parameter 'iamProjectPolicyUpdate' is not null or undefined
            assertParamExists('iamProjectPolicyUpdate', 'iamProjectPolicyUpdate', iamProjectPolicyUpdate)
            const localVarPath = `/iam/project/{projectId}/policy/{policyId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"policyId"}}`, encodeURIComponent(String(policyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(iamProjectPolicyUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IamProjectPolicyApi - functional programming interface
 * @export
 */
export const IamProjectPolicyApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IamProjectPolicyApiAxiosParamCreator(configuration)
    return {
        /**
         * Create iam/policy.actor
         * @summary Create iam/policy.actor
         * @param {string} projectId Project Id
         * @param {string} policyId Policy Id
         * @param {IamActor} iamActor 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectPolicyActorCreate(projectId: string, policyId: string, iamActor: IamActor, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IamActor>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamProjectPolicyActorCreate(projectId, policyId, iamActor, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete iam/policy.actor
         * @summary Delete iam/policy.actor
         * @param {string} projectId Project Id
         * @param {string} policyId Policy Id
         * @param {string} actorId actorId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectPolicyActorDelete(projectId: string, policyId: string, actorId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IamActor>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamProjectPolicyActorDelete(projectId, policyId, actorId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get iam/policy.actor
         * @summary Get iam/policy.actor
         * @param {string} projectId Project Id
         * @param {string} policyId Policy Id
         * @param {string} actorId actorId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectPolicyActorGet(projectId: string, policyId: string, actorId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IamActor>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamProjectPolicyActorGet(projectId, policyId, actorId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List iam/policy.actor
         * @summary List iam/policy.actor
         * @param {string} projectId Project Id
         * @param {string} policyId Policy Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectPolicyActorList(projectId: string, policyId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<IamActor>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamProjectPolicyActorList(projectId, policyId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create policy
         * @summary Create iam/policy
         * @param {string} projectId Project Id
         * @param {IamProjectPolicyCreate} iamProjectPolicyCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectPolicyCreate(projectId: string, iamProjectPolicyCreate: IamProjectPolicyCreate, xIdempotencyKey?: string, xDryRun?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Policy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamProjectPolicyCreate(projectId, iamProjectPolicyCreate, xIdempotencyKey, xDryRun, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete policy
         * @summary Delete iam/policy
         * @param {string} projectId Project Id
         * @param {string} policyId Policy Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectPolicyDelete(projectId: string, policyId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamProjectPolicyDelete(projectId, policyId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get iam/policy.event
         * @summary Get iam/policy.event
         * @param {string} projectId Project Id
         * @param {string} policyId Policy Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectPolicyEventGet(projectId: string, policyId: string, eventId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamProjectPolicyEventGet(projectId, policyId, eventId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List iam/policy.event
         * @summary List iam/policy.event
         * @param {string} projectId Project Id
         * @param {string} policyId Policy Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectPolicyEventList(projectId: string, policyId: string, $limit?: number, $skip?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Event>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamProjectPolicyEventList(projectId, policyId, $limit, $skip, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a single policy
         * @summary Get iam/policy
         * @param {string} projectId Project Id
         * @param {string} policyId Policy Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectPolicyGet(projectId: string, policyId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Policy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamProjectPolicyGet(projectId, policyId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List policy
         * @summary List iam/policy
         * @param {string} projectId Project Id
         * @param {string} [name] Filter by name
         * @param {string} [resource] Filter by resource
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectPolicyList(projectId: string, name?: string, resource?: string, tagValue?: string, tagKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Policy>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamProjectPolicyList(projectId, name, resource, tagValue, tagKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get iam/policy.service
         * @summary Get iam/policy.service
         * @param {string} projectId Project Id
         * @param {string} policyId Policy Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectPolicyServiceGet(projectId: string, policyId: string, serviceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceService>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamProjectPolicyServiceGet(projectId, policyId, serviceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List iam/policy.service
         * @summary List iam/policy.service
         * @param {string} projectId Project Id
         * @param {string} policyId Policy Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectPolicyServiceList(projectId: string, policyId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResourceService>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamProjectPolicyServiceList(projectId, policyId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create iam/policy.tag
         * @summary Create iam/policy.tag
         * @param {string} projectId Project Id
         * @param {string} policyId Policy Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectPolicyTagCreate(projectId: string, policyId: string, tag: Tag, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamProjectPolicyTagCreate(projectId, policyId, tag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete iam/policy.tag
         * @summary Delete iam/policy.tag
         * @param {string} projectId Project Id
         * @param {string} policyId Policy Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectPolicyTagDelete(projectId: string, policyId: string, tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamProjectPolicyTagDelete(projectId, policyId, tagId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get iam/policy.tag
         * @summary Get iam/policy.tag
         * @param {string} projectId Project Id
         * @param {string} policyId Policy Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectPolicyTagGet(projectId: string, policyId: string, tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamProjectPolicyTagGet(projectId, policyId, tagId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List iam/policy.tag
         * @summary List iam/policy.tag
         * @param {string} projectId Project Id
         * @param {string} policyId Policy Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectPolicyTagList(projectId: string, policyId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamProjectPolicyTagList(projectId, policyId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Replace iam/policy.tag
         * @summary Replace iam/policy.tag
         * @param {string} projectId Project Id
         * @param {string} policyId Policy Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectPolicyTagPut(projectId: string, policyId: string, tag: Array<Tag>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamProjectPolicyTagPut(projectId, policyId, tag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns modified policy
         * @summary Update iam/policy
         * @param {string} projectId Project Id
         * @param {string} policyId Policy Id
         * @param {IamProjectPolicyUpdate} iamProjectPolicyUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectPolicyUpdate(projectId: string, policyId: string, iamProjectPolicyUpdate: IamProjectPolicyUpdate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Policy>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamProjectPolicyUpdate(projectId, policyId, iamProjectPolicyUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * IamProjectPolicyApi - factory interface
 * @export
 */
export const IamProjectPolicyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IamProjectPolicyApiFp(configuration)
    return {
        /**
         * Create iam/policy.actor
         * @summary Create iam/policy.actor
         * @param {string} projectId Project Id
         * @param {string} policyId Policy Id
         * @param {IamActor} iamActor 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectPolicyActorCreate(projectId: string, policyId: string, iamActor: IamActor, options?: any): AxiosPromise<IamActor> {
            return localVarFp.iamProjectPolicyActorCreate(projectId, policyId, iamActor, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete iam/policy.actor
         * @summary Delete iam/policy.actor
         * @param {string} projectId Project Id
         * @param {string} policyId Policy Id
         * @param {string} actorId actorId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectPolicyActorDelete(projectId: string, policyId: string, actorId: string, options?: any): AxiosPromise<IamActor> {
            return localVarFp.iamProjectPolicyActorDelete(projectId, policyId, actorId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get iam/policy.actor
         * @summary Get iam/policy.actor
         * @param {string} projectId Project Id
         * @param {string} policyId Policy Id
         * @param {string} actorId actorId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectPolicyActorGet(projectId: string, policyId: string, actorId: string, options?: any): AxiosPromise<IamActor> {
            return localVarFp.iamProjectPolicyActorGet(projectId, policyId, actorId, options).then((request) => request(axios, basePath));
        },
        /**
         * List iam/policy.actor
         * @summary List iam/policy.actor
         * @param {string} projectId Project Id
         * @param {string} policyId Policy Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectPolicyActorList(projectId: string, policyId: string, options?: any): AxiosPromise<Array<IamActor>> {
            return localVarFp.iamProjectPolicyActorList(projectId, policyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create policy
         * @summary Create iam/policy
         * @param {string} projectId Project Id
         * @param {IamProjectPolicyCreate} iamProjectPolicyCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectPolicyCreate(projectId: string, iamProjectPolicyCreate: IamProjectPolicyCreate, xIdempotencyKey?: string, xDryRun?: string, options?: any): AxiosPromise<Policy> {
            return localVarFp.iamProjectPolicyCreate(projectId, iamProjectPolicyCreate, xIdempotencyKey, xDryRun, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete policy
         * @summary Delete iam/policy
         * @param {string} projectId Project Id
         * @param {string} policyId Policy Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectPolicyDelete(projectId: string, policyId: string, options?: any): AxiosPromise<void> {
            return localVarFp.iamProjectPolicyDelete(projectId, policyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get iam/policy.event
         * @summary Get iam/policy.event
         * @param {string} projectId Project Id
         * @param {string} policyId Policy Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectPolicyEventGet(projectId: string, policyId: string, eventId: string, options?: any): AxiosPromise<Event> {
            return localVarFp.iamProjectPolicyEventGet(projectId, policyId, eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * List iam/policy.event
         * @summary List iam/policy.event
         * @param {string} projectId Project Id
         * @param {string} policyId Policy Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectPolicyEventList(projectId: string, policyId: string, $limit?: number, $skip?: number, options?: any): AxiosPromise<Array<Event>> {
            return localVarFp.iamProjectPolicyEventList(projectId, policyId, $limit, $skip, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single policy
         * @summary Get iam/policy
         * @param {string} projectId Project Id
         * @param {string} policyId Policy Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectPolicyGet(projectId: string, policyId: string, options?: any): AxiosPromise<Policy> {
            return localVarFp.iamProjectPolicyGet(projectId, policyId, options).then((request) => request(axios, basePath));
        },
        /**
         * List policy
         * @summary List iam/policy
         * @param {string} projectId Project Id
         * @param {string} [name] Filter by name
         * @param {string} [resource] Filter by resource
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectPolicyList(projectId: string, name?: string, resource?: string, tagValue?: string, tagKey?: string, options?: any): AxiosPromise<Array<Policy>> {
            return localVarFp.iamProjectPolicyList(projectId, name, resource, tagValue, tagKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get iam/policy.service
         * @summary Get iam/policy.service
         * @param {string} projectId Project Id
         * @param {string} policyId Policy Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectPolicyServiceGet(projectId: string, policyId: string, serviceId: string, options?: any): AxiosPromise<ResourceService> {
            return localVarFp.iamProjectPolicyServiceGet(projectId, policyId, serviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * List iam/policy.service
         * @summary List iam/policy.service
         * @param {string} projectId Project Id
         * @param {string} policyId Policy Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectPolicyServiceList(projectId: string, policyId: string, options?: any): AxiosPromise<Array<ResourceService>> {
            return localVarFp.iamProjectPolicyServiceList(projectId, policyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create iam/policy.tag
         * @summary Create iam/policy.tag
         * @param {string} projectId Project Id
         * @param {string} policyId Policy Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectPolicyTagCreate(projectId: string, policyId: string, tag: Tag, options?: any): AxiosPromise<Tag> {
            return localVarFp.iamProjectPolicyTagCreate(projectId, policyId, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete iam/policy.tag
         * @summary Delete iam/policy.tag
         * @param {string} projectId Project Id
         * @param {string} policyId Policy Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectPolicyTagDelete(projectId: string, policyId: string, tagId: string, options?: any): AxiosPromise<void> {
            return localVarFp.iamProjectPolicyTagDelete(projectId, policyId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get iam/policy.tag
         * @summary Get iam/policy.tag
         * @param {string} projectId Project Id
         * @param {string} policyId Policy Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectPolicyTagGet(projectId: string, policyId: string, tagId: string, options?: any): AxiosPromise<Tag> {
            return localVarFp.iamProjectPolicyTagGet(projectId, policyId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * List iam/policy.tag
         * @summary List iam/policy.tag
         * @param {string} projectId Project Id
         * @param {string} policyId Policy Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectPolicyTagList(projectId: string, policyId: string, options?: any): AxiosPromise<Array<Tag>> {
            return localVarFp.iamProjectPolicyTagList(projectId, policyId, options).then((request) => request(axios, basePath));
        },
        /**
         * Replace iam/policy.tag
         * @summary Replace iam/policy.tag
         * @param {string} projectId Project Id
         * @param {string} policyId Policy Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectPolicyTagPut(projectId: string, policyId: string, tag: Array<Tag>, options?: any): AxiosPromise<Array<Tag>> {
            return localVarFp.iamProjectPolicyTagPut(projectId, policyId, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns modified policy
         * @summary Update iam/policy
         * @param {string} projectId Project Id
         * @param {string} policyId Policy Id
         * @param {IamProjectPolicyUpdate} iamProjectPolicyUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectPolicyUpdate(projectId: string, policyId: string, iamProjectPolicyUpdate: IamProjectPolicyUpdate, options?: any): AxiosPromise<Policy> {
            return localVarFp.iamProjectPolicyUpdate(projectId, policyId, iamProjectPolicyUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IamProjectPolicyApi - object-oriented interface
 * @export
 * @class IamProjectPolicyApi
 * @extends {BaseAPI}
 */
export class IamProjectPolicyApi extends BaseAPI {
    /**
     * Create iam/policy.actor
     * @summary Create iam/policy.actor
     * @param {string} projectId Project Id
     * @param {string} policyId Policy Id
     * @param {IamActor} iamActor 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectPolicyApi
     */
    public iamProjectPolicyActorCreate(projectId: string, policyId: string, iamActor: IamActor, options?: any) {
        return IamProjectPolicyApiFp(this.configuration).iamProjectPolicyActorCreate(projectId, policyId, iamActor, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete iam/policy.actor
     * @summary Delete iam/policy.actor
     * @param {string} projectId Project Id
     * @param {string} policyId Policy Id
     * @param {string} actorId actorId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectPolicyApi
     */
    public iamProjectPolicyActorDelete(projectId: string, policyId: string, actorId: string, options?: any) {
        return IamProjectPolicyApiFp(this.configuration).iamProjectPolicyActorDelete(projectId, policyId, actorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get iam/policy.actor
     * @summary Get iam/policy.actor
     * @param {string} projectId Project Id
     * @param {string} policyId Policy Id
     * @param {string} actorId actorId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectPolicyApi
     */
    public iamProjectPolicyActorGet(projectId: string, policyId: string, actorId: string, options?: any) {
        return IamProjectPolicyApiFp(this.configuration).iamProjectPolicyActorGet(projectId, policyId, actorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List iam/policy.actor
     * @summary List iam/policy.actor
     * @param {string} projectId Project Id
     * @param {string} policyId Policy Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectPolicyApi
     */
    public iamProjectPolicyActorList(projectId: string, policyId: string, options?: any) {
        return IamProjectPolicyApiFp(this.configuration).iamProjectPolicyActorList(projectId, policyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create policy
     * @summary Create iam/policy
     * @param {string} projectId Project Id
     * @param {IamProjectPolicyCreate} iamProjectPolicyCreate 
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {string} [xDryRun] Dry run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectPolicyApi
     */
    public iamProjectPolicyCreate(projectId: string, iamProjectPolicyCreate: IamProjectPolicyCreate, xIdempotencyKey?: string, xDryRun?: string, options?: any) {
        return IamProjectPolicyApiFp(this.configuration).iamProjectPolicyCreate(projectId, iamProjectPolicyCreate, xIdempotencyKey, xDryRun, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete policy
     * @summary Delete iam/policy
     * @param {string} projectId Project Id
     * @param {string} policyId Policy Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectPolicyApi
     */
    public iamProjectPolicyDelete(projectId: string, policyId: string, options?: any) {
        return IamProjectPolicyApiFp(this.configuration).iamProjectPolicyDelete(projectId, policyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get iam/policy.event
     * @summary Get iam/policy.event
     * @param {string} projectId Project Id
     * @param {string} policyId Policy Id
     * @param {string} eventId eventId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectPolicyApi
     */
    public iamProjectPolicyEventGet(projectId: string, policyId: string, eventId: string, options?: any) {
        return IamProjectPolicyApiFp(this.configuration).iamProjectPolicyEventGet(projectId, policyId, eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List iam/policy.event
     * @summary List iam/policy.event
     * @param {string} projectId Project Id
     * @param {string} policyId Policy Id
     * @param {number} [$limit] $limit
     * @param {number} [$skip] $skip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectPolicyApi
     */
    public iamProjectPolicyEventList(projectId: string, policyId: string, $limit?: number, $skip?: number, options?: any) {
        return IamProjectPolicyApiFp(this.configuration).iamProjectPolicyEventList(projectId, policyId, $limit, $skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single policy
     * @summary Get iam/policy
     * @param {string} projectId Project Id
     * @param {string} policyId Policy Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectPolicyApi
     */
    public iamProjectPolicyGet(projectId: string, policyId: string, options?: any) {
        return IamProjectPolicyApiFp(this.configuration).iamProjectPolicyGet(projectId, policyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List policy
     * @summary List iam/policy
     * @param {string} projectId Project Id
     * @param {string} [name] Filter by name
     * @param {string} [resource] Filter by resource
     * @param {string} [tagValue] Filter by tag.value
     * @param {string} [tagKey] Filter by tag.key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectPolicyApi
     */
    public iamProjectPolicyList(projectId: string, name?: string, resource?: string, tagValue?: string, tagKey?: string, options?: any) {
        return IamProjectPolicyApiFp(this.configuration).iamProjectPolicyList(projectId, name, resource, tagValue, tagKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get iam/policy.service
     * @summary Get iam/policy.service
     * @param {string} projectId Project Id
     * @param {string} policyId Policy Id
     * @param {string} serviceId serviceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectPolicyApi
     */
    public iamProjectPolicyServiceGet(projectId: string, policyId: string, serviceId: string, options?: any) {
        return IamProjectPolicyApiFp(this.configuration).iamProjectPolicyServiceGet(projectId, policyId, serviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List iam/policy.service
     * @summary List iam/policy.service
     * @param {string} projectId Project Id
     * @param {string} policyId Policy Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectPolicyApi
     */
    public iamProjectPolicyServiceList(projectId: string, policyId: string, options?: any) {
        return IamProjectPolicyApiFp(this.configuration).iamProjectPolicyServiceList(projectId, policyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create iam/policy.tag
     * @summary Create iam/policy.tag
     * @param {string} projectId Project Id
     * @param {string} policyId Policy Id
     * @param {Tag} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectPolicyApi
     */
    public iamProjectPolicyTagCreate(projectId: string, policyId: string, tag: Tag, options?: any) {
        return IamProjectPolicyApiFp(this.configuration).iamProjectPolicyTagCreate(projectId, policyId, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete iam/policy.tag
     * @summary Delete iam/policy.tag
     * @param {string} projectId Project Id
     * @param {string} policyId Policy Id
     * @param {string} tagId tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectPolicyApi
     */
    public iamProjectPolicyTagDelete(projectId: string, policyId: string, tagId: string, options?: any) {
        return IamProjectPolicyApiFp(this.configuration).iamProjectPolicyTagDelete(projectId, policyId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get iam/policy.tag
     * @summary Get iam/policy.tag
     * @param {string} projectId Project Id
     * @param {string} policyId Policy Id
     * @param {string} tagId tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectPolicyApi
     */
    public iamProjectPolicyTagGet(projectId: string, policyId: string, tagId: string, options?: any) {
        return IamProjectPolicyApiFp(this.configuration).iamProjectPolicyTagGet(projectId, policyId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List iam/policy.tag
     * @summary List iam/policy.tag
     * @param {string} projectId Project Id
     * @param {string} policyId Policy Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectPolicyApi
     */
    public iamProjectPolicyTagList(projectId: string, policyId: string, options?: any) {
        return IamProjectPolicyApiFp(this.configuration).iamProjectPolicyTagList(projectId, policyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replace iam/policy.tag
     * @summary Replace iam/policy.tag
     * @param {string} projectId Project Id
     * @param {string} policyId Policy Id
     * @param {Array<Tag>} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectPolicyApi
     */
    public iamProjectPolicyTagPut(projectId: string, policyId: string, tag: Array<Tag>, options?: any) {
        return IamProjectPolicyApiFp(this.configuration).iamProjectPolicyTagPut(projectId, policyId, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns modified policy
     * @summary Update iam/policy
     * @param {string} projectId Project Id
     * @param {string} policyId Policy Id
     * @param {IamProjectPolicyUpdate} iamProjectPolicyUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectPolicyApi
     */
    public iamProjectPolicyUpdate(projectId: string, policyId: string, iamProjectPolicyUpdate: IamProjectPolicyUpdate, options?: any) {
        return IamProjectPolicyApiFp(this.configuration).iamProjectPolicyUpdate(projectId, policyId, iamProjectPolicyUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * IamProjectRoleApi - axios parameter creator
 * @export
 */
export const IamProjectRoleApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create role
         * @summary Create iam/role
         * @param {string} projectId Project Id
         * @param {IamProjectRoleCreate} iamProjectRoleCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectRoleCreate: async (projectId: string, iamProjectRoleCreate: IamProjectRoleCreate, xIdempotencyKey?: string, xDryRun?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('iamProjectRoleCreate', 'projectId', projectId)
            // verify required parameter 'iamProjectRoleCreate' is not null or undefined
            assertParamExists('iamProjectRoleCreate', 'iamProjectRoleCreate', iamProjectRoleCreate)
            const localVarPath = `/iam/project/{projectId}/role`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }

            if (xDryRun !== undefined && xDryRun !== null) {
                localVarHeaderParameter['x-dry-run'] = String(xDryRun);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(iamProjectRoleCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete role
         * @summary Delete iam/role
         * @param {string} projectId Project Id
         * @param {string} roleId Role Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectRoleDelete: async (projectId: string, roleId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('iamProjectRoleDelete', 'projectId', projectId)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('iamProjectRoleDelete', 'roleId', roleId)
            const localVarPath = `/iam/project/{projectId}/role/{roleId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"roleId"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get iam/role.event
         * @summary Get iam/role.event
         * @param {string} projectId Project Id
         * @param {string} roleId Role Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectRoleEventGet: async (projectId: string, roleId: string, eventId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('iamProjectRoleEventGet', 'projectId', projectId)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('iamProjectRoleEventGet', 'roleId', roleId)
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('iamProjectRoleEventGet', 'eventId', eventId)
            const localVarPath = `/iam/project/{projectId}/role/{roleId}/event/{eventId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"roleId"}}`, encodeURIComponent(String(roleId)))
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List iam/role.event
         * @summary List iam/role.event
         * @param {string} projectId Project Id
         * @param {string} roleId Role Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectRoleEventList: async (projectId: string, roleId: string, $limit?: number, $skip?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('iamProjectRoleEventList', 'projectId', projectId)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('iamProjectRoleEventList', 'roleId', roleId)
            const localVarPath = `/iam/project/{projectId}/role/{roleId}/event`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"roleId"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if ($limit !== undefined) {
                localVarQueryParameter['$limit'] = $limit;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single role
         * @summary Get iam/role
         * @param {string} projectId Project Id
         * @param {string} roleId Role Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectRoleGet: async (projectId: string, roleId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('iamProjectRoleGet', 'projectId', projectId)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('iamProjectRoleGet', 'roleId', roleId)
            const localVarPath = `/iam/project/{projectId}/role/{roleId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"roleId"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List role
         * @summary List iam/role
         * @param {string} projectId Project Id
         * @param {string} [name] Filter by name
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectRoleList: async (projectId: string, name?: string, tagValue?: string, tagKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('iamProjectRoleList', 'projectId', projectId)
            const localVarPath = `/iam/project/{projectId}/role`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (tagValue !== undefined) {
                localVarQueryParameter['tag.value'] = tagValue;
            }

            if (tagKey !== undefined) {
                localVarQueryParameter['tag.key'] = tagKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create iam/role.permission
         * @summary Create iam/role.permission
         * @param {string} projectId Project Id
         * @param {string} roleId Role Id
         * @param {IamPermission} iamPermission 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectRolePermissionCreate: async (projectId: string, roleId: string, iamPermission: IamPermission, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('iamProjectRolePermissionCreate', 'projectId', projectId)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('iamProjectRolePermissionCreate', 'roleId', roleId)
            // verify required parameter 'iamPermission' is not null or undefined
            assertParamExists('iamProjectRolePermissionCreate', 'iamPermission', iamPermission)
            const localVarPath = `/iam/project/{projectId}/role/{roleId}/permission`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"roleId"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(iamPermission, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete iam/role.permission
         * @summary Delete iam/role.permission
         * @param {string} projectId Project Id
         * @param {string} roleId Role Id
         * @param {string} permissionId permissionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectRolePermissionDelete: async (projectId: string, roleId: string, permissionId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('iamProjectRolePermissionDelete', 'projectId', projectId)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('iamProjectRolePermissionDelete', 'roleId', roleId)
            // verify required parameter 'permissionId' is not null or undefined
            assertParamExists('iamProjectRolePermissionDelete', 'permissionId', permissionId)
            const localVarPath = `/iam/project/{projectId}/role/{roleId}/permission/{permissionId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"roleId"}}`, encodeURIComponent(String(roleId)))
                .replace(`{${"permissionId"}}`, encodeURIComponent(String(permissionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get iam/role.permission
         * @summary Get iam/role.permission
         * @param {string} projectId Project Id
         * @param {string} roleId Role Id
         * @param {string} permissionId permissionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectRolePermissionGet: async (projectId: string, roleId: string, permissionId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('iamProjectRolePermissionGet', 'projectId', projectId)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('iamProjectRolePermissionGet', 'roleId', roleId)
            // verify required parameter 'permissionId' is not null or undefined
            assertParamExists('iamProjectRolePermissionGet', 'permissionId', permissionId)
            const localVarPath = `/iam/project/{projectId}/role/{roleId}/permission/{permissionId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"roleId"}}`, encodeURIComponent(String(roleId)))
                .replace(`{${"permissionId"}}`, encodeURIComponent(String(permissionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List iam/role.permission
         * @summary List iam/role.permission
         * @param {string} projectId Project Id
         * @param {string} roleId Role Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectRolePermissionList: async (projectId: string, roleId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('iamProjectRolePermissionList', 'projectId', projectId)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('iamProjectRolePermissionList', 'roleId', roleId)
            const localVarPath = `/iam/project/{projectId}/role/{roleId}/permission`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"roleId"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replace iam/role.permission
         * @summary Replace iam/role.permission
         * @param {string} projectId Project Id
         * @param {string} roleId Role Id
         * @param {Array<IamPermission>} iamPermission 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectRolePermissionPut: async (projectId: string, roleId: string, iamPermission: Array<IamPermission>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('iamProjectRolePermissionPut', 'projectId', projectId)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('iamProjectRolePermissionPut', 'roleId', roleId)
            // verify required parameter 'iamPermission' is not null or undefined
            assertParamExists('iamProjectRolePermissionPut', 'iamPermission', iamPermission)
            const localVarPath = `/iam/project/{projectId}/role/{roleId}/permission`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"roleId"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(iamPermission, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get iam/role.service
         * @summary Get iam/role.service
         * @param {string} projectId Project Id
         * @param {string} roleId Role Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectRoleServiceGet: async (projectId: string, roleId: string, serviceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('iamProjectRoleServiceGet', 'projectId', projectId)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('iamProjectRoleServiceGet', 'roleId', roleId)
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('iamProjectRoleServiceGet', 'serviceId', serviceId)
            const localVarPath = `/iam/project/{projectId}/role/{roleId}/service/{serviceId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"roleId"}}`, encodeURIComponent(String(roleId)))
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List iam/role.service
         * @summary List iam/role.service
         * @param {string} projectId Project Id
         * @param {string} roleId Role Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectRoleServiceList: async (projectId: string, roleId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('iamProjectRoleServiceList', 'projectId', projectId)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('iamProjectRoleServiceList', 'roleId', roleId)
            const localVarPath = `/iam/project/{projectId}/role/{roleId}/service`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"roleId"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create iam/role.tag
         * @summary Create iam/role.tag
         * @param {string} projectId Project Id
         * @param {string} roleId Role Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectRoleTagCreate: async (projectId: string, roleId: string, tag: Tag, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('iamProjectRoleTagCreate', 'projectId', projectId)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('iamProjectRoleTagCreate', 'roleId', roleId)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('iamProjectRoleTagCreate', 'tag', tag)
            const localVarPath = `/iam/project/{projectId}/role/{roleId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"roleId"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tag, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete iam/role.tag
         * @summary Delete iam/role.tag
         * @param {string} projectId Project Id
         * @param {string} roleId Role Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectRoleTagDelete: async (projectId: string, roleId: string, tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('iamProjectRoleTagDelete', 'projectId', projectId)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('iamProjectRoleTagDelete', 'roleId', roleId)
            // verify required parameter 'tagId' is not null or undefined
            assertParamExists('iamProjectRoleTagDelete', 'tagId', tagId)
            const localVarPath = `/iam/project/{projectId}/role/{roleId}/tag/{tagId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"roleId"}}`, encodeURIComponent(String(roleId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get iam/role.tag
         * @summary Get iam/role.tag
         * @param {string} projectId Project Id
         * @param {string} roleId Role Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectRoleTagGet: async (projectId: string, roleId: string, tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('iamProjectRoleTagGet', 'projectId', projectId)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('iamProjectRoleTagGet', 'roleId', roleId)
            // verify required parameter 'tagId' is not null or undefined
            assertParamExists('iamProjectRoleTagGet', 'tagId', tagId)
            const localVarPath = `/iam/project/{projectId}/role/{roleId}/tag/{tagId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"roleId"}}`, encodeURIComponent(String(roleId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List iam/role.tag
         * @summary List iam/role.tag
         * @param {string} projectId Project Id
         * @param {string} roleId Role Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectRoleTagList: async (projectId: string, roleId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('iamProjectRoleTagList', 'projectId', projectId)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('iamProjectRoleTagList', 'roleId', roleId)
            const localVarPath = `/iam/project/{projectId}/role/{roleId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"roleId"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replace iam/role.tag
         * @summary Replace iam/role.tag
         * @param {string} projectId Project Id
         * @param {string} roleId Role Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectRoleTagPut: async (projectId: string, roleId: string, tag: Array<Tag>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('iamProjectRoleTagPut', 'projectId', projectId)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('iamProjectRoleTagPut', 'roleId', roleId)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('iamProjectRoleTagPut', 'tag', tag)
            const localVarPath = `/iam/project/{projectId}/role/{roleId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"roleId"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tag, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns modified role
         * @summary Update iam/role
         * @param {string} projectId Project Id
         * @param {string} roleId Role Id
         * @param {IamProjectRoleUpdate} iamProjectRoleUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectRoleUpdate: async (projectId: string, roleId: string, iamProjectRoleUpdate: IamProjectRoleUpdate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('iamProjectRoleUpdate', 'projectId', projectId)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('iamProjectRoleUpdate', 'roleId', roleId)
            // verify required parameter 'iamProjectRoleUpdate' is not null or undefined
            assertParamExists('iamProjectRoleUpdate', 'iamProjectRoleUpdate', iamProjectRoleUpdate)
            const localVarPath = `/iam/project/{projectId}/role/{roleId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"roleId"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(iamProjectRoleUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IamProjectRoleApi - functional programming interface
 * @export
 */
export const IamProjectRoleApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IamProjectRoleApiAxiosParamCreator(configuration)
    return {
        /**
         * Create role
         * @summary Create iam/role
         * @param {string} projectId Project Id
         * @param {IamProjectRoleCreate} iamProjectRoleCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectRoleCreate(projectId: string, iamProjectRoleCreate: IamProjectRoleCreate, xIdempotencyKey?: string, xDryRun?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Role>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamProjectRoleCreate(projectId, iamProjectRoleCreate, xIdempotencyKey, xDryRun, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete role
         * @summary Delete iam/role
         * @param {string} projectId Project Id
         * @param {string} roleId Role Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectRoleDelete(projectId: string, roleId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamProjectRoleDelete(projectId, roleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get iam/role.event
         * @summary Get iam/role.event
         * @param {string} projectId Project Id
         * @param {string} roleId Role Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectRoleEventGet(projectId: string, roleId: string, eventId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamProjectRoleEventGet(projectId, roleId, eventId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List iam/role.event
         * @summary List iam/role.event
         * @param {string} projectId Project Id
         * @param {string} roleId Role Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectRoleEventList(projectId: string, roleId: string, $limit?: number, $skip?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Event>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamProjectRoleEventList(projectId, roleId, $limit, $skip, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a single role
         * @summary Get iam/role
         * @param {string} projectId Project Id
         * @param {string} roleId Role Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectRoleGet(projectId: string, roleId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Role>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamProjectRoleGet(projectId, roleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List role
         * @summary List iam/role
         * @param {string} projectId Project Id
         * @param {string} [name] Filter by name
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectRoleList(projectId: string, name?: string, tagValue?: string, tagKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Role>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamProjectRoleList(projectId, name, tagValue, tagKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create iam/role.permission
         * @summary Create iam/role.permission
         * @param {string} projectId Project Id
         * @param {string} roleId Role Id
         * @param {IamPermission} iamPermission 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectRolePermissionCreate(projectId: string, roleId: string, iamPermission: IamPermission, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IamPermission>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamProjectRolePermissionCreate(projectId, roleId, iamPermission, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete iam/role.permission
         * @summary Delete iam/role.permission
         * @param {string} projectId Project Id
         * @param {string} roleId Role Id
         * @param {string} permissionId permissionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectRolePermissionDelete(projectId: string, roleId: string, permissionId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IamPermission>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamProjectRolePermissionDelete(projectId, roleId, permissionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get iam/role.permission
         * @summary Get iam/role.permission
         * @param {string} projectId Project Id
         * @param {string} roleId Role Id
         * @param {string} permissionId permissionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectRolePermissionGet(projectId: string, roleId: string, permissionId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IamPermission>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamProjectRolePermissionGet(projectId, roleId, permissionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List iam/role.permission
         * @summary List iam/role.permission
         * @param {string} projectId Project Id
         * @param {string} roleId Role Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectRolePermissionList(projectId: string, roleId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<IamPermission>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamProjectRolePermissionList(projectId, roleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Replace iam/role.permission
         * @summary Replace iam/role.permission
         * @param {string} projectId Project Id
         * @param {string} roleId Role Id
         * @param {Array<IamPermission>} iamPermission 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectRolePermissionPut(projectId: string, roleId: string, iamPermission: Array<IamPermission>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<IamPermission>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamProjectRolePermissionPut(projectId, roleId, iamPermission, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get iam/role.service
         * @summary Get iam/role.service
         * @param {string} projectId Project Id
         * @param {string} roleId Role Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectRoleServiceGet(projectId: string, roleId: string, serviceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceService>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamProjectRoleServiceGet(projectId, roleId, serviceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List iam/role.service
         * @summary List iam/role.service
         * @param {string} projectId Project Id
         * @param {string} roleId Role Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectRoleServiceList(projectId: string, roleId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResourceService>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamProjectRoleServiceList(projectId, roleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create iam/role.tag
         * @summary Create iam/role.tag
         * @param {string} projectId Project Id
         * @param {string} roleId Role Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectRoleTagCreate(projectId: string, roleId: string, tag: Tag, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamProjectRoleTagCreate(projectId, roleId, tag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete iam/role.tag
         * @summary Delete iam/role.tag
         * @param {string} projectId Project Id
         * @param {string} roleId Role Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectRoleTagDelete(projectId: string, roleId: string, tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamProjectRoleTagDelete(projectId, roleId, tagId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get iam/role.tag
         * @summary Get iam/role.tag
         * @param {string} projectId Project Id
         * @param {string} roleId Role Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectRoleTagGet(projectId: string, roleId: string, tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamProjectRoleTagGet(projectId, roleId, tagId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List iam/role.tag
         * @summary List iam/role.tag
         * @param {string} projectId Project Id
         * @param {string} roleId Role Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectRoleTagList(projectId: string, roleId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamProjectRoleTagList(projectId, roleId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Replace iam/role.tag
         * @summary Replace iam/role.tag
         * @param {string} projectId Project Id
         * @param {string} roleId Role Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectRoleTagPut(projectId: string, roleId: string, tag: Array<Tag>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamProjectRoleTagPut(projectId, roleId, tag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns modified role
         * @summary Update iam/role
         * @param {string} projectId Project Id
         * @param {string} roleId Role Id
         * @param {IamProjectRoleUpdate} iamProjectRoleUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectRoleUpdate(projectId: string, roleId: string, iamProjectRoleUpdate: IamProjectRoleUpdate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Role>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamProjectRoleUpdate(projectId, roleId, iamProjectRoleUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * IamProjectRoleApi - factory interface
 * @export
 */
export const IamProjectRoleApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IamProjectRoleApiFp(configuration)
    return {
        /**
         * Create role
         * @summary Create iam/role
         * @param {string} projectId Project Id
         * @param {IamProjectRoleCreate} iamProjectRoleCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectRoleCreate(projectId: string, iamProjectRoleCreate: IamProjectRoleCreate, xIdempotencyKey?: string, xDryRun?: string, options?: any): AxiosPromise<Role> {
            return localVarFp.iamProjectRoleCreate(projectId, iamProjectRoleCreate, xIdempotencyKey, xDryRun, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete role
         * @summary Delete iam/role
         * @param {string} projectId Project Id
         * @param {string} roleId Role Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectRoleDelete(projectId: string, roleId: string, options?: any): AxiosPromise<void> {
            return localVarFp.iamProjectRoleDelete(projectId, roleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get iam/role.event
         * @summary Get iam/role.event
         * @param {string} projectId Project Id
         * @param {string} roleId Role Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectRoleEventGet(projectId: string, roleId: string, eventId: string, options?: any): AxiosPromise<Event> {
            return localVarFp.iamProjectRoleEventGet(projectId, roleId, eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * List iam/role.event
         * @summary List iam/role.event
         * @param {string} projectId Project Id
         * @param {string} roleId Role Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectRoleEventList(projectId: string, roleId: string, $limit?: number, $skip?: number, options?: any): AxiosPromise<Array<Event>> {
            return localVarFp.iamProjectRoleEventList(projectId, roleId, $limit, $skip, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single role
         * @summary Get iam/role
         * @param {string} projectId Project Id
         * @param {string} roleId Role Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectRoleGet(projectId: string, roleId: string, options?: any): AxiosPromise<Role> {
            return localVarFp.iamProjectRoleGet(projectId, roleId, options).then((request) => request(axios, basePath));
        },
        /**
         * List role
         * @summary List iam/role
         * @param {string} projectId Project Id
         * @param {string} [name] Filter by name
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectRoleList(projectId: string, name?: string, tagValue?: string, tagKey?: string, options?: any): AxiosPromise<Array<Role>> {
            return localVarFp.iamProjectRoleList(projectId, name, tagValue, tagKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Create iam/role.permission
         * @summary Create iam/role.permission
         * @param {string} projectId Project Id
         * @param {string} roleId Role Id
         * @param {IamPermission} iamPermission 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectRolePermissionCreate(projectId: string, roleId: string, iamPermission: IamPermission, options?: any): AxiosPromise<IamPermission> {
            return localVarFp.iamProjectRolePermissionCreate(projectId, roleId, iamPermission, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete iam/role.permission
         * @summary Delete iam/role.permission
         * @param {string} projectId Project Id
         * @param {string} roleId Role Id
         * @param {string} permissionId permissionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectRolePermissionDelete(projectId: string, roleId: string, permissionId: string, options?: any): AxiosPromise<IamPermission> {
            return localVarFp.iamProjectRolePermissionDelete(projectId, roleId, permissionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get iam/role.permission
         * @summary Get iam/role.permission
         * @param {string} projectId Project Id
         * @param {string} roleId Role Id
         * @param {string} permissionId permissionId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectRolePermissionGet(projectId: string, roleId: string, permissionId: string, options?: any): AxiosPromise<IamPermission> {
            return localVarFp.iamProjectRolePermissionGet(projectId, roleId, permissionId, options).then((request) => request(axios, basePath));
        },
        /**
         * List iam/role.permission
         * @summary List iam/role.permission
         * @param {string} projectId Project Id
         * @param {string} roleId Role Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectRolePermissionList(projectId: string, roleId: string, options?: any): AxiosPromise<Array<IamPermission>> {
            return localVarFp.iamProjectRolePermissionList(projectId, roleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Replace iam/role.permission
         * @summary Replace iam/role.permission
         * @param {string} projectId Project Id
         * @param {string} roleId Role Id
         * @param {Array<IamPermission>} iamPermission 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectRolePermissionPut(projectId: string, roleId: string, iamPermission: Array<IamPermission>, options?: any): AxiosPromise<Array<IamPermission>> {
            return localVarFp.iamProjectRolePermissionPut(projectId, roleId, iamPermission, options).then((request) => request(axios, basePath));
        },
        /**
         * Get iam/role.service
         * @summary Get iam/role.service
         * @param {string} projectId Project Id
         * @param {string} roleId Role Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectRoleServiceGet(projectId: string, roleId: string, serviceId: string, options?: any): AxiosPromise<ResourceService> {
            return localVarFp.iamProjectRoleServiceGet(projectId, roleId, serviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * List iam/role.service
         * @summary List iam/role.service
         * @param {string} projectId Project Id
         * @param {string} roleId Role Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectRoleServiceList(projectId: string, roleId: string, options?: any): AxiosPromise<Array<ResourceService>> {
            return localVarFp.iamProjectRoleServiceList(projectId, roleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create iam/role.tag
         * @summary Create iam/role.tag
         * @param {string} projectId Project Id
         * @param {string} roleId Role Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectRoleTagCreate(projectId: string, roleId: string, tag: Tag, options?: any): AxiosPromise<Tag> {
            return localVarFp.iamProjectRoleTagCreate(projectId, roleId, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete iam/role.tag
         * @summary Delete iam/role.tag
         * @param {string} projectId Project Id
         * @param {string} roleId Role Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectRoleTagDelete(projectId: string, roleId: string, tagId: string, options?: any): AxiosPromise<void> {
            return localVarFp.iamProjectRoleTagDelete(projectId, roleId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get iam/role.tag
         * @summary Get iam/role.tag
         * @param {string} projectId Project Id
         * @param {string} roleId Role Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectRoleTagGet(projectId: string, roleId: string, tagId: string, options?: any): AxiosPromise<Tag> {
            return localVarFp.iamProjectRoleTagGet(projectId, roleId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * List iam/role.tag
         * @summary List iam/role.tag
         * @param {string} projectId Project Id
         * @param {string} roleId Role Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectRoleTagList(projectId: string, roleId: string, options?: any): AxiosPromise<Array<Tag>> {
            return localVarFp.iamProjectRoleTagList(projectId, roleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Replace iam/role.tag
         * @summary Replace iam/role.tag
         * @param {string} projectId Project Id
         * @param {string} roleId Role Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectRoleTagPut(projectId: string, roleId: string, tag: Array<Tag>, options?: any): AxiosPromise<Array<Tag>> {
            return localVarFp.iamProjectRoleTagPut(projectId, roleId, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns modified role
         * @summary Update iam/role
         * @param {string} projectId Project Id
         * @param {string} roleId Role Id
         * @param {IamProjectRoleUpdate} iamProjectRoleUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectRoleUpdate(projectId: string, roleId: string, iamProjectRoleUpdate: IamProjectRoleUpdate, options?: any): AxiosPromise<Role> {
            return localVarFp.iamProjectRoleUpdate(projectId, roleId, iamProjectRoleUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IamProjectRoleApi - object-oriented interface
 * @export
 * @class IamProjectRoleApi
 * @extends {BaseAPI}
 */
export class IamProjectRoleApi extends BaseAPI {
    /**
     * Create role
     * @summary Create iam/role
     * @param {string} projectId Project Id
     * @param {IamProjectRoleCreate} iamProjectRoleCreate 
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {string} [xDryRun] Dry run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectRoleApi
     */
    public iamProjectRoleCreate(projectId: string, iamProjectRoleCreate: IamProjectRoleCreate, xIdempotencyKey?: string, xDryRun?: string, options?: any) {
        return IamProjectRoleApiFp(this.configuration).iamProjectRoleCreate(projectId, iamProjectRoleCreate, xIdempotencyKey, xDryRun, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete role
     * @summary Delete iam/role
     * @param {string} projectId Project Id
     * @param {string} roleId Role Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectRoleApi
     */
    public iamProjectRoleDelete(projectId: string, roleId: string, options?: any) {
        return IamProjectRoleApiFp(this.configuration).iamProjectRoleDelete(projectId, roleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get iam/role.event
     * @summary Get iam/role.event
     * @param {string} projectId Project Id
     * @param {string} roleId Role Id
     * @param {string} eventId eventId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectRoleApi
     */
    public iamProjectRoleEventGet(projectId: string, roleId: string, eventId: string, options?: any) {
        return IamProjectRoleApiFp(this.configuration).iamProjectRoleEventGet(projectId, roleId, eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List iam/role.event
     * @summary List iam/role.event
     * @param {string} projectId Project Id
     * @param {string} roleId Role Id
     * @param {number} [$limit] $limit
     * @param {number} [$skip] $skip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectRoleApi
     */
    public iamProjectRoleEventList(projectId: string, roleId: string, $limit?: number, $skip?: number, options?: any) {
        return IamProjectRoleApiFp(this.configuration).iamProjectRoleEventList(projectId, roleId, $limit, $skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single role
     * @summary Get iam/role
     * @param {string} projectId Project Id
     * @param {string} roleId Role Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectRoleApi
     */
    public iamProjectRoleGet(projectId: string, roleId: string, options?: any) {
        return IamProjectRoleApiFp(this.configuration).iamProjectRoleGet(projectId, roleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List role
     * @summary List iam/role
     * @param {string} projectId Project Id
     * @param {string} [name] Filter by name
     * @param {string} [tagValue] Filter by tag.value
     * @param {string} [tagKey] Filter by tag.key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectRoleApi
     */
    public iamProjectRoleList(projectId: string, name?: string, tagValue?: string, tagKey?: string, options?: any) {
        return IamProjectRoleApiFp(this.configuration).iamProjectRoleList(projectId, name, tagValue, tagKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create iam/role.permission
     * @summary Create iam/role.permission
     * @param {string} projectId Project Id
     * @param {string} roleId Role Id
     * @param {IamPermission} iamPermission 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectRoleApi
     */
    public iamProjectRolePermissionCreate(projectId: string, roleId: string, iamPermission: IamPermission, options?: any) {
        return IamProjectRoleApiFp(this.configuration).iamProjectRolePermissionCreate(projectId, roleId, iamPermission, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete iam/role.permission
     * @summary Delete iam/role.permission
     * @param {string} projectId Project Id
     * @param {string} roleId Role Id
     * @param {string} permissionId permissionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectRoleApi
     */
    public iamProjectRolePermissionDelete(projectId: string, roleId: string, permissionId: string, options?: any) {
        return IamProjectRoleApiFp(this.configuration).iamProjectRolePermissionDelete(projectId, roleId, permissionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get iam/role.permission
     * @summary Get iam/role.permission
     * @param {string} projectId Project Id
     * @param {string} roleId Role Id
     * @param {string} permissionId permissionId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectRoleApi
     */
    public iamProjectRolePermissionGet(projectId: string, roleId: string, permissionId: string, options?: any) {
        return IamProjectRoleApiFp(this.configuration).iamProjectRolePermissionGet(projectId, roleId, permissionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List iam/role.permission
     * @summary List iam/role.permission
     * @param {string} projectId Project Id
     * @param {string} roleId Role Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectRoleApi
     */
    public iamProjectRolePermissionList(projectId: string, roleId: string, options?: any) {
        return IamProjectRoleApiFp(this.configuration).iamProjectRolePermissionList(projectId, roleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replace iam/role.permission
     * @summary Replace iam/role.permission
     * @param {string} projectId Project Id
     * @param {string} roleId Role Id
     * @param {Array<IamPermission>} iamPermission 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectRoleApi
     */
    public iamProjectRolePermissionPut(projectId: string, roleId: string, iamPermission: Array<IamPermission>, options?: any) {
        return IamProjectRoleApiFp(this.configuration).iamProjectRolePermissionPut(projectId, roleId, iamPermission, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get iam/role.service
     * @summary Get iam/role.service
     * @param {string} projectId Project Id
     * @param {string} roleId Role Id
     * @param {string} serviceId serviceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectRoleApi
     */
    public iamProjectRoleServiceGet(projectId: string, roleId: string, serviceId: string, options?: any) {
        return IamProjectRoleApiFp(this.configuration).iamProjectRoleServiceGet(projectId, roleId, serviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List iam/role.service
     * @summary List iam/role.service
     * @param {string} projectId Project Id
     * @param {string} roleId Role Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectRoleApi
     */
    public iamProjectRoleServiceList(projectId: string, roleId: string, options?: any) {
        return IamProjectRoleApiFp(this.configuration).iamProjectRoleServiceList(projectId, roleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create iam/role.tag
     * @summary Create iam/role.tag
     * @param {string} projectId Project Id
     * @param {string} roleId Role Id
     * @param {Tag} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectRoleApi
     */
    public iamProjectRoleTagCreate(projectId: string, roleId: string, tag: Tag, options?: any) {
        return IamProjectRoleApiFp(this.configuration).iamProjectRoleTagCreate(projectId, roleId, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete iam/role.tag
     * @summary Delete iam/role.tag
     * @param {string} projectId Project Id
     * @param {string} roleId Role Id
     * @param {string} tagId tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectRoleApi
     */
    public iamProjectRoleTagDelete(projectId: string, roleId: string, tagId: string, options?: any) {
        return IamProjectRoleApiFp(this.configuration).iamProjectRoleTagDelete(projectId, roleId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get iam/role.tag
     * @summary Get iam/role.tag
     * @param {string} projectId Project Id
     * @param {string} roleId Role Id
     * @param {string} tagId tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectRoleApi
     */
    public iamProjectRoleTagGet(projectId: string, roleId: string, tagId: string, options?: any) {
        return IamProjectRoleApiFp(this.configuration).iamProjectRoleTagGet(projectId, roleId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List iam/role.tag
     * @summary List iam/role.tag
     * @param {string} projectId Project Id
     * @param {string} roleId Role Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectRoleApi
     */
    public iamProjectRoleTagList(projectId: string, roleId: string, options?: any) {
        return IamProjectRoleApiFp(this.configuration).iamProjectRoleTagList(projectId, roleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replace iam/role.tag
     * @summary Replace iam/role.tag
     * @param {string} projectId Project Id
     * @param {string} roleId Role Id
     * @param {Array<Tag>} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectRoleApi
     */
    public iamProjectRoleTagPut(projectId: string, roleId: string, tag: Array<Tag>, options?: any) {
        return IamProjectRoleApiFp(this.configuration).iamProjectRoleTagPut(projectId, roleId, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns modified role
     * @summary Update iam/role
     * @param {string} projectId Project Id
     * @param {string} roleId Role Id
     * @param {IamProjectRoleUpdate} iamProjectRoleUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectRoleApi
     */
    public iamProjectRoleUpdate(projectId: string, roleId: string, iamProjectRoleUpdate: IamProjectRoleUpdate, options?: any) {
        return IamProjectRoleApiFp(this.configuration).iamProjectRoleUpdate(projectId, roleId, iamProjectRoleUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * IamProjectSaApi - axios parameter creator
 * @export
 */
export const IamProjectSaApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create sa
         * @summary Create iam/sa
         * @param {string} projectId Project Id
         * @param {IamProjectSaCreate} iamProjectSaCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectSaCreate: async (projectId: string, iamProjectSaCreate: IamProjectSaCreate, xIdempotencyKey?: string, xDryRun?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('iamProjectSaCreate', 'projectId', projectId)
            // verify required parameter 'iamProjectSaCreate' is not null or undefined
            assertParamExists('iamProjectSaCreate', 'iamProjectSaCreate', iamProjectSaCreate)
            const localVarPath = `/iam/project/{projectId}/sa`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }

            if (xDryRun !== undefined && xDryRun !== null) {
                localVarHeaderParameter['x-dry-run'] = String(xDryRun);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(iamProjectSaCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create iam/sa.credential
         * @summary Create iam/sa.credential
         * @param {string} projectId Project Id
         * @param {string} saId Sa Id
         * @param {SaCredential} saCredential 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectSaCredentialCreate: async (projectId: string, saId: string, saCredential: SaCredential, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('iamProjectSaCredentialCreate', 'projectId', projectId)
            // verify required parameter 'saId' is not null or undefined
            assertParamExists('iamProjectSaCredentialCreate', 'saId', saId)
            // verify required parameter 'saCredential' is not null or undefined
            assertParamExists('iamProjectSaCredentialCreate', 'saCredential', saCredential)
            const localVarPath = `/iam/project/{projectId}/sa/{saId}/credential`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"saId"}}`, encodeURIComponent(String(saId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(saCredential, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete iam/sa.credential
         * @summary Delete iam/sa.credential
         * @param {string} projectId Project Id
         * @param {string} saId Sa Id
         * @param {string} credentialId credentialId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectSaCredentialDelete: async (projectId: string, saId: string, credentialId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('iamProjectSaCredentialDelete', 'projectId', projectId)
            // verify required parameter 'saId' is not null or undefined
            assertParamExists('iamProjectSaCredentialDelete', 'saId', saId)
            // verify required parameter 'credentialId' is not null or undefined
            assertParamExists('iamProjectSaCredentialDelete', 'credentialId', credentialId)
            const localVarPath = `/iam/project/{projectId}/sa/{saId}/credential/{credentialId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"saId"}}`, encodeURIComponent(String(saId)))
                .replace(`{${"credentialId"}}`, encodeURIComponent(String(credentialId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get iam/sa.credential
         * @summary Get iam/sa.credential
         * @param {string} projectId Project Id
         * @param {string} saId Sa Id
         * @param {string} credentialId credentialId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectSaCredentialGet: async (projectId: string, saId: string, credentialId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('iamProjectSaCredentialGet', 'projectId', projectId)
            // verify required parameter 'saId' is not null or undefined
            assertParamExists('iamProjectSaCredentialGet', 'saId', saId)
            // verify required parameter 'credentialId' is not null or undefined
            assertParamExists('iamProjectSaCredentialGet', 'credentialId', credentialId)
            const localVarPath = `/iam/project/{projectId}/sa/{saId}/credential/{credentialId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"saId"}}`, encodeURIComponent(String(saId)))
                .replace(`{${"credentialId"}}`, encodeURIComponent(String(credentialId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List iam/sa.credential
         * @summary List iam/sa.credential
         * @param {string} projectId Project Id
         * @param {string} saId Sa Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectSaCredentialList: async (projectId: string, saId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('iamProjectSaCredentialList', 'projectId', projectId)
            // verify required parameter 'saId' is not null or undefined
            assertParamExists('iamProjectSaCredentialList', 'saId', saId)
            const localVarPath = `/iam/project/{projectId}/sa/{saId}/credential`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"saId"}}`, encodeURIComponent(String(saId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update iam/sa.credential
         * @summary Update iam/sa.credential
         * @param {string} projectId Project Id
         * @param {string} saId Sa Id
         * @param {string} credentialId credentialId
         * @param {IamProjectSaCredentialPatch} iamProjectSaCredentialPatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectSaCredentialPatch: async (projectId: string, saId: string, credentialId: string, iamProjectSaCredentialPatch: IamProjectSaCredentialPatch, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('iamProjectSaCredentialPatch', 'projectId', projectId)
            // verify required parameter 'saId' is not null or undefined
            assertParamExists('iamProjectSaCredentialPatch', 'saId', saId)
            // verify required parameter 'credentialId' is not null or undefined
            assertParamExists('iamProjectSaCredentialPatch', 'credentialId', credentialId)
            // verify required parameter 'iamProjectSaCredentialPatch' is not null or undefined
            assertParamExists('iamProjectSaCredentialPatch', 'iamProjectSaCredentialPatch', iamProjectSaCredentialPatch)
            const localVarPath = `/iam/project/{projectId}/sa/{saId}/credential/{credentialId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"saId"}}`, encodeURIComponent(String(saId)))
                .replace(`{${"credentialId"}}`, encodeURIComponent(String(credentialId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(iamProjectSaCredentialPatch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete sa
         * @summary Delete iam/sa
         * @param {string} projectId Project Id
         * @param {string} saId Sa Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectSaDelete: async (projectId: string, saId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('iamProjectSaDelete', 'projectId', projectId)
            // verify required parameter 'saId' is not null or undefined
            assertParamExists('iamProjectSaDelete', 'saId', saId)
            const localVarPath = `/iam/project/{projectId}/sa/{saId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"saId"}}`, encodeURIComponent(String(saId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get iam/sa.event
         * @summary Get iam/sa.event
         * @param {string} projectId Project Id
         * @param {string} saId Sa Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectSaEventGet: async (projectId: string, saId: string, eventId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('iamProjectSaEventGet', 'projectId', projectId)
            // verify required parameter 'saId' is not null or undefined
            assertParamExists('iamProjectSaEventGet', 'saId', saId)
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('iamProjectSaEventGet', 'eventId', eventId)
            const localVarPath = `/iam/project/{projectId}/sa/{saId}/event/{eventId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"saId"}}`, encodeURIComponent(String(saId)))
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List iam/sa.event
         * @summary List iam/sa.event
         * @param {string} projectId Project Id
         * @param {string} saId Sa Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectSaEventList: async (projectId: string, saId: string, $limit?: number, $skip?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('iamProjectSaEventList', 'projectId', projectId)
            // verify required parameter 'saId' is not null or undefined
            assertParamExists('iamProjectSaEventList', 'saId', saId)
            const localVarPath = `/iam/project/{projectId}/sa/{saId}/event`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"saId"}}`, encodeURIComponent(String(saId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if ($limit !== undefined) {
                localVarQueryParameter['$limit'] = $limit;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single sa
         * @summary Get iam/sa
         * @param {string} projectId Project Id
         * @param {string} saId Sa Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectSaGet: async (projectId: string, saId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('iamProjectSaGet', 'projectId', projectId)
            // verify required parameter 'saId' is not null or undefined
            assertParamExists('iamProjectSaGet', 'saId', saId)
            const localVarPath = `/iam/project/{projectId}/sa/{saId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"saId"}}`, encodeURIComponent(String(saId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List sa
         * @summary List iam/sa
         * @param {string} projectId Project Id
         * @param {string} [name] Filter by name
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectSaList: async (projectId: string, name?: string, tagValue?: string, tagKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('iamProjectSaList', 'projectId', projectId)
            const localVarPath = `/iam/project/{projectId}/sa`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (tagValue !== undefined) {
                localVarQueryParameter['tag.value'] = tagValue;
            }

            if (tagKey !== undefined) {
                localVarQueryParameter['tag.key'] = tagKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get iam/sa.service
         * @summary Get iam/sa.service
         * @param {string} projectId Project Id
         * @param {string} saId Sa Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectSaServiceGet: async (projectId: string, saId: string, serviceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('iamProjectSaServiceGet', 'projectId', projectId)
            // verify required parameter 'saId' is not null or undefined
            assertParamExists('iamProjectSaServiceGet', 'saId', saId)
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('iamProjectSaServiceGet', 'serviceId', serviceId)
            const localVarPath = `/iam/project/{projectId}/sa/{saId}/service/{serviceId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"saId"}}`, encodeURIComponent(String(saId)))
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List iam/sa.service
         * @summary List iam/sa.service
         * @param {string} projectId Project Id
         * @param {string} saId Sa Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectSaServiceList: async (projectId: string, saId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('iamProjectSaServiceList', 'projectId', projectId)
            // verify required parameter 'saId' is not null or undefined
            assertParamExists('iamProjectSaServiceList', 'saId', saId)
            const localVarPath = `/iam/project/{projectId}/sa/{saId}/service`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"saId"}}`, encodeURIComponent(String(saId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create iam/sa.tag
         * @summary Create iam/sa.tag
         * @param {string} projectId Project Id
         * @param {string} saId Sa Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectSaTagCreate: async (projectId: string, saId: string, tag: Tag, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('iamProjectSaTagCreate', 'projectId', projectId)
            // verify required parameter 'saId' is not null or undefined
            assertParamExists('iamProjectSaTagCreate', 'saId', saId)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('iamProjectSaTagCreate', 'tag', tag)
            const localVarPath = `/iam/project/{projectId}/sa/{saId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"saId"}}`, encodeURIComponent(String(saId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tag, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete iam/sa.tag
         * @summary Delete iam/sa.tag
         * @param {string} projectId Project Id
         * @param {string} saId Sa Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectSaTagDelete: async (projectId: string, saId: string, tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('iamProjectSaTagDelete', 'projectId', projectId)
            // verify required parameter 'saId' is not null or undefined
            assertParamExists('iamProjectSaTagDelete', 'saId', saId)
            // verify required parameter 'tagId' is not null or undefined
            assertParamExists('iamProjectSaTagDelete', 'tagId', tagId)
            const localVarPath = `/iam/project/{projectId}/sa/{saId}/tag/{tagId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"saId"}}`, encodeURIComponent(String(saId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get iam/sa.tag
         * @summary Get iam/sa.tag
         * @param {string} projectId Project Id
         * @param {string} saId Sa Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectSaTagGet: async (projectId: string, saId: string, tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('iamProjectSaTagGet', 'projectId', projectId)
            // verify required parameter 'saId' is not null or undefined
            assertParamExists('iamProjectSaTagGet', 'saId', saId)
            // verify required parameter 'tagId' is not null or undefined
            assertParamExists('iamProjectSaTagGet', 'tagId', tagId)
            const localVarPath = `/iam/project/{projectId}/sa/{saId}/tag/{tagId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"saId"}}`, encodeURIComponent(String(saId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List iam/sa.tag
         * @summary List iam/sa.tag
         * @param {string} projectId Project Id
         * @param {string} saId Sa Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectSaTagList: async (projectId: string, saId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('iamProjectSaTagList', 'projectId', projectId)
            // verify required parameter 'saId' is not null or undefined
            assertParamExists('iamProjectSaTagList', 'saId', saId)
            const localVarPath = `/iam/project/{projectId}/sa/{saId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"saId"}}`, encodeURIComponent(String(saId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replace iam/sa.tag
         * @summary Replace iam/sa.tag
         * @param {string} projectId Project Id
         * @param {string} saId Sa Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectSaTagPut: async (projectId: string, saId: string, tag: Array<Tag>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('iamProjectSaTagPut', 'projectId', projectId)
            // verify required parameter 'saId' is not null or undefined
            assertParamExists('iamProjectSaTagPut', 'saId', saId)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('iamProjectSaTagPut', 'tag', tag)
            const localVarPath = `/iam/project/{projectId}/sa/{saId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"saId"}}`, encodeURIComponent(String(saId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tag, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns modified sa
         * @summary Update iam/sa
         * @param {string} projectId Project Id
         * @param {string} saId Sa Id
         * @param {IamProjectSaUpdate} iamProjectSaUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectSaUpdate: async (projectId: string, saId: string, iamProjectSaUpdate: IamProjectSaUpdate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('iamProjectSaUpdate', 'projectId', projectId)
            // verify required parameter 'saId' is not null or undefined
            assertParamExists('iamProjectSaUpdate', 'saId', saId)
            // verify required parameter 'iamProjectSaUpdate' is not null or undefined
            assertParamExists('iamProjectSaUpdate', 'iamProjectSaUpdate', iamProjectSaUpdate)
            const localVarPath = `/iam/project/{projectId}/sa/{saId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"saId"}}`, encodeURIComponent(String(saId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(iamProjectSaUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IamProjectSaApi - functional programming interface
 * @export
 */
export const IamProjectSaApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IamProjectSaApiAxiosParamCreator(configuration)
    return {
        /**
         * Create sa
         * @summary Create iam/sa
         * @param {string} projectId Project Id
         * @param {IamProjectSaCreate} iamProjectSaCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectSaCreate(projectId: string, iamProjectSaCreate: IamProjectSaCreate, xIdempotencyKey?: string, xDryRun?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Sa>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamProjectSaCreate(projectId, iamProjectSaCreate, xIdempotencyKey, xDryRun, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create iam/sa.credential
         * @summary Create iam/sa.credential
         * @param {string} projectId Project Id
         * @param {string} saId Sa Id
         * @param {SaCredential} saCredential 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectSaCredentialCreate(projectId: string, saId: string, saCredential: SaCredential, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SaCredential>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamProjectSaCredentialCreate(projectId, saId, saCredential, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete iam/sa.credential
         * @summary Delete iam/sa.credential
         * @param {string} projectId Project Id
         * @param {string} saId Sa Id
         * @param {string} credentialId credentialId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectSaCredentialDelete(projectId: string, saId: string, credentialId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Sa>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamProjectSaCredentialDelete(projectId, saId, credentialId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get iam/sa.credential
         * @summary Get iam/sa.credential
         * @param {string} projectId Project Id
         * @param {string} saId Sa Id
         * @param {string} credentialId credentialId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectSaCredentialGet(projectId: string, saId: string, credentialId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SaCredential>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamProjectSaCredentialGet(projectId, saId, credentialId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List iam/sa.credential
         * @summary List iam/sa.credential
         * @param {string} projectId Project Id
         * @param {string} saId Sa Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectSaCredentialList(projectId: string, saId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SaCredential>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamProjectSaCredentialList(projectId, saId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update iam/sa.credential
         * @summary Update iam/sa.credential
         * @param {string} projectId Project Id
         * @param {string} saId Sa Id
         * @param {string} credentialId credentialId
         * @param {IamProjectSaCredentialPatch} iamProjectSaCredentialPatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectSaCredentialPatch(projectId: string, saId: string, credentialId: string, iamProjectSaCredentialPatch: IamProjectSaCredentialPatch, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SaCredential>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamProjectSaCredentialPatch(projectId, saId, credentialId, iamProjectSaCredentialPatch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete sa
         * @summary Delete iam/sa
         * @param {string} projectId Project Id
         * @param {string} saId Sa Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectSaDelete(projectId: string, saId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamProjectSaDelete(projectId, saId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get iam/sa.event
         * @summary Get iam/sa.event
         * @param {string} projectId Project Id
         * @param {string} saId Sa Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectSaEventGet(projectId: string, saId: string, eventId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamProjectSaEventGet(projectId, saId, eventId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List iam/sa.event
         * @summary List iam/sa.event
         * @param {string} projectId Project Id
         * @param {string} saId Sa Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectSaEventList(projectId: string, saId: string, $limit?: number, $skip?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Event>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamProjectSaEventList(projectId, saId, $limit, $skip, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a single sa
         * @summary Get iam/sa
         * @param {string} projectId Project Id
         * @param {string} saId Sa Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectSaGet(projectId: string, saId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Sa>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamProjectSaGet(projectId, saId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List sa
         * @summary List iam/sa
         * @param {string} projectId Project Id
         * @param {string} [name] Filter by name
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectSaList(projectId: string, name?: string, tagValue?: string, tagKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Sa>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamProjectSaList(projectId, name, tagValue, tagKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get iam/sa.service
         * @summary Get iam/sa.service
         * @param {string} projectId Project Id
         * @param {string} saId Sa Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectSaServiceGet(projectId: string, saId: string, serviceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceService>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamProjectSaServiceGet(projectId, saId, serviceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List iam/sa.service
         * @summary List iam/sa.service
         * @param {string} projectId Project Id
         * @param {string} saId Sa Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectSaServiceList(projectId: string, saId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResourceService>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamProjectSaServiceList(projectId, saId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create iam/sa.tag
         * @summary Create iam/sa.tag
         * @param {string} projectId Project Id
         * @param {string} saId Sa Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectSaTagCreate(projectId: string, saId: string, tag: Tag, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamProjectSaTagCreate(projectId, saId, tag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete iam/sa.tag
         * @summary Delete iam/sa.tag
         * @param {string} projectId Project Id
         * @param {string} saId Sa Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectSaTagDelete(projectId: string, saId: string, tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamProjectSaTagDelete(projectId, saId, tagId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get iam/sa.tag
         * @summary Get iam/sa.tag
         * @param {string} projectId Project Id
         * @param {string} saId Sa Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectSaTagGet(projectId: string, saId: string, tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamProjectSaTagGet(projectId, saId, tagId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List iam/sa.tag
         * @summary List iam/sa.tag
         * @param {string} projectId Project Id
         * @param {string} saId Sa Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectSaTagList(projectId: string, saId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamProjectSaTagList(projectId, saId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Replace iam/sa.tag
         * @summary Replace iam/sa.tag
         * @param {string} projectId Project Id
         * @param {string} saId Sa Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectSaTagPut(projectId: string, saId: string, tag: Array<Tag>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamProjectSaTagPut(projectId, saId, tag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns modified sa
         * @summary Update iam/sa
         * @param {string} projectId Project Id
         * @param {string} saId Sa Id
         * @param {IamProjectSaUpdate} iamProjectSaUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamProjectSaUpdate(projectId: string, saId: string, iamProjectSaUpdate: IamProjectSaUpdate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Sa>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamProjectSaUpdate(projectId, saId, iamProjectSaUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * IamProjectSaApi - factory interface
 * @export
 */
export const IamProjectSaApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IamProjectSaApiFp(configuration)
    return {
        /**
         * Create sa
         * @summary Create iam/sa
         * @param {string} projectId Project Id
         * @param {IamProjectSaCreate} iamProjectSaCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectSaCreate(projectId: string, iamProjectSaCreate: IamProjectSaCreate, xIdempotencyKey?: string, xDryRun?: string, options?: any): AxiosPromise<Sa> {
            return localVarFp.iamProjectSaCreate(projectId, iamProjectSaCreate, xIdempotencyKey, xDryRun, options).then((request) => request(axios, basePath));
        },
        /**
         * Create iam/sa.credential
         * @summary Create iam/sa.credential
         * @param {string} projectId Project Id
         * @param {string} saId Sa Id
         * @param {SaCredential} saCredential 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectSaCredentialCreate(projectId: string, saId: string, saCredential: SaCredential, options?: any): AxiosPromise<SaCredential> {
            return localVarFp.iamProjectSaCredentialCreate(projectId, saId, saCredential, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete iam/sa.credential
         * @summary Delete iam/sa.credential
         * @param {string} projectId Project Id
         * @param {string} saId Sa Id
         * @param {string} credentialId credentialId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectSaCredentialDelete(projectId: string, saId: string, credentialId: string, options?: any): AxiosPromise<Sa> {
            return localVarFp.iamProjectSaCredentialDelete(projectId, saId, credentialId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get iam/sa.credential
         * @summary Get iam/sa.credential
         * @param {string} projectId Project Id
         * @param {string} saId Sa Id
         * @param {string} credentialId credentialId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectSaCredentialGet(projectId: string, saId: string, credentialId: string, options?: any): AxiosPromise<SaCredential> {
            return localVarFp.iamProjectSaCredentialGet(projectId, saId, credentialId, options).then((request) => request(axios, basePath));
        },
        /**
         * List iam/sa.credential
         * @summary List iam/sa.credential
         * @param {string} projectId Project Id
         * @param {string} saId Sa Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectSaCredentialList(projectId: string, saId: string, options?: any): AxiosPromise<Array<SaCredential>> {
            return localVarFp.iamProjectSaCredentialList(projectId, saId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update iam/sa.credential
         * @summary Update iam/sa.credential
         * @param {string} projectId Project Id
         * @param {string} saId Sa Id
         * @param {string} credentialId credentialId
         * @param {IamProjectSaCredentialPatch} iamProjectSaCredentialPatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectSaCredentialPatch(projectId: string, saId: string, credentialId: string, iamProjectSaCredentialPatch: IamProjectSaCredentialPatch, options?: any): AxiosPromise<SaCredential> {
            return localVarFp.iamProjectSaCredentialPatch(projectId, saId, credentialId, iamProjectSaCredentialPatch, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete sa
         * @summary Delete iam/sa
         * @param {string} projectId Project Id
         * @param {string} saId Sa Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectSaDelete(projectId: string, saId: string, options?: any): AxiosPromise<void> {
            return localVarFp.iamProjectSaDelete(projectId, saId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get iam/sa.event
         * @summary Get iam/sa.event
         * @param {string} projectId Project Id
         * @param {string} saId Sa Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectSaEventGet(projectId: string, saId: string, eventId: string, options?: any): AxiosPromise<Event> {
            return localVarFp.iamProjectSaEventGet(projectId, saId, eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * List iam/sa.event
         * @summary List iam/sa.event
         * @param {string} projectId Project Id
         * @param {string} saId Sa Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectSaEventList(projectId: string, saId: string, $limit?: number, $skip?: number, options?: any): AxiosPromise<Array<Event>> {
            return localVarFp.iamProjectSaEventList(projectId, saId, $limit, $skip, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single sa
         * @summary Get iam/sa
         * @param {string} projectId Project Id
         * @param {string} saId Sa Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectSaGet(projectId: string, saId: string, options?: any): AxiosPromise<Sa> {
            return localVarFp.iamProjectSaGet(projectId, saId, options).then((request) => request(axios, basePath));
        },
        /**
         * List sa
         * @summary List iam/sa
         * @param {string} projectId Project Id
         * @param {string} [name] Filter by name
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectSaList(projectId: string, name?: string, tagValue?: string, tagKey?: string, options?: any): AxiosPromise<Array<Sa>> {
            return localVarFp.iamProjectSaList(projectId, name, tagValue, tagKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get iam/sa.service
         * @summary Get iam/sa.service
         * @param {string} projectId Project Id
         * @param {string} saId Sa Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectSaServiceGet(projectId: string, saId: string, serviceId: string, options?: any): AxiosPromise<ResourceService> {
            return localVarFp.iamProjectSaServiceGet(projectId, saId, serviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * List iam/sa.service
         * @summary List iam/sa.service
         * @param {string} projectId Project Id
         * @param {string} saId Sa Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectSaServiceList(projectId: string, saId: string, options?: any): AxiosPromise<Array<ResourceService>> {
            return localVarFp.iamProjectSaServiceList(projectId, saId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create iam/sa.tag
         * @summary Create iam/sa.tag
         * @param {string} projectId Project Id
         * @param {string} saId Sa Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectSaTagCreate(projectId: string, saId: string, tag: Tag, options?: any): AxiosPromise<Tag> {
            return localVarFp.iamProjectSaTagCreate(projectId, saId, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete iam/sa.tag
         * @summary Delete iam/sa.tag
         * @param {string} projectId Project Id
         * @param {string} saId Sa Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectSaTagDelete(projectId: string, saId: string, tagId: string, options?: any): AxiosPromise<void> {
            return localVarFp.iamProjectSaTagDelete(projectId, saId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get iam/sa.tag
         * @summary Get iam/sa.tag
         * @param {string} projectId Project Id
         * @param {string} saId Sa Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectSaTagGet(projectId: string, saId: string, tagId: string, options?: any): AxiosPromise<Tag> {
            return localVarFp.iamProjectSaTagGet(projectId, saId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * List iam/sa.tag
         * @summary List iam/sa.tag
         * @param {string} projectId Project Id
         * @param {string} saId Sa Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectSaTagList(projectId: string, saId: string, options?: any): AxiosPromise<Array<Tag>> {
            return localVarFp.iamProjectSaTagList(projectId, saId, options).then((request) => request(axios, basePath));
        },
        /**
         * Replace iam/sa.tag
         * @summary Replace iam/sa.tag
         * @param {string} projectId Project Id
         * @param {string} saId Sa Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectSaTagPut(projectId: string, saId: string, tag: Array<Tag>, options?: any): AxiosPromise<Array<Tag>> {
            return localVarFp.iamProjectSaTagPut(projectId, saId, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns modified sa
         * @summary Update iam/sa
         * @param {string} projectId Project Id
         * @param {string} saId Sa Id
         * @param {IamProjectSaUpdate} iamProjectSaUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamProjectSaUpdate(projectId: string, saId: string, iamProjectSaUpdate: IamProjectSaUpdate, options?: any): AxiosPromise<Sa> {
            return localVarFp.iamProjectSaUpdate(projectId, saId, iamProjectSaUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IamProjectSaApi - object-oriented interface
 * @export
 * @class IamProjectSaApi
 * @extends {BaseAPI}
 */
export class IamProjectSaApi extends BaseAPI {
    /**
     * Create sa
     * @summary Create iam/sa
     * @param {string} projectId Project Id
     * @param {IamProjectSaCreate} iamProjectSaCreate 
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {string} [xDryRun] Dry run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectSaApi
     */
    public iamProjectSaCreate(projectId: string, iamProjectSaCreate: IamProjectSaCreate, xIdempotencyKey?: string, xDryRun?: string, options?: any) {
        return IamProjectSaApiFp(this.configuration).iamProjectSaCreate(projectId, iamProjectSaCreate, xIdempotencyKey, xDryRun, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create iam/sa.credential
     * @summary Create iam/sa.credential
     * @param {string} projectId Project Id
     * @param {string} saId Sa Id
     * @param {SaCredential} saCredential 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectSaApi
     */
    public iamProjectSaCredentialCreate(projectId: string, saId: string, saCredential: SaCredential, options?: any) {
        return IamProjectSaApiFp(this.configuration).iamProjectSaCredentialCreate(projectId, saId, saCredential, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete iam/sa.credential
     * @summary Delete iam/sa.credential
     * @param {string} projectId Project Id
     * @param {string} saId Sa Id
     * @param {string} credentialId credentialId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectSaApi
     */
    public iamProjectSaCredentialDelete(projectId: string, saId: string, credentialId: string, options?: any) {
        return IamProjectSaApiFp(this.configuration).iamProjectSaCredentialDelete(projectId, saId, credentialId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get iam/sa.credential
     * @summary Get iam/sa.credential
     * @param {string} projectId Project Id
     * @param {string} saId Sa Id
     * @param {string} credentialId credentialId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectSaApi
     */
    public iamProjectSaCredentialGet(projectId: string, saId: string, credentialId: string, options?: any) {
        return IamProjectSaApiFp(this.configuration).iamProjectSaCredentialGet(projectId, saId, credentialId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List iam/sa.credential
     * @summary List iam/sa.credential
     * @param {string} projectId Project Id
     * @param {string} saId Sa Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectSaApi
     */
    public iamProjectSaCredentialList(projectId: string, saId: string, options?: any) {
        return IamProjectSaApiFp(this.configuration).iamProjectSaCredentialList(projectId, saId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update iam/sa.credential
     * @summary Update iam/sa.credential
     * @param {string} projectId Project Id
     * @param {string} saId Sa Id
     * @param {string} credentialId credentialId
     * @param {IamProjectSaCredentialPatch} iamProjectSaCredentialPatch 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectSaApi
     */
    public iamProjectSaCredentialPatch(projectId: string, saId: string, credentialId: string, iamProjectSaCredentialPatch: IamProjectSaCredentialPatch, options?: any) {
        return IamProjectSaApiFp(this.configuration).iamProjectSaCredentialPatch(projectId, saId, credentialId, iamProjectSaCredentialPatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete sa
     * @summary Delete iam/sa
     * @param {string} projectId Project Id
     * @param {string} saId Sa Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectSaApi
     */
    public iamProjectSaDelete(projectId: string, saId: string, options?: any) {
        return IamProjectSaApiFp(this.configuration).iamProjectSaDelete(projectId, saId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get iam/sa.event
     * @summary Get iam/sa.event
     * @param {string} projectId Project Id
     * @param {string} saId Sa Id
     * @param {string} eventId eventId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectSaApi
     */
    public iamProjectSaEventGet(projectId: string, saId: string, eventId: string, options?: any) {
        return IamProjectSaApiFp(this.configuration).iamProjectSaEventGet(projectId, saId, eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List iam/sa.event
     * @summary List iam/sa.event
     * @param {string} projectId Project Id
     * @param {string} saId Sa Id
     * @param {number} [$limit] $limit
     * @param {number} [$skip] $skip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectSaApi
     */
    public iamProjectSaEventList(projectId: string, saId: string, $limit?: number, $skip?: number, options?: any) {
        return IamProjectSaApiFp(this.configuration).iamProjectSaEventList(projectId, saId, $limit, $skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single sa
     * @summary Get iam/sa
     * @param {string} projectId Project Id
     * @param {string} saId Sa Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectSaApi
     */
    public iamProjectSaGet(projectId: string, saId: string, options?: any) {
        return IamProjectSaApiFp(this.configuration).iamProjectSaGet(projectId, saId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List sa
     * @summary List iam/sa
     * @param {string} projectId Project Id
     * @param {string} [name] Filter by name
     * @param {string} [tagValue] Filter by tag.value
     * @param {string} [tagKey] Filter by tag.key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectSaApi
     */
    public iamProjectSaList(projectId: string, name?: string, tagValue?: string, tagKey?: string, options?: any) {
        return IamProjectSaApiFp(this.configuration).iamProjectSaList(projectId, name, tagValue, tagKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get iam/sa.service
     * @summary Get iam/sa.service
     * @param {string} projectId Project Id
     * @param {string} saId Sa Id
     * @param {string} serviceId serviceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectSaApi
     */
    public iamProjectSaServiceGet(projectId: string, saId: string, serviceId: string, options?: any) {
        return IamProjectSaApiFp(this.configuration).iamProjectSaServiceGet(projectId, saId, serviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List iam/sa.service
     * @summary List iam/sa.service
     * @param {string} projectId Project Id
     * @param {string} saId Sa Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectSaApi
     */
    public iamProjectSaServiceList(projectId: string, saId: string, options?: any) {
        return IamProjectSaApiFp(this.configuration).iamProjectSaServiceList(projectId, saId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create iam/sa.tag
     * @summary Create iam/sa.tag
     * @param {string} projectId Project Id
     * @param {string} saId Sa Id
     * @param {Tag} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectSaApi
     */
    public iamProjectSaTagCreate(projectId: string, saId: string, tag: Tag, options?: any) {
        return IamProjectSaApiFp(this.configuration).iamProjectSaTagCreate(projectId, saId, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete iam/sa.tag
     * @summary Delete iam/sa.tag
     * @param {string} projectId Project Id
     * @param {string} saId Sa Id
     * @param {string} tagId tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectSaApi
     */
    public iamProjectSaTagDelete(projectId: string, saId: string, tagId: string, options?: any) {
        return IamProjectSaApiFp(this.configuration).iamProjectSaTagDelete(projectId, saId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get iam/sa.tag
     * @summary Get iam/sa.tag
     * @param {string} projectId Project Id
     * @param {string} saId Sa Id
     * @param {string} tagId tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectSaApi
     */
    public iamProjectSaTagGet(projectId: string, saId: string, tagId: string, options?: any) {
        return IamProjectSaApiFp(this.configuration).iamProjectSaTagGet(projectId, saId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List iam/sa.tag
     * @summary List iam/sa.tag
     * @param {string} projectId Project Id
     * @param {string} saId Sa Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectSaApi
     */
    public iamProjectSaTagList(projectId: string, saId: string, options?: any) {
        return IamProjectSaApiFp(this.configuration).iamProjectSaTagList(projectId, saId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replace iam/sa.tag
     * @summary Replace iam/sa.tag
     * @param {string} projectId Project Id
     * @param {string} saId Sa Id
     * @param {Array<Tag>} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectSaApi
     */
    public iamProjectSaTagPut(projectId: string, saId: string, tag: Array<Tag>, options?: any) {
        return IamProjectSaApiFp(this.configuration).iamProjectSaTagPut(projectId, saId, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns modified sa
     * @summary Update iam/sa
     * @param {string} projectId Project Id
     * @param {string} saId Sa Id
     * @param {IamProjectSaUpdate} iamProjectSaUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamProjectSaApi
     */
    public iamProjectSaUpdate(projectId: string, saId: string, iamProjectSaUpdate: IamProjectSaUpdate, options?: any) {
        return IamProjectSaApiFp(this.configuration).iamProjectSaUpdate(projectId, saId, iamProjectSaUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * IamUserApi - axios parameter creator
 * @export
 */
export const IamUserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete iam/user.credential
         * @summary Delete iam/user.credential
         * @param {string} userId User Id
         * @param {string} authtokenId authtokenId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamUserCredentialAuthtokenDelete: async (userId: string, authtokenId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('iamUserCredentialAuthtokenDelete', 'userId', userId)
            // verify required parameter 'authtokenId' is not null or undefined
            assertParamExists('iamUserCredentialAuthtokenDelete', 'authtokenId', authtokenId)
            const localVarPath = `/iam/user/{userId}/credential/authtoken/{authtokenId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"authtokenId"}}`, encodeURIComponent(String(authtokenId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get iam/user.credential
         * @summary Get iam/user.credential
         * @param {string} userId User Id
         * @param {string} authtokenId authtokenId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamUserCredentialAuthtokenGet: async (userId: string, authtokenId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('iamUserCredentialAuthtokenGet', 'userId', userId)
            // verify required parameter 'authtokenId' is not null or undefined
            assertParamExists('iamUserCredentialAuthtokenGet', 'authtokenId', authtokenId)
            const localVarPath = `/iam/user/{userId}/credential/authtoken/{authtokenId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"authtokenId"}}`, encodeURIComponent(String(authtokenId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List iam/user.credential
         * @summary List iam/user.credential
         * @param {string} userId User Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamUserCredentialAuthtokenList: async (userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('iamUserCredentialAuthtokenList', 'userId', userId)
            const localVarPath = `/iam/user/{userId}/credential/authtoken`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create iam/user.credential
         * @summary Create iam/user.credential
         * @param {string} userId User Id
         * @param {UserCredential} userCredential 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamUserCredentialCreate: async (userId: string, userCredential: UserCredential, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('iamUserCredentialCreate', 'userId', userId)
            // verify required parameter 'userCredential' is not null or undefined
            assertParamExists('iamUserCredentialCreate', 'userCredential', userCredential)
            const localVarPath = `/iam/user/{userId}/credential`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userCredential, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete iam/user.credential
         * @summary Delete iam/user.credential
         * @param {string} userId User Id
         * @param {string} credentialId credentialId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamUserCredentialDelete: async (userId: string, credentialId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('iamUserCredentialDelete', 'userId', userId)
            // verify required parameter 'credentialId' is not null or undefined
            assertParamExists('iamUserCredentialDelete', 'credentialId', credentialId)
            const localVarPath = `/iam/user/{userId}/credential/{credentialId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"credentialId"}}`, encodeURIComponent(String(credentialId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get iam/user.credential
         * @summary Get iam/user.credential
         * @param {string} userId User Id
         * @param {string} credentialId credentialId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamUserCredentialGet: async (userId: string, credentialId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('iamUserCredentialGet', 'userId', userId)
            // verify required parameter 'credentialId' is not null or undefined
            assertParamExists('iamUserCredentialGet', 'credentialId', credentialId)
            const localVarPath = `/iam/user/{userId}/credential/{credentialId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"credentialId"}}`, encodeURIComponent(String(credentialId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List iam/user.credential
         * @summary List iam/user.credential
         * @param {string} userId User Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamUserCredentialList: async (userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('iamUserCredentialList', 'userId', userId)
            const localVarPath = `/iam/user/{userId}/credential`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update iam/user.credential
         * @summary Update iam/user.credential
         * @param {string} userId User Id
         * @param {string} credentialId credentialId
         * @param {IamUserCredentialPatch} iamUserCredentialPatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamUserCredentialPatch: async (userId: string, credentialId: string, iamUserCredentialPatch: IamUserCredentialPatch, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('iamUserCredentialPatch', 'userId', userId)
            // verify required parameter 'credentialId' is not null or undefined
            assertParamExists('iamUserCredentialPatch', 'credentialId', credentialId)
            // verify required parameter 'iamUserCredentialPatch' is not null or undefined
            assertParamExists('iamUserCredentialPatch', 'iamUserCredentialPatch', iamUserCredentialPatch)
            const localVarPath = `/iam/user/{userId}/credential/{credentialId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"credentialId"}}`, encodeURIComponent(String(credentialId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(iamUserCredentialPatch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single user
         * @summary Get iam/user
         * @param {string} userId User Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamUserGet: async (userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('iamUserGet', 'userId', userId)
            const localVarPath = `/iam/user/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get iam/user.service
         * @summary Get iam/user.service
         * @param {string} userId User Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamUserServiceGet: async (userId: string, serviceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('iamUserServiceGet', 'userId', userId)
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('iamUserServiceGet', 'serviceId', serviceId)
            const localVarPath = `/iam/user/{userId}/service/{serviceId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List iam/user.service
         * @summary List iam/user.service
         * @param {string} userId User Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamUserServiceList: async (userId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('iamUserServiceList', 'userId', userId)
            const localVarPath = `/iam/user/{userId}/service`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns modified user
         * @summary Update iam/user
         * @param {string} userId User Id
         * @param {IamUserUpdate} iamUserUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamUserUpdate: async (userId: string, iamUserUpdate: IamUserUpdate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('iamUserUpdate', 'userId', userId)
            // verify required parameter 'iamUserUpdate' is not null or undefined
            assertParamExists('iamUserUpdate', 'iamUserUpdate', iamUserUpdate)
            const localVarPath = `/iam/user/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(iamUserUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * IamUserApi - functional programming interface
 * @export
 */
export const IamUserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = IamUserApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete iam/user.credential
         * @summary Delete iam/user.credential
         * @param {string} userId User Id
         * @param {string} authtokenId authtokenId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamUserCredentialAuthtokenDelete(userId: string, authtokenId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamUserCredentialAuthtokenDelete(userId, authtokenId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get iam/user.credential
         * @summary Get iam/user.credential
         * @param {string} userId User Id
         * @param {string} authtokenId authtokenId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamUserCredentialAuthtokenGet(userId: string, authtokenId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamUserCredentialAuthtokenGet(userId, authtokenId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List iam/user.credential
         * @summary List iam/user.credential
         * @param {string} userId User Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamUserCredentialAuthtokenList(userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AuthToken>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamUserCredentialAuthtokenList(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create iam/user.credential
         * @summary Create iam/user.credential
         * @param {string} userId User Id
         * @param {UserCredential} userCredential 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamUserCredentialCreate(userId: string, userCredential: UserCredential, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserCredential>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamUserCredentialCreate(userId, userCredential, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete iam/user.credential
         * @summary Delete iam/user.credential
         * @param {string} userId User Id
         * @param {string} credentialId credentialId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamUserCredentialDelete(userId: string, credentialId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamUserCredentialDelete(userId, credentialId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get iam/user.credential
         * @summary Get iam/user.credential
         * @param {string} userId User Id
         * @param {string} credentialId credentialId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamUserCredentialGet(userId: string, credentialId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserCredential>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamUserCredentialGet(userId, credentialId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List iam/user.credential
         * @summary List iam/user.credential
         * @param {string} userId User Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamUserCredentialList(userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserCredential>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamUserCredentialList(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update iam/user.credential
         * @summary Update iam/user.credential
         * @param {string} userId User Id
         * @param {string} credentialId credentialId
         * @param {IamUserCredentialPatch} iamUserCredentialPatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamUserCredentialPatch(userId: string, credentialId: string, iamUserCredentialPatch: IamUserCredentialPatch, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserCredential>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamUserCredentialPatch(userId, credentialId, iamUserCredentialPatch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a single user
         * @summary Get iam/user
         * @param {string} userId User Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamUserGet(userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamUserGet(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get iam/user.service
         * @summary Get iam/user.service
         * @param {string} userId User Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamUserServiceGet(userId: string, serviceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceService>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamUserServiceGet(userId, serviceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List iam/user.service
         * @summary List iam/user.service
         * @param {string} userId User Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamUserServiceList(userId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResourceService>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamUserServiceList(userId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns modified user
         * @summary Update iam/user
         * @param {string} userId User Id
         * @param {IamUserUpdate} iamUserUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async iamUserUpdate(userId: string, iamUserUpdate: IamUserUpdate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.iamUserUpdate(userId, iamUserUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * IamUserApi - factory interface
 * @export
 */
export const IamUserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = IamUserApiFp(configuration)
    return {
        /**
         * Delete iam/user.credential
         * @summary Delete iam/user.credential
         * @param {string} userId User Id
         * @param {string} authtokenId authtokenId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamUserCredentialAuthtokenDelete(userId: string, authtokenId: string, options?: any): AxiosPromise<void> {
            return localVarFp.iamUserCredentialAuthtokenDelete(userId, authtokenId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get iam/user.credential
         * @summary Get iam/user.credential
         * @param {string} userId User Id
         * @param {string} authtokenId authtokenId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamUserCredentialAuthtokenGet(userId: string, authtokenId: string, options?: any): AxiosPromise<AuthToken> {
            return localVarFp.iamUserCredentialAuthtokenGet(userId, authtokenId, options).then((request) => request(axios, basePath));
        },
        /**
         * List iam/user.credential
         * @summary List iam/user.credential
         * @param {string} userId User Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamUserCredentialAuthtokenList(userId: string, options?: any): AxiosPromise<Array<AuthToken>> {
            return localVarFp.iamUserCredentialAuthtokenList(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create iam/user.credential
         * @summary Create iam/user.credential
         * @param {string} userId User Id
         * @param {UserCredential} userCredential 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamUserCredentialCreate(userId: string, userCredential: UserCredential, options?: any): AxiosPromise<UserCredential> {
            return localVarFp.iamUserCredentialCreate(userId, userCredential, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete iam/user.credential
         * @summary Delete iam/user.credential
         * @param {string} userId User Id
         * @param {string} credentialId credentialId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamUserCredentialDelete(userId: string, credentialId: string, options?: any): AxiosPromise<User> {
            return localVarFp.iamUserCredentialDelete(userId, credentialId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get iam/user.credential
         * @summary Get iam/user.credential
         * @param {string} userId User Id
         * @param {string} credentialId credentialId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamUserCredentialGet(userId: string, credentialId: string, options?: any): AxiosPromise<UserCredential> {
            return localVarFp.iamUserCredentialGet(userId, credentialId, options).then((request) => request(axios, basePath));
        },
        /**
         * List iam/user.credential
         * @summary List iam/user.credential
         * @param {string} userId User Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamUserCredentialList(userId: string, options?: any): AxiosPromise<Array<UserCredential>> {
            return localVarFp.iamUserCredentialList(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update iam/user.credential
         * @summary Update iam/user.credential
         * @param {string} userId User Id
         * @param {string} credentialId credentialId
         * @param {IamUserCredentialPatch} iamUserCredentialPatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamUserCredentialPatch(userId: string, credentialId: string, iamUserCredentialPatch: IamUserCredentialPatch, options?: any): AxiosPromise<UserCredential> {
            return localVarFp.iamUserCredentialPatch(userId, credentialId, iamUserCredentialPatch, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single user
         * @summary Get iam/user
         * @param {string} userId User Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamUserGet(userId: string, options?: any): AxiosPromise<User> {
            return localVarFp.iamUserGet(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get iam/user.service
         * @summary Get iam/user.service
         * @param {string} userId User Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamUserServiceGet(userId: string, serviceId: string, options?: any): AxiosPromise<ResourceService> {
            return localVarFp.iamUserServiceGet(userId, serviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * List iam/user.service
         * @summary List iam/user.service
         * @param {string} userId User Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamUserServiceList(userId: string, options?: any): AxiosPromise<Array<ResourceService>> {
            return localVarFp.iamUserServiceList(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns modified user
         * @summary Update iam/user
         * @param {string} userId User Id
         * @param {IamUserUpdate} iamUserUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        iamUserUpdate(userId: string, iamUserUpdate: IamUserUpdate, options?: any): AxiosPromise<User> {
            return localVarFp.iamUserUpdate(userId, iamUserUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * IamUserApi - object-oriented interface
 * @export
 * @class IamUserApi
 * @extends {BaseAPI}
 */
export class IamUserApi extends BaseAPI {
    /**
     * Delete iam/user.credential
     * @summary Delete iam/user.credential
     * @param {string} userId User Id
     * @param {string} authtokenId authtokenId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamUserApi
     */
    public iamUserCredentialAuthtokenDelete(userId: string, authtokenId: string, options?: any) {
        return IamUserApiFp(this.configuration).iamUserCredentialAuthtokenDelete(userId, authtokenId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get iam/user.credential
     * @summary Get iam/user.credential
     * @param {string} userId User Id
     * @param {string} authtokenId authtokenId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamUserApi
     */
    public iamUserCredentialAuthtokenGet(userId: string, authtokenId: string, options?: any) {
        return IamUserApiFp(this.configuration).iamUserCredentialAuthtokenGet(userId, authtokenId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List iam/user.credential
     * @summary List iam/user.credential
     * @param {string} userId User Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamUserApi
     */
    public iamUserCredentialAuthtokenList(userId: string, options?: any) {
        return IamUserApiFp(this.configuration).iamUserCredentialAuthtokenList(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create iam/user.credential
     * @summary Create iam/user.credential
     * @param {string} userId User Id
     * @param {UserCredential} userCredential 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamUserApi
     */
    public iamUserCredentialCreate(userId: string, userCredential: UserCredential, options?: any) {
        return IamUserApiFp(this.configuration).iamUserCredentialCreate(userId, userCredential, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete iam/user.credential
     * @summary Delete iam/user.credential
     * @param {string} userId User Id
     * @param {string} credentialId credentialId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamUserApi
     */
    public iamUserCredentialDelete(userId: string, credentialId: string, options?: any) {
        return IamUserApiFp(this.configuration).iamUserCredentialDelete(userId, credentialId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get iam/user.credential
     * @summary Get iam/user.credential
     * @param {string} userId User Id
     * @param {string} credentialId credentialId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamUserApi
     */
    public iamUserCredentialGet(userId: string, credentialId: string, options?: any) {
        return IamUserApiFp(this.configuration).iamUserCredentialGet(userId, credentialId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List iam/user.credential
     * @summary List iam/user.credential
     * @param {string} userId User Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamUserApi
     */
    public iamUserCredentialList(userId: string, options?: any) {
        return IamUserApiFp(this.configuration).iamUserCredentialList(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update iam/user.credential
     * @summary Update iam/user.credential
     * @param {string} userId User Id
     * @param {string} credentialId credentialId
     * @param {IamUserCredentialPatch} iamUserCredentialPatch 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamUserApi
     */
    public iamUserCredentialPatch(userId: string, credentialId: string, iamUserCredentialPatch: IamUserCredentialPatch, options?: any) {
        return IamUserApiFp(this.configuration).iamUserCredentialPatch(userId, credentialId, iamUserCredentialPatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single user
     * @summary Get iam/user
     * @param {string} userId User Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamUserApi
     */
    public iamUserGet(userId: string, options?: any) {
        return IamUserApiFp(this.configuration).iamUserGet(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get iam/user.service
     * @summary Get iam/user.service
     * @param {string} userId User Id
     * @param {string} serviceId serviceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamUserApi
     */
    public iamUserServiceGet(userId: string, serviceId: string, options?: any) {
        return IamUserApiFp(this.configuration).iamUserServiceGet(userId, serviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List iam/user.service
     * @summary List iam/user.service
     * @param {string} userId User Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamUserApi
     */
    public iamUserServiceList(userId: string, options?: any) {
        return IamUserApiFp(this.configuration).iamUserServiceList(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns modified user
     * @summary Update iam/user
     * @param {string} userId User Id
     * @param {IamUserUpdate} iamUserUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof IamUserApi
     */
    public iamUserUpdate(userId: string, iamUserUpdate: IamUserUpdate, options?: any) {
        return IamUserApiFp(this.configuration).iamUserUpdate(userId, iamUserUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * InsightProjectJournalApi - axios parameter creator
 * @export
 */
export const InsightProjectJournalApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create journal
         * @summary Create insight/journal
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {InsightProjectJournalCreate} insightProjectJournalCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightProjectJournalCreate: async (projectId: string, locationId: string, insightProjectJournalCreate: InsightProjectJournalCreate, xIdempotencyKey?: string, xDryRun?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('insightProjectJournalCreate', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('insightProjectJournalCreate', 'locationId', locationId)
            // verify required parameter 'insightProjectJournalCreate' is not null or undefined
            assertParamExists('insightProjectJournalCreate', 'insightProjectJournalCreate', insightProjectJournalCreate)
            const localVarPath = `/insight/{locationId}/project/{projectId}/journal`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }

            if (xDryRun !== undefined && xDryRun !== null) {
                localVarHeaderParameter['x-dry-run'] = String(xDryRun);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(insightProjectJournalCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create insight/journal.credential
         * @summary Create insight/journal.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {JournalCredential} journalCredential 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightProjectJournalCredentialCreate: async (projectId: string, locationId: string, journalId: string, journalCredential: JournalCredential, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('insightProjectJournalCredentialCreate', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('insightProjectJournalCredentialCreate', 'locationId', locationId)
            // verify required parameter 'journalId' is not null or undefined
            assertParamExists('insightProjectJournalCredentialCreate', 'journalId', journalId)
            // verify required parameter 'journalCredential' is not null or undefined
            assertParamExists('insightProjectJournalCredentialCreate', 'journalCredential', journalCredential)
            const localVarPath = `/insight/{locationId}/project/{projectId}/journal/{journalId}/credential`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"journalId"}}`, encodeURIComponent(String(journalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(journalCredential, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete insight/journal.credential
         * @summary Delete insight/journal.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {string} credentialId credentialId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightProjectJournalCredentialDelete: async (projectId: string, locationId: string, journalId: string, credentialId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('insightProjectJournalCredentialDelete', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('insightProjectJournalCredentialDelete', 'locationId', locationId)
            // verify required parameter 'journalId' is not null or undefined
            assertParamExists('insightProjectJournalCredentialDelete', 'journalId', journalId)
            // verify required parameter 'credentialId' is not null or undefined
            assertParamExists('insightProjectJournalCredentialDelete', 'credentialId', credentialId)
            const localVarPath = `/insight/{locationId}/project/{projectId}/journal/{journalId}/credential/{credentialId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"journalId"}}`, encodeURIComponent(String(journalId)))
                .replace(`{${"credentialId"}}`, encodeURIComponent(String(credentialId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get insight/journal.credential
         * @summary Get insight/journal.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {string} credentialId credentialId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightProjectJournalCredentialGet: async (projectId: string, locationId: string, journalId: string, credentialId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('insightProjectJournalCredentialGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('insightProjectJournalCredentialGet', 'locationId', locationId)
            // verify required parameter 'journalId' is not null or undefined
            assertParamExists('insightProjectJournalCredentialGet', 'journalId', journalId)
            // verify required parameter 'credentialId' is not null or undefined
            assertParamExists('insightProjectJournalCredentialGet', 'credentialId', credentialId)
            const localVarPath = `/insight/{locationId}/project/{projectId}/journal/{journalId}/credential/{credentialId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"journalId"}}`, encodeURIComponent(String(journalId)))
                .replace(`{${"credentialId"}}`, encodeURIComponent(String(credentialId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List insight/journal.credential
         * @summary List insight/journal.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightProjectJournalCredentialList: async (projectId: string, locationId: string, journalId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('insightProjectJournalCredentialList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('insightProjectJournalCredentialList', 'locationId', locationId)
            // verify required parameter 'journalId' is not null or undefined
            assertParamExists('insightProjectJournalCredentialList', 'journalId', journalId)
            const localVarPath = `/insight/{locationId}/project/{projectId}/journal/{journalId}/credential`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"journalId"}}`, encodeURIComponent(String(journalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update insight/journal.credential
         * @summary Update insight/journal.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {string} credentialId credentialId
         * @param {InsightProjectJournalCredentialPatch} insightProjectJournalCredentialPatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightProjectJournalCredentialPatch: async (projectId: string, locationId: string, journalId: string, credentialId: string, insightProjectJournalCredentialPatch: InsightProjectJournalCredentialPatch, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('insightProjectJournalCredentialPatch', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('insightProjectJournalCredentialPatch', 'locationId', locationId)
            // verify required parameter 'journalId' is not null or undefined
            assertParamExists('insightProjectJournalCredentialPatch', 'journalId', journalId)
            // verify required parameter 'credentialId' is not null or undefined
            assertParamExists('insightProjectJournalCredentialPatch', 'credentialId', credentialId)
            // verify required parameter 'insightProjectJournalCredentialPatch' is not null or undefined
            assertParamExists('insightProjectJournalCredentialPatch', 'insightProjectJournalCredentialPatch', insightProjectJournalCredentialPatch)
            const localVarPath = `/insight/{locationId}/project/{projectId}/journal/{journalId}/credential/{credentialId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"journalId"}}`, encodeURIComponent(String(journalId)))
                .replace(`{${"credentialId"}}`, encodeURIComponent(String(credentialId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(insightProjectJournalCredentialPatch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete journal
         * @summary Delete insight/journal
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightProjectJournalDelete: async (projectId: string, locationId: string, journalId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('insightProjectJournalDelete', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('insightProjectJournalDelete', 'locationId', locationId)
            // verify required parameter 'journalId' is not null or undefined
            assertParamExists('insightProjectJournalDelete', 'journalId', journalId)
            const localVarPath = `/insight/{locationId}/project/{projectId}/journal/{journalId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"journalId"}}`, encodeURIComponent(String(journalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get insight/journal.event
         * @summary Get insight/journal.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightProjectJournalEventGet: async (projectId: string, locationId: string, journalId: string, eventId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('insightProjectJournalEventGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('insightProjectJournalEventGet', 'locationId', locationId)
            // verify required parameter 'journalId' is not null or undefined
            assertParamExists('insightProjectJournalEventGet', 'journalId', journalId)
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('insightProjectJournalEventGet', 'eventId', eventId)
            const localVarPath = `/insight/{locationId}/project/{projectId}/journal/{journalId}/event/{eventId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"journalId"}}`, encodeURIComponent(String(journalId)))
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List insight/journal.event
         * @summary List insight/journal.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightProjectJournalEventList: async (projectId: string, locationId: string, journalId: string, $limit?: number, $skip?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('insightProjectJournalEventList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('insightProjectJournalEventList', 'locationId', locationId)
            // verify required parameter 'journalId' is not null or undefined
            assertParamExists('insightProjectJournalEventList', 'journalId', journalId)
            const localVarPath = `/insight/{locationId}/project/{projectId}/journal/{journalId}/event`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"journalId"}}`, encodeURIComponent(String(journalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if ($limit !== undefined) {
                localVarQueryParameter['$limit'] = $limit;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single journal
         * @summary Get insight/journal
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightProjectJournalGet: async (projectId: string, locationId: string, journalId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('insightProjectJournalGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('insightProjectJournalGet', 'locationId', locationId)
            // verify required parameter 'journalId' is not null or undefined
            assertParamExists('insightProjectJournalGet', 'journalId', journalId)
            const localVarPath = `/insight/{locationId}/project/{projectId}/journal/{journalId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"journalId"}}`, encodeURIComponent(String(journalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List journal
         * @summary List insight/journal
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [name] Filter by name
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightProjectJournalList: async (projectId: string, locationId: string, name?: string, tagValue?: string, tagKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('insightProjectJournalList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('insightProjectJournalList', 'locationId', locationId)
            const localVarPath = `/insight/{locationId}/project/{projectId}/journal`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (tagValue !== undefined) {
                localVarQueryParameter['tag.value'] = tagValue;
            }

            if (tagKey !== undefined) {
                localVarQueryParameter['tag.key'] = tagKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * websocket is also supported
         * @summary Get insight/journal.log
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {string} [since] since
         * @param {string} [until] until
         * @param {boolean} [follow] follow
         * @param {number} [tail] tail
         * @param {Array<Tag>} [tag] tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightProjectJournalLogGet: async (projectId: string, locationId: string, journalId: string, since?: string, until?: string, follow?: boolean, tail?: number, tag?: Array<Tag>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('insightProjectJournalLogGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('insightProjectJournalLogGet', 'locationId', locationId)
            // verify required parameter 'journalId' is not null or undefined
            assertParamExists('insightProjectJournalLogGet', 'journalId', journalId)
            const localVarPath = `/insight/{locationId}/project/{projectId}/journal/{journalId}/log`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"journalId"}}`, encodeURIComponent(String(journalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (since !== undefined) {
                localVarQueryParameter['since'] = (since as any instanceof Date) ?
                    (since as any).toISOString() :
                    since;
            }

            if (until !== undefined) {
                localVarQueryParameter['until'] = (until as any instanceof Date) ?
                    (until as any).toISOString() :
                    until;
            }

            if (follow !== undefined) {
                localVarQueryParameter['follow'] = follow;
            }

            if (tail !== undefined) {
                localVarQueryParameter['tail'] = tail;
            }

            if (tag) {
                localVarQueryParameter['tag'] = tag;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get insight/journal.service
         * @summary Get insight/journal.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightProjectJournalServiceGet: async (projectId: string, locationId: string, journalId: string, serviceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('insightProjectJournalServiceGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('insightProjectJournalServiceGet', 'locationId', locationId)
            // verify required parameter 'journalId' is not null or undefined
            assertParamExists('insightProjectJournalServiceGet', 'journalId', journalId)
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('insightProjectJournalServiceGet', 'serviceId', serviceId)
            const localVarPath = `/insight/{locationId}/project/{projectId}/journal/{journalId}/service/{serviceId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"journalId"}}`, encodeURIComponent(String(journalId)))
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List insight/journal.service
         * @summary List insight/journal.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightProjectJournalServiceList: async (projectId: string, locationId: string, journalId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('insightProjectJournalServiceList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('insightProjectJournalServiceList', 'locationId', locationId)
            // verify required parameter 'journalId' is not null or undefined
            assertParamExists('insightProjectJournalServiceList', 'journalId', journalId)
            const localVarPath = `/insight/{locationId}/project/{projectId}/journal/{journalId}/service`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"journalId"}}`, encodeURIComponent(String(journalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create insight/journal.tag
         * @summary Create insight/journal.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightProjectJournalTagCreate: async (projectId: string, locationId: string, journalId: string, tag: Tag, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('insightProjectJournalTagCreate', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('insightProjectJournalTagCreate', 'locationId', locationId)
            // verify required parameter 'journalId' is not null or undefined
            assertParamExists('insightProjectJournalTagCreate', 'journalId', journalId)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('insightProjectJournalTagCreate', 'tag', tag)
            const localVarPath = `/insight/{locationId}/project/{projectId}/journal/{journalId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"journalId"}}`, encodeURIComponent(String(journalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tag, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete insight/journal.tag
         * @summary Delete insight/journal.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightProjectJournalTagDelete: async (projectId: string, locationId: string, journalId: string, tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('insightProjectJournalTagDelete', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('insightProjectJournalTagDelete', 'locationId', locationId)
            // verify required parameter 'journalId' is not null or undefined
            assertParamExists('insightProjectJournalTagDelete', 'journalId', journalId)
            // verify required parameter 'tagId' is not null or undefined
            assertParamExists('insightProjectJournalTagDelete', 'tagId', tagId)
            const localVarPath = `/insight/{locationId}/project/{projectId}/journal/{journalId}/tag/{tagId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"journalId"}}`, encodeURIComponent(String(journalId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get insight/journal.tag
         * @summary Get insight/journal.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightProjectJournalTagGet: async (projectId: string, locationId: string, journalId: string, tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('insightProjectJournalTagGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('insightProjectJournalTagGet', 'locationId', locationId)
            // verify required parameter 'journalId' is not null or undefined
            assertParamExists('insightProjectJournalTagGet', 'journalId', journalId)
            // verify required parameter 'tagId' is not null or undefined
            assertParamExists('insightProjectJournalTagGet', 'tagId', tagId)
            const localVarPath = `/insight/{locationId}/project/{projectId}/journal/{journalId}/tag/{tagId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"journalId"}}`, encodeURIComponent(String(journalId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List insight/journal.tag
         * @summary List insight/journal.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightProjectJournalTagList: async (projectId: string, locationId: string, journalId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('insightProjectJournalTagList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('insightProjectJournalTagList', 'locationId', locationId)
            // verify required parameter 'journalId' is not null or undefined
            assertParamExists('insightProjectJournalTagList', 'journalId', journalId)
            const localVarPath = `/insight/{locationId}/project/{projectId}/journal/{journalId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"journalId"}}`, encodeURIComponent(String(journalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replace insight/journal.tag
         * @summary Replace insight/journal.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightProjectJournalTagPut: async (projectId: string, locationId: string, journalId: string, tag: Array<Tag>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('insightProjectJournalTagPut', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('insightProjectJournalTagPut', 'locationId', locationId)
            // verify required parameter 'journalId' is not null or undefined
            assertParamExists('insightProjectJournalTagPut', 'journalId', journalId)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('insightProjectJournalTagPut', 'tag', tag)
            const localVarPath = `/insight/{locationId}/project/{projectId}/journal/{journalId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"journalId"}}`, encodeURIComponent(String(journalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tag, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * action transfer
         * @summary Transfer insight/journal
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {InsightProjectJournalTransfer} insightProjectJournalTransfer 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightProjectJournalTransfer: async (projectId: string, locationId: string, journalId: string, insightProjectJournalTransfer: InsightProjectJournalTransfer, xIdempotencyKey?: string, xDryRun?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('insightProjectJournalTransfer', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('insightProjectJournalTransfer', 'locationId', locationId)
            // verify required parameter 'journalId' is not null or undefined
            assertParamExists('insightProjectJournalTransfer', 'journalId', journalId)
            // verify required parameter 'insightProjectJournalTransfer' is not null or undefined
            assertParamExists('insightProjectJournalTransfer', 'insightProjectJournalTransfer', insightProjectJournalTransfer)
            const localVarPath = `/insight/{locationId}/project/{projectId}/journal/{journalId}/actions/transfer`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"journalId"}}`, encodeURIComponent(String(journalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }

            if (xDryRun !== undefined && xDryRun !== null) {
                localVarHeaderParameter['x-dry-run'] = String(xDryRun);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(insightProjectJournalTransfer, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns modified journal
         * @summary Update insight/journal
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {InsightProjectJournalUpdate} insightProjectJournalUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightProjectJournalUpdate: async (projectId: string, locationId: string, journalId: string, insightProjectJournalUpdate: InsightProjectJournalUpdate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('insightProjectJournalUpdate', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('insightProjectJournalUpdate', 'locationId', locationId)
            // verify required parameter 'journalId' is not null or undefined
            assertParamExists('insightProjectJournalUpdate', 'journalId', journalId)
            // verify required parameter 'insightProjectJournalUpdate' is not null or undefined
            assertParamExists('insightProjectJournalUpdate', 'insightProjectJournalUpdate', insightProjectJournalUpdate)
            const localVarPath = `/insight/{locationId}/project/{projectId}/journal/{journalId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"journalId"}}`, encodeURIComponent(String(journalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(insightProjectJournalUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InsightProjectJournalApi - functional programming interface
 * @export
 */
export const InsightProjectJournalApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = InsightProjectJournalApiAxiosParamCreator(configuration)
    return {
        /**
         * Create journal
         * @summary Create insight/journal
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {InsightProjectJournalCreate} insightProjectJournalCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async insightProjectJournalCreate(projectId: string, locationId: string, insightProjectJournalCreate: InsightProjectJournalCreate, xIdempotencyKey?: string, xDryRun?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Journal>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.insightProjectJournalCreate(projectId, locationId, insightProjectJournalCreate, xIdempotencyKey, xDryRun, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create insight/journal.credential
         * @summary Create insight/journal.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {JournalCredential} journalCredential 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async insightProjectJournalCredentialCreate(projectId: string, locationId: string, journalId: string, journalCredential: JournalCredential, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JournalCredential>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.insightProjectJournalCredentialCreate(projectId, locationId, journalId, journalCredential, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete insight/journal.credential
         * @summary Delete insight/journal.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {string} credentialId credentialId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async insightProjectJournalCredentialDelete(projectId: string, locationId: string, journalId: string, credentialId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Journal>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.insightProjectJournalCredentialDelete(projectId, locationId, journalId, credentialId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get insight/journal.credential
         * @summary Get insight/journal.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {string} credentialId credentialId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async insightProjectJournalCredentialGet(projectId: string, locationId: string, journalId: string, credentialId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JournalCredential>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.insightProjectJournalCredentialGet(projectId, locationId, journalId, credentialId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List insight/journal.credential
         * @summary List insight/journal.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async insightProjectJournalCredentialList(projectId: string, locationId: string, journalId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<JournalCredential>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.insightProjectJournalCredentialList(projectId, locationId, journalId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update insight/journal.credential
         * @summary Update insight/journal.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {string} credentialId credentialId
         * @param {InsightProjectJournalCredentialPatch} insightProjectJournalCredentialPatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async insightProjectJournalCredentialPatch(projectId: string, locationId: string, journalId: string, credentialId: string, insightProjectJournalCredentialPatch: InsightProjectJournalCredentialPatch, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JournalCredential>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.insightProjectJournalCredentialPatch(projectId, locationId, journalId, credentialId, insightProjectJournalCredentialPatch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete journal
         * @summary Delete insight/journal
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async insightProjectJournalDelete(projectId: string, locationId: string, journalId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.insightProjectJournalDelete(projectId, locationId, journalId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get insight/journal.event
         * @summary Get insight/journal.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async insightProjectJournalEventGet(projectId: string, locationId: string, journalId: string, eventId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.insightProjectJournalEventGet(projectId, locationId, journalId, eventId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List insight/journal.event
         * @summary List insight/journal.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async insightProjectJournalEventList(projectId: string, locationId: string, journalId: string, $limit?: number, $skip?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Event>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.insightProjectJournalEventList(projectId, locationId, journalId, $limit, $skip, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a single journal
         * @summary Get insight/journal
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async insightProjectJournalGet(projectId: string, locationId: string, journalId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Journal>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.insightProjectJournalGet(projectId, locationId, journalId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List journal
         * @summary List insight/journal
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [name] Filter by name
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async insightProjectJournalList(projectId: string, locationId: string, name?: string, tagValue?: string, tagKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Journal>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.insightProjectJournalList(projectId, locationId, name, tagValue, tagKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * websocket is also supported
         * @summary Get insight/journal.log
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {string} [since] since
         * @param {string} [until] until
         * @param {boolean} [follow] follow
         * @param {number} [tail] tail
         * @param {Array<Tag>} [tag] tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async insightProjectJournalLogGet(projectId: string, locationId: string, journalId: string, since?: string, until?: string, follow?: boolean, tail?: number, tag?: Array<Tag>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.insightProjectJournalLogGet(projectId, locationId, journalId, since, until, follow, tail, tag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get insight/journal.service
         * @summary Get insight/journal.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async insightProjectJournalServiceGet(projectId: string, locationId: string, journalId: string, serviceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceService>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.insightProjectJournalServiceGet(projectId, locationId, journalId, serviceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List insight/journal.service
         * @summary List insight/journal.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async insightProjectJournalServiceList(projectId: string, locationId: string, journalId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResourceService>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.insightProjectJournalServiceList(projectId, locationId, journalId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create insight/journal.tag
         * @summary Create insight/journal.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async insightProjectJournalTagCreate(projectId: string, locationId: string, journalId: string, tag: Tag, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.insightProjectJournalTagCreate(projectId, locationId, journalId, tag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete insight/journal.tag
         * @summary Delete insight/journal.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async insightProjectJournalTagDelete(projectId: string, locationId: string, journalId: string, tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.insightProjectJournalTagDelete(projectId, locationId, journalId, tagId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get insight/journal.tag
         * @summary Get insight/journal.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async insightProjectJournalTagGet(projectId: string, locationId: string, journalId: string, tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.insightProjectJournalTagGet(projectId, locationId, journalId, tagId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List insight/journal.tag
         * @summary List insight/journal.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async insightProjectJournalTagList(projectId: string, locationId: string, journalId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.insightProjectJournalTagList(projectId, locationId, journalId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Replace insight/journal.tag
         * @summary Replace insight/journal.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async insightProjectJournalTagPut(projectId: string, locationId: string, journalId: string, tag: Array<Tag>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.insightProjectJournalTagPut(projectId, locationId, journalId, tag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * action transfer
         * @summary Transfer insight/journal
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {InsightProjectJournalTransfer} insightProjectJournalTransfer 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async insightProjectJournalTransfer(projectId: string, locationId: string, journalId: string, insightProjectJournalTransfer: InsightProjectJournalTransfer, xIdempotencyKey?: string, xDryRun?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Journal>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.insightProjectJournalTransfer(projectId, locationId, journalId, insightProjectJournalTransfer, xIdempotencyKey, xDryRun, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns modified journal
         * @summary Update insight/journal
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {InsightProjectJournalUpdate} insightProjectJournalUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async insightProjectJournalUpdate(projectId: string, locationId: string, journalId: string, insightProjectJournalUpdate: InsightProjectJournalUpdate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Journal>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.insightProjectJournalUpdate(projectId, locationId, journalId, insightProjectJournalUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * InsightProjectJournalApi - factory interface
 * @export
 */
export const InsightProjectJournalApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = InsightProjectJournalApiFp(configuration)
    return {
        /**
         * Create journal
         * @summary Create insight/journal
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {InsightProjectJournalCreate} insightProjectJournalCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightProjectJournalCreate(projectId: string, locationId: string, insightProjectJournalCreate: InsightProjectJournalCreate, xIdempotencyKey?: string, xDryRun?: string, options?: any): AxiosPromise<Journal> {
            return localVarFp.insightProjectJournalCreate(projectId, locationId, insightProjectJournalCreate, xIdempotencyKey, xDryRun, options).then((request) => request(axios, basePath));
        },
        /**
         * Create insight/journal.credential
         * @summary Create insight/journal.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {JournalCredential} journalCredential 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightProjectJournalCredentialCreate(projectId: string, locationId: string, journalId: string, journalCredential: JournalCredential, options?: any): AxiosPromise<JournalCredential> {
            return localVarFp.insightProjectJournalCredentialCreate(projectId, locationId, journalId, journalCredential, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete insight/journal.credential
         * @summary Delete insight/journal.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {string} credentialId credentialId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightProjectJournalCredentialDelete(projectId: string, locationId: string, journalId: string, credentialId: string, options?: any): AxiosPromise<Journal> {
            return localVarFp.insightProjectJournalCredentialDelete(projectId, locationId, journalId, credentialId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get insight/journal.credential
         * @summary Get insight/journal.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {string} credentialId credentialId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightProjectJournalCredentialGet(projectId: string, locationId: string, journalId: string, credentialId: string, options?: any): AxiosPromise<JournalCredential> {
            return localVarFp.insightProjectJournalCredentialGet(projectId, locationId, journalId, credentialId, options).then((request) => request(axios, basePath));
        },
        /**
         * List insight/journal.credential
         * @summary List insight/journal.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightProjectJournalCredentialList(projectId: string, locationId: string, journalId: string, options?: any): AxiosPromise<Array<JournalCredential>> {
            return localVarFp.insightProjectJournalCredentialList(projectId, locationId, journalId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update insight/journal.credential
         * @summary Update insight/journal.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {string} credentialId credentialId
         * @param {InsightProjectJournalCredentialPatch} insightProjectJournalCredentialPatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightProjectJournalCredentialPatch(projectId: string, locationId: string, journalId: string, credentialId: string, insightProjectJournalCredentialPatch: InsightProjectJournalCredentialPatch, options?: any): AxiosPromise<JournalCredential> {
            return localVarFp.insightProjectJournalCredentialPatch(projectId, locationId, journalId, credentialId, insightProjectJournalCredentialPatch, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete journal
         * @summary Delete insight/journal
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightProjectJournalDelete(projectId: string, locationId: string, journalId: string, options?: any): AxiosPromise<void> {
            return localVarFp.insightProjectJournalDelete(projectId, locationId, journalId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get insight/journal.event
         * @summary Get insight/journal.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightProjectJournalEventGet(projectId: string, locationId: string, journalId: string, eventId: string, options?: any): AxiosPromise<Event> {
            return localVarFp.insightProjectJournalEventGet(projectId, locationId, journalId, eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * List insight/journal.event
         * @summary List insight/journal.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightProjectJournalEventList(projectId: string, locationId: string, journalId: string, $limit?: number, $skip?: number, options?: any): AxiosPromise<Array<Event>> {
            return localVarFp.insightProjectJournalEventList(projectId, locationId, journalId, $limit, $skip, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single journal
         * @summary Get insight/journal
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightProjectJournalGet(projectId: string, locationId: string, journalId: string, options?: any): AxiosPromise<Journal> {
            return localVarFp.insightProjectJournalGet(projectId, locationId, journalId, options).then((request) => request(axios, basePath));
        },
        /**
         * List journal
         * @summary List insight/journal
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [name] Filter by name
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightProjectJournalList(projectId: string, locationId: string, name?: string, tagValue?: string, tagKey?: string, options?: any): AxiosPromise<Array<Journal>> {
            return localVarFp.insightProjectJournalList(projectId, locationId, name, tagValue, tagKey, options).then((request) => request(axios, basePath));
        },
        /**
         * websocket is also supported
         * @summary Get insight/journal.log
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {string} [since] since
         * @param {string} [until] until
         * @param {boolean} [follow] follow
         * @param {number} [tail] tail
         * @param {Array<Tag>} [tag] tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightProjectJournalLogGet(projectId: string, locationId: string, journalId: string, since?: string, until?: string, follow?: boolean, tail?: number, tag?: Array<Tag>, options?: any): AxiosPromise<void> {
            return localVarFp.insightProjectJournalLogGet(projectId, locationId, journalId, since, until, follow, tail, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * Get insight/journal.service
         * @summary Get insight/journal.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightProjectJournalServiceGet(projectId: string, locationId: string, journalId: string, serviceId: string, options?: any): AxiosPromise<ResourceService> {
            return localVarFp.insightProjectJournalServiceGet(projectId, locationId, journalId, serviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * List insight/journal.service
         * @summary List insight/journal.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightProjectJournalServiceList(projectId: string, locationId: string, journalId: string, options?: any): AxiosPromise<Array<ResourceService>> {
            return localVarFp.insightProjectJournalServiceList(projectId, locationId, journalId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create insight/journal.tag
         * @summary Create insight/journal.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightProjectJournalTagCreate(projectId: string, locationId: string, journalId: string, tag: Tag, options?: any): AxiosPromise<Tag> {
            return localVarFp.insightProjectJournalTagCreate(projectId, locationId, journalId, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete insight/journal.tag
         * @summary Delete insight/journal.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightProjectJournalTagDelete(projectId: string, locationId: string, journalId: string, tagId: string, options?: any): AxiosPromise<void> {
            return localVarFp.insightProjectJournalTagDelete(projectId, locationId, journalId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get insight/journal.tag
         * @summary Get insight/journal.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightProjectJournalTagGet(projectId: string, locationId: string, journalId: string, tagId: string, options?: any): AxiosPromise<Tag> {
            return localVarFp.insightProjectJournalTagGet(projectId, locationId, journalId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * List insight/journal.tag
         * @summary List insight/journal.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightProjectJournalTagList(projectId: string, locationId: string, journalId: string, options?: any): AxiosPromise<Array<Tag>> {
            return localVarFp.insightProjectJournalTagList(projectId, locationId, journalId, options).then((request) => request(axios, basePath));
        },
        /**
         * Replace insight/journal.tag
         * @summary Replace insight/journal.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightProjectJournalTagPut(projectId: string, locationId: string, journalId: string, tag: Array<Tag>, options?: any): AxiosPromise<Array<Tag>> {
            return localVarFp.insightProjectJournalTagPut(projectId, locationId, journalId, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * action transfer
         * @summary Transfer insight/journal
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {InsightProjectJournalTransfer} insightProjectJournalTransfer 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightProjectJournalTransfer(projectId: string, locationId: string, journalId: string, insightProjectJournalTransfer: InsightProjectJournalTransfer, xIdempotencyKey?: string, xDryRun?: string, options?: any): AxiosPromise<Journal> {
            return localVarFp.insightProjectJournalTransfer(projectId, locationId, journalId, insightProjectJournalTransfer, xIdempotencyKey, xDryRun, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns modified journal
         * @summary Update insight/journal
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} journalId Journal Id
         * @param {InsightProjectJournalUpdate} insightProjectJournalUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        insightProjectJournalUpdate(projectId: string, locationId: string, journalId: string, insightProjectJournalUpdate: InsightProjectJournalUpdate, options?: any): AxiosPromise<Journal> {
            return localVarFp.insightProjectJournalUpdate(projectId, locationId, journalId, insightProjectJournalUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * InsightProjectJournalApi - object-oriented interface
 * @export
 * @class InsightProjectJournalApi
 * @extends {BaseAPI}
 */
export class InsightProjectJournalApi extends BaseAPI {
    /**
     * Create journal
     * @summary Create insight/journal
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {InsightProjectJournalCreate} insightProjectJournalCreate 
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {string} [xDryRun] Dry run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightProjectJournalApi
     */
    public insightProjectJournalCreate(projectId: string, locationId: string, insightProjectJournalCreate: InsightProjectJournalCreate, xIdempotencyKey?: string, xDryRun?: string, options?: any) {
        return InsightProjectJournalApiFp(this.configuration).insightProjectJournalCreate(projectId, locationId, insightProjectJournalCreate, xIdempotencyKey, xDryRun, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create insight/journal.credential
     * @summary Create insight/journal.credential
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} journalId Journal Id
     * @param {JournalCredential} journalCredential 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightProjectJournalApi
     */
    public insightProjectJournalCredentialCreate(projectId: string, locationId: string, journalId: string, journalCredential: JournalCredential, options?: any) {
        return InsightProjectJournalApiFp(this.configuration).insightProjectJournalCredentialCreate(projectId, locationId, journalId, journalCredential, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete insight/journal.credential
     * @summary Delete insight/journal.credential
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} journalId Journal Id
     * @param {string} credentialId credentialId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightProjectJournalApi
     */
    public insightProjectJournalCredentialDelete(projectId: string, locationId: string, journalId: string, credentialId: string, options?: any) {
        return InsightProjectJournalApiFp(this.configuration).insightProjectJournalCredentialDelete(projectId, locationId, journalId, credentialId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get insight/journal.credential
     * @summary Get insight/journal.credential
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} journalId Journal Id
     * @param {string} credentialId credentialId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightProjectJournalApi
     */
    public insightProjectJournalCredentialGet(projectId: string, locationId: string, journalId: string, credentialId: string, options?: any) {
        return InsightProjectJournalApiFp(this.configuration).insightProjectJournalCredentialGet(projectId, locationId, journalId, credentialId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List insight/journal.credential
     * @summary List insight/journal.credential
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} journalId Journal Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightProjectJournalApi
     */
    public insightProjectJournalCredentialList(projectId: string, locationId: string, journalId: string, options?: any) {
        return InsightProjectJournalApiFp(this.configuration).insightProjectJournalCredentialList(projectId, locationId, journalId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update insight/journal.credential
     * @summary Update insight/journal.credential
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} journalId Journal Id
     * @param {string} credentialId credentialId
     * @param {InsightProjectJournalCredentialPatch} insightProjectJournalCredentialPatch 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightProjectJournalApi
     */
    public insightProjectJournalCredentialPatch(projectId: string, locationId: string, journalId: string, credentialId: string, insightProjectJournalCredentialPatch: InsightProjectJournalCredentialPatch, options?: any) {
        return InsightProjectJournalApiFp(this.configuration).insightProjectJournalCredentialPatch(projectId, locationId, journalId, credentialId, insightProjectJournalCredentialPatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete journal
     * @summary Delete insight/journal
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} journalId Journal Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightProjectJournalApi
     */
    public insightProjectJournalDelete(projectId: string, locationId: string, journalId: string, options?: any) {
        return InsightProjectJournalApiFp(this.configuration).insightProjectJournalDelete(projectId, locationId, journalId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get insight/journal.event
     * @summary Get insight/journal.event
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} journalId Journal Id
     * @param {string} eventId eventId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightProjectJournalApi
     */
    public insightProjectJournalEventGet(projectId: string, locationId: string, journalId: string, eventId: string, options?: any) {
        return InsightProjectJournalApiFp(this.configuration).insightProjectJournalEventGet(projectId, locationId, journalId, eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List insight/journal.event
     * @summary List insight/journal.event
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} journalId Journal Id
     * @param {number} [$limit] $limit
     * @param {number} [$skip] $skip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightProjectJournalApi
     */
    public insightProjectJournalEventList(projectId: string, locationId: string, journalId: string, $limit?: number, $skip?: number, options?: any) {
        return InsightProjectJournalApiFp(this.configuration).insightProjectJournalEventList(projectId, locationId, journalId, $limit, $skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single journal
     * @summary Get insight/journal
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} journalId Journal Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightProjectJournalApi
     */
    public insightProjectJournalGet(projectId: string, locationId: string, journalId: string, options?: any) {
        return InsightProjectJournalApiFp(this.configuration).insightProjectJournalGet(projectId, locationId, journalId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List journal
     * @summary List insight/journal
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} [name] Filter by name
     * @param {string} [tagValue] Filter by tag.value
     * @param {string} [tagKey] Filter by tag.key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightProjectJournalApi
     */
    public insightProjectJournalList(projectId: string, locationId: string, name?: string, tagValue?: string, tagKey?: string, options?: any) {
        return InsightProjectJournalApiFp(this.configuration).insightProjectJournalList(projectId, locationId, name, tagValue, tagKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * websocket is also supported
     * @summary Get insight/journal.log
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} journalId Journal Id
     * @param {string} [since] since
     * @param {string} [until] until
     * @param {boolean} [follow] follow
     * @param {number} [tail] tail
     * @param {Array<Tag>} [tag] tag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightProjectJournalApi
     */
    public insightProjectJournalLogGet(projectId: string, locationId: string, journalId: string, since?: string, until?: string, follow?: boolean, tail?: number, tag?: Array<Tag>, options?: any) {
        return InsightProjectJournalApiFp(this.configuration).insightProjectJournalLogGet(projectId, locationId, journalId, since, until, follow, tail, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get insight/journal.service
     * @summary Get insight/journal.service
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} journalId Journal Id
     * @param {string} serviceId serviceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightProjectJournalApi
     */
    public insightProjectJournalServiceGet(projectId: string, locationId: string, journalId: string, serviceId: string, options?: any) {
        return InsightProjectJournalApiFp(this.configuration).insightProjectJournalServiceGet(projectId, locationId, journalId, serviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List insight/journal.service
     * @summary List insight/journal.service
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} journalId Journal Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightProjectJournalApi
     */
    public insightProjectJournalServiceList(projectId: string, locationId: string, journalId: string, options?: any) {
        return InsightProjectJournalApiFp(this.configuration).insightProjectJournalServiceList(projectId, locationId, journalId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create insight/journal.tag
     * @summary Create insight/journal.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} journalId Journal Id
     * @param {Tag} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightProjectJournalApi
     */
    public insightProjectJournalTagCreate(projectId: string, locationId: string, journalId: string, tag: Tag, options?: any) {
        return InsightProjectJournalApiFp(this.configuration).insightProjectJournalTagCreate(projectId, locationId, journalId, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete insight/journal.tag
     * @summary Delete insight/journal.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} journalId Journal Id
     * @param {string} tagId tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightProjectJournalApi
     */
    public insightProjectJournalTagDelete(projectId: string, locationId: string, journalId: string, tagId: string, options?: any) {
        return InsightProjectJournalApiFp(this.configuration).insightProjectJournalTagDelete(projectId, locationId, journalId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get insight/journal.tag
     * @summary Get insight/journal.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} journalId Journal Id
     * @param {string} tagId tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightProjectJournalApi
     */
    public insightProjectJournalTagGet(projectId: string, locationId: string, journalId: string, tagId: string, options?: any) {
        return InsightProjectJournalApiFp(this.configuration).insightProjectJournalTagGet(projectId, locationId, journalId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List insight/journal.tag
     * @summary List insight/journal.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} journalId Journal Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightProjectJournalApi
     */
    public insightProjectJournalTagList(projectId: string, locationId: string, journalId: string, options?: any) {
        return InsightProjectJournalApiFp(this.configuration).insightProjectJournalTagList(projectId, locationId, journalId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replace insight/journal.tag
     * @summary Replace insight/journal.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} journalId Journal Id
     * @param {Array<Tag>} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightProjectJournalApi
     */
    public insightProjectJournalTagPut(projectId: string, locationId: string, journalId: string, tag: Array<Tag>, options?: any) {
        return InsightProjectJournalApiFp(this.configuration).insightProjectJournalTagPut(projectId, locationId, journalId, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * action transfer
     * @summary Transfer insight/journal
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} journalId Journal Id
     * @param {InsightProjectJournalTransfer} insightProjectJournalTransfer 
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {string} [xDryRun] Dry run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightProjectJournalApi
     */
    public insightProjectJournalTransfer(projectId: string, locationId: string, journalId: string, insightProjectJournalTransfer: InsightProjectJournalTransfer, xIdempotencyKey?: string, xDryRun?: string, options?: any) {
        return InsightProjectJournalApiFp(this.configuration).insightProjectJournalTransfer(projectId, locationId, journalId, insightProjectJournalTransfer, xIdempotencyKey, xDryRun, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns modified journal
     * @summary Update insight/journal
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} journalId Journal Id
     * @param {InsightProjectJournalUpdate} insightProjectJournalUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InsightProjectJournalApi
     */
    public insightProjectJournalUpdate(projectId: string, locationId: string, journalId: string, insightProjectJournalUpdate: InsightProjectJournalUpdate, options?: any) {
        return InsightProjectJournalApiFp(this.configuration).insightProjectJournalUpdate(projectId, locationId, journalId, insightProjectJournalUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * NetworkingProjectFirewallApi - axios parameter creator
 * @export
 */
export const NetworkingProjectFirewallApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create firewall
         * @summary Create networking/firewall
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {NetworkingProjectFirewallCreate} networkingProjectFirewallCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectFirewallCreate: async (projectId: string, locationId: string, networkingProjectFirewallCreate: NetworkingProjectFirewallCreate, xIdempotencyKey?: string, xDryRun?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('networkingProjectFirewallCreate', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('networkingProjectFirewallCreate', 'locationId', locationId)
            // verify required parameter 'networkingProjectFirewallCreate' is not null or undefined
            assertParamExists('networkingProjectFirewallCreate', 'networkingProjectFirewallCreate', networkingProjectFirewallCreate)
            const localVarPath = `/networking/{locationId}/project/{projectId}/firewall`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }

            if (xDryRun !== undefined && xDryRun !== null) {
                localVarHeaderParameter['x-dry-run'] = String(xDryRun);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(networkingProjectFirewallCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete firewall
         * @summary Delete networking/firewall
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectFirewallDelete: async (projectId: string, locationId: string, firewallId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('networkingProjectFirewallDelete', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('networkingProjectFirewallDelete', 'locationId', locationId)
            // verify required parameter 'firewallId' is not null or undefined
            assertParamExists('networkingProjectFirewallDelete', 'firewallId', firewallId)
            const localVarPath = `/networking/{locationId}/project/{projectId}/firewall/{firewallId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"firewallId"}}`, encodeURIComponent(String(firewallId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create networking/firewall.egress
         * @summary Create networking/firewall.egress
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {NetworkingRule} networkingRule 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectFirewallEgressCreate: async (projectId: string, locationId: string, firewallId: string, networkingRule: NetworkingRule, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('networkingProjectFirewallEgressCreate', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('networkingProjectFirewallEgressCreate', 'locationId', locationId)
            // verify required parameter 'firewallId' is not null or undefined
            assertParamExists('networkingProjectFirewallEgressCreate', 'firewallId', firewallId)
            // verify required parameter 'networkingRule' is not null or undefined
            assertParamExists('networkingProjectFirewallEgressCreate', 'networkingRule', networkingRule)
            const localVarPath = `/networking/{locationId}/project/{projectId}/firewall/{firewallId}/egress`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"firewallId"}}`, encodeURIComponent(String(firewallId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(networkingRule, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete networking/firewall.egress
         * @summary Delete networking/firewall.egress
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {string} egressId egressId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectFirewallEgressDelete: async (projectId: string, locationId: string, firewallId: string, egressId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('networkingProjectFirewallEgressDelete', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('networkingProjectFirewallEgressDelete', 'locationId', locationId)
            // verify required parameter 'firewallId' is not null or undefined
            assertParamExists('networkingProjectFirewallEgressDelete', 'firewallId', firewallId)
            // verify required parameter 'egressId' is not null or undefined
            assertParamExists('networkingProjectFirewallEgressDelete', 'egressId', egressId)
            const localVarPath = `/networking/{locationId}/project/{projectId}/firewall/{firewallId}/egress/{egressId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"firewallId"}}`, encodeURIComponent(String(firewallId)))
                .replace(`{${"egressId"}}`, encodeURIComponent(String(egressId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get networking/firewall.egress
         * @summary Get networking/firewall.egress
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {string} egressId egressId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectFirewallEgressGet: async (projectId: string, locationId: string, firewallId: string, egressId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('networkingProjectFirewallEgressGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('networkingProjectFirewallEgressGet', 'locationId', locationId)
            // verify required parameter 'firewallId' is not null or undefined
            assertParamExists('networkingProjectFirewallEgressGet', 'firewallId', firewallId)
            // verify required parameter 'egressId' is not null or undefined
            assertParamExists('networkingProjectFirewallEgressGet', 'egressId', egressId)
            const localVarPath = `/networking/{locationId}/project/{projectId}/firewall/{firewallId}/egress/{egressId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"firewallId"}}`, encodeURIComponent(String(firewallId)))
                .replace(`{${"egressId"}}`, encodeURIComponent(String(egressId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List networking/firewall.egress
         * @summary List networking/firewall.egress
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectFirewallEgressList: async (projectId: string, locationId: string, firewallId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('networkingProjectFirewallEgressList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('networkingProjectFirewallEgressList', 'locationId', locationId)
            // verify required parameter 'firewallId' is not null or undefined
            assertParamExists('networkingProjectFirewallEgressList', 'firewallId', firewallId)
            const localVarPath = `/networking/{locationId}/project/{projectId}/firewall/{firewallId}/egress`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"firewallId"}}`, encodeURIComponent(String(firewallId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replace networking/firewall.egress
         * @summary Replace networking/firewall.egress
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {Array<NetworkingRule>} networkingRule 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectFirewallEgressPut: async (projectId: string, locationId: string, firewallId: string, networkingRule: Array<NetworkingRule>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('networkingProjectFirewallEgressPut', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('networkingProjectFirewallEgressPut', 'locationId', locationId)
            // verify required parameter 'firewallId' is not null or undefined
            assertParamExists('networkingProjectFirewallEgressPut', 'firewallId', firewallId)
            // verify required parameter 'networkingRule' is not null or undefined
            assertParamExists('networkingProjectFirewallEgressPut', 'networkingRule', networkingRule)
            const localVarPath = `/networking/{locationId}/project/{projectId}/firewall/{firewallId}/egress`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"firewallId"}}`, encodeURIComponent(String(firewallId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(networkingRule, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get networking/firewall.event
         * @summary Get networking/firewall.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectFirewallEventGet: async (projectId: string, locationId: string, firewallId: string, eventId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('networkingProjectFirewallEventGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('networkingProjectFirewallEventGet', 'locationId', locationId)
            // verify required parameter 'firewallId' is not null or undefined
            assertParamExists('networkingProjectFirewallEventGet', 'firewallId', firewallId)
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('networkingProjectFirewallEventGet', 'eventId', eventId)
            const localVarPath = `/networking/{locationId}/project/{projectId}/firewall/{firewallId}/event/{eventId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"firewallId"}}`, encodeURIComponent(String(firewallId)))
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List networking/firewall.event
         * @summary List networking/firewall.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectFirewallEventList: async (projectId: string, locationId: string, firewallId: string, $limit?: number, $skip?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('networkingProjectFirewallEventList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('networkingProjectFirewallEventList', 'locationId', locationId)
            // verify required parameter 'firewallId' is not null or undefined
            assertParamExists('networkingProjectFirewallEventList', 'firewallId', firewallId)
            const localVarPath = `/networking/{locationId}/project/{projectId}/firewall/{firewallId}/event`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"firewallId"}}`, encodeURIComponent(String(firewallId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if ($limit !== undefined) {
                localVarQueryParameter['$limit'] = $limit;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single firewall
         * @summary Get networking/firewall
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectFirewallGet: async (projectId: string, locationId: string, firewallId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('networkingProjectFirewallGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('networkingProjectFirewallGet', 'locationId', locationId)
            // verify required parameter 'firewallId' is not null or undefined
            assertParamExists('networkingProjectFirewallGet', 'firewallId', firewallId)
            const localVarPath = `/networking/{locationId}/project/{projectId}/firewall/{firewallId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"firewallId"}}`, encodeURIComponent(String(firewallId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create networking/firewall.ingress
         * @summary Create networking/firewall.ingress
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {NetworkingRule} networkingRule 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectFirewallIngressCreate: async (projectId: string, locationId: string, firewallId: string, networkingRule: NetworkingRule, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('networkingProjectFirewallIngressCreate', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('networkingProjectFirewallIngressCreate', 'locationId', locationId)
            // verify required parameter 'firewallId' is not null or undefined
            assertParamExists('networkingProjectFirewallIngressCreate', 'firewallId', firewallId)
            // verify required parameter 'networkingRule' is not null or undefined
            assertParamExists('networkingProjectFirewallIngressCreate', 'networkingRule', networkingRule)
            const localVarPath = `/networking/{locationId}/project/{projectId}/firewall/{firewallId}/ingress`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"firewallId"}}`, encodeURIComponent(String(firewallId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(networkingRule, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete networking/firewall.ingress
         * @summary Delete networking/firewall.ingress
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {string} ingressId ingressId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectFirewallIngressDelete: async (projectId: string, locationId: string, firewallId: string, ingressId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('networkingProjectFirewallIngressDelete', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('networkingProjectFirewallIngressDelete', 'locationId', locationId)
            // verify required parameter 'firewallId' is not null or undefined
            assertParamExists('networkingProjectFirewallIngressDelete', 'firewallId', firewallId)
            // verify required parameter 'ingressId' is not null or undefined
            assertParamExists('networkingProjectFirewallIngressDelete', 'ingressId', ingressId)
            const localVarPath = `/networking/{locationId}/project/{projectId}/firewall/{firewallId}/ingress/{ingressId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"firewallId"}}`, encodeURIComponent(String(firewallId)))
                .replace(`{${"ingressId"}}`, encodeURIComponent(String(ingressId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get networking/firewall.ingress
         * @summary Get networking/firewall.ingress
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {string} ingressId ingressId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectFirewallIngressGet: async (projectId: string, locationId: string, firewallId: string, ingressId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('networkingProjectFirewallIngressGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('networkingProjectFirewallIngressGet', 'locationId', locationId)
            // verify required parameter 'firewallId' is not null or undefined
            assertParamExists('networkingProjectFirewallIngressGet', 'firewallId', firewallId)
            // verify required parameter 'ingressId' is not null or undefined
            assertParamExists('networkingProjectFirewallIngressGet', 'ingressId', ingressId)
            const localVarPath = `/networking/{locationId}/project/{projectId}/firewall/{firewallId}/ingress/{ingressId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"firewallId"}}`, encodeURIComponent(String(firewallId)))
                .replace(`{${"ingressId"}}`, encodeURIComponent(String(ingressId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List networking/firewall.ingress
         * @summary List networking/firewall.ingress
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectFirewallIngressList: async (projectId: string, locationId: string, firewallId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('networkingProjectFirewallIngressList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('networkingProjectFirewallIngressList', 'locationId', locationId)
            // verify required parameter 'firewallId' is not null or undefined
            assertParamExists('networkingProjectFirewallIngressList', 'firewallId', firewallId)
            const localVarPath = `/networking/{locationId}/project/{projectId}/firewall/{firewallId}/ingress`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"firewallId"}}`, encodeURIComponent(String(firewallId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replace networking/firewall.ingress
         * @summary Replace networking/firewall.ingress
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {Array<NetworkingRule>} networkingRule 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectFirewallIngressPut: async (projectId: string, locationId: string, firewallId: string, networkingRule: Array<NetworkingRule>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('networkingProjectFirewallIngressPut', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('networkingProjectFirewallIngressPut', 'locationId', locationId)
            // verify required parameter 'firewallId' is not null or undefined
            assertParamExists('networkingProjectFirewallIngressPut', 'firewallId', firewallId)
            // verify required parameter 'networkingRule' is not null or undefined
            assertParamExists('networkingProjectFirewallIngressPut', 'networkingRule', networkingRule)
            const localVarPath = `/networking/{locationId}/project/{projectId}/firewall/{firewallId}/ingress`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"firewallId"}}`, encodeURIComponent(String(firewallId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(networkingRule, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List firewall
         * @summary List networking/firewall
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [name] Filter by name
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectFirewallList: async (projectId: string, locationId: string, name?: string, tagValue?: string, tagKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('networkingProjectFirewallList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('networkingProjectFirewallList', 'locationId', locationId)
            const localVarPath = `/networking/{locationId}/project/{projectId}/firewall`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (tagValue !== undefined) {
                localVarQueryParameter['tag.value'] = tagValue;
            }

            if (tagKey !== undefined) {
                localVarQueryParameter['tag.key'] = tagKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get networking/firewall.service
         * @summary Get networking/firewall.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectFirewallServiceGet: async (projectId: string, locationId: string, firewallId: string, serviceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('networkingProjectFirewallServiceGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('networkingProjectFirewallServiceGet', 'locationId', locationId)
            // verify required parameter 'firewallId' is not null or undefined
            assertParamExists('networkingProjectFirewallServiceGet', 'firewallId', firewallId)
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('networkingProjectFirewallServiceGet', 'serviceId', serviceId)
            const localVarPath = `/networking/{locationId}/project/{projectId}/firewall/{firewallId}/service/{serviceId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"firewallId"}}`, encodeURIComponent(String(firewallId)))
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List networking/firewall.service
         * @summary List networking/firewall.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectFirewallServiceList: async (projectId: string, locationId: string, firewallId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('networkingProjectFirewallServiceList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('networkingProjectFirewallServiceList', 'locationId', locationId)
            // verify required parameter 'firewallId' is not null or undefined
            assertParamExists('networkingProjectFirewallServiceList', 'firewallId', firewallId)
            const localVarPath = `/networking/{locationId}/project/{projectId}/firewall/{firewallId}/service`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"firewallId"}}`, encodeURIComponent(String(firewallId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create networking/firewall.tag
         * @summary Create networking/firewall.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectFirewallTagCreate: async (projectId: string, locationId: string, firewallId: string, tag: Tag, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('networkingProjectFirewallTagCreate', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('networkingProjectFirewallTagCreate', 'locationId', locationId)
            // verify required parameter 'firewallId' is not null or undefined
            assertParamExists('networkingProjectFirewallTagCreate', 'firewallId', firewallId)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('networkingProjectFirewallTagCreate', 'tag', tag)
            const localVarPath = `/networking/{locationId}/project/{projectId}/firewall/{firewallId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"firewallId"}}`, encodeURIComponent(String(firewallId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tag, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete networking/firewall.tag
         * @summary Delete networking/firewall.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectFirewallTagDelete: async (projectId: string, locationId: string, firewallId: string, tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('networkingProjectFirewallTagDelete', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('networkingProjectFirewallTagDelete', 'locationId', locationId)
            // verify required parameter 'firewallId' is not null or undefined
            assertParamExists('networkingProjectFirewallTagDelete', 'firewallId', firewallId)
            // verify required parameter 'tagId' is not null or undefined
            assertParamExists('networkingProjectFirewallTagDelete', 'tagId', tagId)
            const localVarPath = `/networking/{locationId}/project/{projectId}/firewall/{firewallId}/tag/{tagId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"firewallId"}}`, encodeURIComponent(String(firewallId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get networking/firewall.tag
         * @summary Get networking/firewall.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectFirewallTagGet: async (projectId: string, locationId: string, firewallId: string, tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('networkingProjectFirewallTagGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('networkingProjectFirewallTagGet', 'locationId', locationId)
            // verify required parameter 'firewallId' is not null or undefined
            assertParamExists('networkingProjectFirewallTagGet', 'firewallId', firewallId)
            // verify required parameter 'tagId' is not null or undefined
            assertParamExists('networkingProjectFirewallTagGet', 'tagId', tagId)
            const localVarPath = `/networking/{locationId}/project/{projectId}/firewall/{firewallId}/tag/{tagId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"firewallId"}}`, encodeURIComponent(String(firewallId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List networking/firewall.tag
         * @summary List networking/firewall.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectFirewallTagList: async (projectId: string, locationId: string, firewallId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('networkingProjectFirewallTagList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('networkingProjectFirewallTagList', 'locationId', locationId)
            // verify required parameter 'firewallId' is not null or undefined
            assertParamExists('networkingProjectFirewallTagList', 'firewallId', firewallId)
            const localVarPath = `/networking/{locationId}/project/{projectId}/firewall/{firewallId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"firewallId"}}`, encodeURIComponent(String(firewallId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replace networking/firewall.tag
         * @summary Replace networking/firewall.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectFirewallTagPut: async (projectId: string, locationId: string, firewallId: string, tag: Array<Tag>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('networkingProjectFirewallTagPut', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('networkingProjectFirewallTagPut', 'locationId', locationId)
            // verify required parameter 'firewallId' is not null or undefined
            assertParamExists('networkingProjectFirewallTagPut', 'firewallId', firewallId)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('networkingProjectFirewallTagPut', 'tag', tag)
            const localVarPath = `/networking/{locationId}/project/{projectId}/firewall/{firewallId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"firewallId"}}`, encodeURIComponent(String(firewallId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tag, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * action transfer
         * @summary Transfer networking/firewall
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {NetworkingProjectFirewallTransfer} networkingProjectFirewallTransfer 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectFirewallTransfer: async (projectId: string, locationId: string, firewallId: string, networkingProjectFirewallTransfer: NetworkingProjectFirewallTransfer, xIdempotencyKey?: string, xDryRun?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('networkingProjectFirewallTransfer', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('networkingProjectFirewallTransfer', 'locationId', locationId)
            // verify required parameter 'firewallId' is not null or undefined
            assertParamExists('networkingProjectFirewallTransfer', 'firewallId', firewallId)
            // verify required parameter 'networkingProjectFirewallTransfer' is not null or undefined
            assertParamExists('networkingProjectFirewallTransfer', 'networkingProjectFirewallTransfer', networkingProjectFirewallTransfer)
            const localVarPath = `/networking/{locationId}/project/{projectId}/firewall/{firewallId}/actions/transfer`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"firewallId"}}`, encodeURIComponent(String(firewallId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }

            if (xDryRun !== undefined && xDryRun !== null) {
                localVarHeaderParameter['x-dry-run'] = String(xDryRun);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(networkingProjectFirewallTransfer, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns modified firewall
         * @summary Update networking/firewall
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {NetworkingProjectFirewallUpdate} networkingProjectFirewallUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectFirewallUpdate: async (projectId: string, locationId: string, firewallId: string, networkingProjectFirewallUpdate: NetworkingProjectFirewallUpdate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('networkingProjectFirewallUpdate', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('networkingProjectFirewallUpdate', 'locationId', locationId)
            // verify required parameter 'firewallId' is not null or undefined
            assertParamExists('networkingProjectFirewallUpdate', 'firewallId', firewallId)
            // verify required parameter 'networkingProjectFirewallUpdate' is not null or undefined
            assertParamExists('networkingProjectFirewallUpdate', 'networkingProjectFirewallUpdate', networkingProjectFirewallUpdate)
            const localVarPath = `/networking/{locationId}/project/{projectId}/firewall/{firewallId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"firewallId"}}`, encodeURIComponent(String(firewallId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(networkingProjectFirewallUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NetworkingProjectFirewallApi - functional programming interface
 * @export
 */
export const NetworkingProjectFirewallApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NetworkingProjectFirewallApiAxiosParamCreator(configuration)
    return {
        /**
         * Create firewall
         * @summary Create networking/firewall
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {NetworkingProjectFirewallCreate} networkingProjectFirewallCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectFirewallCreate(projectId: string, locationId: string, networkingProjectFirewallCreate: NetworkingProjectFirewallCreate, xIdempotencyKey?: string, xDryRun?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Firewall>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkingProjectFirewallCreate(projectId, locationId, networkingProjectFirewallCreate, xIdempotencyKey, xDryRun, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete firewall
         * @summary Delete networking/firewall
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectFirewallDelete(projectId: string, locationId: string, firewallId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkingProjectFirewallDelete(projectId, locationId, firewallId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create networking/firewall.egress
         * @summary Create networking/firewall.egress
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {NetworkingRule} networkingRule 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectFirewallEgressCreate(projectId: string, locationId: string, firewallId: string, networkingRule: NetworkingRule, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NetworkingRule>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkingProjectFirewallEgressCreate(projectId, locationId, firewallId, networkingRule, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete networking/firewall.egress
         * @summary Delete networking/firewall.egress
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {string} egressId egressId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectFirewallEgressDelete(projectId: string, locationId: string, firewallId: string, egressId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkingProjectFirewallEgressDelete(projectId, locationId, firewallId, egressId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get networking/firewall.egress
         * @summary Get networking/firewall.egress
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {string} egressId egressId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectFirewallEgressGet(projectId: string, locationId: string, firewallId: string, egressId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NetworkingRule>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkingProjectFirewallEgressGet(projectId, locationId, firewallId, egressId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List networking/firewall.egress
         * @summary List networking/firewall.egress
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectFirewallEgressList(projectId: string, locationId: string, firewallId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NetworkingRule>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkingProjectFirewallEgressList(projectId, locationId, firewallId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Replace networking/firewall.egress
         * @summary Replace networking/firewall.egress
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {Array<NetworkingRule>} networkingRule 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectFirewallEgressPut(projectId: string, locationId: string, firewallId: string, networkingRule: Array<NetworkingRule>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NetworkingRule>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkingProjectFirewallEgressPut(projectId, locationId, firewallId, networkingRule, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get networking/firewall.event
         * @summary Get networking/firewall.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectFirewallEventGet(projectId: string, locationId: string, firewallId: string, eventId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkingProjectFirewallEventGet(projectId, locationId, firewallId, eventId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List networking/firewall.event
         * @summary List networking/firewall.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectFirewallEventList(projectId: string, locationId: string, firewallId: string, $limit?: number, $skip?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Event>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkingProjectFirewallEventList(projectId, locationId, firewallId, $limit, $skip, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a single firewall
         * @summary Get networking/firewall
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectFirewallGet(projectId: string, locationId: string, firewallId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Firewall>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkingProjectFirewallGet(projectId, locationId, firewallId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create networking/firewall.ingress
         * @summary Create networking/firewall.ingress
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {NetworkingRule} networkingRule 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectFirewallIngressCreate(projectId: string, locationId: string, firewallId: string, networkingRule: NetworkingRule, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NetworkingRule>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkingProjectFirewallIngressCreate(projectId, locationId, firewallId, networkingRule, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete networking/firewall.ingress
         * @summary Delete networking/firewall.ingress
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {string} ingressId ingressId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectFirewallIngressDelete(projectId: string, locationId: string, firewallId: string, ingressId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkingProjectFirewallIngressDelete(projectId, locationId, firewallId, ingressId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get networking/firewall.ingress
         * @summary Get networking/firewall.ingress
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {string} ingressId ingressId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectFirewallIngressGet(projectId: string, locationId: string, firewallId: string, ingressId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NetworkingRule>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkingProjectFirewallIngressGet(projectId, locationId, firewallId, ingressId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List networking/firewall.ingress
         * @summary List networking/firewall.ingress
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectFirewallIngressList(projectId: string, locationId: string, firewallId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NetworkingRule>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkingProjectFirewallIngressList(projectId, locationId, firewallId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Replace networking/firewall.ingress
         * @summary Replace networking/firewall.ingress
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {Array<NetworkingRule>} networkingRule 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectFirewallIngressPut(projectId: string, locationId: string, firewallId: string, networkingRule: Array<NetworkingRule>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NetworkingRule>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkingProjectFirewallIngressPut(projectId, locationId, firewallId, networkingRule, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List firewall
         * @summary List networking/firewall
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [name] Filter by name
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectFirewallList(projectId: string, locationId: string, name?: string, tagValue?: string, tagKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Firewall>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkingProjectFirewallList(projectId, locationId, name, tagValue, tagKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get networking/firewall.service
         * @summary Get networking/firewall.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectFirewallServiceGet(projectId: string, locationId: string, firewallId: string, serviceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceService>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkingProjectFirewallServiceGet(projectId, locationId, firewallId, serviceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List networking/firewall.service
         * @summary List networking/firewall.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectFirewallServiceList(projectId: string, locationId: string, firewallId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResourceService>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkingProjectFirewallServiceList(projectId, locationId, firewallId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create networking/firewall.tag
         * @summary Create networking/firewall.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectFirewallTagCreate(projectId: string, locationId: string, firewallId: string, tag: Tag, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkingProjectFirewallTagCreate(projectId, locationId, firewallId, tag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete networking/firewall.tag
         * @summary Delete networking/firewall.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectFirewallTagDelete(projectId: string, locationId: string, firewallId: string, tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkingProjectFirewallTagDelete(projectId, locationId, firewallId, tagId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get networking/firewall.tag
         * @summary Get networking/firewall.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectFirewallTagGet(projectId: string, locationId: string, firewallId: string, tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkingProjectFirewallTagGet(projectId, locationId, firewallId, tagId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List networking/firewall.tag
         * @summary List networking/firewall.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectFirewallTagList(projectId: string, locationId: string, firewallId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkingProjectFirewallTagList(projectId, locationId, firewallId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Replace networking/firewall.tag
         * @summary Replace networking/firewall.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectFirewallTagPut(projectId: string, locationId: string, firewallId: string, tag: Array<Tag>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkingProjectFirewallTagPut(projectId, locationId, firewallId, tag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * action transfer
         * @summary Transfer networking/firewall
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {NetworkingProjectFirewallTransfer} networkingProjectFirewallTransfer 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectFirewallTransfer(projectId: string, locationId: string, firewallId: string, networkingProjectFirewallTransfer: NetworkingProjectFirewallTransfer, xIdempotencyKey?: string, xDryRun?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Firewall>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkingProjectFirewallTransfer(projectId, locationId, firewallId, networkingProjectFirewallTransfer, xIdempotencyKey, xDryRun, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns modified firewall
         * @summary Update networking/firewall
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {NetworkingProjectFirewallUpdate} networkingProjectFirewallUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectFirewallUpdate(projectId: string, locationId: string, firewallId: string, networkingProjectFirewallUpdate: NetworkingProjectFirewallUpdate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Firewall>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkingProjectFirewallUpdate(projectId, locationId, firewallId, networkingProjectFirewallUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * NetworkingProjectFirewallApi - factory interface
 * @export
 */
export const NetworkingProjectFirewallApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NetworkingProjectFirewallApiFp(configuration)
    return {
        /**
         * Create firewall
         * @summary Create networking/firewall
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {NetworkingProjectFirewallCreate} networkingProjectFirewallCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectFirewallCreate(projectId: string, locationId: string, networkingProjectFirewallCreate: NetworkingProjectFirewallCreate, xIdempotencyKey?: string, xDryRun?: string, options?: any): AxiosPromise<Firewall> {
            return localVarFp.networkingProjectFirewallCreate(projectId, locationId, networkingProjectFirewallCreate, xIdempotencyKey, xDryRun, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete firewall
         * @summary Delete networking/firewall
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectFirewallDelete(projectId: string, locationId: string, firewallId: string, options?: any): AxiosPromise<void> {
            return localVarFp.networkingProjectFirewallDelete(projectId, locationId, firewallId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create networking/firewall.egress
         * @summary Create networking/firewall.egress
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {NetworkingRule} networkingRule 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectFirewallEgressCreate(projectId: string, locationId: string, firewallId: string, networkingRule: NetworkingRule, options?: any): AxiosPromise<NetworkingRule> {
            return localVarFp.networkingProjectFirewallEgressCreate(projectId, locationId, firewallId, networkingRule, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete networking/firewall.egress
         * @summary Delete networking/firewall.egress
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {string} egressId egressId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectFirewallEgressDelete(projectId: string, locationId: string, firewallId: string, egressId: string, options?: any): AxiosPromise<void> {
            return localVarFp.networkingProjectFirewallEgressDelete(projectId, locationId, firewallId, egressId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get networking/firewall.egress
         * @summary Get networking/firewall.egress
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {string} egressId egressId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectFirewallEgressGet(projectId: string, locationId: string, firewallId: string, egressId: string, options?: any): AxiosPromise<NetworkingRule> {
            return localVarFp.networkingProjectFirewallEgressGet(projectId, locationId, firewallId, egressId, options).then((request) => request(axios, basePath));
        },
        /**
         * List networking/firewall.egress
         * @summary List networking/firewall.egress
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectFirewallEgressList(projectId: string, locationId: string, firewallId: string, options?: any): AxiosPromise<Array<NetworkingRule>> {
            return localVarFp.networkingProjectFirewallEgressList(projectId, locationId, firewallId, options).then((request) => request(axios, basePath));
        },
        /**
         * Replace networking/firewall.egress
         * @summary Replace networking/firewall.egress
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {Array<NetworkingRule>} networkingRule 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectFirewallEgressPut(projectId: string, locationId: string, firewallId: string, networkingRule: Array<NetworkingRule>, options?: any): AxiosPromise<Array<NetworkingRule>> {
            return localVarFp.networkingProjectFirewallEgressPut(projectId, locationId, firewallId, networkingRule, options).then((request) => request(axios, basePath));
        },
        /**
         * Get networking/firewall.event
         * @summary Get networking/firewall.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectFirewallEventGet(projectId: string, locationId: string, firewallId: string, eventId: string, options?: any): AxiosPromise<Event> {
            return localVarFp.networkingProjectFirewallEventGet(projectId, locationId, firewallId, eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * List networking/firewall.event
         * @summary List networking/firewall.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectFirewallEventList(projectId: string, locationId: string, firewallId: string, $limit?: number, $skip?: number, options?: any): AxiosPromise<Array<Event>> {
            return localVarFp.networkingProjectFirewallEventList(projectId, locationId, firewallId, $limit, $skip, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single firewall
         * @summary Get networking/firewall
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectFirewallGet(projectId: string, locationId: string, firewallId: string, options?: any): AxiosPromise<Firewall> {
            return localVarFp.networkingProjectFirewallGet(projectId, locationId, firewallId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create networking/firewall.ingress
         * @summary Create networking/firewall.ingress
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {NetworkingRule} networkingRule 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectFirewallIngressCreate(projectId: string, locationId: string, firewallId: string, networkingRule: NetworkingRule, options?: any): AxiosPromise<NetworkingRule> {
            return localVarFp.networkingProjectFirewallIngressCreate(projectId, locationId, firewallId, networkingRule, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete networking/firewall.ingress
         * @summary Delete networking/firewall.ingress
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {string} ingressId ingressId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectFirewallIngressDelete(projectId: string, locationId: string, firewallId: string, ingressId: string, options?: any): AxiosPromise<void> {
            return localVarFp.networkingProjectFirewallIngressDelete(projectId, locationId, firewallId, ingressId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get networking/firewall.ingress
         * @summary Get networking/firewall.ingress
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {string} ingressId ingressId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectFirewallIngressGet(projectId: string, locationId: string, firewallId: string, ingressId: string, options?: any): AxiosPromise<NetworkingRule> {
            return localVarFp.networkingProjectFirewallIngressGet(projectId, locationId, firewallId, ingressId, options).then((request) => request(axios, basePath));
        },
        /**
         * List networking/firewall.ingress
         * @summary List networking/firewall.ingress
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectFirewallIngressList(projectId: string, locationId: string, firewallId: string, options?: any): AxiosPromise<Array<NetworkingRule>> {
            return localVarFp.networkingProjectFirewallIngressList(projectId, locationId, firewallId, options).then((request) => request(axios, basePath));
        },
        /**
         * Replace networking/firewall.ingress
         * @summary Replace networking/firewall.ingress
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {Array<NetworkingRule>} networkingRule 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectFirewallIngressPut(projectId: string, locationId: string, firewallId: string, networkingRule: Array<NetworkingRule>, options?: any): AxiosPromise<Array<NetworkingRule>> {
            return localVarFp.networkingProjectFirewallIngressPut(projectId, locationId, firewallId, networkingRule, options).then((request) => request(axios, basePath));
        },
        /**
         * List firewall
         * @summary List networking/firewall
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [name] Filter by name
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectFirewallList(projectId: string, locationId: string, name?: string, tagValue?: string, tagKey?: string, options?: any): AxiosPromise<Array<Firewall>> {
            return localVarFp.networkingProjectFirewallList(projectId, locationId, name, tagValue, tagKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get networking/firewall.service
         * @summary Get networking/firewall.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectFirewallServiceGet(projectId: string, locationId: string, firewallId: string, serviceId: string, options?: any): AxiosPromise<ResourceService> {
            return localVarFp.networkingProjectFirewallServiceGet(projectId, locationId, firewallId, serviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * List networking/firewall.service
         * @summary List networking/firewall.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectFirewallServiceList(projectId: string, locationId: string, firewallId: string, options?: any): AxiosPromise<Array<ResourceService>> {
            return localVarFp.networkingProjectFirewallServiceList(projectId, locationId, firewallId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create networking/firewall.tag
         * @summary Create networking/firewall.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectFirewallTagCreate(projectId: string, locationId: string, firewallId: string, tag: Tag, options?: any): AxiosPromise<Tag> {
            return localVarFp.networkingProjectFirewallTagCreate(projectId, locationId, firewallId, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete networking/firewall.tag
         * @summary Delete networking/firewall.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectFirewallTagDelete(projectId: string, locationId: string, firewallId: string, tagId: string, options?: any): AxiosPromise<void> {
            return localVarFp.networkingProjectFirewallTagDelete(projectId, locationId, firewallId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get networking/firewall.tag
         * @summary Get networking/firewall.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectFirewallTagGet(projectId: string, locationId: string, firewallId: string, tagId: string, options?: any): AxiosPromise<Tag> {
            return localVarFp.networkingProjectFirewallTagGet(projectId, locationId, firewallId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * List networking/firewall.tag
         * @summary List networking/firewall.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectFirewallTagList(projectId: string, locationId: string, firewallId: string, options?: any): AxiosPromise<Array<Tag>> {
            return localVarFp.networkingProjectFirewallTagList(projectId, locationId, firewallId, options).then((request) => request(axios, basePath));
        },
        /**
         * Replace networking/firewall.tag
         * @summary Replace networking/firewall.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectFirewallTagPut(projectId: string, locationId: string, firewallId: string, tag: Array<Tag>, options?: any): AxiosPromise<Array<Tag>> {
            return localVarFp.networkingProjectFirewallTagPut(projectId, locationId, firewallId, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * action transfer
         * @summary Transfer networking/firewall
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {NetworkingProjectFirewallTransfer} networkingProjectFirewallTransfer 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectFirewallTransfer(projectId: string, locationId: string, firewallId: string, networkingProjectFirewallTransfer: NetworkingProjectFirewallTransfer, xIdempotencyKey?: string, xDryRun?: string, options?: any): AxiosPromise<Firewall> {
            return localVarFp.networkingProjectFirewallTransfer(projectId, locationId, firewallId, networkingProjectFirewallTransfer, xIdempotencyKey, xDryRun, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns modified firewall
         * @summary Update networking/firewall
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} firewallId Firewall Id
         * @param {NetworkingProjectFirewallUpdate} networkingProjectFirewallUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectFirewallUpdate(projectId: string, locationId: string, firewallId: string, networkingProjectFirewallUpdate: NetworkingProjectFirewallUpdate, options?: any): AxiosPromise<Firewall> {
            return localVarFp.networkingProjectFirewallUpdate(projectId, locationId, firewallId, networkingProjectFirewallUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NetworkingProjectFirewallApi - object-oriented interface
 * @export
 * @class NetworkingProjectFirewallApi
 * @extends {BaseAPI}
 */
export class NetworkingProjectFirewallApi extends BaseAPI {
    /**
     * Create firewall
     * @summary Create networking/firewall
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {NetworkingProjectFirewallCreate} networkingProjectFirewallCreate 
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {string} [xDryRun] Dry run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectFirewallApi
     */
    public networkingProjectFirewallCreate(projectId: string, locationId: string, networkingProjectFirewallCreate: NetworkingProjectFirewallCreate, xIdempotencyKey?: string, xDryRun?: string, options?: any) {
        return NetworkingProjectFirewallApiFp(this.configuration).networkingProjectFirewallCreate(projectId, locationId, networkingProjectFirewallCreate, xIdempotencyKey, xDryRun, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete firewall
     * @summary Delete networking/firewall
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} firewallId Firewall Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectFirewallApi
     */
    public networkingProjectFirewallDelete(projectId: string, locationId: string, firewallId: string, options?: any) {
        return NetworkingProjectFirewallApiFp(this.configuration).networkingProjectFirewallDelete(projectId, locationId, firewallId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create networking/firewall.egress
     * @summary Create networking/firewall.egress
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} firewallId Firewall Id
     * @param {NetworkingRule} networkingRule 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectFirewallApi
     */
    public networkingProjectFirewallEgressCreate(projectId: string, locationId: string, firewallId: string, networkingRule: NetworkingRule, options?: any) {
        return NetworkingProjectFirewallApiFp(this.configuration).networkingProjectFirewallEgressCreate(projectId, locationId, firewallId, networkingRule, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete networking/firewall.egress
     * @summary Delete networking/firewall.egress
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} firewallId Firewall Id
     * @param {string} egressId egressId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectFirewallApi
     */
    public networkingProjectFirewallEgressDelete(projectId: string, locationId: string, firewallId: string, egressId: string, options?: any) {
        return NetworkingProjectFirewallApiFp(this.configuration).networkingProjectFirewallEgressDelete(projectId, locationId, firewallId, egressId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get networking/firewall.egress
     * @summary Get networking/firewall.egress
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} firewallId Firewall Id
     * @param {string} egressId egressId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectFirewallApi
     */
    public networkingProjectFirewallEgressGet(projectId: string, locationId: string, firewallId: string, egressId: string, options?: any) {
        return NetworkingProjectFirewallApiFp(this.configuration).networkingProjectFirewallEgressGet(projectId, locationId, firewallId, egressId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List networking/firewall.egress
     * @summary List networking/firewall.egress
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} firewallId Firewall Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectFirewallApi
     */
    public networkingProjectFirewallEgressList(projectId: string, locationId: string, firewallId: string, options?: any) {
        return NetworkingProjectFirewallApiFp(this.configuration).networkingProjectFirewallEgressList(projectId, locationId, firewallId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replace networking/firewall.egress
     * @summary Replace networking/firewall.egress
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} firewallId Firewall Id
     * @param {Array<NetworkingRule>} networkingRule 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectFirewallApi
     */
    public networkingProjectFirewallEgressPut(projectId: string, locationId: string, firewallId: string, networkingRule: Array<NetworkingRule>, options?: any) {
        return NetworkingProjectFirewallApiFp(this.configuration).networkingProjectFirewallEgressPut(projectId, locationId, firewallId, networkingRule, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get networking/firewall.event
     * @summary Get networking/firewall.event
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} firewallId Firewall Id
     * @param {string} eventId eventId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectFirewallApi
     */
    public networkingProjectFirewallEventGet(projectId: string, locationId: string, firewallId: string, eventId: string, options?: any) {
        return NetworkingProjectFirewallApiFp(this.configuration).networkingProjectFirewallEventGet(projectId, locationId, firewallId, eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List networking/firewall.event
     * @summary List networking/firewall.event
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} firewallId Firewall Id
     * @param {number} [$limit] $limit
     * @param {number} [$skip] $skip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectFirewallApi
     */
    public networkingProjectFirewallEventList(projectId: string, locationId: string, firewallId: string, $limit?: number, $skip?: number, options?: any) {
        return NetworkingProjectFirewallApiFp(this.configuration).networkingProjectFirewallEventList(projectId, locationId, firewallId, $limit, $skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single firewall
     * @summary Get networking/firewall
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} firewallId Firewall Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectFirewallApi
     */
    public networkingProjectFirewallGet(projectId: string, locationId: string, firewallId: string, options?: any) {
        return NetworkingProjectFirewallApiFp(this.configuration).networkingProjectFirewallGet(projectId, locationId, firewallId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create networking/firewall.ingress
     * @summary Create networking/firewall.ingress
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} firewallId Firewall Id
     * @param {NetworkingRule} networkingRule 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectFirewallApi
     */
    public networkingProjectFirewallIngressCreate(projectId: string, locationId: string, firewallId: string, networkingRule: NetworkingRule, options?: any) {
        return NetworkingProjectFirewallApiFp(this.configuration).networkingProjectFirewallIngressCreate(projectId, locationId, firewallId, networkingRule, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete networking/firewall.ingress
     * @summary Delete networking/firewall.ingress
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} firewallId Firewall Id
     * @param {string} ingressId ingressId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectFirewallApi
     */
    public networkingProjectFirewallIngressDelete(projectId: string, locationId: string, firewallId: string, ingressId: string, options?: any) {
        return NetworkingProjectFirewallApiFp(this.configuration).networkingProjectFirewallIngressDelete(projectId, locationId, firewallId, ingressId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get networking/firewall.ingress
     * @summary Get networking/firewall.ingress
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} firewallId Firewall Id
     * @param {string} ingressId ingressId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectFirewallApi
     */
    public networkingProjectFirewallIngressGet(projectId: string, locationId: string, firewallId: string, ingressId: string, options?: any) {
        return NetworkingProjectFirewallApiFp(this.configuration).networkingProjectFirewallIngressGet(projectId, locationId, firewallId, ingressId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List networking/firewall.ingress
     * @summary List networking/firewall.ingress
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} firewallId Firewall Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectFirewallApi
     */
    public networkingProjectFirewallIngressList(projectId: string, locationId: string, firewallId: string, options?: any) {
        return NetworkingProjectFirewallApiFp(this.configuration).networkingProjectFirewallIngressList(projectId, locationId, firewallId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replace networking/firewall.ingress
     * @summary Replace networking/firewall.ingress
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} firewallId Firewall Id
     * @param {Array<NetworkingRule>} networkingRule 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectFirewallApi
     */
    public networkingProjectFirewallIngressPut(projectId: string, locationId: string, firewallId: string, networkingRule: Array<NetworkingRule>, options?: any) {
        return NetworkingProjectFirewallApiFp(this.configuration).networkingProjectFirewallIngressPut(projectId, locationId, firewallId, networkingRule, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List firewall
     * @summary List networking/firewall
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} [name] Filter by name
     * @param {string} [tagValue] Filter by tag.value
     * @param {string} [tagKey] Filter by tag.key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectFirewallApi
     */
    public networkingProjectFirewallList(projectId: string, locationId: string, name?: string, tagValue?: string, tagKey?: string, options?: any) {
        return NetworkingProjectFirewallApiFp(this.configuration).networkingProjectFirewallList(projectId, locationId, name, tagValue, tagKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get networking/firewall.service
     * @summary Get networking/firewall.service
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} firewallId Firewall Id
     * @param {string} serviceId serviceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectFirewallApi
     */
    public networkingProjectFirewallServiceGet(projectId: string, locationId: string, firewallId: string, serviceId: string, options?: any) {
        return NetworkingProjectFirewallApiFp(this.configuration).networkingProjectFirewallServiceGet(projectId, locationId, firewallId, serviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List networking/firewall.service
     * @summary List networking/firewall.service
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} firewallId Firewall Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectFirewallApi
     */
    public networkingProjectFirewallServiceList(projectId: string, locationId: string, firewallId: string, options?: any) {
        return NetworkingProjectFirewallApiFp(this.configuration).networkingProjectFirewallServiceList(projectId, locationId, firewallId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create networking/firewall.tag
     * @summary Create networking/firewall.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} firewallId Firewall Id
     * @param {Tag} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectFirewallApi
     */
    public networkingProjectFirewallTagCreate(projectId: string, locationId: string, firewallId: string, tag: Tag, options?: any) {
        return NetworkingProjectFirewallApiFp(this.configuration).networkingProjectFirewallTagCreate(projectId, locationId, firewallId, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete networking/firewall.tag
     * @summary Delete networking/firewall.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} firewallId Firewall Id
     * @param {string} tagId tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectFirewallApi
     */
    public networkingProjectFirewallTagDelete(projectId: string, locationId: string, firewallId: string, tagId: string, options?: any) {
        return NetworkingProjectFirewallApiFp(this.configuration).networkingProjectFirewallTagDelete(projectId, locationId, firewallId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get networking/firewall.tag
     * @summary Get networking/firewall.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} firewallId Firewall Id
     * @param {string} tagId tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectFirewallApi
     */
    public networkingProjectFirewallTagGet(projectId: string, locationId: string, firewallId: string, tagId: string, options?: any) {
        return NetworkingProjectFirewallApiFp(this.configuration).networkingProjectFirewallTagGet(projectId, locationId, firewallId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List networking/firewall.tag
     * @summary List networking/firewall.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} firewallId Firewall Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectFirewallApi
     */
    public networkingProjectFirewallTagList(projectId: string, locationId: string, firewallId: string, options?: any) {
        return NetworkingProjectFirewallApiFp(this.configuration).networkingProjectFirewallTagList(projectId, locationId, firewallId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replace networking/firewall.tag
     * @summary Replace networking/firewall.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} firewallId Firewall Id
     * @param {Array<Tag>} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectFirewallApi
     */
    public networkingProjectFirewallTagPut(projectId: string, locationId: string, firewallId: string, tag: Array<Tag>, options?: any) {
        return NetworkingProjectFirewallApiFp(this.configuration).networkingProjectFirewallTagPut(projectId, locationId, firewallId, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * action transfer
     * @summary Transfer networking/firewall
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} firewallId Firewall Id
     * @param {NetworkingProjectFirewallTransfer} networkingProjectFirewallTransfer 
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {string} [xDryRun] Dry run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectFirewallApi
     */
    public networkingProjectFirewallTransfer(projectId: string, locationId: string, firewallId: string, networkingProjectFirewallTransfer: NetworkingProjectFirewallTransfer, xIdempotencyKey?: string, xDryRun?: string, options?: any) {
        return NetworkingProjectFirewallApiFp(this.configuration).networkingProjectFirewallTransfer(projectId, locationId, firewallId, networkingProjectFirewallTransfer, xIdempotencyKey, xDryRun, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns modified firewall
     * @summary Update networking/firewall
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} firewallId Firewall Id
     * @param {NetworkingProjectFirewallUpdate} networkingProjectFirewallUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectFirewallApi
     */
    public networkingProjectFirewallUpdate(projectId: string, locationId: string, firewallId: string, networkingProjectFirewallUpdate: NetworkingProjectFirewallUpdate, options?: any) {
        return NetworkingProjectFirewallApiFp(this.configuration).networkingProjectFirewallUpdate(projectId, locationId, firewallId, networkingProjectFirewallUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * NetworkingProjectIpApi - axios parameter creator
 * @export
 */
export const NetworkingProjectIpApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * action associate
         * @summary Associate networking/ip
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} ipId Ip Id
         * @param {NetworkingProjectIpAssociate} networkingProjectIpAssociate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectIpAssociate: async (projectId: string, locationId: string, ipId: string, networkingProjectIpAssociate: NetworkingProjectIpAssociate, xIdempotencyKey?: string, xDryRun?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('networkingProjectIpAssociate', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('networkingProjectIpAssociate', 'locationId', locationId)
            // verify required parameter 'ipId' is not null or undefined
            assertParamExists('networkingProjectIpAssociate', 'ipId', ipId)
            // verify required parameter 'networkingProjectIpAssociate' is not null or undefined
            assertParamExists('networkingProjectIpAssociate', 'networkingProjectIpAssociate', networkingProjectIpAssociate)
            const localVarPath = `/networking/{locationId}/project/{projectId}/ip/{ipId}/actions/associate`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"ipId"}}`, encodeURIComponent(String(ipId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }

            if (xDryRun !== undefined && xDryRun !== null) {
                localVarHeaderParameter['x-dry-run'] = String(xDryRun);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(networkingProjectIpAssociate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create ip
         * @summary Create networking/ip
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {NetworkingProjectIpCreate} networkingProjectIpCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectIpCreate: async (projectId: string, locationId: string, networkingProjectIpCreate: NetworkingProjectIpCreate, xIdempotencyKey?: string, xDryRun?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('networkingProjectIpCreate', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('networkingProjectIpCreate', 'locationId', locationId)
            // verify required parameter 'networkingProjectIpCreate' is not null or undefined
            assertParamExists('networkingProjectIpCreate', 'networkingProjectIpCreate', networkingProjectIpCreate)
            const localVarPath = `/networking/{locationId}/project/{projectId}/ip`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }

            if (xDryRun !== undefined && xDryRun !== null) {
                localVarHeaderParameter['x-dry-run'] = String(xDryRun);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(networkingProjectIpCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete ip
         * @summary Delete networking/ip
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} ipId Ip Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectIpDelete: async (projectId: string, locationId: string, ipId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('networkingProjectIpDelete', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('networkingProjectIpDelete', 'locationId', locationId)
            // verify required parameter 'ipId' is not null or undefined
            assertParamExists('networkingProjectIpDelete', 'ipId', ipId)
            const localVarPath = `/networking/{locationId}/project/{projectId}/ip/{ipId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"ipId"}}`, encodeURIComponent(String(ipId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * action disassociate
         * @summary Disassociate networking/ip
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} ipId Ip Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectIpDisassociate: async (projectId: string, locationId: string, ipId: string, xIdempotencyKey?: string, xDryRun?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('networkingProjectIpDisassociate', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('networkingProjectIpDisassociate', 'locationId', locationId)
            // verify required parameter 'ipId' is not null or undefined
            assertParamExists('networkingProjectIpDisassociate', 'ipId', ipId)
            const localVarPath = `/networking/{locationId}/project/{projectId}/ip/{ipId}/actions/disassociate`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"ipId"}}`, encodeURIComponent(String(ipId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }

            if (xDryRun !== undefined && xDryRun !== null) {
                localVarHeaderParameter['x-dry-run'] = String(xDryRun);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get networking/ip.event
         * @summary Get networking/ip.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} ipId Ip Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectIpEventGet: async (projectId: string, locationId: string, ipId: string, eventId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('networkingProjectIpEventGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('networkingProjectIpEventGet', 'locationId', locationId)
            // verify required parameter 'ipId' is not null or undefined
            assertParamExists('networkingProjectIpEventGet', 'ipId', ipId)
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('networkingProjectIpEventGet', 'eventId', eventId)
            const localVarPath = `/networking/{locationId}/project/{projectId}/ip/{ipId}/event/{eventId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"ipId"}}`, encodeURIComponent(String(ipId)))
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List networking/ip.event
         * @summary List networking/ip.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} ipId Ip Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectIpEventList: async (projectId: string, locationId: string, ipId: string, $limit?: number, $skip?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('networkingProjectIpEventList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('networkingProjectIpEventList', 'locationId', locationId)
            // verify required parameter 'ipId' is not null or undefined
            assertParamExists('networkingProjectIpEventList', 'ipId', ipId)
            const localVarPath = `/networking/{locationId}/project/{projectId}/ip/{ipId}/event`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"ipId"}}`, encodeURIComponent(String(ipId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if ($limit !== undefined) {
                localVarQueryParameter['$limit'] = $limit;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single ip
         * @summary Get networking/ip
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} ipId Ip Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectIpGet: async (projectId: string, locationId: string, ipId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('networkingProjectIpGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('networkingProjectIpGet', 'locationId', locationId)
            // verify required parameter 'ipId' is not null or undefined
            assertParamExists('networkingProjectIpGet', 'ipId', ipId)
            const localVarPath = `/networking/{locationId}/project/{projectId}/ip/{ipId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"ipId"}}`, encodeURIComponent(String(ipId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List ip
         * @summary List networking/ip
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [network] Filter by network
         * @param {string} [associatedNetadp] Filter by associated.netadp
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectIpList: async (projectId: string, locationId: string, network?: string, associatedNetadp?: string, tagValue?: string, tagKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('networkingProjectIpList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('networkingProjectIpList', 'locationId', locationId)
            const localVarPath = `/networking/{locationId}/project/{projectId}/ip`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (network !== undefined) {
                localVarQueryParameter['network'] = network;
            }

            if (associatedNetadp !== undefined) {
                localVarQueryParameter['associated.netadp'] = associatedNetadp;
            }

            if (tagValue !== undefined) {
                localVarQueryParameter['tag.value'] = tagValue;
            }

            if (tagKey !== undefined) {
                localVarQueryParameter['tag.key'] = tagKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * action persist
         * @summary Persist networking/ip
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} ipId Ip Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectIpPersist: async (projectId: string, locationId: string, ipId: string, xIdempotencyKey?: string, xDryRun?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('networkingProjectIpPersist', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('networkingProjectIpPersist', 'locationId', locationId)
            // verify required parameter 'ipId' is not null or undefined
            assertParamExists('networkingProjectIpPersist', 'ipId', ipId)
            const localVarPath = `/networking/{locationId}/project/{projectId}/ip/{ipId}/actions/persist`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"ipId"}}`, encodeURIComponent(String(ipId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }

            if (xDryRun !== undefined && xDryRun !== null) {
                localVarHeaderParameter['x-dry-run'] = String(xDryRun);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get networking/ip.service
         * @summary Get networking/ip.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} ipId Ip Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectIpServiceGet: async (projectId: string, locationId: string, ipId: string, serviceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('networkingProjectIpServiceGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('networkingProjectIpServiceGet', 'locationId', locationId)
            // verify required parameter 'ipId' is not null or undefined
            assertParamExists('networkingProjectIpServiceGet', 'ipId', ipId)
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('networkingProjectIpServiceGet', 'serviceId', serviceId)
            const localVarPath = `/networking/{locationId}/project/{projectId}/ip/{ipId}/service/{serviceId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"ipId"}}`, encodeURIComponent(String(ipId)))
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List networking/ip.service
         * @summary List networking/ip.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} ipId Ip Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectIpServiceList: async (projectId: string, locationId: string, ipId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('networkingProjectIpServiceList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('networkingProjectIpServiceList', 'locationId', locationId)
            // verify required parameter 'ipId' is not null or undefined
            assertParamExists('networkingProjectIpServiceList', 'ipId', ipId)
            const localVarPath = `/networking/{locationId}/project/{projectId}/ip/{ipId}/service`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"ipId"}}`, encodeURIComponent(String(ipId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create networking/ip.tag
         * @summary Create networking/ip.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} ipId Ip Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectIpTagCreate: async (projectId: string, locationId: string, ipId: string, tag: Tag, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('networkingProjectIpTagCreate', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('networkingProjectIpTagCreate', 'locationId', locationId)
            // verify required parameter 'ipId' is not null or undefined
            assertParamExists('networkingProjectIpTagCreate', 'ipId', ipId)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('networkingProjectIpTagCreate', 'tag', tag)
            const localVarPath = `/networking/{locationId}/project/{projectId}/ip/{ipId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"ipId"}}`, encodeURIComponent(String(ipId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tag, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete networking/ip.tag
         * @summary Delete networking/ip.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} ipId Ip Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectIpTagDelete: async (projectId: string, locationId: string, ipId: string, tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('networkingProjectIpTagDelete', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('networkingProjectIpTagDelete', 'locationId', locationId)
            // verify required parameter 'ipId' is not null or undefined
            assertParamExists('networkingProjectIpTagDelete', 'ipId', ipId)
            // verify required parameter 'tagId' is not null or undefined
            assertParamExists('networkingProjectIpTagDelete', 'tagId', tagId)
            const localVarPath = `/networking/{locationId}/project/{projectId}/ip/{ipId}/tag/{tagId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"ipId"}}`, encodeURIComponent(String(ipId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get networking/ip.tag
         * @summary Get networking/ip.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} ipId Ip Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectIpTagGet: async (projectId: string, locationId: string, ipId: string, tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('networkingProjectIpTagGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('networkingProjectIpTagGet', 'locationId', locationId)
            // verify required parameter 'ipId' is not null or undefined
            assertParamExists('networkingProjectIpTagGet', 'ipId', ipId)
            // verify required parameter 'tagId' is not null or undefined
            assertParamExists('networkingProjectIpTagGet', 'tagId', tagId)
            const localVarPath = `/networking/{locationId}/project/{projectId}/ip/{ipId}/tag/{tagId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"ipId"}}`, encodeURIComponent(String(ipId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List networking/ip.tag
         * @summary List networking/ip.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} ipId Ip Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectIpTagList: async (projectId: string, locationId: string, ipId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('networkingProjectIpTagList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('networkingProjectIpTagList', 'locationId', locationId)
            // verify required parameter 'ipId' is not null or undefined
            assertParamExists('networkingProjectIpTagList', 'ipId', ipId)
            const localVarPath = `/networking/{locationId}/project/{projectId}/ip/{ipId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"ipId"}}`, encodeURIComponent(String(ipId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replace networking/ip.tag
         * @summary Replace networking/ip.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} ipId Ip Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectIpTagPut: async (projectId: string, locationId: string, ipId: string, tag: Array<Tag>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('networkingProjectIpTagPut', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('networkingProjectIpTagPut', 'locationId', locationId)
            // verify required parameter 'ipId' is not null or undefined
            assertParamExists('networkingProjectIpTagPut', 'ipId', ipId)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('networkingProjectIpTagPut', 'tag', tag)
            const localVarPath = `/networking/{locationId}/project/{projectId}/ip/{ipId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"ipId"}}`, encodeURIComponent(String(ipId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tag, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * action transfer
         * @summary Transfer networking/ip
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} ipId Ip Id
         * @param {NetworkingProjectIpTransfer} networkingProjectIpTransfer 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectIpTransfer: async (projectId: string, locationId: string, ipId: string, networkingProjectIpTransfer: NetworkingProjectIpTransfer, xIdempotencyKey?: string, xDryRun?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('networkingProjectIpTransfer', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('networkingProjectIpTransfer', 'locationId', locationId)
            // verify required parameter 'ipId' is not null or undefined
            assertParamExists('networkingProjectIpTransfer', 'ipId', ipId)
            // verify required parameter 'networkingProjectIpTransfer' is not null or undefined
            assertParamExists('networkingProjectIpTransfer', 'networkingProjectIpTransfer', networkingProjectIpTransfer)
            const localVarPath = `/networking/{locationId}/project/{projectId}/ip/{ipId}/actions/transfer`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"ipId"}}`, encodeURIComponent(String(ipId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }

            if (xDryRun !== undefined && xDryRun !== null) {
                localVarHeaderParameter['x-dry-run'] = String(xDryRun);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(networkingProjectIpTransfer, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns modified ip
         * @summary Update networking/ip
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} ipId Ip Id
         * @param {NetworkingProjectIpUpdate} networkingProjectIpUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectIpUpdate: async (projectId: string, locationId: string, ipId: string, networkingProjectIpUpdate: NetworkingProjectIpUpdate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('networkingProjectIpUpdate', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('networkingProjectIpUpdate', 'locationId', locationId)
            // verify required parameter 'ipId' is not null or undefined
            assertParamExists('networkingProjectIpUpdate', 'ipId', ipId)
            // verify required parameter 'networkingProjectIpUpdate' is not null or undefined
            assertParamExists('networkingProjectIpUpdate', 'networkingProjectIpUpdate', networkingProjectIpUpdate)
            const localVarPath = `/networking/{locationId}/project/{projectId}/ip/{ipId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"ipId"}}`, encodeURIComponent(String(ipId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(networkingProjectIpUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NetworkingProjectIpApi - functional programming interface
 * @export
 */
export const NetworkingProjectIpApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NetworkingProjectIpApiAxiosParamCreator(configuration)
    return {
        /**
         * action associate
         * @summary Associate networking/ip
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} ipId Ip Id
         * @param {NetworkingProjectIpAssociate} networkingProjectIpAssociate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectIpAssociate(projectId: string, locationId: string, ipId: string, networkingProjectIpAssociate: NetworkingProjectIpAssociate, xIdempotencyKey?: string, xDryRun?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Ip>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkingProjectIpAssociate(projectId, locationId, ipId, networkingProjectIpAssociate, xIdempotencyKey, xDryRun, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create ip
         * @summary Create networking/ip
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {NetworkingProjectIpCreate} networkingProjectIpCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectIpCreate(projectId: string, locationId: string, networkingProjectIpCreate: NetworkingProjectIpCreate, xIdempotencyKey?: string, xDryRun?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Ip>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkingProjectIpCreate(projectId, locationId, networkingProjectIpCreate, xIdempotencyKey, xDryRun, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete ip
         * @summary Delete networking/ip
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} ipId Ip Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectIpDelete(projectId: string, locationId: string, ipId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkingProjectIpDelete(projectId, locationId, ipId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * action disassociate
         * @summary Disassociate networking/ip
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} ipId Ip Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectIpDisassociate(projectId: string, locationId: string, ipId: string, xIdempotencyKey?: string, xDryRun?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Ip>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkingProjectIpDisassociate(projectId, locationId, ipId, xIdempotencyKey, xDryRun, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get networking/ip.event
         * @summary Get networking/ip.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} ipId Ip Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectIpEventGet(projectId: string, locationId: string, ipId: string, eventId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkingProjectIpEventGet(projectId, locationId, ipId, eventId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List networking/ip.event
         * @summary List networking/ip.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} ipId Ip Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectIpEventList(projectId: string, locationId: string, ipId: string, $limit?: number, $skip?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Event>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkingProjectIpEventList(projectId, locationId, ipId, $limit, $skip, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a single ip
         * @summary Get networking/ip
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} ipId Ip Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectIpGet(projectId: string, locationId: string, ipId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Ip>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkingProjectIpGet(projectId, locationId, ipId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List ip
         * @summary List networking/ip
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [network] Filter by network
         * @param {string} [associatedNetadp] Filter by associated.netadp
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectIpList(projectId: string, locationId: string, network?: string, associatedNetadp?: string, tagValue?: string, tagKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Ip>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkingProjectIpList(projectId, locationId, network, associatedNetadp, tagValue, tagKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * action persist
         * @summary Persist networking/ip
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} ipId Ip Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectIpPersist(projectId: string, locationId: string, ipId: string, xIdempotencyKey?: string, xDryRun?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Ip>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkingProjectIpPersist(projectId, locationId, ipId, xIdempotencyKey, xDryRun, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get networking/ip.service
         * @summary Get networking/ip.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} ipId Ip Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectIpServiceGet(projectId: string, locationId: string, ipId: string, serviceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceService>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkingProjectIpServiceGet(projectId, locationId, ipId, serviceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List networking/ip.service
         * @summary List networking/ip.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} ipId Ip Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectIpServiceList(projectId: string, locationId: string, ipId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResourceService>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkingProjectIpServiceList(projectId, locationId, ipId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create networking/ip.tag
         * @summary Create networking/ip.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} ipId Ip Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectIpTagCreate(projectId: string, locationId: string, ipId: string, tag: Tag, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkingProjectIpTagCreate(projectId, locationId, ipId, tag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete networking/ip.tag
         * @summary Delete networking/ip.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} ipId Ip Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectIpTagDelete(projectId: string, locationId: string, ipId: string, tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkingProjectIpTagDelete(projectId, locationId, ipId, tagId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get networking/ip.tag
         * @summary Get networking/ip.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} ipId Ip Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectIpTagGet(projectId: string, locationId: string, ipId: string, tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkingProjectIpTagGet(projectId, locationId, ipId, tagId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List networking/ip.tag
         * @summary List networking/ip.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} ipId Ip Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectIpTagList(projectId: string, locationId: string, ipId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkingProjectIpTagList(projectId, locationId, ipId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Replace networking/ip.tag
         * @summary Replace networking/ip.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} ipId Ip Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectIpTagPut(projectId: string, locationId: string, ipId: string, tag: Array<Tag>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkingProjectIpTagPut(projectId, locationId, ipId, tag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * action transfer
         * @summary Transfer networking/ip
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} ipId Ip Id
         * @param {NetworkingProjectIpTransfer} networkingProjectIpTransfer 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectIpTransfer(projectId: string, locationId: string, ipId: string, networkingProjectIpTransfer: NetworkingProjectIpTransfer, xIdempotencyKey?: string, xDryRun?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Ip>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkingProjectIpTransfer(projectId, locationId, ipId, networkingProjectIpTransfer, xIdempotencyKey, xDryRun, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns modified ip
         * @summary Update networking/ip
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} ipId Ip Id
         * @param {NetworkingProjectIpUpdate} networkingProjectIpUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectIpUpdate(projectId: string, locationId: string, ipId: string, networkingProjectIpUpdate: NetworkingProjectIpUpdate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Ip>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkingProjectIpUpdate(projectId, locationId, ipId, networkingProjectIpUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * NetworkingProjectIpApi - factory interface
 * @export
 */
export const NetworkingProjectIpApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NetworkingProjectIpApiFp(configuration)
    return {
        /**
         * action associate
         * @summary Associate networking/ip
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} ipId Ip Id
         * @param {NetworkingProjectIpAssociate} networkingProjectIpAssociate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectIpAssociate(projectId: string, locationId: string, ipId: string, networkingProjectIpAssociate: NetworkingProjectIpAssociate, xIdempotencyKey?: string, xDryRun?: string, options?: any): AxiosPromise<Ip> {
            return localVarFp.networkingProjectIpAssociate(projectId, locationId, ipId, networkingProjectIpAssociate, xIdempotencyKey, xDryRun, options).then((request) => request(axios, basePath));
        },
        /**
         * Create ip
         * @summary Create networking/ip
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {NetworkingProjectIpCreate} networkingProjectIpCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectIpCreate(projectId: string, locationId: string, networkingProjectIpCreate: NetworkingProjectIpCreate, xIdempotencyKey?: string, xDryRun?: string, options?: any): AxiosPromise<Ip> {
            return localVarFp.networkingProjectIpCreate(projectId, locationId, networkingProjectIpCreate, xIdempotencyKey, xDryRun, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete ip
         * @summary Delete networking/ip
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} ipId Ip Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectIpDelete(projectId: string, locationId: string, ipId: string, options?: any): AxiosPromise<void> {
            return localVarFp.networkingProjectIpDelete(projectId, locationId, ipId, options).then((request) => request(axios, basePath));
        },
        /**
         * action disassociate
         * @summary Disassociate networking/ip
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} ipId Ip Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectIpDisassociate(projectId: string, locationId: string, ipId: string, xIdempotencyKey?: string, xDryRun?: string, options?: any): AxiosPromise<Ip> {
            return localVarFp.networkingProjectIpDisassociate(projectId, locationId, ipId, xIdempotencyKey, xDryRun, options).then((request) => request(axios, basePath));
        },
        /**
         * Get networking/ip.event
         * @summary Get networking/ip.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} ipId Ip Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectIpEventGet(projectId: string, locationId: string, ipId: string, eventId: string, options?: any): AxiosPromise<Event> {
            return localVarFp.networkingProjectIpEventGet(projectId, locationId, ipId, eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * List networking/ip.event
         * @summary List networking/ip.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} ipId Ip Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectIpEventList(projectId: string, locationId: string, ipId: string, $limit?: number, $skip?: number, options?: any): AxiosPromise<Array<Event>> {
            return localVarFp.networkingProjectIpEventList(projectId, locationId, ipId, $limit, $skip, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single ip
         * @summary Get networking/ip
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} ipId Ip Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectIpGet(projectId: string, locationId: string, ipId: string, options?: any): AxiosPromise<Ip> {
            return localVarFp.networkingProjectIpGet(projectId, locationId, ipId, options).then((request) => request(axios, basePath));
        },
        /**
         * List ip
         * @summary List networking/ip
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [network] Filter by network
         * @param {string} [associatedNetadp] Filter by associated.netadp
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectIpList(projectId: string, locationId: string, network?: string, associatedNetadp?: string, tagValue?: string, tagKey?: string, options?: any): AxiosPromise<Array<Ip>> {
            return localVarFp.networkingProjectIpList(projectId, locationId, network, associatedNetadp, tagValue, tagKey, options).then((request) => request(axios, basePath));
        },
        /**
         * action persist
         * @summary Persist networking/ip
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} ipId Ip Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectIpPersist(projectId: string, locationId: string, ipId: string, xIdempotencyKey?: string, xDryRun?: string, options?: any): AxiosPromise<Ip> {
            return localVarFp.networkingProjectIpPersist(projectId, locationId, ipId, xIdempotencyKey, xDryRun, options).then((request) => request(axios, basePath));
        },
        /**
         * Get networking/ip.service
         * @summary Get networking/ip.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} ipId Ip Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectIpServiceGet(projectId: string, locationId: string, ipId: string, serviceId: string, options?: any): AxiosPromise<ResourceService> {
            return localVarFp.networkingProjectIpServiceGet(projectId, locationId, ipId, serviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * List networking/ip.service
         * @summary List networking/ip.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} ipId Ip Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectIpServiceList(projectId: string, locationId: string, ipId: string, options?: any): AxiosPromise<Array<ResourceService>> {
            return localVarFp.networkingProjectIpServiceList(projectId, locationId, ipId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create networking/ip.tag
         * @summary Create networking/ip.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} ipId Ip Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectIpTagCreate(projectId: string, locationId: string, ipId: string, tag: Tag, options?: any): AxiosPromise<Tag> {
            return localVarFp.networkingProjectIpTagCreate(projectId, locationId, ipId, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete networking/ip.tag
         * @summary Delete networking/ip.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} ipId Ip Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectIpTagDelete(projectId: string, locationId: string, ipId: string, tagId: string, options?: any): AxiosPromise<void> {
            return localVarFp.networkingProjectIpTagDelete(projectId, locationId, ipId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get networking/ip.tag
         * @summary Get networking/ip.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} ipId Ip Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectIpTagGet(projectId: string, locationId: string, ipId: string, tagId: string, options?: any): AxiosPromise<Tag> {
            return localVarFp.networkingProjectIpTagGet(projectId, locationId, ipId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * List networking/ip.tag
         * @summary List networking/ip.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} ipId Ip Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectIpTagList(projectId: string, locationId: string, ipId: string, options?: any): AxiosPromise<Array<Tag>> {
            return localVarFp.networkingProjectIpTagList(projectId, locationId, ipId, options).then((request) => request(axios, basePath));
        },
        /**
         * Replace networking/ip.tag
         * @summary Replace networking/ip.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} ipId Ip Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectIpTagPut(projectId: string, locationId: string, ipId: string, tag: Array<Tag>, options?: any): AxiosPromise<Array<Tag>> {
            return localVarFp.networkingProjectIpTagPut(projectId, locationId, ipId, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * action transfer
         * @summary Transfer networking/ip
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} ipId Ip Id
         * @param {NetworkingProjectIpTransfer} networkingProjectIpTransfer 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectIpTransfer(projectId: string, locationId: string, ipId: string, networkingProjectIpTransfer: NetworkingProjectIpTransfer, xIdempotencyKey?: string, xDryRun?: string, options?: any): AxiosPromise<Ip> {
            return localVarFp.networkingProjectIpTransfer(projectId, locationId, ipId, networkingProjectIpTransfer, xIdempotencyKey, xDryRun, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns modified ip
         * @summary Update networking/ip
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} ipId Ip Id
         * @param {NetworkingProjectIpUpdate} networkingProjectIpUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectIpUpdate(projectId: string, locationId: string, ipId: string, networkingProjectIpUpdate: NetworkingProjectIpUpdate, options?: any): AxiosPromise<Ip> {
            return localVarFp.networkingProjectIpUpdate(projectId, locationId, ipId, networkingProjectIpUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NetworkingProjectIpApi - object-oriented interface
 * @export
 * @class NetworkingProjectIpApi
 * @extends {BaseAPI}
 */
export class NetworkingProjectIpApi extends BaseAPI {
    /**
     * action associate
     * @summary Associate networking/ip
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} ipId Ip Id
     * @param {NetworkingProjectIpAssociate} networkingProjectIpAssociate 
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {string} [xDryRun] Dry run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectIpApi
     */
    public networkingProjectIpAssociate(projectId: string, locationId: string, ipId: string, networkingProjectIpAssociate: NetworkingProjectIpAssociate, xIdempotencyKey?: string, xDryRun?: string, options?: any) {
        return NetworkingProjectIpApiFp(this.configuration).networkingProjectIpAssociate(projectId, locationId, ipId, networkingProjectIpAssociate, xIdempotencyKey, xDryRun, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create ip
     * @summary Create networking/ip
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {NetworkingProjectIpCreate} networkingProjectIpCreate 
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {string} [xDryRun] Dry run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectIpApi
     */
    public networkingProjectIpCreate(projectId: string, locationId: string, networkingProjectIpCreate: NetworkingProjectIpCreate, xIdempotencyKey?: string, xDryRun?: string, options?: any) {
        return NetworkingProjectIpApiFp(this.configuration).networkingProjectIpCreate(projectId, locationId, networkingProjectIpCreate, xIdempotencyKey, xDryRun, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete ip
     * @summary Delete networking/ip
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} ipId Ip Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectIpApi
     */
    public networkingProjectIpDelete(projectId: string, locationId: string, ipId: string, options?: any) {
        return NetworkingProjectIpApiFp(this.configuration).networkingProjectIpDelete(projectId, locationId, ipId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * action disassociate
     * @summary Disassociate networking/ip
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} ipId Ip Id
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {string} [xDryRun] Dry run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectIpApi
     */
    public networkingProjectIpDisassociate(projectId: string, locationId: string, ipId: string, xIdempotencyKey?: string, xDryRun?: string, options?: any) {
        return NetworkingProjectIpApiFp(this.configuration).networkingProjectIpDisassociate(projectId, locationId, ipId, xIdempotencyKey, xDryRun, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get networking/ip.event
     * @summary Get networking/ip.event
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} ipId Ip Id
     * @param {string} eventId eventId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectIpApi
     */
    public networkingProjectIpEventGet(projectId: string, locationId: string, ipId: string, eventId: string, options?: any) {
        return NetworkingProjectIpApiFp(this.configuration).networkingProjectIpEventGet(projectId, locationId, ipId, eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List networking/ip.event
     * @summary List networking/ip.event
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} ipId Ip Id
     * @param {number} [$limit] $limit
     * @param {number} [$skip] $skip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectIpApi
     */
    public networkingProjectIpEventList(projectId: string, locationId: string, ipId: string, $limit?: number, $skip?: number, options?: any) {
        return NetworkingProjectIpApiFp(this.configuration).networkingProjectIpEventList(projectId, locationId, ipId, $limit, $skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single ip
     * @summary Get networking/ip
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} ipId Ip Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectIpApi
     */
    public networkingProjectIpGet(projectId: string, locationId: string, ipId: string, options?: any) {
        return NetworkingProjectIpApiFp(this.configuration).networkingProjectIpGet(projectId, locationId, ipId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List ip
     * @summary List networking/ip
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} [network] Filter by network
     * @param {string} [associatedNetadp] Filter by associated.netadp
     * @param {string} [tagValue] Filter by tag.value
     * @param {string} [tagKey] Filter by tag.key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectIpApi
     */
    public networkingProjectIpList(projectId: string, locationId: string, network?: string, associatedNetadp?: string, tagValue?: string, tagKey?: string, options?: any) {
        return NetworkingProjectIpApiFp(this.configuration).networkingProjectIpList(projectId, locationId, network, associatedNetadp, tagValue, tagKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * action persist
     * @summary Persist networking/ip
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} ipId Ip Id
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {string} [xDryRun] Dry run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectIpApi
     */
    public networkingProjectIpPersist(projectId: string, locationId: string, ipId: string, xIdempotencyKey?: string, xDryRun?: string, options?: any) {
        return NetworkingProjectIpApiFp(this.configuration).networkingProjectIpPersist(projectId, locationId, ipId, xIdempotencyKey, xDryRun, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get networking/ip.service
     * @summary Get networking/ip.service
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} ipId Ip Id
     * @param {string} serviceId serviceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectIpApi
     */
    public networkingProjectIpServiceGet(projectId: string, locationId: string, ipId: string, serviceId: string, options?: any) {
        return NetworkingProjectIpApiFp(this.configuration).networkingProjectIpServiceGet(projectId, locationId, ipId, serviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List networking/ip.service
     * @summary List networking/ip.service
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} ipId Ip Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectIpApi
     */
    public networkingProjectIpServiceList(projectId: string, locationId: string, ipId: string, options?: any) {
        return NetworkingProjectIpApiFp(this.configuration).networkingProjectIpServiceList(projectId, locationId, ipId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create networking/ip.tag
     * @summary Create networking/ip.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} ipId Ip Id
     * @param {Tag} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectIpApi
     */
    public networkingProjectIpTagCreate(projectId: string, locationId: string, ipId: string, tag: Tag, options?: any) {
        return NetworkingProjectIpApiFp(this.configuration).networkingProjectIpTagCreate(projectId, locationId, ipId, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete networking/ip.tag
     * @summary Delete networking/ip.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} ipId Ip Id
     * @param {string} tagId tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectIpApi
     */
    public networkingProjectIpTagDelete(projectId: string, locationId: string, ipId: string, tagId: string, options?: any) {
        return NetworkingProjectIpApiFp(this.configuration).networkingProjectIpTagDelete(projectId, locationId, ipId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get networking/ip.tag
     * @summary Get networking/ip.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} ipId Ip Id
     * @param {string} tagId tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectIpApi
     */
    public networkingProjectIpTagGet(projectId: string, locationId: string, ipId: string, tagId: string, options?: any) {
        return NetworkingProjectIpApiFp(this.configuration).networkingProjectIpTagGet(projectId, locationId, ipId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List networking/ip.tag
     * @summary List networking/ip.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} ipId Ip Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectIpApi
     */
    public networkingProjectIpTagList(projectId: string, locationId: string, ipId: string, options?: any) {
        return NetworkingProjectIpApiFp(this.configuration).networkingProjectIpTagList(projectId, locationId, ipId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replace networking/ip.tag
     * @summary Replace networking/ip.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} ipId Ip Id
     * @param {Array<Tag>} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectIpApi
     */
    public networkingProjectIpTagPut(projectId: string, locationId: string, ipId: string, tag: Array<Tag>, options?: any) {
        return NetworkingProjectIpApiFp(this.configuration).networkingProjectIpTagPut(projectId, locationId, ipId, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * action transfer
     * @summary Transfer networking/ip
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} ipId Ip Id
     * @param {NetworkingProjectIpTransfer} networkingProjectIpTransfer 
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {string} [xDryRun] Dry run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectIpApi
     */
    public networkingProjectIpTransfer(projectId: string, locationId: string, ipId: string, networkingProjectIpTransfer: NetworkingProjectIpTransfer, xIdempotencyKey?: string, xDryRun?: string, options?: any) {
        return NetworkingProjectIpApiFp(this.configuration).networkingProjectIpTransfer(projectId, locationId, ipId, networkingProjectIpTransfer, xIdempotencyKey, xDryRun, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns modified ip
     * @summary Update networking/ip
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} ipId Ip Id
     * @param {NetworkingProjectIpUpdate} networkingProjectIpUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectIpApi
     */
    public networkingProjectIpUpdate(projectId: string, locationId: string, ipId: string, networkingProjectIpUpdate: NetworkingProjectIpUpdate, options?: any) {
        return NetworkingProjectIpApiFp(this.configuration).networkingProjectIpUpdate(projectId, locationId, ipId, networkingProjectIpUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * NetworkingProjectNetadpApi - axios parameter creator
 * @export
 */
export const NetworkingProjectNetadpApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create netadp
         * @summary Create networking/netadp
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {NetworkingProjectNetadpCreate} networkingProjectNetadpCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetadpCreate: async (projectId: string, locationId: string, networkingProjectNetadpCreate: NetworkingProjectNetadpCreate, xIdempotencyKey?: string, xDryRun?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('networkingProjectNetadpCreate', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('networkingProjectNetadpCreate', 'locationId', locationId)
            // verify required parameter 'networkingProjectNetadpCreate' is not null or undefined
            assertParamExists('networkingProjectNetadpCreate', 'networkingProjectNetadpCreate', networkingProjectNetadpCreate)
            const localVarPath = `/networking/{locationId}/project/{projectId}/netadp`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }

            if (xDryRun !== undefined && xDryRun !== null) {
                localVarHeaderParameter['x-dry-run'] = String(xDryRun);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(networkingProjectNetadpCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete netadp
         * @summary Delete networking/netadp
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netadpId Netadp Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetadpDelete: async (projectId: string, locationId: string, netadpId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('networkingProjectNetadpDelete', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('networkingProjectNetadpDelete', 'locationId', locationId)
            // verify required parameter 'netadpId' is not null or undefined
            assertParamExists('networkingProjectNetadpDelete', 'netadpId', netadpId)
            const localVarPath = `/networking/{locationId}/project/{projectId}/netadp/{netadpId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"netadpId"}}`, encodeURIComponent(String(netadpId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get networking/netadp.event
         * @summary Get networking/netadp.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netadpId Netadp Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetadpEventGet: async (projectId: string, locationId: string, netadpId: string, eventId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('networkingProjectNetadpEventGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('networkingProjectNetadpEventGet', 'locationId', locationId)
            // verify required parameter 'netadpId' is not null or undefined
            assertParamExists('networkingProjectNetadpEventGet', 'netadpId', netadpId)
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('networkingProjectNetadpEventGet', 'eventId', eventId)
            const localVarPath = `/networking/{locationId}/project/{projectId}/netadp/{netadpId}/event/{eventId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"netadpId"}}`, encodeURIComponent(String(netadpId)))
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List networking/netadp.event
         * @summary List networking/netadp.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netadpId Netadp Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetadpEventList: async (projectId: string, locationId: string, netadpId: string, $limit?: number, $skip?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('networkingProjectNetadpEventList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('networkingProjectNetadpEventList', 'locationId', locationId)
            // verify required parameter 'netadpId' is not null or undefined
            assertParamExists('networkingProjectNetadpEventList', 'netadpId', netadpId)
            const localVarPath = `/networking/{locationId}/project/{projectId}/netadp/{netadpId}/event`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"netadpId"}}`, encodeURIComponent(String(netadpId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if ($limit !== undefined) {
                localVarQueryParameter['$limit'] = $limit;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single netadp
         * @summary Get networking/netadp
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netadpId Netadp Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetadpGet: async (projectId: string, locationId: string, netadpId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('networkingProjectNetadpGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('networkingProjectNetadpGet', 'locationId', locationId)
            // verify required parameter 'netadpId' is not null or undefined
            assertParamExists('networkingProjectNetadpGet', 'netadpId', netadpId)
            const localVarPath = `/networking/{locationId}/project/{projectId}/netadp/{netadpId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"netadpId"}}`, encodeURIComponent(String(netadpId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List netadp
         * @summary List networking/netadp
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [assignedResource] Filter by assigned.resource
         * @param {string} [assignedId] Filter by assigned.id
         * @param {string} [network] Filter by network
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetadpList: async (projectId: string, locationId: string, assignedResource?: string, assignedId?: string, network?: string, tagValue?: string, tagKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('networkingProjectNetadpList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('networkingProjectNetadpList', 'locationId', locationId)
            const localVarPath = `/networking/{locationId}/project/{projectId}/netadp`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (assignedResource !== undefined) {
                localVarQueryParameter['assigned.resource'] = assignedResource;
            }

            if (assignedId !== undefined) {
                localVarQueryParameter['assigned.id'] = assignedId;
            }

            if (network !== undefined) {
                localVarQueryParameter['network'] = network;
            }

            if (tagValue !== undefined) {
                localVarQueryParameter['tag.value'] = tagValue;
            }

            if (tagKey !== undefined) {
                localVarQueryParameter['tag.key'] = tagKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get networking/netadp.metric
         * @summary Get networking/netadp.metric
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netadpId Netadp Id
         * @param {string} metricId metricId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetadpMetricGet: async (projectId: string, locationId: string, netadpId: string, metricId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('networkingProjectNetadpMetricGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('networkingProjectNetadpMetricGet', 'locationId', locationId)
            // verify required parameter 'netadpId' is not null or undefined
            assertParamExists('networkingProjectNetadpMetricGet', 'netadpId', netadpId)
            // verify required parameter 'metricId' is not null or undefined
            assertParamExists('networkingProjectNetadpMetricGet', 'metricId', metricId)
            const localVarPath = `/networking/{locationId}/project/{projectId}/netadp/{netadpId}/metric/{metricId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"netadpId"}}`, encodeURIComponent(String(netadpId)))
                .replace(`{${"metricId"}}`, encodeURIComponent(String(metricId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List networking/netadp.metric
         * @summary List networking/netadp.metric
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netadpId Netadp Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetadpMetricList: async (projectId: string, locationId: string, netadpId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('networkingProjectNetadpMetricList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('networkingProjectNetadpMetricList', 'locationId', locationId)
            // verify required parameter 'netadpId' is not null or undefined
            assertParamExists('networkingProjectNetadpMetricList', 'netadpId', netadpId)
            const localVarPath = `/networking/{locationId}/project/{projectId}/netadp/{netadpId}/metric`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"netadpId"}}`, encodeURIComponent(String(netadpId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List networking/netadp.point
         * @summary List networking/netadp.point
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netadpId Netadp Id
         * @param {string} metricId metricId
         * @param {string} [interval] interval
         * @param {string} [timespan] timespan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetadpMetricPointList: async (projectId: string, locationId: string, netadpId: string, metricId: string, interval?: string, timespan?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('networkingProjectNetadpMetricPointList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('networkingProjectNetadpMetricPointList', 'locationId', locationId)
            // verify required parameter 'netadpId' is not null or undefined
            assertParamExists('networkingProjectNetadpMetricPointList', 'netadpId', netadpId)
            // verify required parameter 'metricId' is not null or undefined
            assertParamExists('networkingProjectNetadpMetricPointList', 'metricId', metricId)
            const localVarPath = `/networking/{locationId}/project/{projectId}/netadp/{netadpId}/metric/{metricId}/point`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"netadpId"}}`, encodeURIComponent(String(netadpId)))
                .replace(`{${"metricId"}}`, encodeURIComponent(String(metricId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (timespan !== undefined) {
                localVarQueryParameter['timespan'] = timespan;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get networking/netadp.service
         * @summary Get networking/netadp.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netadpId Netadp Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetadpServiceGet: async (projectId: string, locationId: string, netadpId: string, serviceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('networkingProjectNetadpServiceGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('networkingProjectNetadpServiceGet', 'locationId', locationId)
            // verify required parameter 'netadpId' is not null or undefined
            assertParamExists('networkingProjectNetadpServiceGet', 'netadpId', netadpId)
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('networkingProjectNetadpServiceGet', 'serviceId', serviceId)
            const localVarPath = `/networking/{locationId}/project/{projectId}/netadp/{netadpId}/service/{serviceId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"netadpId"}}`, encodeURIComponent(String(netadpId)))
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List networking/netadp.service
         * @summary List networking/netadp.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netadpId Netadp Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetadpServiceList: async (projectId: string, locationId: string, netadpId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('networkingProjectNetadpServiceList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('networkingProjectNetadpServiceList', 'locationId', locationId)
            // verify required parameter 'netadpId' is not null or undefined
            assertParamExists('networkingProjectNetadpServiceList', 'netadpId', netadpId)
            const localVarPath = `/networking/{locationId}/project/{projectId}/netadp/{netadpId}/service`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"netadpId"}}`, encodeURIComponent(String(netadpId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create networking/netadp.tag
         * @summary Create networking/netadp.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netadpId Netadp Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetadpTagCreate: async (projectId: string, locationId: string, netadpId: string, tag: Tag, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('networkingProjectNetadpTagCreate', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('networkingProjectNetadpTagCreate', 'locationId', locationId)
            // verify required parameter 'netadpId' is not null or undefined
            assertParamExists('networkingProjectNetadpTagCreate', 'netadpId', netadpId)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('networkingProjectNetadpTagCreate', 'tag', tag)
            const localVarPath = `/networking/{locationId}/project/{projectId}/netadp/{netadpId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"netadpId"}}`, encodeURIComponent(String(netadpId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tag, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete networking/netadp.tag
         * @summary Delete networking/netadp.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netadpId Netadp Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetadpTagDelete: async (projectId: string, locationId: string, netadpId: string, tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('networkingProjectNetadpTagDelete', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('networkingProjectNetadpTagDelete', 'locationId', locationId)
            // verify required parameter 'netadpId' is not null or undefined
            assertParamExists('networkingProjectNetadpTagDelete', 'netadpId', netadpId)
            // verify required parameter 'tagId' is not null or undefined
            assertParamExists('networkingProjectNetadpTagDelete', 'tagId', tagId)
            const localVarPath = `/networking/{locationId}/project/{projectId}/netadp/{netadpId}/tag/{tagId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"netadpId"}}`, encodeURIComponent(String(netadpId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get networking/netadp.tag
         * @summary Get networking/netadp.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netadpId Netadp Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetadpTagGet: async (projectId: string, locationId: string, netadpId: string, tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('networkingProjectNetadpTagGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('networkingProjectNetadpTagGet', 'locationId', locationId)
            // verify required parameter 'netadpId' is not null or undefined
            assertParamExists('networkingProjectNetadpTagGet', 'netadpId', netadpId)
            // verify required parameter 'tagId' is not null or undefined
            assertParamExists('networkingProjectNetadpTagGet', 'tagId', tagId)
            const localVarPath = `/networking/{locationId}/project/{projectId}/netadp/{netadpId}/tag/{tagId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"netadpId"}}`, encodeURIComponent(String(netadpId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List networking/netadp.tag
         * @summary List networking/netadp.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netadpId Netadp Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetadpTagList: async (projectId: string, locationId: string, netadpId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('networkingProjectNetadpTagList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('networkingProjectNetadpTagList', 'locationId', locationId)
            // verify required parameter 'netadpId' is not null or undefined
            assertParamExists('networkingProjectNetadpTagList', 'netadpId', netadpId)
            const localVarPath = `/networking/{locationId}/project/{projectId}/netadp/{netadpId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"netadpId"}}`, encodeURIComponent(String(netadpId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replace networking/netadp.tag
         * @summary Replace networking/netadp.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netadpId Netadp Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetadpTagPut: async (projectId: string, locationId: string, netadpId: string, tag: Array<Tag>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('networkingProjectNetadpTagPut', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('networkingProjectNetadpTagPut', 'locationId', locationId)
            // verify required parameter 'netadpId' is not null or undefined
            assertParamExists('networkingProjectNetadpTagPut', 'netadpId', netadpId)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('networkingProjectNetadpTagPut', 'tag', tag)
            const localVarPath = `/networking/{locationId}/project/{projectId}/netadp/{netadpId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"netadpId"}}`, encodeURIComponent(String(netadpId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tag, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns modified netadp
         * @summary Update networking/netadp
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netadpId Netadp Id
         * @param {NetworkingProjectNetadpUpdate} networkingProjectNetadpUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetadpUpdate: async (projectId: string, locationId: string, netadpId: string, networkingProjectNetadpUpdate: NetworkingProjectNetadpUpdate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('networkingProjectNetadpUpdate', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('networkingProjectNetadpUpdate', 'locationId', locationId)
            // verify required parameter 'netadpId' is not null or undefined
            assertParamExists('networkingProjectNetadpUpdate', 'netadpId', netadpId)
            // verify required parameter 'networkingProjectNetadpUpdate' is not null or undefined
            assertParamExists('networkingProjectNetadpUpdate', 'networkingProjectNetadpUpdate', networkingProjectNetadpUpdate)
            const localVarPath = `/networking/{locationId}/project/{projectId}/netadp/{netadpId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"netadpId"}}`, encodeURIComponent(String(netadpId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(networkingProjectNetadpUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NetworkingProjectNetadpApi - functional programming interface
 * @export
 */
export const NetworkingProjectNetadpApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NetworkingProjectNetadpApiAxiosParamCreator(configuration)
    return {
        /**
         * Create netadp
         * @summary Create networking/netadp
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {NetworkingProjectNetadpCreate} networkingProjectNetadpCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectNetadpCreate(projectId: string, locationId: string, networkingProjectNetadpCreate: NetworkingProjectNetadpCreate, xIdempotencyKey?: string, xDryRun?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Netadp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkingProjectNetadpCreate(projectId, locationId, networkingProjectNetadpCreate, xIdempotencyKey, xDryRun, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete netadp
         * @summary Delete networking/netadp
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netadpId Netadp Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectNetadpDelete(projectId: string, locationId: string, netadpId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkingProjectNetadpDelete(projectId, locationId, netadpId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get networking/netadp.event
         * @summary Get networking/netadp.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netadpId Netadp Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectNetadpEventGet(projectId: string, locationId: string, netadpId: string, eventId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkingProjectNetadpEventGet(projectId, locationId, netadpId, eventId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List networking/netadp.event
         * @summary List networking/netadp.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netadpId Netadp Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectNetadpEventList(projectId: string, locationId: string, netadpId: string, $limit?: number, $skip?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Event>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkingProjectNetadpEventList(projectId, locationId, netadpId, $limit, $skip, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a single netadp
         * @summary Get networking/netadp
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netadpId Netadp Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectNetadpGet(projectId: string, locationId: string, netadpId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Netadp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkingProjectNetadpGet(projectId, locationId, netadpId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List netadp
         * @summary List networking/netadp
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [assignedResource] Filter by assigned.resource
         * @param {string} [assignedId] Filter by assigned.id
         * @param {string} [network] Filter by network
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectNetadpList(projectId: string, locationId: string, assignedResource?: string, assignedId?: string, network?: string, tagValue?: string, tagKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Netadp>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkingProjectNetadpList(projectId, locationId, assignedResource, assignedId, network, tagValue, tagKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get networking/netadp.metric
         * @summary Get networking/netadp.metric
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netadpId Netadp Id
         * @param {string} metricId metricId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectNetadpMetricGet(projectId: string, locationId: string, netadpId: string, metricId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Metric>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkingProjectNetadpMetricGet(projectId, locationId, netadpId, metricId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List networking/netadp.metric
         * @summary List networking/netadp.metric
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netadpId Netadp Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectNetadpMetricList(projectId: string, locationId: string, netadpId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Metric>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkingProjectNetadpMetricList(projectId, locationId, netadpId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List networking/netadp.point
         * @summary List networking/netadp.point
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netadpId Netadp Id
         * @param {string} metricId metricId
         * @param {string} [interval] interval
         * @param {string} [timespan] timespan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectNetadpMetricPointList(projectId: string, locationId: string, netadpId: string, metricId: string, interval?: string, timespan?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Point>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkingProjectNetadpMetricPointList(projectId, locationId, netadpId, metricId, interval, timespan, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get networking/netadp.service
         * @summary Get networking/netadp.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netadpId Netadp Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectNetadpServiceGet(projectId: string, locationId: string, netadpId: string, serviceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceService>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkingProjectNetadpServiceGet(projectId, locationId, netadpId, serviceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List networking/netadp.service
         * @summary List networking/netadp.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netadpId Netadp Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectNetadpServiceList(projectId: string, locationId: string, netadpId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResourceService>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkingProjectNetadpServiceList(projectId, locationId, netadpId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create networking/netadp.tag
         * @summary Create networking/netadp.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netadpId Netadp Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectNetadpTagCreate(projectId: string, locationId: string, netadpId: string, tag: Tag, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkingProjectNetadpTagCreate(projectId, locationId, netadpId, tag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete networking/netadp.tag
         * @summary Delete networking/netadp.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netadpId Netadp Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectNetadpTagDelete(projectId: string, locationId: string, netadpId: string, tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkingProjectNetadpTagDelete(projectId, locationId, netadpId, tagId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get networking/netadp.tag
         * @summary Get networking/netadp.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netadpId Netadp Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectNetadpTagGet(projectId: string, locationId: string, netadpId: string, tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkingProjectNetadpTagGet(projectId, locationId, netadpId, tagId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List networking/netadp.tag
         * @summary List networking/netadp.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netadpId Netadp Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectNetadpTagList(projectId: string, locationId: string, netadpId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkingProjectNetadpTagList(projectId, locationId, netadpId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Replace networking/netadp.tag
         * @summary Replace networking/netadp.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netadpId Netadp Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectNetadpTagPut(projectId: string, locationId: string, netadpId: string, tag: Array<Tag>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkingProjectNetadpTagPut(projectId, locationId, netadpId, tag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns modified netadp
         * @summary Update networking/netadp
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netadpId Netadp Id
         * @param {NetworkingProjectNetadpUpdate} networkingProjectNetadpUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectNetadpUpdate(projectId: string, locationId: string, netadpId: string, networkingProjectNetadpUpdate: NetworkingProjectNetadpUpdate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Netadp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkingProjectNetadpUpdate(projectId, locationId, netadpId, networkingProjectNetadpUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * NetworkingProjectNetadpApi - factory interface
 * @export
 */
export const NetworkingProjectNetadpApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NetworkingProjectNetadpApiFp(configuration)
    return {
        /**
         * Create netadp
         * @summary Create networking/netadp
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {NetworkingProjectNetadpCreate} networkingProjectNetadpCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetadpCreate(projectId: string, locationId: string, networkingProjectNetadpCreate: NetworkingProjectNetadpCreate, xIdempotencyKey?: string, xDryRun?: string, options?: any): AxiosPromise<Netadp> {
            return localVarFp.networkingProjectNetadpCreate(projectId, locationId, networkingProjectNetadpCreate, xIdempotencyKey, xDryRun, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete netadp
         * @summary Delete networking/netadp
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netadpId Netadp Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetadpDelete(projectId: string, locationId: string, netadpId: string, options?: any): AxiosPromise<void> {
            return localVarFp.networkingProjectNetadpDelete(projectId, locationId, netadpId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get networking/netadp.event
         * @summary Get networking/netadp.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netadpId Netadp Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetadpEventGet(projectId: string, locationId: string, netadpId: string, eventId: string, options?: any): AxiosPromise<Event> {
            return localVarFp.networkingProjectNetadpEventGet(projectId, locationId, netadpId, eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * List networking/netadp.event
         * @summary List networking/netadp.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netadpId Netadp Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetadpEventList(projectId: string, locationId: string, netadpId: string, $limit?: number, $skip?: number, options?: any): AxiosPromise<Array<Event>> {
            return localVarFp.networkingProjectNetadpEventList(projectId, locationId, netadpId, $limit, $skip, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single netadp
         * @summary Get networking/netadp
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netadpId Netadp Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetadpGet(projectId: string, locationId: string, netadpId: string, options?: any): AxiosPromise<Netadp> {
            return localVarFp.networkingProjectNetadpGet(projectId, locationId, netadpId, options).then((request) => request(axios, basePath));
        },
        /**
         * List netadp
         * @summary List networking/netadp
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [assignedResource] Filter by assigned.resource
         * @param {string} [assignedId] Filter by assigned.id
         * @param {string} [network] Filter by network
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetadpList(projectId: string, locationId: string, assignedResource?: string, assignedId?: string, network?: string, tagValue?: string, tagKey?: string, options?: any): AxiosPromise<Array<Netadp>> {
            return localVarFp.networkingProjectNetadpList(projectId, locationId, assignedResource, assignedId, network, tagValue, tagKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get networking/netadp.metric
         * @summary Get networking/netadp.metric
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netadpId Netadp Id
         * @param {string} metricId metricId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetadpMetricGet(projectId: string, locationId: string, netadpId: string, metricId: string, options?: any): AxiosPromise<Metric> {
            return localVarFp.networkingProjectNetadpMetricGet(projectId, locationId, netadpId, metricId, options).then((request) => request(axios, basePath));
        },
        /**
         * List networking/netadp.metric
         * @summary List networking/netadp.metric
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netadpId Netadp Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetadpMetricList(projectId: string, locationId: string, netadpId: string, options?: any): AxiosPromise<Array<Metric>> {
            return localVarFp.networkingProjectNetadpMetricList(projectId, locationId, netadpId, options).then((request) => request(axios, basePath));
        },
        /**
         * List networking/netadp.point
         * @summary List networking/netadp.point
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netadpId Netadp Id
         * @param {string} metricId metricId
         * @param {string} [interval] interval
         * @param {string} [timespan] timespan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetadpMetricPointList(projectId: string, locationId: string, netadpId: string, metricId: string, interval?: string, timespan?: string, options?: any): AxiosPromise<Array<Point>> {
            return localVarFp.networkingProjectNetadpMetricPointList(projectId, locationId, netadpId, metricId, interval, timespan, options).then((request) => request(axios, basePath));
        },
        /**
         * Get networking/netadp.service
         * @summary Get networking/netadp.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netadpId Netadp Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetadpServiceGet(projectId: string, locationId: string, netadpId: string, serviceId: string, options?: any): AxiosPromise<ResourceService> {
            return localVarFp.networkingProjectNetadpServiceGet(projectId, locationId, netadpId, serviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * List networking/netadp.service
         * @summary List networking/netadp.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netadpId Netadp Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetadpServiceList(projectId: string, locationId: string, netadpId: string, options?: any): AxiosPromise<Array<ResourceService>> {
            return localVarFp.networkingProjectNetadpServiceList(projectId, locationId, netadpId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create networking/netadp.tag
         * @summary Create networking/netadp.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netadpId Netadp Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetadpTagCreate(projectId: string, locationId: string, netadpId: string, tag: Tag, options?: any): AxiosPromise<Tag> {
            return localVarFp.networkingProjectNetadpTagCreate(projectId, locationId, netadpId, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete networking/netadp.tag
         * @summary Delete networking/netadp.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netadpId Netadp Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetadpTagDelete(projectId: string, locationId: string, netadpId: string, tagId: string, options?: any): AxiosPromise<void> {
            return localVarFp.networkingProjectNetadpTagDelete(projectId, locationId, netadpId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get networking/netadp.tag
         * @summary Get networking/netadp.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netadpId Netadp Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetadpTagGet(projectId: string, locationId: string, netadpId: string, tagId: string, options?: any): AxiosPromise<Tag> {
            return localVarFp.networkingProjectNetadpTagGet(projectId, locationId, netadpId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * List networking/netadp.tag
         * @summary List networking/netadp.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netadpId Netadp Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetadpTagList(projectId: string, locationId: string, netadpId: string, options?: any): AxiosPromise<Array<Tag>> {
            return localVarFp.networkingProjectNetadpTagList(projectId, locationId, netadpId, options).then((request) => request(axios, basePath));
        },
        /**
         * Replace networking/netadp.tag
         * @summary Replace networking/netadp.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netadpId Netadp Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetadpTagPut(projectId: string, locationId: string, netadpId: string, tag: Array<Tag>, options?: any): AxiosPromise<Array<Tag>> {
            return localVarFp.networkingProjectNetadpTagPut(projectId, locationId, netadpId, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns modified netadp
         * @summary Update networking/netadp
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netadpId Netadp Id
         * @param {NetworkingProjectNetadpUpdate} networkingProjectNetadpUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetadpUpdate(projectId: string, locationId: string, netadpId: string, networkingProjectNetadpUpdate: NetworkingProjectNetadpUpdate, options?: any): AxiosPromise<Netadp> {
            return localVarFp.networkingProjectNetadpUpdate(projectId, locationId, netadpId, networkingProjectNetadpUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NetworkingProjectNetadpApi - object-oriented interface
 * @export
 * @class NetworkingProjectNetadpApi
 * @extends {BaseAPI}
 */
export class NetworkingProjectNetadpApi extends BaseAPI {
    /**
     * Create netadp
     * @summary Create networking/netadp
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {NetworkingProjectNetadpCreate} networkingProjectNetadpCreate 
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {string} [xDryRun] Dry run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectNetadpApi
     */
    public networkingProjectNetadpCreate(projectId: string, locationId: string, networkingProjectNetadpCreate: NetworkingProjectNetadpCreate, xIdempotencyKey?: string, xDryRun?: string, options?: any) {
        return NetworkingProjectNetadpApiFp(this.configuration).networkingProjectNetadpCreate(projectId, locationId, networkingProjectNetadpCreate, xIdempotencyKey, xDryRun, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete netadp
     * @summary Delete networking/netadp
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} netadpId Netadp Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectNetadpApi
     */
    public networkingProjectNetadpDelete(projectId: string, locationId: string, netadpId: string, options?: any) {
        return NetworkingProjectNetadpApiFp(this.configuration).networkingProjectNetadpDelete(projectId, locationId, netadpId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get networking/netadp.event
     * @summary Get networking/netadp.event
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} netadpId Netadp Id
     * @param {string} eventId eventId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectNetadpApi
     */
    public networkingProjectNetadpEventGet(projectId: string, locationId: string, netadpId: string, eventId: string, options?: any) {
        return NetworkingProjectNetadpApiFp(this.configuration).networkingProjectNetadpEventGet(projectId, locationId, netadpId, eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List networking/netadp.event
     * @summary List networking/netadp.event
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} netadpId Netadp Id
     * @param {number} [$limit] $limit
     * @param {number} [$skip] $skip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectNetadpApi
     */
    public networkingProjectNetadpEventList(projectId: string, locationId: string, netadpId: string, $limit?: number, $skip?: number, options?: any) {
        return NetworkingProjectNetadpApiFp(this.configuration).networkingProjectNetadpEventList(projectId, locationId, netadpId, $limit, $skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single netadp
     * @summary Get networking/netadp
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} netadpId Netadp Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectNetadpApi
     */
    public networkingProjectNetadpGet(projectId: string, locationId: string, netadpId: string, options?: any) {
        return NetworkingProjectNetadpApiFp(this.configuration).networkingProjectNetadpGet(projectId, locationId, netadpId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List netadp
     * @summary List networking/netadp
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} [assignedResource] Filter by assigned.resource
     * @param {string} [assignedId] Filter by assigned.id
     * @param {string} [network] Filter by network
     * @param {string} [tagValue] Filter by tag.value
     * @param {string} [tagKey] Filter by tag.key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectNetadpApi
     */
    public networkingProjectNetadpList(projectId: string, locationId: string, assignedResource?: string, assignedId?: string, network?: string, tagValue?: string, tagKey?: string, options?: any) {
        return NetworkingProjectNetadpApiFp(this.configuration).networkingProjectNetadpList(projectId, locationId, assignedResource, assignedId, network, tagValue, tagKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get networking/netadp.metric
     * @summary Get networking/netadp.metric
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} netadpId Netadp Id
     * @param {string} metricId metricId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectNetadpApi
     */
    public networkingProjectNetadpMetricGet(projectId: string, locationId: string, netadpId: string, metricId: string, options?: any) {
        return NetworkingProjectNetadpApiFp(this.configuration).networkingProjectNetadpMetricGet(projectId, locationId, netadpId, metricId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List networking/netadp.metric
     * @summary List networking/netadp.metric
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} netadpId Netadp Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectNetadpApi
     */
    public networkingProjectNetadpMetricList(projectId: string, locationId: string, netadpId: string, options?: any) {
        return NetworkingProjectNetadpApiFp(this.configuration).networkingProjectNetadpMetricList(projectId, locationId, netadpId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List networking/netadp.point
     * @summary List networking/netadp.point
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} netadpId Netadp Id
     * @param {string} metricId metricId
     * @param {string} [interval] interval
     * @param {string} [timespan] timespan
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectNetadpApi
     */
    public networkingProjectNetadpMetricPointList(projectId: string, locationId: string, netadpId: string, metricId: string, interval?: string, timespan?: string, options?: any) {
        return NetworkingProjectNetadpApiFp(this.configuration).networkingProjectNetadpMetricPointList(projectId, locationId, netadpId, metricId, interval, timespan, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get networking/netadp.service
     * @summary Get networking/netadp.service
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} netadpId Netadp Id
     * @param {string} serviceId serviceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectNetadpApi
     */
    public networkingProjectNetadpServiceGet(projectId: string, locationId: string, netadpId: string, serviceId: string, options?: any) {
        return NetworkingProjectNetadpApiFp(this.configuration).networkingProjectNetadpServiceGet(projectId, locationId, netadpId, serviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List networking/netadp.service
     * @summary List networking/netadp.service
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} netadpId Netadp Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectNetadpApi
     */
    public networkingProjectNetadpServiceList(projectId: string, locationId: string, netadpId: string, options?: any) {
        return NetworkingProjectNetadpApiFp(this.configuration).networkingProjectNetadpServiceList(projectId, locationId, netadpId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create networking/netadp.tag
     * @summary Create networking/netadp.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} netadpId Netadp Id
     * @param {Tag} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectNetadpApi
     */
    public networkingProjectNetadpTagCreate(projectId: string, locationId: string, netadpId: string, tag: Tag, options?: any) {
        return NetworkingProjectNetadpApiFp(this.configuration).networkingProjectNetadpTagCreate(projectId, locationId, netadpId, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete networking/netadp.tag
     * @summary Delete networking/netadp.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} netadpId Netadp Id
     * @param {string} tagId tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectNetadpApi
     */
    public networkingProjectNetadpTagDelete(projectId: string, locationId: string, netadpId: string, tagId: string, options?: any) {
        return NetworkingProjectNetadpApiFp(this.configuration).networkingProjectNetadpTagDelete(projectId, locationId, netadpId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get networking/netadp.tag
     * @summary Get networking/netadp.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} netadpId Netadp Id
     * @param {string} tagId tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectNetadpApi
     */
    public networkingProjectNetadpTagGet(projectId: string, locationId: string, netadpId: string, tagId: string, options?: any) {
        return NetworkingProjectNetadpApiFp(this.configuration).networkingProjectNetadpTagGet(projectId, locationId, netadpId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List networking/netadp.tag
     * @summary List networking/netadp.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} netadpId Netadp Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectNetadpApi
     */
    public networkingProjectNetadpTagList(projectId: string, locationId: string, netadpId: string, options?: any) {
        return NetworkingProjectNetadpApiFp(this.configuration).networkingProjectNetadpTagList(projectId, locationId, netadpId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replace networking/netadp.tag
     * @summary Replace networking/netadp.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} netadpId Netadp Id
     * @param {Array<Tag>} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectNetadpApi
     */
    public networkingProjectNetadpTagPut(projectId: string, locationId: string, netadpId: string, tag: Array<Tag>, options?: any) {
        return NetworkingProjectNetadpApiFp(this.configuration).networkingProjectNetadpTagPut(projectId, locationId, netadpId, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns modified netadp
     * @summary Update networking/netadp
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} netadpId Netadp Id
     * @param {NetworkingProjectNetadpUpdate} networkingProjectNetadpUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectNetadpApi
     */
    public networkingProjectNetadpUpdate(projectId: string, locationId: string, netadpId: string, networkingProjectNetadpUpdate: NetworkingProjectNetadpUpdate, options?: any) {
        return NetworkingProjectNetadpApiFp(this.configuration).networkingProjectNetadpUpdate(projectId, locationId, netadpId, networkingProjectNetadpUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * NetworkingProjectNetgwApi - axios parameter creator
 * @export
 */
export const NetworkingProjectNetgwApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * action attach
         * @summary Attach networking/netgw
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netgwId Netgw Id
         * @param {NetworkingProjectNetgwAttach} networkingProjectNetgwAttach 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetgwAttach: async (projectId: string, locationId: string, netgwId: string, networkingProjectNetgwAttach: NetworkingProjectNetgwAttach, xIdempotencyKey?: string, xDryRun?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('networkingProjectNetgwAttach', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('networkingProjectNetgwAttach', 'locationId', locationId)
            // verify required parameter 'netgwId' is not null or undefined
            assertParamExists('networkingProjectNetgwAttach', 'netgwId', netgwId)
            // verify required parameter 'networkingProjectNetgwAttach' is not null or undefined
            assertParamExists('networkingProjectNetgwAttach', 'networkingProjectNetgwAttach', networkingProjectNetgwAttach)
            const localVarPath = `/networking/{locationId}/project/{projectId}/netgw/{netgwId}/actions/attach`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"netgwId"}}`, encodeURIComponent(String(netgwId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }

            if (xDryRun !== undefined && xDryRun !== null) {
                localVarHeaderParameter['x-dry-run'] = String(xDryRun);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(networkingProjectNetgwAttach, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create netgw
         * @summary Create networking/netgw
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {NetworkingProjectNetgwCreate} networkingProjectNetgwCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetgwCreate: async (projectId: string, locationId: string, networkingProjectNetgwCreate: NetworkingProjectNetgwCreate, xIdempotencyKey?: string, xDryRun?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('networkingProjectNetgwCreate', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('networkingProjectNetgwCreate', 'locationId', locationId)
            // verify required parameter 'networkingProjectNetgwCreate' is not null or undefined
            assertParamExists('networkingProjectNetgwCreate', 'networkingProjectNetgwCreate', networkingProjectNetgwCreate)
            const localVarPath = `/networking/{locationId}/project/{projectId}/netgw`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }

            if (xDryRun !== undefined && xDryRun !== null) {
                localVarHeaderParameter['x-dry-run'] = String(xDryRun);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(networkingProjectNetgwCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete netgw
         * @summary Delete networking/netgw
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netgwId Netgw Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetgwDelete: async (projectId: string, locationId: string, netgwId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('networkingProjectNetgwDelete', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('networkingProjectNetgwDelete', 'locationId', locationId)
            // verify required parameter 'netgwId' is not null or undefined
            assertParamExists('networkingProjectNetgwDelete', 'netgwId', netgwId)
            const localVarPath = `/networking/{locationId}/project/{projectId}/netgw/{netgwId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"netgwId"}}`, encodeURIComponent(String(netgwId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * action detach
         * @summary Detach networking/netgw
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netgwId Netgw Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetgwDetach: async (projectId: string, locationId: string, netgwId: string, xIdempotencyKey?: string, xDryRun?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('networkingProjectNetgwDetach', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('networkingProjectNetgwDetach', 'locationId', locationId)
            // verify required parameter 'netgwId' is not null or undefined
            assertParamExists('networkingProjectNetgwDetach', 'netgwId', netgwId)
            const localVarPath = `/networking/{locationId}/project/{projectId}/netgw/{netgwId}/actions/detach`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"netgwId"}}`, encodeURIComponent(String(netgwId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }

            if (xDryRun !== undefined && xDryRun !== null) {
                localVarHeaderParameter['x-dry-run'] = String(xDryRun);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get networking/netgw.event
         * @summary Get networking/netgw.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netgwId Netgw Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetgwEventGet: async (projectId: string, locationId: string, netgwId: string, eventId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('networkingProjectNetgwEventGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('networkingProjectNetgwEventGet', 'locationId', locationId)
            // verify required parameter 'netgwId' is not null or undefined
            assertParamExists('networkingProjectNetgwEventGet', 'netgwId', netgwId)
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('networkingProjectNetgwEventGet', 'eventId', eventId)
            const localVarPath = `/networking/{locationId}/project/{projectId}/netgw/{netgwId}/event/{eventId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"netgwId"}}`, encodeURIComponent(String(netgwId)))
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List networking/netgw.event
         * @summary List networking/netgw.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netgwId Netgw Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetgwEventList: async (projectId: string, locationId: string, netgwId: string, $limit?: number, $skip?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('networkingProjectNetgwEventList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('networkingProjectNetgwEventList', 'locationId', locationId)
            // verify required parameter 'netgwId' is not null or undefined
            assertParamExists('networkingProjectNetgwEventList', 'netgwId', netgwId)
            const localVarPath = `/networking/{locationId}/project/{projectId}/netgw/{netgwId}/event`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"netgwId"}}`, encodeURIComponent(String(netgwId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if ($limit !== undefined) {
                localVarQueryParameter['$limit'] = $limit;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single netgw
         * @summary Get networking/netgw
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netgwId Netgw Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetgwGet: async (projectId: string, locationId: string, netgwId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('networkingProjectNetgwGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('networkingProjectNetgwGet', 'locationId', locationId)
            // verify required parameter 'netgwId' is not null or undefined
            assertParamExists('networkingProjectNetgwGet', 'netgwId', netgwId)
            const localVarPath = `/networking/{locationId}/project/{projectId}/netgw/{netgwId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"netgwId"}}`, encodeURIComponent(String(netgwId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List netgw
         * @summary List networking/netgw
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [name] Filter by name
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetgwList: async (projectId: string, locationId: string, name?: string, tagValue?: string, tagKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('networkingProjectNetgwList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('networkingProjectNetgwList', 'locationId', locationId)
            const localVarPath = `/networking/{locationId}/project/{projectId}/netgw`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (tagValue !== undefined) {
                localVarQueryParameter['tag.value'] = tagValue;
            }

            if (tagKey !== undefined) {
                localVarQueryParameter['tag.key'] = tagKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get networking/netgw.service
         * @summary Get networking/netgw.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netgwId Netgw Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetgwServiceGet: async (projectId: string, locationId: string, netgwId: string, serviceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('networkingProjectNetgwServiceGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('networkingProjectNetgwServiceGet', 'locationId', locationId)
            // verify required parameter 'netgwId' is not null or undefined
            assertParamExists('networkingProjectNetgwServiceGet', 'netgwId', netgwId)
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('networkingProjectNetgwServiceGet', 'serviceId', serviceId)
            const localVarPath = `/networking/{locationId}/project/{projectId}/netgw/{netgwId}/service/{serviceId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"netgwId"}}`, encodeURIComponent(String(netgwId)))
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List networking/netgw.service
         * @summary List networking/netgw.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netgwId Netgw Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetgwServiceList: async (projectId: string, locationId: string, netgwId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('networkingProjectNetgwServiceList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('networkingProjectNetgwServiceList', 'locationId', locationId)
            // verify required parameter 'netgwId' is not null or undefined
            assertParamExists('networkingProjectNetgwServiceList', 'netgwId', netgwId)
            const localVarPath = `/networking/{locationId}/project/{projectId}/netgw/{netgwId}/service`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"netgwId"}}`, encodeURIComponent(String(netgwId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create networking/netgw.tag
         * @summary Create networking/netgw.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netgwId Netgw Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetgwTagCreate: async (projectId: string, locationId: string, netgwId: string, tag: Tag, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('networkingProjectNetgwTagCreate', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('networkingProjectNetgwTagCreate', 'locationId', locationId)
            // verify required parameter 'netgwId' is not null or undefined
            assertParamExists('networkingProjectNetgwTagCreate', 'netgwId', netgwId)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('networkingProjectNetgwTagCreate', 'tag', tag)
            const localVarPath = `/networking/{locationId}/project/{projectId}/netgw/{netgwId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"netgwId"}}`, encodeURIComponent(String(netgwId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tag, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete networking/netgw.tag
         * @summary Delete networking/netgw.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netgwId Netgw Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetgwTagDelete: async (projectId: string, locationId: string, netgwId: string, tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('networkingProjectNetgwTagDelete', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('networkingProjectNetgwTagDelete', 'locationId', locationId)
            // verify required parameter 'netgwId' is not null or undefined
            assertParamExists('networkingProjectNetgwTagDelete', 'netgwId', netgwId)
            // verify required parameter 'tagId' is not null or undefined
            assertParamExists('networkingProjectNetgwTagDelete', 'tagId', tagId)
            const localVarPath = `/networking/{locationId}/project/{projectId}/netgw/{netgwId}/tag/{tagId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"netgwId"}}`, encodeURIComponent(String(netgwId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get networking/netgw.tag
         * @summary Get networking/netgw.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netgwId Netgw Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetgwTagGet: async (projectId: string, locationId: string, netgwId: string, tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('networkingProjectNetgwTagGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('networkingProjectNetgwTagGet', 'locationId', locationId)
            // verify required parameter 'netgwId' is not null or undefined
            assertParamExists('networkingProjectNetgwTagGet', 'netgwId', netgwId)
            // verify required parameter 'tagId' is not null or undefined
            assertParamExists('networkingProjectNetgwTagGet', 'tagId', tagId)
            const localVarPath = `/networking/{locationId}/project/{projectId}/netgw/{netgwId}/tag/{tagId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"netgwId"}}`, encodeURIComponent(String(netgwId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List networking/netgw.tag
         * @summary List networking/netgw.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netgwId Netgw Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetgwTagList: async (projectId: string, locationId: string, netgwId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('networkingProjectNetgwTagList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('networkingProjectNetgwTagList', 'locationId', locationId)
            // verify required parameter 'netgwId' is not null or undefined
            assertParamExists('networkingProjectNetgwTagList', 'netgwId', netgwId)
            const localVarPath = `/networking/{locationId}/project/{projectId}/netgw/{netgwId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"netgwId"}}`, encodeURIComponent(String(netgwId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replace networking/netgw.tag
         * @summary Replace networking/netgw.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netgwId Netgw Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetgwTagPut: async (projectId: string, locationId: string, netgwId: string, tag: Array<Tag>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('networkingProjectNetgwTagPut', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('networkingProjectNetgwTagPut', 'locationId', locationId)
            // verify required parameter 'netgwId' is not null or undefined
            assertParamExists('networkingProjectNetgwTagPut', 'netgwId', netgwId)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('networkingProjectNetgwTagPut', 'tag', tag)
            const localVarPath = `/networking/{locationId}/project/{projectId}/netgw/{netgwId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"netgwId"}}`, encodeURIComponent(String(netgwId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tag, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns modified netgw
         * @summary Update networking/netgw
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netgwId Netgw Id
         * @param {NetworkingProjectNetgwUpdate} networkingProjectNetgwUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetgwUpdate: async (projectId: string, locationId: string, netgwId: string, networkingProjectNetgwUpdate: NetworkingProjectNetgwUpdate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('networkingProjectNetgwUpdate', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('networkingProjectNetgwUpdate', 'locationId', locationId)
            // verify required parameter 'netgwId' is not null or undefined
            assertParamExists('networkingProjectNetgwUpdate', 'netgwId', netgwId)
            // verify required parameter 'networkingProjectNetgwUpdate' is not null or undefined
            assertParamExists('networkingProjectNetgwUpdate', 'networkingProjectNetgwUpdate', networkingProjectNetgwUpdate)
            const localVarPath = `/networking/{locationId}/project/{projectId}/netgw/{netgwId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"netgwId"}}`, encodeURIComponent(String(netgwId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(networkingProjectNetgwUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NetworkingProjectNetgwApi - functional programming interface
 * @export
 */
export const NetworkingProjectNetgwApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NetworkingProjectNetgwApiAxiosParamCreator(configuration)
    return {
        /**
         * action attach
         * @summary Attach networking/netgw
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netgwId Netgw Id
         * @param {NetworkingProjectNetgwAttach} networkingProjectNetgwAttach 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectNetgwAttach(projectId: string, locationId: string, netgwId: string, networkingProjectNetgwAttach: NetworkingProjectNetgwAttach, xIdempotencyKey?: string, xDryRun?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Netgw>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkingProjectNetgwAttach(projectId, locationId, netgwId, networkingProjectNetgwAttach, xIdempotencyKey, xDryRun, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create netgw
         * @summary Create networking/netgw
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {NetworkingProjectNetgwCreate} networkingProjectNetgwCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectNetgwCreate(projectId: string, locationId: string, networkingProjectNetgwCreate: NetworkingProjectNetgwCreate, xIdempotencyKey?: string, xDryRun?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Netgw>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkingProjectNetgwCreate(projectId, locationId, networkingProjectNetgwCreate, xIdempotencyKey, xDryRun, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete netgw
         * @summary Delete networking/netgw
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netgwId Netgw Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectNetgwDelete(projectId: string, locationId: string, netgwId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkingProjectNetgwDelete(projectId, locationId, netgwId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * action detach
         * @summary Detach networking/netgw
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netgwId Netgw Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectNetgwDetach(projectId: string, locationId: string, netgwId: string, xIdempotencyKey?: string, xDryRun?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Netgw>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkingProjectNetgwDetach(projectId, locationId, netgwId, xIdempotencyKey, xDryRun, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get networking/netgw.event
         * @summary Get networking/netgw.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netgwId Netgw Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectNetgwEventGet(projectId: string, locationId: string, netgwId: string, eventId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkingProjectNetgwEventGet(projectId, locationId, netgwId, eventId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List networking/netgw.event
         * @summary List networking/netgw.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netgwId Netgw Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectNetgwEventList(projectId: string, locationId: string, netgwId: string, $limit?: number, $skip?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Event>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkingProjectNetgwEventList(projectId, locationId, netgwId, $limit, $skip, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a single netgw
         * @summary Get networking/netgw
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netgwId Netgw Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectNetgwGet(projectId: string, locationId: string, netgwId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Netgw>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkingProjectNetgwGet(projectId, locationId, netgwId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List netgw
         * @summary List networking/netgw
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [name] Filter by name
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectNetgwList(projectId: string, locationId: string, name?: string, tagValue?: string, tagKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Netgw>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkingProjectNetgwList(projectId, locationId, name, tagValue, tagKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get networking/netgw.service
         * @summary Get networking/netgw.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netgwId Netgw Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectNetgwServiceGet(projectId: string, locationId: string, netgwId: string, serviceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceService>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkingProjectNetgwServiceGet(projectId, locationId, netgwId, serviceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List networking/netgw.service
         * @summary List networking/netgw.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netgwId Netgw Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectNetgwServiceList(projectId: string, locationId: string, netgwId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResourceService>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkingProjectNetgwServiceList(projectId, locationId, netgwId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create networking/netgw.tag
         * @summary Create networking/netgw.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netgwId Netgw Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectNetgwTagCreate(projectId: string, locationId: string, netgwId: string, tag: Tag, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkingProjectNetgwTagCreate(projectId, locationId, netgwId, tag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete networking/netgw.tag
         * @summary Delete networking/netgw.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netgwId Netgw Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectNetgwTagDelete(projectId: string, locationId: string, netgwId: string, tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkingProjectNetgwTagDelete(projectId, locationId, netgwId, tagId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get networking/netgw.tag
         * @summary Get networking/netgw.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netgwId Netgw Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectNetgwTagGet(projectId: string, locationId: string, netgwId: string, tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkingProjectNetgwTagGet(projectId, locationId, netgwId, tagId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List networking/netgw.tag
         * @summary List networking/netgw.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netgwId Netgw Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectNetgwTagList(projectId: string, locationId: string, netgwId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkingProjectNetgwTagList(projectId, locationId, netgwId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Replace networking/netgw.tag
         * @summary Replace networking/netgw.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netgwId Netgw Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectNetgwTagPut(projectId: string, locationId: string, netgwId: string, tag: Array<Tag>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkingProjectNetgwTagPut(projectId, locationId, netgwId, tag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns modified netgw
         * @summary Update networking/netgw
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netgwId Netgw Id
         * @param {NetworkingProjectNetgwUpdate} networkingProjectNetgwUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectNetgwUpdate(projectId: string, locationId: string, netgwId: string, networkingProjectNetgwUpdate: NetworkingProjectNetgwUpdate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Netgw>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkingProjectNetgwUpdate(projectId, locationId, netgwId, networkingProjectNetgwUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * NetworkingProjectNetgwApi - factory interface
 * @export
 */
export const NetworkingProjectNetgwApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NetworkingProjectNetgwApiFp(configuration)
    return {
        /**
         * action attach
         * @summary Attach networking/netgw
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netgwId Netgw Id
         * @param {NetworkingProjectNetgwAttach} networkingProjectNetgwAttach 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetgwAttach(projectId: string, locationId: string, netgwId: string, networkingProjectNetgwAttach: NetworkingProjectNetgwAttach, xIdempotencyKey?: string, xDryRun?: string, options?: any): AxiosPromise<Netgw> {
            return localVarFp.networkingProjectNetgwAttach(projectId, locationId, netgwId, networkingProjectNetgwAttach, xIdempotencyKey, xDryRun, options).then((request) => request(axios, basePath));
        },
        /**
         * Create netgw
         * @summary Create networking/netgw
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {NetworkingProjectNetgwCreate} networkingProjectNetgwCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetgwCreate(projectId: string, locationId: string, networkingProjectNetgwCreate: NetworkingProjectNetgwCreate, xIdempotencyKey?: string, xDryRun?: string, options?: any): AxiosPromise<Netgw> {
            return localVarFp.networkingProjectNetgwCreate(projectId, locationId, networkingProjectNetgwCreate, xIdempotencyKey, xDryRun, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete netgw
         * @summary Delete networking/netgw
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netgwId Netgw Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetgwDelete(projectId: string, locationId: string, netgwId: string, options?: any): AxiosPromise<void> {
            return localVarFp.networkingProjectNetgwDelete(projectId, locationId, netgwId, options).then((request) => request(axios, basePath));
        },
        /**
         * action detach
         * @summary Detach networking/netgw
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netgwId Netgw Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetgwDetach(projectId: string, locationId: string, netgwId: string, xIdempotencyKey?: string, xDryRun?: string, options?: any): AxiosPromise<Netgw> {
            return localVarFp.networkingProjectNetgwDetach(projectId, locationId, netgwId, xIdempotencyKey, xDryRun, options).then((request) => request(axios, basePath));
        },
        /**
         * Get networking/netgw.event
         * @summary Get networking/netgw.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netgwId Netgw Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetgwEventGet(projectId: string, locationId: string, netgwId: string, eventId: string, options?: any): AxiosPromise<Event> {
            return localVarFp.networkingProjectNetgwEventGet(projectId, locationId, netgwId, eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * List networking/netgw.event
         * @summary List networking/netgw.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netgwId Netgw Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetgwEventList(projectId: string, locationId: string, netgwId: string, $limit?: number, $skip?: number, options?: any): AxiosPromise<Array<Event>> {
            return localVarFp.networkingProjectNetgwEventList(projectId, locationId, netgwId, $limit, $skip, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single netgw
         * @summary Get networking/netgw
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netgwId Netgw Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetgwGet(projectId: string, locationId: string, netgwId: string, options?: any): AxiosPromise<Netgw> {
            return localVarFp.networkingProjectNetgwGet(projectId, locationId, netgwId, options).then((request) => request(axios, basePath));
        },
        /**
         * List netgw
         * @summary List networking/netgw
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [name] Filter by name
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetgwList(projectId: string, locationId: string, name?: string, tagValue?: string, tagKey?: string, options?: any): AxiosPromise<Array<Netgw>> {
            return localVarFp.networkingProjectNetgwList(projectId, locationId, name, tagValue, tagKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get networking/netgw.service
         * @summary Get networking/netgw.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netgwId Netgw Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetgwServiceGet(projectId: string, locationId: string, netgwId: string, serviceId: string, options?: any): AxiosPromise<ResourceService> {
            return localVarFp.networkingProjectNetgwServiceGet(projectId, locationId, netgwId, serviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * List networking/netgw.service
         * @summary List networking/netgw.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netgwId Netgw Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetgwServiceList(projectId: string, locationId: string, netgwId: string, options?: any): AxiosPromise<Array<ResourceService>> {
            return localVarFp.networkingProjectNetgwServiceList(projectId, locationId, netgwId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create networking/netgw.tag
         * @summary Create networking/netgw.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netgwId Netgw Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetgwTagCreate(projectId: string, locationId: string, netgwId: string, tag: Tag, options?: any): AxiosPromise<Tag> {
            return localVarFp.networkingProjectNetgwTagCreate(projectId, locationId, netgwId, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete networking/netgw.tag
         * @summary Delete networking/netgw.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netgwId Netgw Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetgwTagDelete(projectId: string, locationId: string, netgwId: string, tagId: string, options?: any): AxiosPromise<void> {
            return localVarFp.networkingProjectNetgwTagDelete(projectId, locationId, netgwId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get networking/netgw.tag
         * @summary Get networking/netgw.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netgwId Netgw Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetgwTagGet(projectId: string, locationId: string, netgwId: string, tagId: string, options?: any): AxiosPromise<Tag> {
            return localVarFp.networkingProjectNetgwTagGet(projectId, locationId, netgwId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * List networking/netgw.tag
         * @summary List networking/netgw.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netgwId Netgw Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetgwTagList(projectId: string, locationId: string, netgwId: string, options?: any): AxiosPromise<Array<Tag>> {
            return localVarFp.networkingProjectNetgwTagList(projectId, locationId, netgwId, options).then((request) => request(axios, basePath));
        },
        /**
         * Replace networking/netgw.tag
         * @summary Replace networking/netgw.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netgwId Netgw Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetgwTagPut(projectId: string, locationId: string, netgwId: string, tag: Array<Tag>, options?: any): AxiosPromise<Array<Tag>> {
            return localVarFp.networkingProjectNetgwTagPut(projectId, locationId, netgwId, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns modified netgw
         * @summary Update networking/netgw
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} netgwId Netgw Id
         * @param {NetworkingProjectNetgwUpdate} networkingProjectNetgwUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetgwUpdate(projectId: string, locationId: string, netgwId: string, networkingProjectNetgwUpdate: NetworkingProjectNetgwUpdate, options?: any): AxiosPromise<Netgw> {
            return localVarFp.networkingProjectNetgwUpdate(projectId, locationId, netgwId, networkingProjectNetgwUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NetworkingProjectNetgwApi - object-oriented interface
 * @export
 * @class NetworkingProjectNetgwApi
 * @extends {BaseAPI}
 */
export class NetworkingProjectNetgwApi extends BaseAPI {
    /**
     * action attach
     * @summary Attach networking/netgw
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} netgwId Netgw Id
     * @param {NetworkingProjectNetgwAttach} networkingProjectNetgwAttach 
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {string} [xDryRun] Dry run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectNetgwApi
     */
    public networkingProjectNetgwAttach(projectId: string, locationId: string, netgwId: string, networkingProjectNetgwAttach: NetworkingProjectNetgwAttach, xIdempotencyKey?: string, xDryRun?: string, options?: any) {
        return NetworkingProjectNetgwApiFp(this.configuration).networkingProjectNetgwAttach(projectId, locationId, netgwId, networkingProjectNetgwAttach, xIdempotencyKey, xDryRun, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create netgw
     * @summary Create networking/netgw
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {NetworkingProjectNetgwCreate} networkingProjectNetgwCreate 
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {string} [xDryRun] Dry run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectNetgwApi
     */
    public networkingProjectNetgwCreate(projectId: string, locationId: string, networkingProjectNetgwCreate: NetworkingProjectNetgwCreate, xIdempotencyKey?: string, xDryRun?: string, options?: any) {
        return NetworkingProjectNetgwApiFp(this.configuration).networkingProjectNetgwCreate(projectId, locationId, networkingProjectNetgwCreate, xIdempotencyKey, xDryRun, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete netgw
     * @summary Delete networking/netgw
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} netgwId Netgw Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectNetgwApi
     */
    public networkingProjectNetgwDelete(projectId: string, locationId: string, netgwId: string, options?: any) {
        return NetworkingProjectNetgwApiFp(this.configuration).networkingProjectNetgwDelete(projectId, locationId, netgwId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * action detach
     * @summary Detach networking/netgw
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} netgwId Netgw Id
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {string} [xDryRun] Dry run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectNetgwApi
     */
    public networkingProjectNetgwDetach(projectId: string, locationId: string, netgwId: string, xIdempotencyKey?: string, xDryRun?: string, options?: any) {
        return NetworkingProjectNetgwApiFp(this.configuration).networkingProjectNetgwDetach(projectId, locationId, netgwId, xIdempotencyKey, xDryRun, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get networking/netgw.event
     * @summary Get networking/netgw.event
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} netgwId Netgw Id
     * @param {string} eventId eventId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectNetgwApi
     */
    public networkingProjectNetgwEventGet(projectId: string, locationId: string, netgwId: string, eventId: string, options?: any) {
        return NetworkingProjectNetgwApiFp(this.configuration).networkingProjectNetgwEventGet(projectId, locationId, netgwId, eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List networking/netgw.event
     * @summary List networking/netgw.event
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} netgwId Netgw Id
     * @param {number} [$limit] $limit
     * @param {number} [$skip] $skip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectNetgwApi
     */
    public networkingProjectNetgwEventList(projectId: string, locationId: string, netgwId: string, $limit?: number, $skip?: number, options?: any) {
        return NetworkingProjectNetgwApiFp(this.configuration).networkingProjectNetgwEventList(projectId, locationId, netgwId, $limit, $skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single netgw
     * @summary Get networking/netgw
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} netgwId Netgw Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectNetgwApi
     */
    public networkingProjectNetgwGet(projectId: string, locationId: string, netgwId: string, options?: any) {
        return NetworkingProjectNetgwApiFp(this.configuration).networkingProjectNetgwGet(projectId, locationId, netgwId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List netgw
     * @summary List networking/netgw
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} [name] Filter by name
     * @param {string} [tagValue] Filter by tag.value
     * @param {string} [tagKey] Filter by tag.key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectNetgwApi
     */
    public networkingProjectNetgwList(projectId: string, locationId: string, name?: string, tagValue?: string, tagKey?: string, options?: any) {
        return NetworkingProjectNetgwApiFp(this.configuration).networkingProjectNetgwList(projectId, locationId, name, tagValue, tagKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get networking/netgw.service
     * @summary Get networking/netgw.service
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} netgwId Netgw Id
     * @param {string} serviceId serviceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectNetgwApi
     */
    public networkingProjectNetgwServiceGet(projectId: string, locationId: string, netgwId: string, serviceId: string, options?: any) {
        return NetworkingProjectNetgwApiFp(this.configuration).networkingProjectNetgwServiceGet(projectId, locationId, netgwId, serviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List networking/netgw.service
     * @summary List networking/netgw.service
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} netgwId Netgw Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectNetgwApi
     */
    public networkingProjectNetgwServiceList(projectId: string, locationId: string, netgwId: string, options?: any) {
        return NetworkingProjectNetgwApiFp(this.configuration).networkingProjectNetgwServiceList(projectId, locationId, netgwId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create networking/netgw.tag
     * @summary Create networking/netgw.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} netgwId Netgw Id
     * @param {Tag} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectNetgwApi
     */
    public networkingProjectNetgwTagCreate(projectId: string, locationId: string, netgwId: string, tag: Tag, options?: any) {
        return NetworkingProjectNetgwApiFp(this.configuration).networkingProjectNetgwTagCreate(projectId, locationId, netgwId, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete networking/netgw.tag
     * @summary Delete networking/netgw.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} netgwId Netgw Id
     * @param {string} tagId tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectNetgwApi
     */
    public networkingProjectNetgwTagDelete(projectId: string, locationId: string, netgwId: string, tagId: string, options?: any) {
        return NetworkingProjectNetgwApiFp(this.configuration).networkingProjectNetgwTagDelete(projectId, locationId, netgwId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get networking/netgw.tag
     * @summary Get networking/netgw.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} netgwId Netgw Id
     * @param {string} tagId tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectNetgwApi
     */
    public networkingProjectNetgwTagGet(projectId: string, locationId: string, netgwId: string, tagId: string, options?: any) {
        return NetworkingProjectNetgwApiFp(this.configuration).networkingProjectNetgwTagGet(projectId, locationId, netgwId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List networking/netgw.tag
     * @summary List networking/netgw.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} netgwId Netgw Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectNetgwApi
     */
    public networkingProjectNetgwTagList(projectId: string, locationId: string, netgwId: string, options?: any) {
        return NetworkingProjectNetgwApiFp(this.configuration).networkingProjectNetgwTagList(projectId, locationId, netgwId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replace networking/netgw.tag
     * @summary Replace networking/netgw.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} netgwId Netgw Id
     * @param {Array<Tag>} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectNetgwApi
     */
    public networkingProjectNetgwTagPut(projectId: string, locationId: string, netgwId: string, tag: Array<Tag>, options?: any) {
        return NetworkingProjectNetgwApiFp(this.configuration).networkingProjectNetgwTagPut(projectId, locationId, netgwId, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns modified netgw
     * @summary Update networking/netgw
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} netgwId Netgw Id
     * @param {NetworkingProjectNetgwUpdate} networkingProjectNetgwUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectNetgwApi
     */
    public networkingProjectNetgwUpdate(projectId: string, locationId: string, netgwId: string, networkingProjectNetgwUpdate: NetworkingProjectNetgwUpdate, options?: any) {
        return NetworkingProjectNetgwApiFp(this.configuration).networkingProjectNetgwUpdate(projectId, locationId, netgwId, networkingProjectNetgwUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * NetworkingProjectNetworkApi - axios parameter creator
 * @export
 */
export const NetworkingProjectNetworkApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create network
         * @summary Create networking/network
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {NetworkingProjectNetworkCreate} networkingProjectNetworkCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetworkCreate: async (projectId: string, locationId: string, networkingProjectNetworkCreate: NetworkingProjectNetworkCreate, xIdempotencyKey?: string, xDryRun?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('networkingProjectNetworkCreate', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('networkingProjectNetworkCreate', 'locationId', locationId)
            // verify required parameter 'networkingProjectNetworkCreate' is not null or undefined
            assertParamExists('networkingProjectNetworkCreate', 'networkingProjectNetworkCreate', networkingProjectNetworkCreate)
            const localVarPath = `/networking/{locationId}/project/{projectId}/network`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }

            if (xDryRun !== undefined && xDryRun !== null) {
                localVarHeaderParameter['x-dry-run'] = String(xDryRun);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(networkingProjectNetworkCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete network
         * @summary Delete networking/network
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} networkId Network Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetworkDelete: async (projectId: string, locationId: string, networkId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('networkingProjectNetworkDelete', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('networkingProjectNetworkDelete', 'locationId', locationId)
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networkingProjectNetworkDelete', 'networkId', networkId)
            const localVarPath = `/networking/{locationId}/project/{projectId}/network/{networkId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"networkId"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get networking/network.event
         * @summary Get networking/network.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} networkId Network Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetworkEventGet: async (projectId: string, locationId: string, networkId: string, eventId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('networkingProjectNetworkEventGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('networkingProjectNetworkEventGet', 'locationId', locationId)
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networkingProjectNetworkEventGet', 'networkId', networkId)
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('networkingProjectNetworkEventGet', 'eventId', eventId)
            const localVarPath = `/networking/{locationId}/project/{projectId}/network/{networkId}/event/{eventId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"networkId"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List networking/network.event
         * @summary List networking/network.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} networkId Network Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetworkEventList: async (projectId: string, locationId: string, networkId: string, $limit?: number, $skip?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('networkingProjectNetworkEventList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('networkingProjectNetworkEventList', 'locationId', locationId)
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networkingProjectNetworkEventList', 'networkId', networkId)
            const localVarPath = `/networking/{locationId}/project/{projectId}/network/{networkId}/event`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"networkId"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if ($limit !== undefined) {
                localVarQueryParameter['$limit'] = $limit;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single network
         * @summary Get networking/network
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} networkId Network Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetworkGet: async (projectId: string, locationId: string, networkId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('networkingProjectNetworkGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('networkingProjectNetworkGet', 'locationId', locationId)
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networkingProjectNetworkGet', 'networkId', networkId)
            const localVarPath = `/networking/{locationId}/project/{projectId}/network/{networkId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"networkId"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List network
         * @summary List networking/network
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [name] Filter by name
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetworkList: async (projectId: string, locationId: string, name?: string, tagValue?: string, tagKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('networkingProjectNetworkList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('networkingProjectNetworkList', 'locationId', locationId)
            const localVarPath = `/networking/{locationId}/project/{projectId}/network`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (tagValue !== undefined) {
                localVarQueryParameter['tag.value'] = tagValue;
            }

            if (tagKey !== undefined) {
                localVarQueryParameter['tag.key'] = tagKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get networking/network.service
         * @summary Get networking/network.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} networkId Network Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetworkServiceGet: async (projectId: string, locationId: string, networkId: string, serviceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('networkingProjectNetworkServiceGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('networkingProjectNetworkServiceGet', 'locationId', locationId)
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networkingProjectNetworkServiceGet', 'networkId', networkId)
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('networkingProjectNetworkServiceGet', 'serviceId', serviceId)
            const localVarPath = `/networking/{locationId}/project/{projectId}/network/{networkId}/service/{serviceId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"networkId"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List networking/network.service
         * @summary List networking/network.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} networkId Network Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetworkServiceList: async (projectId: string, locationId: string, networkId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('networkingProjectNetworkServiceList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('networkingProjectNetworkServiceList', 'locationId', locationId)
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networkingProjectNetworkServiceList', 'networkId', networkId)
            const localVarPath = `/networking/{locationId}/project/{projectId}/network/{networkId}/service`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"networkId"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create networking/network.tag
         * @summary Create networking/network.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} networkId Network Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetworkTagCreate: async (projectId: string, locationId: string, networkId: string, tag: Tag, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('networkingProjectNetworkTagCreate', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('networkingProjectNetworkTagCreate', 'locationId', locationId)
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networkingProjectNetworkTagCreate', 'networkId', networkId)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('networkingProjectNetworkTagCreate', 'tag', tag)
            const localVarPath = `/networking/{locationId}/project/{projectId}/network/{networkId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"networkId"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tag, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete networking/network.tag
         * @summary Delete networking/network.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} networkId Network Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetworkTagDelete: async (projectId: string, locationId: string, networkId: string, tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('networkingProjectNetworkTagDelete', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('networkingProjectNetworkTagDelete', 'locationId', locationId)
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networkingProjectNetworkTagDelete', 'networkId', networkId)
            // verify required parameter 'tagId' is not null or undefined
            assertParamExists('networkingProjectNetworkTagDelete', 'tagId', tagId)
            const localVarPath = `/networking/{locationId}/project/{projectId}/network/{networkId}/tag/{tagId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"networkId"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get networking/network.tag
         * @summary Get networking/network.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} networkId Network Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetworkTagGet: async (projectId: string, locationId: string, networkId: string, tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('networkingProjectNetworkTagGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('networkingProjectNetworkTagGet', 'locationId', locationId)
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networkingProjectNetworkTagGet', 'networkId', networkId)
            // verify required parameter 'tagId' is not null or undefined
            assertParamExists('networkingProjectNetworkTagGet', 'tagId', tagId)
            const localVarPath = `/networking/{locationId}/project/{projectId}/network/{networkId}/tag/{tagId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"networkId"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List networking/network.tag
         * @summary List networking/network.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} networkId Network Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetworkTagList: async (projectId: string, locationId: string, networkId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('networkingProjectNetworkTagList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('networkingProjectNetworkTagList', 'locationId', locationId)
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networkingProjectNetworkTagList', 'networkId', networkId)
            const localVarPath = `/networking/{locationId}/project/{projectId}/network/{networkId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"networkId"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replace networking/network.tag
         * @summary Replace networking/network.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} networkId Network Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetworkTagPut: async (projectId: string, locationId: string, networkId: string, tag: Array<Tag>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('networkingProjectNetworkTagPut', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('networkingProjectNetworkTagPut', 'locationId', locationId)
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networkingProjectNetworkTagPut', 'networkId', networkId)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('networkingProjectNetworkTagPut', 'tag', tag)
            const localVarPath = `/networking/{locationId}/project/{projectId}/network/{networkId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"networkId"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tag, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns modified network
         * @summary Update networking/network
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} networkId Network Id
         * @param {NetworkingProjectNetworkUpdate} networkingProjectNetworkUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetworkUpdate: async (projectId: string, locationId: string, networkId: string, networkingProjectNetworkUpdate: NetworkingProjectNetworkUpdate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('networkingProjectNetworkUpdate', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('networkingProjectNetworkUpdate', 'locationId', locationId)
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networkingProjectNetworkUpdate', 'networkId', networkId)
            // verify required parameter 'networkingProjectNetworkUpdate' is not null or undefined
            assertParamExists('networkingProjectNetworkUpdate', 'networkingProjectNetworkUpdate', networkingProjectNetworkUpdate)
            const localVarPath = `/networking/{locationId}/project/{projectId}/network/{networkId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"networkId"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(networkingProjectNetworkUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NetworkingProjectNetworkApi - functional programming interface
 * @export
 */
export const NetworkingProjectNetworkApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NetworkingProjectNetworkApiAxiosParamCreator(configuration)
    return {
        /**
         * Create network
         * @summary Create networking/network
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {NetworkingProjectNetworkCreate} networkingProjectNetworkCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectNetworkCreate(projectId: string, locationId: string, networkingProjectNetworkCreate: NetworkingProjectNetworkCreate, xIdempotencyKey?: string, xDryRun?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Network>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkingProjectNetworkCreate(projectId, locationId, networkingProjectNetworkCreate, xIdempotencyKey, xDryRun, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete network
         * @summary Delete networking/network
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} networkId Network Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectNetworkDelete(projectId: string, locationId: string, networkId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkingProjectNetworkDelete(projectId, locationId, networkId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get networking/network.event
         * @summary Get networking/network.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} networkId Network Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectNetworkEventGet(projectId: string, locationId: string, networkId: string, eventId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkingProjectNetworkEventGet(projectId, locationId, networkId, eventId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List networking/network.event
         * @summary List networking/network.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} networkId Network Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectNetworkEventList(projectId: string, locationId: string, networkId: string, $limit?: number, $skip?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Event>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkingProjectNetworkEventList(projectId, locationId, networkId, $limit, $skip, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a single network
         * @summary Get networking/network
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} networkId Network Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectNetworkGet(projectId: string, locationId: string, networkId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Network>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkingProjectNetworkGet(projectId, locationId, networkId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List network
         * @summary List networking/network
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [name] Filter by name
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectNetworkList(projectId: string, locationId: string, name?: string, tagValue?: string, tagKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Network>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkingProjectNetworkList(projectId, locationId, name, tagValue, tagKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get networking/network.service
         * @summary Get networking/network.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} networkId Network Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectNetworkServiceGet(projectId: string, locationId: string, networkId: string, serviceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceService>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkingProjectNetworkServiceGet(projectId, locationId, networkId, serviceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List networking/network.service
         * @summary List networking/network.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} networkId Network Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectNetworkServiceList(projectId: string, locationId: string, networkId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResourceService>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkingProjectNetworkServiceList(projectId, locationId, networkId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create networking/network.tag
         * @summary Create networking/network.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} networkId Network Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectNetworkTagCreate(projectId: string, locationId: string, networkId: string, tag: Tag, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkingProjectNetworkTagCreate(projectId, locationId, networkId, tag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete networking/network.tag
         * @summary Delete networking/network.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} networkId Network Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectNetworkTagDelete(projectId: string, locationId: string, networkId: string, tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkingProjectNetworkTagDelete(projectId, locationId, networkId, tagId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get networking/network.tag
         * @summary Get networking/network.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} networkId Network Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectNetworkTagGet(projectId: string, locationId: string, networkId: string, tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkingProjectNetworkTagGet(projectId, locationId, networkId, tagId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List networking/network.tag
         * @summary List networking/network.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} networkId Network Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectNetworkTagList(projectId: string, locationId: string, networkId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkingProjectNetworkTagList(projectId, locationId, networkId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Replace networking/network.tag
         * @summary Replace networking/network.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} networkId Network Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectNetworkTagPut(projectId: string, locationId: string, networkId: string, tag: Array<Tag>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkingProjectNetworkTagPut(projectId, locationId, networkId, tag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns modified network
         * @summary Update networking/network
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} networkId Network Id
         * @param {NetworkingProjectNetworkUpdate} networkingProjectNetworkUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkingProjectNetworkUpdate(projectId: string, locationId: string, networkId: string, networkingProjectNetworkUpdate: NetworkingProjectNetworkUpdate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Network>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkingProjectNetworkUpdate(projectId, locationId, networkId, networkingProjectNetworkUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * NetworkingProjectNetworkApi - factory interface
 * @export
 */
export const NetworkingProjectNetworkApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NetworkingProjectNetworkApiFp(configuration)
    return {
        /**
         * Create network
         * @summary Create networking/network
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {NetworkingProjectNetworkCreate} networkingProjectNetworkCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetworkCreate(projectId: string, locationId: string, networkingProjectNetworkCreate: NetworkingProjectNetworkCreate, xIdempotencyKey?: string, xDryRun?: string, options?: any): AxiosPromise<Network> {
            return localVarFp.networkingProjectNetworkCreate(projectId, locationId, networkingProjectNetworkCreate, xIdempotencyKey, xDryRun, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete network
         * @summary Delete networking/network
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} networkId Network Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetworkDelete(projectId: string, locationId: string, networkId: string, options?: any): AxiosPromise<void> {
            return localVarFp.networkingProjectNetworkDelete(projectId, locationId, networkId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get networking/network.event
         * @summary Get networking/network.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} networkId Network Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetworkEventGet(projectId: string, locationId: string, networkId: string, eventId: string, options?: any): AxiosPromise<Event> {
            return localVarFp.networkingProjectNetworkEventGet(projectId, locationId, networkId, eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * List networking/network.event
         * @summary List networking/network.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} networkId Network Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetworkEventList(projectId: string, locationId: string, networkId: string, $limit?: number, $skip?: number, options?: any): AxiosPromise<Array<Event>> {
            return localVarFp.networkingProjectNetworkEventList(projectId, locationId, networkId, $limit, $skip, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single network
         * @summary Get networking/network
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} networkId Network Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetworkGet(projectId: string, locationId: string, networkId: string, options?: any): AxiosPromise<Network> {
            return localVarFp.networkingProjectNetworkGet(projectId, locationId, networkId, options).then((request) => request(axios, basePath));
        },
        /**
         * List network
         * @summary List networking/network
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [name] Filter by name
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetworkList(projectId: string, locationId: string, name?: string, tagValue?: string, tagKey?: string, options?: any): AxiosPromise<Array<Network>> {
            return localVarFp.networkingProjectNetworkList(projectId, locationId, name, tagValue, tagKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get networking/network.service
         * @summary Get networking/network.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} networkId Network Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetworkServiceGet(projectId: string, locationId: string, networkId: string, serviceId: string, options?: any): AxiosPromise<ResourceService> {
            return localVarFp.networkingProjectNetworkServiceGet(projectId, locationId, networkId, serviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * List networking/network.service
         * @summary List networking/network.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} networkId Network Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetworkServiceList(projectId: string, locationId: string, networkId: string, options?: any): AxiosPromise<Array<ResourceService>> {
            return localVarFp.networkingProjectNetworkServiceList(projectId, locationId, networkId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create networking/network.tag
         * @summary Create networking/network.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} networkId Network Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetworkTagCreate(projectId: string, locationId: string, networkId: string, tag: Tag, options?: any): AxiosPromise<Tag> {
            return localVarFp.networkingProjectNetworkTagCreate(projectId, locationId, networkId, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete networking/network.tag
         * @summary Delete networking/network.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} networkId Network Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetworkTagDelete(projectId: string, locationId: string, networkId: string, tagId: string, options?: any): AxiosPromise<void> {
            return localVarFp.networkingProjectNetworkTagDelete(projectId, locationId, networkId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get networking/network.tag
         * @summary Get networking/network.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} networkId Network Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetworkTagGet(projectId: string, locationId: string, networkId: string, tagId: string, options?: any): AxiosPromise<Tag> {
            return localVarFp.networkingProjectNetworkTagGet(projectId, locationId, networkId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * List networking/network.tag
         * @summary List networking/network.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} networkId Network Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetworkTagList(projectId: string, locationId: string, networkId: string, options?: any): AxiosPromise<Array<Tag>> {
            return localVarFp.networkingProjectNetworkTagList(projectId, locationId, networkId, options).then((request) => request(axios, basePath));
        },
        /**
         * Replace networking/network.tag
         * @summary Replace networking/network.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} networkId Network Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetworkTagPut(projectId: string, locationId: string, networkId: string, tag: Array<Tag>, options?: any): AxiosPromise<Array<Tag>> {
            return localVarFp.networkingProjectNetworkTagPut(projectId, locationId, networkId, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns modified network
         * @summary Update networking/network
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} networkId Network Id
         * @param {NetworkingProjectNetworkUpdate} networkingProjectNetworkUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkingProjectNetworkUpdate(projectId: string, locationId: string, networkId: string, networkingProjectNetworkUpdate: NetworkingProjectNetworkUpdate, options?: any): AxiosPromise<Network> {
            return localVarFp.networkingProjectNetworkUpdate(projectId, locationId, networkId, networkingProjectNetworkUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NetworkingProjectNetworkApi - object-oriented interface
 * @export
 * @class NetworkingProjectNetworkApi
 * @extends {BaseAPI}
 */
export class NetworkingProjectNetworkApi extends BaseAPI {
    /**
     * Create network
     * @summary Create networking/network
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {NetworkingProjectNetworkCreate} networkingProjectNetworkCreate 
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {string} [xDryRun] Dry run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectNetworkApi
     */
    public networkingProjectNetworkCreate(projectId: string, locationId: string, networkingProjectNetworkCreate: NetworkingProjectNetworkCreate, xIdempotencyKey?: string, xDryRun?: string, options?: any) {
        return NetworkingProjectNetworkApiFp(this.configuration).networkingProjectNetworkCreate(projectId, locationId, networkingProjectNetworkCreate, xIdempotencyKey, xDryRun, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete network
     * @summary Delete networking/network
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} networkId Network Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectNetworkApi
     */
    public networkingProjectNetworkDelete(projectId: string, locationId: string, networkId: string, options?: any) {
        return NetworkingProjectNetworkApiFp(this.configuration).networkingProjectNetworkDelete(projectId, locationId, networkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get networking/network.event
     * @summary Get networking/network.event
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} networkId Network Id
     * @param {string} eventId eventId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectNetworkApi
     */
    public networkingProjectNetworkEventGet(projectId: string, locationId: string, networkId: string, eventId: string, options?: any) {
        return NetworkingProjectNetworkApiFp(this.configuration).networkingProjectNetworkEventGet(projectId, locationId, networkId, eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List networking/network.event
     * @summary List networking/network.event
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} networkId Network Id
     * @param {number} [$limit] $limit
     * @param {number} [$skip] $skip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectNetworkApi
     */
    public networkingProjectNetworkEventList(projectId: string, locationId: string, networkId: string, $limit?: number, $skip?: number, options?: any) {
        return NetworkingProjectNetworkApiFp(this.configuration).networkingProjectNetworkEventList(projectId, locationId, networkId, $limit, $skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single network
     * @summary Get networking/network
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} networkId Network Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectNetworkApi
     */
    public networkingProjectNetworkGet(projectId: string, locationId: string, networkId: string, options?: any) {
        return NetworkingProjectNetworkApiFp(this.configuration).networkingProjectNetworkGet(projectId, locationId, networkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List network
     * @summary List networking/network
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} [name] Filter by name
     * @param {string} [tagValue] Filter by tag.value
     * @param {string} [tagKey] Filter by tag.key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectNetworkApi
     */
    public networkingProjectNetworkList(projectId: string, locationId: string, name?: string, tagValue?: string, tagKey?: string, options?: any) {
        return NetworkingProjectNetworkApiFp(this.configuration).networkingProjectNetworkList(projectId, locationId, name, tagValue, tagKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get networking/network.service
     * @summary Get networking/network.service
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} networkId Network Id
     * @param {string} serviceId serviceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectNetworkApi
     */
    public networkingProjectNetworkServiceGet(projectId: string, locationId: string, networkId: string, serviceId: string, options?: any) {
        return NetworkingProjectNetworkApiFp(this.configuration).networkingProjectNetworkServiceGet(projectId, locationId, networkId, serviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List networking/network.service
     * @summary List networking/network.service
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} networkId Network Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectNetworkApi
     */
    public networkingProjectNetworkServiceList(projectId: string, locationId: string, networkId: string, options?: any) {
        return NetworkingProjectNetworkApiFp(this.configuration).networkingProjectNetworkServiceList(projectId, locationId, networkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create networking/network.tag
     * @summary Create networking/network.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} networkId Network Id
     * @param {Tag} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectNetworkApi
     */
    public networkingProjectNetworkTagCreate(projectId: string, locationId: string, networkId: string, tag: Tag, options?: any) {
        return NetworkingProjectNetworkApiFp(this.configuration).networkingProjectNetworkTagCreate(projectId, locationId, networkId, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete networking/network.tag
     * @summary Delete networking/network.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} networkId Network Id
     * @param {string} tagId tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectNetworkApi
     */
    public networkingProjectNetworkTagDelete(projectId: string, locationId: string, networkId: string, tagId: string, options?: any) {
        return NetworkingProjectNetworkApiFp(this.configuration).networkingProjectNetworkTagDelete(projectId, locationId, networkId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get networking/network.tag
     * @summary Get networking/network.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} networkId Network Id
     * @param {string} tagId tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectNetworkApi
     */
    public networkingProjectNetworkTagGet(projectId: string, locationId: string, networkId: string, tagId: string, options?: any) {
        return NetworkingProjectNetworkApiFp(this.configuration).networkingProjectNetworkTagGet(projectId, locationId, networkId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List networking/network.tag
     * @summary List networking/network.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} networkId Network Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectNetworkApi
     */
    public networkingProjectNetworkTagList(projectId: string, locationId: string, networkId: string, options?: any) {
        return NetworkingProjectNetworkApiFp(this.configuration).networkingProjectNetworkTagList(projectId, locationId, networkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replace networking/network.tag
     * @summary Replace networking/network.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} networkId Network Id
     * @param {Array<Tag>} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectNetworkApi
     */
    public networkingProjectNetworkTagPut(projectId: string, locationId: string, networkId: string, tag: Array<Tag>, options?: any) {
        return NetworkingProjectNetworkApiFp(this.configuration).networkingProjectNetworkTagPut(projectId, locationId, networkId, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns modified network
     * @summary Update networking/network
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} networkId Network Id
     * @param {NetworkingProjectNetworkUpdate} networkingProjectNetworkUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingProjectNetworkApi
     */
    public networkingProjectNetworkUpdate(projectId: string, locationId: string, networkId: string, networkingProjectNetworkUpdate: NetworkingProjectNetworkUpdate, options?: any) {
        return NetworkingProjectNetworkApiFp(this.configuration).networkingProjectNetworkUpdate(projectId, locationId, networkId, networkingProjectNetworkUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProviderProjectAgentApi - axios parameter creator
 * @export
 */
export const ProviderProjectAgentApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create agent
         * @summary Create provider/agent
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {ProviderProjectAgentCreate} providerProjectAgentCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentCreate: async (projectId: string, locationId: string, providerProjectAgentCreate: ProviderProjectAgentCreate, xIdempotencyKey?: string, xDryRun?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('providerProjectAgentCreate', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('providerProjectAgentCreate', 'locationId', locationId)
            // verify required parameter 'providerProjectAgentCreate' is not null or undefined
            assertParamExists('providerProjectAgentCreate', 'providerProjectAgentCreate', providerProjectAgentCreate)
            const localVarPath = `/provider/{locationId}/project/{projectId}/agent`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }

            if (xDryRun !== undefined && xDryRun !== null) {
                localVarHeaderParameter['x-dry-run'] = String(xDryRun);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(providerProjectAgentCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create provider/agent.credential
         * @summary Create provider/agent.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {AgentCredential} agentCredential 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentCredentialCreate: async (projectId: string, locationId: string, agentId: string, agentCredential: AgentCredential, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('providerProjectAgentCredentialCreate', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('providerProjectAgentCredentialCreate', 'locationId', locationId)
            // verify required parameter 'agentId' is not null or undefined
            assertParamExists('providerProjectAgentCredentialCreate', 'agentId', agentId)
            // verify required parameter 'agentCredential' is not null or undefined
            assertParamExists('providerProjectAgentCredentialCreate', 'agentCredential', agentCredential)
            const localVarPath = `/provider/{locationId}/project/{projectId}/agent/{agentId}/credential`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"agentId"}}`, encodeURIComponent(String(agentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(agentCredential, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete provider/agent.credential
         * @summary Delete provider/agent.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {string} credentialId credentialId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentCredentialDelete: async (projectId: string, locationId: string, agentId: string, credentialId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('providerProjectAgentCredentialDelete', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('providerProjectAgentCredentialDelete', 'locationId', locationId)
            // verify required parameter 'agentId' is not null or undefined
            assertParamExists('providerProjectAgentCredentialDelete', 'agentId', agentId)
            // verify required parameter 'credentialId' is not null or undefined
            assertParamExists('providerProjectAgentCredentialDelete', 'credentialId', credentialId)
            const localVarPath = `/provider/{locationId}/project/{projectId}/agent/{agentId}/credential/{credentialId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"agentId"}}`, encodeURIComponent(String(agentId)))
                .replace(`{${"credentialId"}}`, encodeURIComponent(String(credentialId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get provider/agent.credential
         * @summary Get provider/agent.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {string} credentialId credentialId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentCredentialGet: async (projectId: string, locationId: string, agentId: string, credentialId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('providerProjectAgentCredentialGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('providerProjectAgentCredentialGet', 'locationId', locationId)
            // verify required parameter 'agentId' is not null or undefined
            assertParamExists('providerProjectAgentCredentialGet', 'agentId', agentId)
            // verify required parameter 'credentialId' is not null or undefined
            assertParamExists('providerProjectAgentCredentialGet', 'credentialId', credentialId)
            const localVarPath = `/provider/{locationId}/project/{projectId}/agent/{agentId}/credential/{credentialId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"agentId"}}`, encodeURIComponent(String(agentId)))
                .replace(`{${"credentialId"}}`, encodeURIComponent(String(credentialId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List provider/agent.credential
         * @summary List provider/agent.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentCredentialList: async (projectId: string, locationId: string, agentId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('providerProjectAgentCredentialList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('providerProjectAgentCredentialList', 'locationId', locationId)
            // verify required parameter 'agentId' is not null or undefined
            assertParamExists('providerProjectAgentCredentialList', 'agentId', agentId)
            const localVarPath = `/provider/{locationId}/project/{projectId}/agent/{agentId}/credential`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"agentId"}}`, encodeURIComponent(String(agentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update provider/agent.credential
         * @summary Update provider/agent.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {string} credentialId credentialId
         * @param {ProviderProjectAgentCredentialPatch} providerProjectAgentCredentialPatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentCredentialPatch: async (projectId: string, locationId: string, agentId: string, credentialId: string, providerProjectAgentCredentialPatch: ProviderProjectAgentCredentialPatch, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('providerProjectAgentCredentialPatch', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('providerProjectAgentCredentialPatch', 'locationId', locationId)
            // verify required parameter 'agentId' is not null or undefined
            assertParamExists('providerProjectAgentCredentialPatch', 'agentId', agentId)
            // verify required parameter 'credentialId' is not null or undefined
            assertParamExists('providerProjectAgentCredentialPatch', 'credentialId', credentialId)
            // verify required parameter 'providerProjectAgentCredentialPatch' is not null or undefined
            assertParamExists('providerProjectAgentCredentialPatch', 'providerProjectAgentCredentialPatch', providerProjectAgentCredentialPatch)
            const localVarPath = `/provider/{locationId}/project/{projectId}/agent/{agentId}/credential/{credentialId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"agentId"}}`, encodeURIComponent(String(agentId)))
                .replace(`{${"credentialId"}}`, encodeURIComponent(String(credentialId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(providerProjectAgentCredentialPatch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete agent
         * @summary Delete provider/agent
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentDelete: async (projectId: string, locationId: string, agentId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('providerProjectAgentDelete', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('providerProjectAgentDelete', 'locationId', locationId)
            // verify required parameter 'agentId' is not null or undefined
            assertParamExists('providerProjectAgentDelete', 'agentId', agentId)
            const localVarPath = `/provider/{locationId}/project/{projectId}/agent/{agentId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"agentId"}}`, encodeURIComponent(String(agentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create provider/agent.enabledService
         * @summary Create provider/agent.enabledService
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {EnabledService} enabledService 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentEnabledServiceCreate: async (projectId: string, locationId: string, agentId: string, enabledService: EnabledService, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('providerProjectAgentEnabledServiceCreate', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('providerProjectAgentEnabledServiceCreate', 'locationId', locationId)
            // verify required parameter 'agentId' is not null or undefined
            assertParamExists('providerProjectAgentEnabledServiceCreate', 'agentId', agentId)
            // verify required parameter 'enabledService' is not null or undefined
            assertParamExists('providerProjectAgentEnabledServiceCreate', 'enabledService', enabledService)
            const localVarPath = `/provider/{locationId}/project/{projectId}/agent/{agentId}/enabledService`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"agentId"}}`, encodeURIComponent(String(agentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(enabledService, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete provider/agent.enabledService
         * @summary Delete provider/agent.enabledService
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {string} enabledServiceId enabledServiceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentEnabledServiceDelete: async (projectId: string, locationId: string, agentId: string, enabledServiceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('providerProjectAgentEnabledServiceDelete', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('providerProjectAgentEnabledServiceDelete', 'locationId', locationId)
            // verify required parameter 'agentId' is not null or undefined
            assertParamExists('providerProjectAgentEnabledServiceDelete', 'agentId', agentId)
            // verify required parameter 'enabledServiceId' is not null or undefined
            assertParamExists('providerProjectAgentEnabledServiceDelete', 'enabledServiceId', enabledServiceId)
            const localVarPath = `/provider/{locationId}/project/{projectId}/agent/{agentId}/enabledService/{enabledServiceId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"agentId"}}`, encodeURIComponent(String(agentId)))
                .replace(`{${"enabledServiceId"}}`, encodeURIComponent(String(enabledServiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get provider/agent.enabledService
         * @summary Get provider/agent.enabledService
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {string} enabledServiceId enabledServiceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentEnabledServiceGet: async (projectId: string, locationId: string, agentId: string, enabledServiceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('providerProjectAgentEnabledServiceGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('providerProjectAgentEnabledServiceGet', 'locationId', locationId)
            // verify required parameter 'agentId' is not null or undefined
            assertParamExists('providerProjectAgentEnabledServiceGet', 'agentId', agentId)
            // verify required parameter 'enabledServiceId' is not null or undefined
            assertParamExists('providerProjectAgentEnabledServiceGet', 'enabledServiceId', enabledServiceId)
            const localVarPath = `/provider/{locationId}/project/{projectId}/agent/{agentId}/enabledService/{enabledServiceId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"agentId"}}`, encodeURIComponent(String(agentId)))
                .replace(`{${"enabledServiceId"}}`, encodeURIComponent(String(enabledServiceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List provider/agent.enabledService
         * @summary List provider/agent.enabledService
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentEnabledServiceList: async (projectId: string, locationId: string, agentId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('providerProjectAgentEnabledServiceList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('providerProjectAgentEnabledServiceList', 'locationId', locationId)
            // verify required parameter 'agentId' is not null or undefined
            assertParamExists('providerProjectAgentEnabledServiceList', 'agentId', agentId)
            const localVarPath = `/provider/{locationId}/project/{projectId}/agent/{agentId}/enabledService`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"agentId"}}`, encodeURIComponent(String(agentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get provider/agent.event
         * @summary Get provider/agent.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentEventGet: async (projectId: string, locationId: string, agentId: string, eventId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('providerProjectAgentEventGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('providerProjectAgentEventGet', 'locationId', locationId)
            // verify required parameter 'agentId' is not null or undefined
            assertParamExists('providerProjectAgentEventGet', 'agentId', agentId)
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('providerProjectAgentEventGet', 'eventId', eventId)
            const localVarPath = `/provider/{locationId}/project/{projectId}/agent/{agentId}/event/{eventId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"agentId"}}`, encodeURIComponent(String(agentId)))
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List provider/agent.event
         * @summary List provider/agent.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentEventList: async (projectId: string, locationId: string, agentId: string, $limit?: number, $skip?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('providerProjectAgentEventList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('providerProjectAgentEventList', 'locationId', locationId)
            // verify required parameter 'agentId' is not null or undefined
            assertParamExists('providerProjectAgentEventList', 'agentId', agentId)
            const localVarPath = `/provider/{locationId}/project/{projectId}/agent/{agentId}/event`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"agentId"}}`, encodeURIComponent(String(agentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if ($limit !== undefined) {
                localVarQueryParameter['$limit'] = $limit;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single agent
         * @summary Get provider/agent
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentGet: async (projectId: string, locationId: string, agentId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('providerProjectAgentGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('providerProjectAgentGet', 'locationId', locationId)
            // verify required parameter 'agentId' is not null or undefined
            assertParamExists('providerProjectAgentGet', 'agentId', agentId)
            const localVarPath = `/provider/{locationId}/project/{projectId}/agent/{agentId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"agentId"}}`, encodeURIComponent(String(agentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * action inspect
         * @summary Inspect provider/agent
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentInspect: async (projectId: string, locationId: string, agentId: string, xIdempotencyKey?: string, xDryRun?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('providerProjectAgentInspect', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('providerProjectAgentInspect', 'locationId', locationId)
            // verify required parameter 'agentId' is not null or undefined
            assertParamExists('providerProjectAgentInspect', 'agentId', agentId)
            const localVarPath = `/provider/{locationId}/project/{projectId}/agent/{agentId}/actions/inspect`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"agentId"}}`, encodeURIComponent(String(agentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }

            if (xDryRun !== undefined && xDryRun !== null) {
                localVarHeaderParameter['x-dry-run'] = String(xDryRun);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List agent
         * @summary List provider/agent
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [name] Filter by name
         * @param {string} [enabledServices] Filter by enabledServices
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentList: async (projectId: string, locationId: string, name?: string, enabledServices?: string, tagValue?: string, tagKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('providerProjectAgentList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('providerProjectAgentList', 'locationId', locationId)
            const localVarPath = `/provider/{locationId}/project/{projectId}/agent`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (enabledServices !== undefined) {
                localVarQueryParameter['enabledServices'] = enabledServices;
            }

            if (tagValue !== undefined) {
                localVarQueryParameter['tag.value'] = tagValue;
            }

            if (tagKey !== undefined) {
                localVarQueryParameter['tag.key'] = tagKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get provider/agent.metric
         * @summary Get provider/agent.metric
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {string} metricId metricId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentMetricGet: async (projectId: string, locationId: string, agentId: string, metricId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('providerProjectAgentMetricGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('providerProjectAgentMetricGet', 'locationId', locationId)
            // verify required parameter 'agentId' is not null or undefined
            assertParamExists('providerProjectAgentMetricGet', 'agentId', agentId)
            // verify required parameter 'metricId' is not null or undefined
            assertParamExists('providerProjectAgentMetricGet', 'metricId', metricId)
            const localVarPath = `/provider/{locationId}/project/{projectId}/agent/{agentId}/metric/{metricId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"agentId"}}`, encodeURIComponent(String(agentId)))
                .replace(`{${"metricId"}}`, encodeURIComponent(String(metricId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List provider/agent.metric
         * @summary List provider/agent.metric
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentMetricList: async (projectId: string, locationId: string, agentId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('providerProjectAgentMetricList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('providerProjectAgentMetricList', 'locationId', locationId)
            // verify required parameter 'agentId' is not null or undefined
            assertParamExists('providerProjectAgentMetricList', 'agentId', agentId)
            const localVarPath = `/provider/{locationId}/project/{projectId}/agent/{agentId}/metric`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"agentId"}}`, encodeURIComponent(String(agentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List provider/agent.point
         * @summary List provider/agent.point
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {string} metricId metricId
         * @param {string} [interval] interval
         * @param {string} [timespan] timespan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentMetricPointList: async (projectId: string, locationId: string, agentId: string, metricId: string, interval?: string, timespan?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('providerProjectAgentMetricPointList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('providerProjectAgentMetricPointList', 'locationId', locationId)
            // verify required parameter 'agentId' is not null or undefined
            assertParamExists('providerProjectAgentMetricPointList', 'agentId', agentId)
            // verify required parameter 'metricId' is not null or undefined
            assertParamExists('providerProjectAgentMetricPointList', 'metricId', metricId)
            const localVarPath = `/provider/{locationId}/project/{projectId}/agent/{agentId}/metric/{metricId}/point`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"agentId"}}`, encodeURIComponent(String(agentId)))
                .replace(`{${"metricId"}}`, encodeURIComponent(String(metricId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (timespan !== undefined) {
                localVarQueryParameter['timespan'] = timespan;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List provider/agent.event
         * @summary List provider/agent.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {string} resourceId resourceId
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentResourceEventList: async (projectId: string, locationId: string, agentId: string, resourceId: string, $limit?: number, $skip?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('providerProjectAgentResourceEventList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('providerProjectAgentResourceEventList', 'locationId', locationId)
            // verify required parameter 'agentId' is not null or undefined
            assertParamExists('providerProjectAgentResourceEventList', 'agentId', agentId)
            // verify required parameter 'resourceId' is not null or undefined
            assertParamExists('providerProjectAgentResourceEventList', 'resourceId', resourceId)
            const localVarPath = `/provider/{locationId}/project/{projectId}/agent/{agentId}/resource/{resourceId}/event`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"agentId"}}`, encodeURIComponent(String(agentId)))
                .replace(`{${"resourceId"}}`, encodeURIComponent(String(resourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if ($limit !== undefined) {
                localVarQueryParameter['$limit'] = $limit;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get provider/agent.resource
         * @summary Get provider/agent.resource
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {string} resourceId resourceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentResourceGet: async (projectId: string, locationId: string, agentId: string, resourceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('providerProjectAgentResourceGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('providerProjectAgentResourceGet', 'locationId', locationId)
            // verify required parameter 'agentId' is not null or undefined
            assertParamExists('providerProjectAgentResourceGet', 'agentId', agentId)
            // verify required parameter 'resourceId' is not null or undefined
            assertParamExists('providerProjectAgentResourceGet', 'resourceId', resourceId)
            const localVarPath = `/provider/{locationId}/project/{projectId}/agent/{agentId}/resource/{resourceId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"agentId"}}`, encodeURIComponent(String(agentId)))
                .replace(`{${"resourceId"}}`, encodeURIComponent(String(resourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * action inspect
         * @summary Inspect provider/agent.resource
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {string} resourceId resourceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentResourceInspect: async (projectId: string, locationId: string, agentId: string, resourceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('providerProjectAgentResourceInspect', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('providerProjectAgentResourceInspect', 'locationId', locationId)
            // verify required parameter 'agentId' is not null or undefined
            assertParamExists('providerProjectAgentResourceInspect', 'agentId', agentId)
            // verify required parameter 'resourceId' is not null or undefined
            assertParamExists('providerProjectAgentResourceInspect', 'resourceId', resourceId)
            const localVarPath = `/provider/{locationId}/project/{projectId}/agent/{agentId}/resource/{resourceId}/actions/inspect`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"agentId"}}`, encodeURIComponent(String(agentId)))
                .replace(`{${"resourceId"}}`, encodeURIComponent(String(resourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List provider/agent.resource
         * @summary List provider/agent.resource
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentResourceList: async (projectId: string, locationId: string, agentId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('providerProjectAgentResourceList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('providerProjectAgentResourceList', 'locationId', locationId)
            // verify required parameter 'agentId' is not null or undefined
            assertParamExists('providerProjectAgentResourceList', 'agentId', agentId)
            const localVarPath = `/provider/{locationId}/project/{projectId}/agent/{agentId}/resource`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"agentId"}}`, encodeURIComponent(String(agentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * action recreate
         * @summary Recreate provider/agent.resource
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {string} resourceId resourceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentResourceRecreate: async (projectId: string, locationId: string, agentId: string, resourceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('providerProjectAgentResourceRecreate', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('providerProjectAgentResourceRecreate', 'locationId', locationId)
            // verify required parameter 'agentId' is not null or undefined
            assertParamExists('providerProjectAgentResourceRecreate', 'agentId', agentId)
            // verify required parameter 'resourceId' is not null or undefined
            assertParamExists('providerProjectAgentResourceRecreate', 'resourceId', resourceId)
            const localVarPath = `/provider/{locationId}/project/{projectId}/agent/{agentId}/resource/{resourceId}/actions/recreate`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"agentId"}}`, encodeURIComponent(String(agentId)))
                .replace(`{${"resourceId"}}`, encodeURIComponent(String(resourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get provider/agent.service
         * @summary Get provider/agent.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentServiceGet: async (projectId: string, locationId: string, agentId: string, serviceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('providerProjectAgentServiceGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('providerProjectAgentServiceGet', 'locationId', locationId)
            // verify required parameter 'agentId' is not null or undefined
            assertParamExists('providerProjectAgentServiceGet', 'agentId', agentId)
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('providerProjectAgentServiceGet', 'serviceId', serviceId)
            const localVarPath = `/provider/{locationId}/project/{projectId}/agent/{agentId}/service/{serviceId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"agentId"}}`, encodeURIComponent(String(agentId)))
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List provider/agent.service
         * @summary List provider/agent.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentServiceList: async (projectId: string, locationId: string, agentId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('providerProjectAgentServiceList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('providerProjectAgentServiceList', 'locationId', locationId)
            // verify required parameter 'agentId' is not null or undefined
            assertParamExists('providerProjectAgentServiceList', 'agentId', agentId)
            const localVarPath = `/provider/{locationId}/project/{projectId}/agent/{agentId}/service`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"agentId"}}`, encodeURIComponent(String(agentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * action start
         * @summary Start provider/agent
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentStart: async (projectId: string, locationId: string, agentId: string, xIdempotencyKey?: string, xDryRun?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('providerProjectAgentStart', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('providerProjectAgentStart', 'locationId', locationId)
            // verify required parameter 'agentId' is not null or undefined
            assertParamExists('providerProjectAgentStart', 'agentId', agentId)
            const localVarPath = `/provider/{locationId}/project/{projectId}/agent/{agentId}/actions/start`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"agentId"}}`, encodeURIComponent(String(agentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }

            if (xDryRun !== undefined && xDryRun !== null) {
                localVarHeaderParameter['x-dry-run'] = String(xDryRun);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * action suspend
         * @summary Suspend provider/agent
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentSuspend: async (projectId: string, locationId: string, agentId: string, xIdempotencyKey?: string, xDryRun?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('providerProjectAgentSuspend', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('providerProjectAgentSuspend', 'locationId', locationId)
            // verify required parameter 'agentId' is not null or undefined
            assertParamExists('providerProjectAgentSuspend', 'agentId', agentId)
            const localVarPath = `/provider/{locationId}/project/{projectId}/agent/{agentId}/actions/suspend`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"agentId"}}`, encodeURIComponent(String(agentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }

            if (xDryRun !== undefined && xDryRun !== null) {
                localVarHeaderParameter['x-dry-run'] = String(xDryRun);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create provider/agent.tag
         * @summary Create provider/agent.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentTagCreate: async (projectId: string, locationId: string, agentId: string, tag: Tag, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('providerProjectAgentTagCreate', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('providerProjectAgentTagCreate', 'locationId', locationId)
            // verify required parameter 'agentId' is not null or undefined
            assertParamExists('providerProjectAgentTagCreate', 'agentId', agentId)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('providerProjectAgentTagCreate', 'tag', tag)
            const localVarPath = `/provider/{locationId}/project/{projectId}/agent/{agentId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"agentId"}}`, encodeURIComponent(String(agentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tag, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete provider/agent.tag
         * @summary Delete provider/agent.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentTagDelete: async (projectId: string, locationId: string, agentId: string, tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('providerProjectAgentTagDelete', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('providerProjectAgentTagDelete', 'locationId', locationId)
            // verify required parameter 'agentId' is not null or undefined
            assertParamExists('providerProjectAgentTagDelete', 'agentId', agentId)
            // verify required parameter 'tagId' is not null or undefined
            assertParamExists('providerProjectAgentTagDelete', 'tagId', tagId)
            const localVarPath = `/provider/{locationId}/project/{projectId}/agent/{agentId}/tag/{tagId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"agentId"}}`, encodeURIComponent(String(agentId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get provider/agent.tag
         * @summary Get provider/agent.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentTagGet: async (projectId: string, locationId: string, agentId: string, tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('providerProjectAgentTagGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('providerProjectAgentTagGet', 'locationId', locationId)
            // verify required parameter 'agentId' is not null or undefined
            assertParamExists('providerProjectAgentTagGet', 'agentId', agentId)
            // verify required parameter 'tagId' is not null or undefined
            assertParamExists('providerProjectAgentTagGet', 'tagId', tagId)
            const localVarPath = `/provider/{locationId}/project/{projectId}/agent/{agentId}/tag/{tagId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"agentId"}}`, encodeURIComponent(String(agentId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List provider/agent.tag
         * @summary List provider/agent.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentTagList: async (projectId: string, locationId: string, agentId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('providerProjectAgentTagList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('providerProjectAgentTagList', 'locationId', locationId)
            // verify required parameter 'agentId' is not null or undefined
            assertParamExists('providerProjectAgentTagList', 'agentId', agentId)
            const localVarPath = `/provider/{locationId}/project/{projectId}/agent/{agentId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"agentId"}}`, encodeURIComponent(String(agentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replace provider/agent.tag
         * @summary Replace provider/agent.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentTagPut: async (projectId: string, locationId: string, agentId: string, tag: Array<Tag>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('providerProjectAgentTagPut', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('providerProjectAgentTagPut', 'locationId', locationId)
            // verify required parameter 'agentId' is not null or undefined
            assertParamExists('providerProjectAgentTagPut', 'agentId', agentId)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('providerProjectAgentTagPut', 'tag', tag)
            const localVarPath = `/provider/{locationId}/project/{projectId}/agent/{agentId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"agentId"}}`, encodeURIComponent(String(agentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tag, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * action transfer
         * @summary Transfer provider/agent
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {ProviderProjectAgentTransfer} providerProjectAgentTransfer 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentTransfer: async (projectId: string, locationId: string, agentId: string, providerProjectAgentTransfer: ProviderProjectAgentTransfer, xIdempotencyKey?: string, xDryRun?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('providerProjectAgentTransfer', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('providerProjectAgentTransfer', 'locationId', locationId)
            // verify required parameter 'agentId' is not null or undefined
            assertParamExists('providerProjectAgentTransfer', 'agentId', agentId)
            // verify required parameter 'providerProjectAgentTransfer' is not null or undefined
            assertParamExists('providerProjectAgentTransfer', 'providerProjectAgentTransfer', providerProjectAgentTransfer)
            const localVarPath = `/provider/{locationId}/project/{projectId}/agent/{agentId}/actions/transfer`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"agentId"}}`, encodeURIComponent(String(agentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }

            if (xDryRun !== undefined && xDryRun !== null) {
                localVarHeaderParameter['x-dry-run'] = String(xDryRun);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(providerProjectAgentTransfer, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns modified agent
         * @summary Update provider/agent
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {ProviderProjectAgentUpdate} providerProjectAgentUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentUpdate: async (projectId: string, locationId: string, agentId: string, providerProjectAgentUpdate: ProviderProjectAgentUpdate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('providerProjectAgentUpdate', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('providerProjectAgentUpdate', 'locationId', locationId)
            // verify required parameter 'agentId' is not null or undefined
            assertParamExists('providerProjectAgentUpdate', 'agentId', agentId)
            // verify required parameter 'providerProjectAgentUpdate' is not null or undefined
            assertParamExists('providerProjectAgentUpdate', 'providerProjectAgentUpdate', providerProjectAgentUpdate)
            const localVarPath = `/provider/{locationId}/project/{projectId}/agent/{agentId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"agentId"}}`, encodeURIComponent(String(agentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(providerProjectAgentUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProviderProjectAgentApi - functional programming interface
 * @export
 */
export const ProviderProjectAgentApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProviderProjectAgentApiAxiosParamCreator(configuration)
    return {
        /**
         * Create agent
         * @summary Create provider/agent
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {ProviderProjectAgentCreate} providerProjectAgentCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async providerProjectAgentCreate(projectId: string, locationId: string, providerProjectAgentCreate: ProviderProjectAgentCreate, xIdempotencyKey?: string, xDryRun?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Agent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.providerProjectAgentCreate(projectId, locationId, providerProjectAgentCreate, xIdempotencyKey, xDryRun, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create provider/agent.credential
         * @summary Create provider/agent.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {AgentCredential} agentCredential 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async providerProjectAgentCredentialCreate(projectId: string, locationId: string, agentId: string, agentCredential: AgentCredential, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AgentCredential>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.providerProjectAgentCredentialCreate(projectId, locationId, agentId, agentCredential, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete provider/agent.credential
         * @summary Delete provider/agent.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {string} credentialId credentialId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async providerProjectAgentCredentialDelete(projectId: string, locationId: string, agentId: string, credentialId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Agent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.providerProjectAgentCredentialDelete(projectId, locationId, agentId, credentialId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get provider/agent.credential
         * @summary Get provider/agent.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {string} credentialId credentialId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async providerProjectAgentCredentialGet(projectId: string, locationId: string, agentId: string, credentialId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AgentCredential>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.providerProjectAgentCredentialGet(projectId, locationId, agentId, credentialId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List provider/agent.credential
         * @summary List provider/agent.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async providerProjectAgentCredentialList(projectId: string, locationId: string, agentId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AgentCredential>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.providerProjectAgentCredentialList(projectId, locationId, agentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update provider/agent.credential
         * @summary Update provider/agent.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {string} credentialId credentialId
         * @param {ProviderProjectAgentCredentialPatch} providerProjectAgentCredentialPatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async providerProjectAgentCredentialPatch(projectId: string, locationId: string, agentId: string, credentialId: string, providerProjectAgentCredentialPatch: ProviderProjectAgentCredentialPatch, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AgentCredential>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.providerProjectAgentCredentialPatch(projectId, locationId, agentId, credentialId, providerProjectAgentCredentialPatch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete agent
         * @summary Delete provider/agent
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async providerProjectAgentDelete(projectId: string, locationId: string, agentId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.providerProjectAgentDelete(projectId, locationId, agentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create provider/agent.enabledService
         * @summary Create provider/agent.enabledService
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {EnabledService} enabledService 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async providerProjectAgentEnabledServiceCreate(projectId: string, locationId: string, agentId: string, enabledService: EnabledService, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnabledService>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.providerProjectAgentEnabledServiceCreate(projectId, locationId, agentId, enabledService, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete provider/agent.enabledService
         * @summary Delete provider/agent.enabledService
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {string} enabledServiceId enabledServiceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async providerProjectAgentEnabledServiceDelete(projectId: string, locationId: string, agentId: string, enabledServiceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Agent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.providerProjectAgentEnabledServiceDelete(projectId, locationId, agentId, enabledServiceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get provider/agent.enabledService
         * @summary Get provider/agent.enabledService
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {string} enabledServiceId enabledServiceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async providerProjectAgentEnabledServiceGet(projectId: string, locationId: string, agentId: string, enabledServiceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnabledService>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.providerProjectAgentEnabledServiceGet(projectId, locationId, agentId, enabledServiceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List provider/agent.enabledService
         * @summary List provider/agent.enabledService
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async providerProjectAgentEnabledServiceList(projectId: string, locationId: string, agentId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EnabledService>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.providerProjectAgentEnabledServiceList(projectId, locationId, agentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get provider/agent.event
         * @summary Get provider/agent.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async providerProjectAgentEventGet(projectId: string, locationId: string, agentId: string, eventId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.providerProjectAgentEventGet(projectId, locationId, agentId, eventId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List provider/agent.event
         * @summary List provider/agent.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async providerProjectAgentEventList(projectId: string, locationId: string, agentId: string, $limit?: number, $skip?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Event>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.providerProjectAgentEventList(projectId, locationId, agentId, $limit, $skip, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a single agent
         * @summary Get provider/agent
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async providerProjectAgentGet(projectId: string, locationId: string, agentId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Agent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.providerProjectAgentGet(projectId, locationId, agentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * action inspect
         * @summary Inspect provider/agent
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async providerProjectAgentInspect(projectId: string, locationId: string, agentId: string, xIdempotencyKey?: string, xDryRun?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.providerProjectAgentInspect(projectId, locationId, agentId, xIdempotencyKey, xDryRun, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List agent
         * @summary List provider/agent
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [name] Filter by name
         * @param {string} [enabledServices] Filter by enabledServices
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async providerProjectAgentList(projectId: string, locationId: string, name?: string, enabledServices?: string, tagValue?: string, tagKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Agent>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.providerProjectAgentList(projectId, locationId, name, enabledServices, tagValue, tagKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get provider/agent.metric
         * @summary Get provider/agent.metric
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {string} metricId metricId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async providerProjectAgentMetricGet(projectId: string, locationId: string, agentId: string, metricId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Metric>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.providerProjectAgentMetricGet(projectId, locationId, agentId, metricId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List provider/agent.metric
         * @summary List provider/agent.metric
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async providerProjectAgentMetricList(projectId: string, locationId: string, agentId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Metric>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.providerProjectAgentMetricList(projectId, locationId, agentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List provider/agent.point
         * @summary List provider/agent.point
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {string} metricId metricId
         * @param {string} [interval] interval
         * @param {string} [timespan] timespan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async providerProjectAgentMetricPointList(projectId: string, locationId: string, agentId: string, metricId: string, interval?: string, timespan?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Point>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.providerProjectAgentMetricPointList(projectId, locationId, agentId, metricId, interval, timespan, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List provider/agent.event
         * @summary List provider/agent.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {string} resourceId resourceId
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async providerProjectAgentResourceEventList(projectId: string, locationId: string, agentId: string, resourceId: string, $limit?: number, $skip?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProviderAgentResourceEvent>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.providerProjectAgentResourceEventList(projectId, locationId, agentId, resourceId, $limit, $skip, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get provider/agent.resource
         * @summary Get provider/agent.resource
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {string} resourceId resourceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async providerProjectAgentResourceGet(projectId: string, locationId: string, agentId: string, resourceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProviderAgentResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.providerProjectAgentResourceGet(projectId, locationId, agentId, resourceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * action inspect
         * @summary Inspect provider/agent.resource
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {string} resourceId resourceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async providerProjectAgentResourceInspect(projectId: string, locationId: string, agentId: string, resourceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.providerProjectAgentResourceInspect(projectId, locationId, agentId, resourceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List provider/agent.resource
         * @summary List provider/agent.resource
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async providerProjectAgentResourceList(projectId: string, locationId: string, agentId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProviderAgentResource>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.providerProjectAgentResourceList(projectId, locationId, agentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * action recreate
         * @summary Recreate provider/agent.resource
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {string} resourceId resourceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async providerProjectAgentResourceRecreate(projectId: string, locationId: string, agentId: string, resourceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProviderAgentResource>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.providerProjectAgentResourceRecreate(projectId, locationId, agentId, resourceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get provider/agent.service
         * @summary Get provider/agent.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async providerProjectAgentServiceGet(projectId: string, locationId: string, agentId: string, serviceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceService>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.providerProjectAgentServiceGet(projectId, locationId, agentId, serviceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List provider/agent.service
         * @summary List provider/agent.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async providerProjectAgentServiceList(projectId: string, locationId: string, agentId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResourceService>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.providerProjectAgentServiceList(projectId, locationId, agentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * action start
         * @summary Start provider/agent
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async providerProjectAgentStart(projectId: string, locationId: string, agentId: string, xIdempotencyKey?: string, xDryRun?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Agent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.providerProjectAgentStart(projectId, locationId, agentId, xIdempotencyKey, xDryRun, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * action suspend
         * @summary Suspend provider/agent
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async providerProjectAgentSuspend(projectId: string, locationId: string, agentId: string, xIdempotencyKey?: string, xDryRun?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Agent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.providerProjectAgentSuspend(projectId, locationId, agentId, xIdempotencyKey, xDryRun, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create provider/agent.tag
         * @summary Create provider/agent.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async providerProjectAgentTagCreate(projectId: string, locationId: string, agentId: string, tag: Tag, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.providerProjectAgentTagCreate(projectId, locationId, agentId, tag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete provider/agent.tag
         * @summary Delete provider/agent.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async providerProjectAgentTagDelete(projectId: string, locationId: string, agentId: string, tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.providerProjectAgentTagDelete(projectId, locationId, agentId, tagId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get provider/agent.tag
         * @summary Get provider/agent.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async providerProjectAgentTagGet(projectId: string, locationId: string, agentId: string, tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.providerProjectAgentTagGet(projectId, locationId, agentId, tagId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List provider/agent.tag
         * @summary List provider/agent.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async providerProjectAgentTagList(projectId: string, locationId: string, agentId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.providerProjectAgentTagList(projectId, locationId, agentId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Replace provider/agent.tag
         * @summary Replace provider/agent.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async providerProjectAgentTagPut(projectId: string, locationId: string, agentId: string, tag: Array<Tag>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.providerProjectAgentTagPut(projectId, locationId, agentId, tag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * action transfer
         * @summary Transfer provider/agent
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {ProviderProjectAgentTransfer} providerProjectAgentTransfer 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async providerProjectAgentTransfer(projectId: string, locationId: string, agentId: string, providerProjectAgentTransfer: ProviderProjectAgentTransfer, xIdempotencyKey?: string, xDryRun?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Agent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.providerProjectAgentTransfer(projectId, locationId, agentId, providerProjectAgentTransfer, xIdempotencyKey, xDryRun, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns modified agent
         * @summary Update provider/agent
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {ProviderProjectAgentUpdate} providerProjectAgentUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async providerProjectAgentUpdate(projectId: string, locationId: string, agentId: string, providerProjectAgentUpdate: ProviderProjectAgentUpdate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Agent>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.providerProjectAgentUpdate(projectId, locationId, agentId, providerProjectAgentUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProviderProjectAgentApi - factory interface
 * @export
 */
export const ProviderProjectAgentApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProviderProjectAgentApiFp(configuration)
    return {
        /**
         * Create agent
         * @summary Create provider/agent
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {ProviderProjectAgentCreate} providerProjectAgentCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentCreate(projectId: string, locationId: string, providerProjectAgentCreate: ProviderProjectAgentCreate, xIdempotencyKey?: string, xDryRun?: string, options?: any): AxiosPromise<Agent> {
            return localVarFp.providerProjectAgentCreate(projectId, locationId, providerProjectAgentCreate, xIdempotencyKey, xDryRun, options).then((request) => request(axios, basePath));
        },
        /**
         * Create provider/agent.credential
         * @summary Create provider/agent.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {AgentCredential} agentCredential 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentCredentialCreate(projectId: string, locationId: string, agentId: string, agentCredential: AgentCredential, options?: any): AxiosPromise<AgentCredential> {
            return localVarFp.providerProjectAgentCredentialCreate(projectId, locationId, agentId, agentCredential, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete provider/agent.credential
         * @summary Delete provider/agent.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {string} credentialId credentialId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentCredentialDelete(projectId: string, locationId: string, agentId: string, credentialId: string, options?: any): AxiosPromise<Agent> {
            return localVarFp.providerProjectAgentCredentialDelete(projectId, locationId, agentId, credentialId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get provider/agent.credential
         * @summary Get provider/agent.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {string} credentialId credentialId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentCredentialGet(projectId: string, locationId: string, agentId: string, credentialId: string, options?: any): AxiosPromise<AgentCredential> {
            return localVarFp.providerProjectAgentCredentialGet(projectId, locationId, agentId, credentialId, options).then((request) => request(axios, basePath));
        },
        /**
         * List provider/agent.credential
         * @summary List provider/agent.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentCredentialList(projectId: string, locationId: string, agentId: string, options?: any): AxiosPromise<Array<AgentCredential>> {
            return localVarFp.providerProjectAgentCredentialList(projectId, locationId, agentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update provider/agent.credential
         * @summary Update provider/agent.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {string} credentialId credentialId
         * @param {ProviderProjectAgentCredentialPatch} providerProjectAgentCredentialPatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentCredentialPatch(projectId: string, locationId: string, agentId: string, credentialId: string, providerProjectAgentCredentialPatch: ProviderProjectAgentCredentialPatch, options?: any): AxiosPromise<AgentCredential> {
            return localVarFp.providerProjectAgentCredentialPatch(projectId, locationId, agentId, credentialId, providerProjectAgentCredentialPatch, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete agent
         * @summary Delete provider/agent
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentDelete(projectId: string, locationId: string, agentId: string, options?: any): AxiosPromise<void> {
            return localVarFp.providerProjectAgentDelete(projectId, locationId, agentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create provider/agent.enabledService
         * @summary Create provider/agent.enabledService
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {EnabledService} enabledService 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentEnabledServiceCreate(projectId: string, locationId: string, agentId: string, enabledService: EnabledService, options?: any): AxiosPromise<EnabledService> {
            return localVarFp.providerProjectAgentEnabledServiceCreate(projectId, locationId, agentId, enabledService, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete provider/agent.enabledService
         * @summary Delete provider/agent.enabledService
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {string} enabledServiceId enabledServiceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentEnabledServiceDelete(projectId: string, locationId: string, agentId: string, enabledServiceId: string, options?: any): AxiosPromise<Agent> {
            return localVarFp.providerProjectAgentEnabledServiceDelete(projectId, locationId, agentId, enabledServiceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get provider/agent.enabledService
         * @summary Get provider/agent.enabledService
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {string} enabledServiceId enabledServiceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentEnabledServiceGet(projectId: string, locationId: string, agentId: string, enabledServiceId: string, options?: any): AxiosPromise<EnabledService> {
            return localVarFp.providerProjectAgentEnabledServiceGet(projectId, locationId, agentId, enabledServiceId, options).then((request) => request(axios, basePath));
        },
        /**
         * List provider/agent.enabledService
         * @summary List provider/agent.enabledService
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentEnabledServiceList(projectId: string, locationId: string, agentId: string, options?: any): AxiosPromise<Array<EnabledService>> {
            return localVarFp.providerProjectAgentEnabledServiceList(projectId, locationId, agentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get provider/agent.event
         * @summary Get provider/agent.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentEventGet(projectId: string, locationId: string, agentId: string, eventId: string, options?: any): AxiosPromise<Event> {
            return localVarFp.providerProjectAgentEventGet(projectId, locationId, agentId, eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * List provider/agent.event
         * @summary List provider/agent.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentEventList(projectId: string, locationId: string, agentId: string, $limit?: number, $skip?: number, options?: any): AxiosPromise<Array<Event>> {
            return localVarFp.providerProjectAgentEventList(projectId, locationId, agentId, $limit, $skip, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single agent
         * @summary Get provider/agent
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentGet(projectId: string, locationId: string, agentId: string, options?: any): AxiosPromise<Agent> {
            return localVarFp.providerProjectAgentGet(projectId, locationId, agentId, options).then((request) => request(axios, basePath));
        },
        /**
         * action inspect
         * @summary Inspect provider/agent
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentInspect(projectId: string, locationId: string, agentId: string, xIdempotencyKey?: string, xDryRun?: string, options?: any): AxiosPromise<object> {
            return localVarFp.providerProjectAgentInspect(projectId, locationId, agentId, xIdempotencyKey, xDryRun, options).then((request) => request(axios, basePath));
        },
        /**
         * List agent
         * @summary List provider/agent
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [name] Filter by name
         * @param {string} [enabledServices] Filter by enabledServices
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentList(projectId: string, locationId: string, name?: string, enabledServices?: string, tagValue?: string, tagKey?: string, options?: any): AxiosPromise<Array<Agent>> {
            return localVarFp.providerProjectAgentList(projectId, locationId, name, enabledServices, tagValue, tagKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get provider/agent.metric
         * @summary Get provider/agent.metric
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {string} metricId metricId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentMetricGet(projectId: string, locationId: string, agentId: string, metricId: string, options?: any): AxiosPromise<Metric> {
            return localVarFp.providerProjectAgentMetricGet(projectId, locationId, agentId, metricId, options).then((request) => request(axios, basePath));
        },
        /**
         * List provider/agent.metric
         * @summary List provider/agent.metric
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentMetricList(projectId: string, locationId: string, agentId: string, options?: any): AxiosPromise<Array<Metric>> {
            return localVarFp.providerProjectAgentMetricList(projectId, locationId, agentId, options).then((request) => request(axios, basePath));
        },
        /**
         * List provider/agent.point
         * @summary List provider/agent.point
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {string} metricId metricId
         * @param {string} [interval] interval
         * @param {string} [timespan] timespan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentMetricPointList(projectId: string, locationId: string, agentId: string, metricId: string, interval?: string, timespan?: string, options?: any): AxiosPromise<Array<Point>> {
            return localVarFp.providerProjectAgentMetricPointList(projectId, locationId, agentId, metricId, interval, timespan, options).then((request) => request(axios, basePath));
        },
        /**
         * List provider/agent.event
         * @summary List provider/agent.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {string} resourceId resourceId
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentResourceEventList(projectId: string, locationId: string, agentId: string, resourceId: string, $limit?: number, $skip?: number, options?: any): AxiosPromise<Array<ProviderAgentResourceEvent>> {
            return localVarFp.providerProjectAgentResourceEventList(projectId, locationId, agentId, resourceId, $limit, $skip, options).then((request) => request(axios, basePath));
        },
        /**
         * Get provider/agent.resource
         * @summary Get provider/agent.resource
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {string} resourceId resourceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentResourceGet(projectId: string, locationId: string, agentId: string, resourceId: string, options?: any): AxiosPromise<ProviderAgentResource> {
            return localVarFp.providerProjectAgentResourceGet(projectId, locationId, agentId, resourceId, options).then((request) => request(axios, basePath));
        },
        /**
         * action inspect
         * @summary Inspect provider/agent.resource
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {string} resourceId resourceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentResourceInspect(projectId: string, locationId: string, agentId: string, resourceId: string, options?: any): AxiosPromise<any> {
            return localVarFp.providerProjectAgentResourceInspect(projectId, locationId, agentId, resourceId, options).then((request) => request(axios, basePath));
        },
        /**
         * List provider/agent.resource
         * @summary List provider/agent.resource
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentResourceList(projectId: string, locationId: string, agentId: string, options?: any): AxiosPromise<Array<ProviderAgentResource>> {
            return localVarFp.providerProjectAgentResourceList(projectId, locationId, agentId, options).then((request) => request(axios, basePath));
        },
        /**
         * action recreate
         * @summary Recreate provider/agent.resource
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {string} resourceId resourceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentResourceRecreate(projectId: string, locationId: string, agentId: string, resourceId: string, options?: any): AxiosPromise<ProviderAgentResource> {
            return localVarFp.providerProjectAgentResourceRecreate(projectId, locationId, agentId, resourceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get provider/agent.service
         * @summary Get provider/agent.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentServiceGet(projectId: string, locationId: string, agentId: string, serviceId: string, options?: any): AxiosPromise<ResourceService> {
            return localVarFp.providerProjectAgentServiceGet(projectId, locationId, agentId, serviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * List provider/agent.service
         * @summary List provider/agent.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentServiceList(projectId: string, locationId: string, agentId: string, options?: any): AxiosPromise<Array<ResourceService>> {
            return localVarFp.providerProjectAgentServiceList(projectId, locationId, agentId, options).then((request) => request(axios, basePath));
        },
        /**
         * action start
         * @summary Start provider/agent
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentStart(projectId: string, locationId: string, agentId: string, xIdempotencyKey?: string, xDryRun?: string, options?: any): AxiosPromise<Agent> {
            return localVarFp.providerProjectAgentStart(projectId, locationId, agentId, xIdempotencyKey, xDryRun, options).then((request) => request(axios, basePath));
        },
        /**
         * action suspend
         * @summary Suspend provider/agent
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentSuspend(projectId: string, locationId: string, agentId: string, xIdempotencyKey?: string, xDryRun?: string, options?: any): AxiosPromise<Agent> {
            return localVarFp.providerProjectAgentSuspend(projectId, locationId, agentId, xIdempotencyKey, xDryRun, options).then((request) => request(axios, basePath));
        },
        /**
         * Create provider/agent.tag
         * @summary Create provider/agent.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentTagCreate(projectId: string, locationId: string, agentId: string, tag: Tag, options?: any): AxiosPromise<Tag> {
            return localVarFp.providerProjectAgentTagCreate(projectId, locationId, agentId, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete provider/agent.tag
         * @summary Delete provider/agent.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentTagDelete(projectId: string, locationId: string, agentId: string, tagId: string, options?: any): AxiosPromise<void> {
            return localVarFp.providerProjectAgentTagDelete(projectId, locationId, agentId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get provider/agent.tag
         * @summary Get provider/agent.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentTagGet(projectId: string, locationId: string, agentId: string, tagId: string, options?: any): AxiosPromise<Tag> {
            return localVarFp.providerProjectAgentTagGet(projectId, locationId, agentId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * List provider/agent.tag
         * @summary List provider/agent.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentTagList(projectId: string, locationId: string, agentId: string, options?: any): AxiosPromise<Array<Tag>> {
            return localVarFp.providerProjectAgentTagList(projectId, locationId, agentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Replace provider/agent.tag
         * @summary Replace provider/agent.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentTagPut(projectId: string, locationId: string, agentId: string, tag: Array<Tag>, options?: any): AxiosPromise<Array<Tag>> {
            return localVarFp.providerProjectAgentTagPut(projectId, locationId, agentId, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * action transfer
         * @summary Transfer provider/agent
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {ProviderProjectAgentTransfer} providerProjectAgentTransfer 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentTransfer(projectId: string, locationId: string, agentId: string, providerProjectAgentTransfer: ProviderProjectAgentTransfer, xIdempotencyKey?: string, xDryRun?: string, options?: any): AxiosPromise<Agent> {
            return localVarFp.providerProjectAgentTransfer(projectId, locationId, agentId, providerProjectAgentTransfer, xIdempotencyKey, xDryRun, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns modified agent
         * @summary Update provider/agent
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} agentId Agent Id
         * @param {ProviderProjectAgentUpdate} providerProjectAgentUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        providerProjectAgentUpdate(projectId: string, locationId: string, agentId: string, providerProjectAgentUpdate: ProviderProjectAgentUpdate, options?: any): AxiosPromise<Agent> {
            return localVarFp.providerProjectAgentUpdate(projectId, locationId, agentId, providerProjectAgentUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProviderProjectAgentApi - object-oriented interface
 * @export
 * @class ProviderProjectAgentApi
 * @extends {BaseAPI}
 */
export class ProviderProjectAgentApi extends BaseAPI {
    /**
     * Create agent
     * @summary Create provider/agent
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {ProviderProjectAgentCreate} providerProjectAgentCreate 
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {string} [xDryRun] Dry run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderProjectAgentApi
     */
    public providerProjectAgentCreate(projectId: string, locationId: string, providerProjectAgentCreate: ProviderProjectAgentCreate, xIdempotencyKey?: string, xDryRun?: string, options?: any) {
        return ProviderProjectAgentApiFp(this.configuration).providerProjectAgentCreate(projectId, locationId, providerProjectAgentCreate, xIdempotencyKey, xDryRun, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create provider/agent.credential
     * @summary Create provider/agent.credential
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} agentId Agent Id
     * @param {AgentCredential} agentCredential 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderProjectAgentApi
     */
    public providerProjectAgentCredentialCreate(projectId: string, locationId: string, agentId: string, agentCredential: AgentCredential, options?: any) {
        return ProviderProjectAgentApiFp(this.configuration).providerProjectAgentCredentialCreate(projectId, locationId, agentId, agentCredential, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete provider/agent.credential
     * @summary Delete provider/agent.credential
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} agentId Agent Id
     * @param {string} credentialId credentialId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderProjectAgentApi
     */
    public providerProjectAgentCredentialDelete(projectId: string, locationId: string, agentId: string, credentialId: string, options?: any) {
        return ProviderProjectAgentApiFp(this.configuration).providerProjectAgentCredentialDelete(projectId, locationId, agentId, credentialId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get provider/agent.credential
     * @summary Get provider/agent.credential
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} agentId Agent Id
     * @param {string} credentialId credentialId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderProjectAgentApi
     */
    public providerProjectAgentCredentialGet(projectId: string, locationId: string, agentId: string, credentialId: string, options?: any) {
        return ProviderProjectAgentApiFp(this.configuration).providerProjectAgentCredentialGet(projectId, locationId, agentId, credentialId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List provider/agent.credential
     * @summary List provider/agent.credential
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} agentId Agent Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderProjectAgentApi
     */
    public providerProjectAgentCredentialList(projectId: string, locationId: string, agentId: string, options?: any) {
        return ProviderProjectAgentApiFp(this.configuration).providerProjectAgentCredentialList(projectId, locationId, agentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update provider/agent.credential
     * @summary Update provider/agent.credential
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} agentId Agent Id
     * @param {string} credentialId credentialId
     * @param {ProviderProjectAgentCredentialPatch} providerProjectAgentCredentialPatch 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderProjectAgentApi
     */
    public providerProjectAgentCredentialPatch(projectId: string, locationId: string, agentId: string, credentialId: string, providerProjectAgentCredentialPatch: ProviderProjectAgentCredentialPatch, options?: any) {
        return ProviderProjectAgentApiFp(this.configuration).providerProjectAgentCredentialPatch(projectId, locationId, agentId, credentialId, providerProjectAgentCredentialPatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete agent
     * @summary Delete provider/agent
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} agentId Agent Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderProjectAgentApi
     */
    public providerProjectAgentDelete(projectId: string, locationId: string, agentId: string, options?: any) {
        return ProviderProjectAgentApiFp(this.configuration).providerProjectAgentDelete(projectId, locationId, agentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create provider/agent.enabledService
     * @summary Create provider/agent.enabledService
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} agentId Agent Id
     * @param {EnabledService} enabledService 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderProjectAgentApi
     */
    public providerProjectAgentEnabledServiceCreate(projectId: string, locationId: string, agentId: string, enabledService: EnabledService, options?: any) {
        return ProviderProjectAgentApiFp(this.configuration).providerProjectAgentEnabledServiceCreate(projectId, locationId, agentId, enabledService, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete provider/agent.enabledService
     * @summary Delete provider/agent.enabledService
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} agentId Agent Id
     * @param {string} enabledServiceId enabledServiceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderProjectAgentApi
     */
    public providerProjectAgentEnabledServiceDelete(projectId: string, locationId: string, agentId: string, enabledServiceId: string, options?: any) {
        return ProviderProjectAgentApiFp(this.configuration).providerProjectAgentEnabledServiceDelete(projectId, locationId, agentId, enabledServiceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get provider/agent.enabledService
     * @summary Get provider/agent.enabledService
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} agentId Agent Id
     * @param {string} enabledServiceId enabledServiceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderProjectAgentApi
     */
    public providerProjectAgentEnabledServiceGet(projectId: string, locationId: string, agentId: string, enabledServiceId: string, options?: any) {
        return ProviderProjectAgentApiFp(this.configuration).providerProjectAgentEnabledServiceGet(projectId, locationId, agentId, enabledServiceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List provider/agent.enabledService
     * @summary List provider/agent.enabledService
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} agentId Agent Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderProjectAgentApi
     */
    public providerProjectAgentEnabledServiceList(projectId: string, locationId: string, agentId: string, options?: any) {
        return ProviderProjectAgentApiFp(this.configuration).providerProjectAgentEnabledServiceList(projectId, locationId, agentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get provider/agent.event
     * @summary Get provider/agent.event
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} agentId Agent Id
     * @param {string} eventId eventId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderProjectAgentApi
     */
    public providerProjectAgentEventGet(projectId: string, locationId: string, agentId: string, eventId: string, options?: any) {
        return ProviderProjectAgentApiFp(this.configuration).providerProjectAgentEventGet(projectId, locationId, agentId, eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List provider/agent.event
     * @summary List provider/agent.event
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} agentId Agent Id
     * @param {number} [$limit] $limit
     * @param {number} [$skip] $skip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderProjectAgentApi
     */
    public providerProjectAgentEventList(projectId: string, locationId: string, agentId: string, $limit?: number, $skip?: number, options?: any) {
        return ProviderProjectAgentApiFp(this.configuration).providerProjectAgentEventList(projectId, locationId, agentId, $limit, $skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single agent
     * @summary Get provider/agent
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} agentId Agent Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderProjectAgentApi
     */
    public providerProjectAgentGet(projectId: string, locationId: string, agentId: string, options?: any) {
        return ProviderProjectAgentApiFp(this.configuration).providerProjectAgentGet(projectId, locationId, agentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * action inspect
     * @summary Inspect provider/agent
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} agentId Agent Id
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {string} [xDryRun] Dry run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderProjectAgentApi
     */
    public providerProjectAgentInspect(projectId: string, locationId: string, agentId: string, xIdempotencyKey?: string, xDryRun?: string, options?: any) {
        return ProviderProjectAgentApiFp(this.configuration).providerProjectAgentInspect(projectId, locationId, agentId, xIdempotencyKey, xDryRun, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List agent
     * @summary List provider/agent
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} [name] Filter by name
     * @param {string} [enabledServices] Filter by enabledServices
     * @param {string} [tagValue] Filter by tag.value
     * @param {string} [tagKey] Filter by tag.key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderProjectAgentApi
     */
    public providerProjectAgentList(projectId: string, locationId: string, name?: string, enabledServices?: string, tagValue?: string, tagKey?: string, options?: any) {
        return ProviderProjectAgentApiFp(this.configuration).providerProjectAgentList(projectId, locationId, name, enabledServices, tagValue, tagKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get provider/agent.metric
     * @summary Get provider/agent.metric
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} agentId Agent Id
     * @param {string} metricId metricId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderProjectAgentApi
     */
    public providerProjectAgentMetricGet(projectId: string, locationId: string, agentId: string, metricId: string, options?: any) {
        return ProviderProjectAgentApiFp(this.configuration).providerProjectAgentMetricGet(projectId, locationId, agentId, metricId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List provider/agent.metric
     * @summary List provider/agent.metric
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} agentId Agent Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderProjectAgentApi
     */
    public providerProjectAgentMetricList(projectId: string, locationId: string, agentId: string, options?: any) {
        return ProviderProjectAgentApiFp(this.configuration).providerProjectAgentMetricList(projectId, locationId, agentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List provider/agent.point
     * @summary List provider/agent.point
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} agentId Agent Id
     * @param {string} metricId metricId
     * @param {string} [interval] interval
     * @param {string} [timespan] timespan
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderProjectAgentApi
     */
    public providerProjectAgentMetricPointList(projectId: string, locationId: string, agentId: string, metricId: string, interval?: string, timespan?: string, options?: any) {
        return ProviderProjectAgentApiFp(this.configuration).providerProjectAgentMetricPointList(projectId, locationId, agentId, metricId, interval, timespan, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List provider/agent.event
     * @summary List provider/agent.event
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} agentId Agent Id
     * @param {string} resourceId resourceId
     * @param {number} [$limit] $limit
     * @param {number} [$skip] $skip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderProjectAgentApi
     */
    public providerProjectAgentResourceEventList(projectId: string, locationId: string, agentId: string, resourceId: string, $limit?: number, $skip?: number, options?: any) {
        return ProviderProjectAgentApiFp(this.configuration).providerProjectAgentResourceEventList(projectId, locationId, agentId, resourceId, $limit, $skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get provider/agent.resource
     * @summary Get provider/agent.resource
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} agentId Agent Id
     * @param {string} resourceId resourceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderProjectAgentApi
     */
    public providerProjectAgentResourceGet(projectId: string, locationId: string, agentId: string, resourceId: string, options?: any) {
        return ProviderProjectAgentApiFp(this.configuration).providerProjectAgentResourceGet(projectId, locationId, agentId, resourceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * action inspect
     * @summary Inspect provider/agent.resource
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} agentId Agent Id
     * @param {string} resourceId resourceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderProjectAgentApi
     */
    public providerProjectAgentResourceInspect(projectId: string, locationId: string, agentId: string, resourceId: string, options?: any) {
        return ProviderProjectAgentApiFp(this.configuration).providerProjectAgentResourceInspect(projectId, locationId, agentId, resourceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List provider/agent.resource
     * @summary List provider/agent.resource
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} agentId Agent Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderProjectAgentApi
     */
    public providerProjectAgentResourceList(projectId: string, locationId: string, agentId: string, options?: any) {
        return ProviderProjectAgentApiFp(this.configuration).providerProjectAgentResourceList(projectId, locationId, agentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * action recreate
     * @summary Recreate provider/agent.resource
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} agentId Agent Id
     * @param {string} resourceId resourceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderProjectAgentApi
     */
    public providerProjectAgentResourceRecreate(projectId: string, locationId: string, agentId: string, resourceId: string, options?: any) {
        return ProviderProjectAgentApiFp(this.configuration).providerProjectAgentResourceRecreate(projectId, locationId, agentId, resourceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get provider/agent.service
     * @summary Get provider/agent.service
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} agentId Agent Id
     * @param {string} serviceId serviceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderProjectAgentApi
     */
    public providerProjectAgentServiceGet(projectId: string, locationId: string, agentId: string, serviceId: string, options?: any) {
        return ProviderProjectAgentApiFp(this.configuration).providerProjectAgentServiceGet(projectId, locationId, agentId, serviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List provider/agent.service
     * @summary List provider/agent.service
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} agentId Agent Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderProjectAgentApi
     */
    public providerProjectAgentServiceList(projectId: string, locationId: string, agentId: string, options?: any) {
        return ProviderProjectAgentApiFp(this.configuration).providerProjectAgentServiceList(projectId, locationId, agentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * action start
     * @summary Start provider/agent
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} agentId Agent Id
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {string} [xDryRun] Dry run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderProjectAgentApi
     */
    public providerProjectAgentStart(projectId: string, locationId: string, agentId: string, xIdempotencyKey?: string, xDryRun?: string, options?: any) {
        return ProviderProjectAgentApiFp(this.configuration).providerProjectAgentStart(projectId, locationId, agentId, xIdempotencyKey, xDryRun, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * action suspend
     * @summary Suspend provider/agent
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} agentId Agent Id
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {string} [xDryRun] Dry run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderProjectAgentApi
     */
    public providerProjectAgentSuspend(projectId: string, locationId: string, agentId: string, xIdempotencyKey?: string, xDryRun?: string, options?: any) {
        return ProviderProjectAgentApiFp(this.configuration).providerProjectAgentSuspend(projectId, locationId, agentId, xIdempotencyKey, xDryRun, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create provider/agent.tag
     * @summary Create provider/agent.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} agentId Agent Id
     * @param {Tag} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderProjectAgentApi
     */
    public providerProjectAgentTagCreate(projectId: string, locationId: string, agentId: string, tag: Tag, options?: any) {
        return ProviderProjectAgentApiFp(this.configuration).providerProjectAgentTagCreate(projectId, locationId, agentId, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete provider/agent.tag
     * @summary Delete provider/agent.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} agentId Agent Id
     * @param {string} tagId tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderProjectAgentApi
     */
    public providerProjectAgentTagDelete(projectId: string, locationId: string, agentId: string, tagId: string, options?: any) {
        return ProviderProjectAgentApiFp(this.configuration).providerProjectAgentTagDelete(projectId, locationId, agentId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get provider/agent.tag
     * @summary Get provider/agent.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} agentId Agent Id
     * @param {string} tagId tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderProjectAgentApi
     */
    public providerProjectAgentTagGet(projectId: string, locationId: string, agentId: string, tagId: string, options?: any) {
        return ProviderProjectAgentApiFp(this.configuration).providerProjectAgentTagGet(projectId, locationId, agentId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List provider/agent.tag
     * @summary List provider/agent.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} agentId Agent Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderProjectAgentApi
     */
    public providerProjectAgentTagList(projectId: string, locationId: string, agentId: string, options?: any) {
        return ProviderProjectAgentApiFp(this.configuration).providerProjectAgentTagList(projectId, locationId, agentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replace provider/agent.tag
     * @summary Replace provider/agent.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} agentId Agent Id
     * @param {Array<Tag>} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderProjectAgentApi
     */
    public providerProjectAgentTagPut(projectId: string, locationId: string, agentId: string, tag: Array<Tag>, options?: any) {
        return ProviderProjectAgentApiFp(this.configuration).providerProjectAgentTagPut(projectId, locationId, agentId, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * action transfer
     * @summary Transfer provider/agent
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} agentId Agent Id
     * @param {ProviderProjectAgentTransfer} providerProjectAgentTransfer 
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {string} [xDryRun] Dry run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderProjectAgentApi
     */
    public providerProjectAgentTransfer(projectId: string, locationId: string, agentId: string, providerProjectAgentTransfer: ProviderProjectAgentTransfer, xIdempotencyKey?: string, xDryRun?: string, options?: any) {
        return ProviderProjectAgentApiFp(this.configuration).providerProjectAgentTransfer(projectId, locationId, agentId, providerProjectAgentTransfer, xIdempotencyKey, xDryRun, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns modified agent
     * @summary Update provider/agent
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} agentId Agent Id
     * @param {ProviderProjectAgentUpdate} providerProjectAgentUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProviderProjectAgentApi
     */
    public providerProjectAgentUpdate(projectId: string, locationId: string, agentId: string, providerProjectAgentUpdate: ProviderProjectAgentUpdate, options?: any) {
        return ProviderProjectAgentApiFp(this.configuration).providerProjectAgentUpdate(projectId, locationId, agentId, providerProjectAgentUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RecoveryProjectBackupApi - axios parameter creator
 * @export
 */
export const RecoveryProjectBackupApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create backup
         * @summary Create recovery/backup
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {RecoveryProjectBackupCreate} recoveryProjectBackupCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoveryProjectBackupCreate: async (projectId: string, locationId: string, recoveryProjectBackupCreate: RecoveryProjectBackupCreate, xIdempotencyKey?: string, xDryRun?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('recoveryProjectBackupCreate', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('recoveryProjectBackupCreate', 'locationId', locationId)
            // verify required parameter 'recoveryProjectBackupCreate' is not null or undefined
            assertParamExists('recoveryProjectBackupCreate', 'recoveryProjectBackupCreate', recoveryProjectBackupCreate)
            const localVarPath = `/recovery/{locationId}/project/{projectId}/backup`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }

            if (xDryRun !== undefined && xDryRun !== null) {
                localVarHeaderParameter['x-dry-run'] = String(xDryRun);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(recoveryProjectBackupCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete backup
         * @summary Delete recovery/backup
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} backupId Backup Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoveryProjectBackupDelete: async (projectId: string, locationId: string, backupId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('recoveryProjectBackupDelete', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('recoveryProjectBackupDelete', 'locationId', locationId)
            // verify required parameter 'backupId' is not null or undefined
            assertParamExists('recoveryProjectBackupDelete', 'backupId', backupId)
            const localVarPath = `/recovery/{locationId}/project/{projectId}/backup/{backupId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"backupId"}}`, encodeURIComponent(String(backupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get recovery/backup.event
         * @summary Get recovery/backup.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} backupId Backup Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoveryProjectBackupEventGet: async (projectId: string, locationId: string, backupId: string, eventId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('recoveryProjectBackupEventGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('recoveryProjectBackupEventGet', 'locationId', locationId)
            // verify required parameter 'backupId' is not null or undefined
            assertParamExists('recoveryProjectBackupEventGet', 'backupId', backupId)
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('recoveryProjectBackupEventGet', 'eventId', eventId)
            const localVarPath = `/recovery/{locationId}/project/{projectId}/backup/{backupId}/event/{eventId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"backupId"}}`, encodeURIComponent(String(backupId)))
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List recovery/backup.event
         * @summary List recovery/backup.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} backupId Backup Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoveryProjectBackupEventList: async (projectId: string, locationId: string, backupId: string, $limit?: number, $skip?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('recoveryProjectBackupEventList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('recoveryProjectBackupEventList', 'locationId', locationId)
            // verify required parameter 'backupId' is not null or undefined
            assertParamExists('recoveryProjectBackupEventList', 'backupId', backupId)
            const localVarPath = `/recovery/{locationId}/project/{projectId}/backup/{backupId}/event`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"backupId"}}`, encodeURIComponent(String(backupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if ($limit !== undefined) {
                localVarQueryParameter['$limit'] = $limit;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * action export
         * @summary Export recovery/backup
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} backupId Backup Id
         * @param {RecoveryProjectBackupExport} recoveryProjectBackupExport 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoveryProjectBackupExport: async (projectId: string, locationId: string, backupId: string, recoveryProjectBackupExport: RecoveryProjectBackupExport, xIdempotencyKey?: string, xDryRun?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('recoveryProjectBackupExport', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('recoveryProjectBackupExport', 'locationId', locationId)
            // verify required parameter 'backupId' is not null or undefined
            assertParamExists('recoveryProjectBackupExport', 'backupId', backupId)
            // verify required parameter 'recoveryProjectBackupExport' is not null or undefined
            assertParamExists('recoveryProjectBackupExport', 'recoveryProjectBackupExport', recoveryProjectBackupExport)
            const localVarPath = `/recovery/{locationId}/project/{projectId}/backup/{backupId}/actions/export`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"backupId"}}`, encodeURIComponent(String(backupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }

            if (xDryRun !== undefined && xDryRun !== null) {
                localVarHeaderParameter['x-dry-run'] = String(xDryRun);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(recoveryProjectBackupExport, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single backup
         * @summary Get recovery/backup
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} backupId Backup Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoveryProjectBackupGet: async (projectId: string, locationId: string, backupId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('recoveryProjectBackupGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('recoveryProjectBackupGet', 'locationId', locationId)
            // verify required parameter 'backupId' is not null or undefined
            assertParamExists('recoveryProjectBackupGet', 'backupId', backupId)
            const localVarPath = `/recovery/{locationId}/project/{projectId}/backup/{backupId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"backupId"}}`, encodeURIComponent(String(backupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List backup
         * @summary List recovery/backup
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [name] Filter by name
         * @param {string} [source] Filter by source
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoveryProjectBackupList: async (projectId: string, locationId: string, name?: string, source?: string, tagValue?: string, tagKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('recoveryProjectBackupList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('recoveryProjectBackupList', 'locationId', locationId)
            const localVarPath = `/recovery/{locationId}/project/{projectId}/backup`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (source !== undefined) {
                localVarQueryParameter['source'] = source;
            }

            if (tagValue !== undefined) {
                localVarQueryParameter['tag.value'] = tagValue;
            }

            if (tagKey !== undefined) {
                localVarQueryParameter['tag.key'] = tagKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get recovery/backup.metric
         * @summary Get recovery/backup.metric
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} backupId Backup Id
         * @param {string} metricId metricId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoveryProjectBackupMetricGet: async (projectId: string, locationId: string, backupId: string, metricId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('recoveryProjectBackupMetricGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('recoveryProjectBackupMetricGet', 'locationId', locationId)
            // verify required parameter 'backupId' is not null or undefined
            assertParamExists('recoveryProjectBackupMetricGet', 'backupId', backupId)
            // verify required parameter 'metricId' is not null or undefined
            assertParamExists('recoveryProjectBackupMetricGet', 'metricId', metricId)
            const localVarPath = `/recovery/{locationId}/project/{projectId}/backup/{backupId}/metric/{metricId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"backupId"}}`, encodeURIComponent(String(backupId)))
                .replace(`{${"metricId"}}`, encodeURIComponent(String(metricId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List recovery/backup.metric
         * @summary List recovery/backup.metric
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} backupId Backup Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoveryProjectBackupMetricList: async (projectId: string, locationId: string, backupId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('recoveryProjectBackupMetricList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('recoveryProjectBackupMetricList', 'locationId', locationId)
            // verify required parameter 'backupId' is not null or undefined
            assertParamExists('recoveryProjectBackupMetricList', 'backupId', backupId)
            const localVarPath = `/recovery/{locationId}/project/{projectId}/backup/{backupId}/metric`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"backupId"}}`, encodeURIComponent(String(backupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List recovery/backup.point
         * @summary List recovery/backup.point
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} backupId Backup Id
         * @param {string} metricId metricId
         * @param {string} [interval] interval
         * @param {string} [timespan] timespan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoveryProjectBackupMetricPointList: async (projectId: string, locationId: string, backupId: string, metricId: string, interval?: string, timespan?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('recoveryProjectBackupMetricPointList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('recoveryProjectBackupMetricPointList', 'locationId', locationId)
            // verify required parameter 'backupId' is not null or undefined
            assertParamExists('recoveryProjectBackupMetricPointList', 'backupId', backupId)
            // verify required parameter 'metricId' is not null or undefined
            assertParamExists('recoveryProjectBackupMetricPointList', 'metricId', metricId)
            const localVarPath = `/recovery/{locationId}/project/{projectId}/backup/{backupId}/metric/{metricId}/point`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"backupId"}}`, encodeURIComponent(String(backupId)))
                .replace(`{${"metricId"}}`, encodeURIComponent(String(metricId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (timespan !== undefined) {
                localVarQueryParameter['timespan'] = timespan;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get recovery/backup.service
         * @summary Get recovery/backup.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} backupId Backup Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoveryProjectBackupServiceGet: async (projectId: string, locationId: string, backupId: string, serviceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('recoveryProjectBackupServiceGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('recoveryProjectBackupServiceGet', 'locationId', locationId)
            // verify required parameter 'backupId' is not null or undefined
            assertParamExists('recoveryProjectBackupServiceGet', 'backupId', backupId)
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('recoveryProjectBackupServiceGet', 'serviceId', serviceId)
            const localVarPath = `/recovery/{locationId}/project/{projectId}/backup/{backupId}/service/{serviceId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"backupId"}}`, encodeURIComponent(String(backupId)))
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List recovery/backup.service
         * @summary List recovery/backup.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} backupId Backup Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoveryProjectBackupServiceList: async (projectId: string, locationId: string, backupId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('recoveryProjectBackupServiceList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('recoveryProjectBackupServiceList', 'locationId', locationId)
            // verify required parameter 'backupId' is not null or undefined
            assertParamExists('recoveryProjectBackupServiceList', 'backupId', backupId)
            const localVarPath = `/recovery/{locationId}/project/{projectId}/backup/{backupId}/service`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"backupId"}}`, encodeURIComponent(String(backupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create recovery/backup.tag
         * @summary Create recovery/backup.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} backupId Backup Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoveryProjectBackupTagCreate: async (projectId: string, locationId: string, backupId: string, tag: Tag, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('recoveryProjectBackupTagCreate', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('recoveryProjectBackupTagCreate', 'locationId', locationId)
            // verify required parameter 'backupId' is not null or undefined
            assertParamExists('recoveryProjectBackupTagCreate', 'backupId', backupId)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('recoveryProjectBackupTagCreate', 'tag', tag)
            const localVarPath = `/recovery/{locationId}/project/{projectId}/backup/{backupId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"backupId"}}`, encodeURIComponent(String(backupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tag, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete recovery/backup.tag
         * @summary Delete recovery/backup.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} backupId Backup Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoveryProjectBackupTagDelete: async (projectId: string, locationId: string, backupId: string, tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('recoveryProjectBackupTagDelete', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('recoveryProjectBackupTagDelete', 'locationId', locationId)
            // verify required parameter 'backupId' is not null or undefined
            assertParamExists('recoveryProjectBackupTagDelete', 'backupId', backupId)
            // verify required parameter 'tagId' is not null or undefined
            assertParamExists('recoveryProjectBackupTagDelete', 'tagId', tagId)
            const localVarPath = `/recovery/{locationId}/project/{projectId}/backup/{backupId}/tag/{tagId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"backupId"}}`, encodeURIComponent(String(backupId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get recovery/backup.tag
         * @summary Get recovery/backup.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} backupId Backup Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoveryProjectBackupTagGet: async (projectId: string, locationId: string, backupId: string, tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('recoveryProjectBackupTagGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('recoveryProjectBackupTagGet', 'locationId', locationId)
            // verify required parameter 'backupId' is not null or undefined
            assertParamExists('recoveryProjectBackupTagGet', 'backupId', backupId)
            // verify required parameter 'tagId' is not null or undefined
            assertParamExists('recoveryProjectBackupTagGet', 'tagId', tagId)
            const localVarPath = `/recovery/{locationId}/project/{projectId}/backup/{backupId}/tag/{tagId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"backupId"}}`, encodeURIComponent(String(backupId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List recovery/backup.tag
         * @summary List recovery/backup.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} backupId Backup Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoveryProjectBackupTagList: async (projectId: string, locationId: string, backupId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('recoveryProjectBackupTagList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('recoveryProjectBackupTagList', 'locationId', locationId)
            // verify required parameter 'backupId' is not null or undefined
            assertParamExists('recoveryProjectBackupTagList', 'backupId', backupId)
            const localVarPath = `/recovery/{locationId}/project/{projectId}/backup/{backupId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"backupId"}}`, encodeURIComponent(String(backupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replace recovery/backup.tag
         * @summary Replace recovery/backup.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} backupId Backup Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoveryProjectBackupTagPut: async (projectId: string, locationId: string, backupId: string, tag: Array<Tag>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('recoveryProjectBackupTagPut', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('recoveryProjectBackupTagPut', 'locationId', locationId)
            // verify required parameter 'backupId' is not null or undefined
            assertParamExists('recoveryProjectBackupTagPut', 'backupId', backupId)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('recoveryProjectBackupTagPut', 'tag', tag)
            const localVarPath = `/recovery/{locationId}/project/{projectId}/backup/{backupId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"backupId"}}`, encodeURIComponent(String(backupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tag, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns modified backup
         * @summary Update recovery/backup
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} backupId Backup Id
         * @param {RecoveryProjectBackupUpdate} recoveryProjectBackupUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoveryProjectBackupUpdate: async (projectId: string, locationId: string, backupId: string, recoveryProjectBackupUpdate: RecoveryProjectBackupUpdate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('recoveryProjectBackupUpdate', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('recoveryProjectBackupUpdate', 'locationId', locationId)
            // verify required parameter 'backupId' is not null or undefined
            assertParamExists('recoveryProjectBackupUpdate', 'backupId', backupId)
            // verify required parameter 'recoveryProjectBackupUpdate' is not null or undefined
            assertParamExists('recoveryProjectBackupUpdate', 'recoveryProjectBackupUpdate', recoveryProjectBackupUpdate)
            const localVarPath = `/recovery/{locationId}/project/{projectId}/backup/{backupId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"backupId"}}`, encodeURIComponent(String(backupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(recoveryProjectBackupUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RecoveryProjectBackupApi - functional programming interface
 * @export
 */
export const RecoveryProjectBackupApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RecoveryProjectBackupApiAxiosParamCreator(configuration)
    return {
        /**
         * Create backup
         * @summary Create recovery/backup
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {RecoveryProjectBackupCreate} recoveryProjectBackupCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recoveryProjectBackupCreate(projectId: string, locationId: string, recoveryProjectBackupCreate: RecoveryProjectBackupCreate, xIdempotencyKey?: string, xDryRun?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Backup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recoveryProjectBackupCreate(projectId, locationId, recoveryProjectBackupCreate, xIdempotencyKey, xDryRun, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete backup
         * @summary Delete recovery/backup
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} backupId Backup Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recoveryProjectBackupDelete(projectId: string, locationId: string, backupId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recoveryProjectBackupDelete(projectId, locationId, backupId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get recovery/backup.event
         * @summary Get recovery/backup.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} backupId Backup Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recoveryProjectBackupEventGet(projectId: string, locationId: string, backupId: string, eventId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recoveryProjectBackupEventGet(projectId, locationId, backupId, eventId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List recovery/backup.event
         * @summary List recovery/backup.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} backupId Backup Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recoveryProjectBackupEventList(projectId: string, locationId: string, backupId: string, $limit?: number, $skip?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Event>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recoveryProjectBackupEventList(projectId, locationId, backupId, $limit, $skip, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * action export
         * @summary Export recovery/backup
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} backupId Backup Id
         * @param {RecoveryProjectBackupExport} recoveryProjectBackupExport 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recoveryProjectBackupExport(projectId: string, locationId: string, backupId: string, recoveryProjectBackupExport: RecoveryProjectBackupExport, xIdempotencyKey?: string, xDryRun?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Backup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recoveryProjectBackupExport(projectId, locationId, backupId, recoveryProjectBackupExport, xIdempotencyKey, xDryRun, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a single backup
         * @summary Get recovery/backup
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} backupId Backup Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recoveryProjectBackupGet(projectId: string, locationId: string, backupId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Backup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recoveryProjectBackupGet(projectId, locationId, backupId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List backup
         * @summary List recovery/backup
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [name] Filter by name
         * @param {string} [source] Filter by source
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recoveryProjectBackupList(projectId: string, locationId: string, name?: string, source?: string, tagValue?: string, tagKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Backup>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recoveryProjectBackupList(projectId, locationId, name, source, tagValue, tagKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get recovery/backup.metric
         * @summary Get recovery/backup.metric
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} backupId Backup Id
         * @param {string} metricId metricId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recoveryProjectBackupMetricGet(projectId: string, locationId: string, backupId: string, metricId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Metric>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recoveryProjectBackupMetricGet(projectId, locationId, backupId, metricId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List recovery/backup.metric
         * @summary List recovery/backup.metric
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} backupId Backup Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recoveryProjectBackupMetricList(projectId: string, locationId: string, backupId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Metric>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recoveryProjectBackupMetricList(projectId, locationId, backupId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List recovery/backup.point
         * @summary List recovery/backup.point
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} backupId Backup Id
         * @param {string} metricId metricId
         * @param {string} [interval] interval
         * @param {string} [timespan] timespan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recoveryProjectBackupMetricPointList(projectId: string, locationId: string, backupId: string, metricId: string, interval?: string, timespan?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Point>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recoveryProjectBackupMetricPointList(projectId, locationId, backupId, metricId, interval, timespan, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get recovery/backup.service
         * @summary Get recovery/backup.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} backupId Backup Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recoveryProjectBackupServiceGet(projectId: string, locationId: string, backupId: string, serviceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceService>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recoveryProjectBackupServiceGet(projectId, locationId, backupId, serviceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List recovery/backup.service
         * @summary List recovery/backup.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} backupId Backup Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recoveryProjectBackupServiceList(projectId: string, locationId: string, backupId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResourceService>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recoveryProjectBackupServiceList(projectId, locationId, backupId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create recovery/backup.tag
         * @summary Create recovery/backup.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} backupId Backup Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recoveryProjectBackupTagCreate(projectId: string, locationId: string, backupId: string, tag: Tag, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recoveryProjectBackupTagCreate(projectId, locationId, backupId, tag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete recovery/backup.tag
         * @summary Delete recovery/backup.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} backupId Backup Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recoveryProjectBackupTagDelete(projectId: string, locationId: string, backupId: string, tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recoveryProjectBackupTagDelete(projectId, locationId, backupId, tagId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get recovery/backup.tag
         * @summary Get recovery/backup.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} backupId Backup Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recoveryProjectBackupTagGet(projectId: string, locationId: string, backupId: string, tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recoveryProjectBackupTagGet(projectId, locationId, backupId, tagId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List recovery/backup.tag
         * @summary List recovery/backup.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} backupId Backup Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recoveryProjectBackupTagList(projectId: string, locationId: string, backupId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recoveryProjectBackupTagList(projectId, locationId, backupId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Replace recovery/backup.tag
         * @summary Replace recovery/backup.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} backupId Backup Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recoveryProjectBackupTagPut(projectId: string, locationId: string, backupId: string, tag: Array<Tag>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recoveryProjectBackupTagPut(projectId, locationId, backupId, tag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns modified backup
         * @summary Update recovery/backup
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} backupId Backup Id
         * @param {RecoveryProjectBackupUpdate} recoveryProjectBackupUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recoveryProjectBackupUpdate(projectId: string, locationId: string, backupId: string, recoveryProjectBackupUpdate: RecoveryProjectBackupUpdate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Backup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recoveryProjectBackupUpdate(projectId, locationId, backupId, recoveryProjectBackupUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RecoveryProjectBackupApi - factory interface
 * @export
 */
export const RecoveryProjectBackupApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RecoveryProjectBackupApiFp(configuration)
    return {
        /**
         * Create backup
         * @summary Create recovery/backup
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {RecoveryProjectBackupCreate} recoveryProjectBackupCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoveryProjectBackupCreate(projectId: string, locationId: string, recoveryProjectBackupCreate: RecoveryProjectBackupCreate, xIdempotencyKey?: string, xDryRun?: string, options?: any): AxiosPromise<Backup> {
            return localVarFp.recoveryProjectBackupCreate(projectId, locationId, recoveryProjectBackupCreate, xIdempotencyKey, xDryRun, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete backup
         * @summary Delete recovery/backup
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} backupId Backup Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoveryProjectBackupDelete(projectId: string, locationId: string, backupId: string, options?: any): AxiosPromise<void> {
            return localVarFp.recoveryProjectBackupDelete(projectId, locationId, backupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get recovery/backup.event
         * @summary Get recovery/backup.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} backupId Backup Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoveryProjectBackupEventGet(projectId: string, locationId: string, backupId: string, eventId: string, options?: any): AxiosPromise<Event> {
            return localVarFp.recoveryProjectBackupEventGet(projectId, locationId, backupId, eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * List recovery/backup.event
         * @summary List recovery/backup.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} backupId Backup Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoveryProjectBackupEventList(projectId: string, locationId: string, backupId: string, $limit?: number, $skip?: number, options?: any): AxiosPromise<Array<Event>> {
            return localVarFp.recoveryProjectBackupEventList(projectId, locationId, backupId, $limit, $skip, options).then((request) => request(axios, basePath));
        },
        /**
         * action export
         * @summary Export recovery/backup
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} backupId Backup Id
         * @param {RecoveryProjectBackupExport} recoveryProjectBackupExport 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoveryProjectBackupExport(projectId: string, locationId: string, backupId: string, recoveryProjectBackupExport: RecoveryProjectBackupExport, xIdempotencyKey?: string, xDryRun?: string, options?: any): AxiosPromise<Backup> {
            return localVarFp.recoveryProjectBackupExport(projectId, locationId, backupId, recoveryProjectBackupExport, xIdempotencyKey, xDryRun, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single backup
         * @summary Get recovery/backup
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} backupId Backup Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoveryProjectBackupGet(projectId: string, locationId: string, backupId: string, options?: any): AxiosPromise<Backup> {
            return localVarFp.recoveryProjectBackupGet(projectId, locationId, backupId, options).then((request) => request(axios, basePath));
        },
        /**
         * List backup
         * @summary List recovery/backup
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [name] Filter by name
         * @param {string} [source] Filter by source
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoveryProjectBackupList(projectId: string, locationId: string, name?: string, source?: string, tagValue?: string, tagKey?: string, options?: any): AxiosPromise<Array<Backup>> {
            return localVarFp.recoveryProjectBackupList(projectId, locationId, name, source, tagValue, tagKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get recovery/backup.metric
         * @summary Get recovery/backup.metric
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} backupId Backup Id
         * @param {string} metricId metricId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoveryProjectBackupMetricGet(projectId: string, locationId: string, backupId: string, metricId: string, options?: any): AxiosPromise<Metric> {
            return localVarFp.recoveryProjectBackupMetricGet(projectId, locationId, backupId, metricId, options).then((request) => request(axios, basePath));
        },
        /**
         * List recovery/backup.metric
         * @summary List recovery/backup.metric
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} backupId Backup Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoveryProjectBackupMetricList(projectId: string, locationId: string, backupId: string, options?: any): AxiosPromise<Array<Metric>> {
            return localVarFp.recoveryProjectBackupMetricList(projectId, locationId, backupId, options).then((request) => request(axios, basePath));
        },
        /**
         * List recovery/backup.point
         * @summary List recovery/backup.point
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} backupId Backup Id
         * @param {string} metricId metricId
         * @param {string} [interval] interval
         * @param {string} [timespan] timespan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoveryProjectBackupMetricPointList(projectId: string, locationId: string, backupId: string, metricId: string, interval?: string, timespan?: string, options?: any): AxiosPromise<Array<Point>> {
            return localVarFp.recoveryProjectBackupMetricPointList(projectId, locationId, backupId, metricId, interval, timespan, options).then((request) => request(axios, basePath));
        },
        /**
         * Get recovery/backup.service
         * @summary Get recovery/backup.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} backupId Backup Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoveryProjectBackupServiceGet(projectId: string, locationId: string, backupId: string, serviceId: string, options?: any): AxiosPromise<ResourceService> {
            return localVarFp.recoveryProjectBackupServiceGet(projectId, locationId, backupId, serviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * List recovery/backup.service
         * @summary List recovery/backup.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} backupId Backup Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoveryProjectBackupServiceList(projectId: string, locationId: string, backupId: string, options?: any): AxiosPromise<Array<ResourceService>> {
            return localVarFp.recoveryProjectBackupServiceList(projectId, locationId, backupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create recovery/backup.tag
         * @summary Create recovery/backup.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} backupId Backup Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoveryProjectBackupTagCreate(projectId: string, locationId: string, backupId: string, tag: Tag, options?: any): AxiosPromise<Tag> {
            return localVarFp.recoveryProjectBackupTagCreate(projectId, locationId, backupId, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete recovery/backup.tag
         * @summary Delete recovery/backup.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} backupId Backup Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoveryProjectBackupTagDelete(projectId: string, locationId: string, backupId: string, tagId: string, options?: any): AxiosPromise<void> {
            return localVarFp.recoveryProjectBackupTagDelete(projectId, locationId, backupId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get recovery/backup.tag
         * @summary Get recovery/backup.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} backupId Backup Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoveryProjectBackupTagGet(projectId: string, locationId: string, backupId: string, tagId: string, options?: any): AxiosPromise<Tag> {
            return localVarFp.recoveryProjectBackupTagGet(projectId, locationId, backupId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * List recovery/backup.tag
         * @summary List recovery/backup.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} backupId Backup Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoveryProjectBackupTagList(projectId: string, locationId: string, backupId: string, options?: any): AxiosPromise<Array<Tag>> {
            return localVarFp.recoveryProjectBackupTagList(projectId, locationId, backupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Replace recovery/backup.tag
         * @summary Replace recovery/backup.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} backupId Backup Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoveryProjectBackupTagPut(projectId: string, locationId: string, backupId: string, tag: Array<Tag>, options?: any): AxiosPromise<Array<Tag>> {
            return localVarFp.recoveryProjectBackupTagPut(projectId, locationId, backupId, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns modified backup
         * @summary Update recovery/backup
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} backupId Backup Id
         * @param {RecoveryProjectBackupUpdate} recoveryProjectBackupUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoveryProjectBackupUpdate(projectId: string, locationId: string, backupId: string, recoveryProjectBackupUpdate: RecoveryProjectBackupUpdate, options?: any): AxiosPromise<Backup> {
            return localVarFp.recoveryProjectBackupUpdate(projectId, locationId, backupId, recoveryProjectBackupUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RecoveryProjectBackupApi - object-oriented interface
 * @export
 * @class RecoveryProjectBackupApi
 * @extends {BaseAPI}
 */
export class RecoveryProjectBackupApi extends BaseAPI {
    /**
     * Create backup
     * @summary Create recovery/backup
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {RecoveryProjectBackupCreate} recoveryProjectBackupCreate 
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {string} [xDryRun] Dry run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecoveryProjectBackupApi
     */
    public recoveryProjectBackupCreate(projectId: string, locationId: string, recoveryProjectBackupCreate: RecoveryProjectBackupCreate, xIdempotencyKey?: string, xDryRun?: string, options?: any) {
        return RecoveryProjectBackupApiFp(this.configuration).recoveryProjectBackupCreate(projectId, locationId, recoveryProjectBackupCreate, xIdempotencyKey, xDryRun, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete backup
     * @summary Delete recovery/backup
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} backupId Backup Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecoveryProjectBackupApi
     */
    public recoveryProjectBackupDelete(projectId: string, locationId: string, backupId: string, options?: any) {
        return RecoveryProjectBackupApiFp(this.configuration).recoveryProjectBackupDelete(projectId, locationId, backupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get recovery/backup.event
     * @summary Get recovery/backup.event
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} backupId Backup Id
     * @param {string} eventId eventId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecoveryProjectBackupApi
     */
    public recoveryProjectBackupEventGet(projectId: string, locationId: string, backupId: string, eventId: string, options?: any) {
        return RecoveryProjectBackupApiFp(this.configuration).recoveryProjectBackupEventGet(projectId, locationId, backupId, eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List recovery/backup.event
     * @summary List recovery/backup.event
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} backupId Backup Id
     * @param {number} [$limit] $limit
     * @param {number} [$skip] $skip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecoveryProjectBackupApi
     */
    public recoveryProjectBackupEventList(projectId: string, locationId: string, backupId: string, $limit?: number, $skip?: number, options?: any) {
        return RecoveryProjectBackupApiFp(this.configuration).recoveryProjectBackupEventList(projectId, locationId, backupId, $limit, $skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * action export
     * @summary Export recovery/backup
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} backupId Backup Id
     * @param {RecoveryProjectBackupExport} recoveryProjectBackupExport 
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {string} [xDryRun] Dry run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecoveryProjectBackupApi
     */
    public recoveryProjectBackupExport(projectId: string, locationId: string, backupId: string, recoveryProjectBackupExport: RecoveryProjectBackupExport, xIdempotencyKey?: string, xDryRun?: string, options?: any) {
        return RecoveryProjectBackupApiFp(this.configuration).recoveryProjectBackupExport(projectId, locationId, backupId, recoveryProjectBackupExport, xIdempotencyKey, xDryRun, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single backup
     * @summary Get recovery/backup
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} backupId Backup Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecoveryProjectBackupApi
     */
    public recoveryProjectBackupGet(projectId: string, locationId: string, backupId: string, options?: any) {
        return RecoveryProjectBackupApiFp(this.configuration).recoveryProjectBackupGet(projectId, locationId, backupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List backup
     * @summary List recovery/backup
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} [name] Filter by name
     * @param {string} [source] Filter by source
     * @param {string} [tagValue] Filter by tag.value
     * @param {string} [tagKey] Filter by tag.key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecoveryProjectBackupApi
     */
    public recoveryProjectBackupList(projectId: string, locationId: string, name?: string, source?: string, tagValue?: string, tagKey?: string, options?: any) {
        return RecoveryProjectBackupApiFp(this.configuration).recoveryProjectBackupList(projectId, locationId, name, source, tagValue, tagKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get recovery/backup.metric
     * @summary Get recovery/backup.metric
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} backupId Backup Id
     * @param {string} metricId metricId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecoveryProjectBackupApi
     */
    public recoveryProjectBackupMetricGet(projectId: string, locationId: string, backupId: string, metricId: string, options?: any) {
        return RecoveryProjectBackupApiFp(this.configuration).recoveryProjectBackupMetricGet(projectId, locationId, backupId, metricId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List recovery/backup.metric
     * @summary List recovery/backup.metric
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} backupId Backup Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecoveryProjectBackupApi
     */
    public recoveryProjectBackupMetricList(projectId: string, locationId: string, backupId: string, options?: any) {
        return RecoveryProjectBackupApiFp(this.configuration).recoveryProjectBackupMetricList(projectId, locationId, backupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List recovery/backup.point
     * @summary List recovery/backup.point
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} backupId Backup Id
     * @param {string} metricId metricId
     * @param {string} [interval] interval
     * @param {string} [timespan] timespan
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecoveryProjectBackupApi
     */
    public recoveryProjectBackupMetricPointList(projectId: string, locationId: string, backupId: string, metricId: string, interval?: string, timespan?: string, options?: any) {
        return RecoveryProjectBackupApiFp(this.configuration).recoveryProjectBackupMetricPointList(projectId, locationId, backupId, metricId, interval, timespan, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get recovery/backup.service
     * @summary Get recovery/backup.service
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} backupId Backup Id
     * @param {string} serviceId serviceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecoveryProjectBackupApi
     */
    public recoveryProjectBackupServiceGet(projectId: string, locationId: string, backupId: string, serviceId: string, options?: any) {
        return RecoveryProjectBackupApiFp(this.configuration).recoveryProjectBackupServiceGet(projectId, locationId, backupId, serviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List recovery/backup.service
     * @summary List recovery/backup.service
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} backupId Backup Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecoveryProjectBackupApi
     */
    public recoveryProjectBackupServiceList(projectId: string, locationId: string, backupId: string, options?: any) {
        return RecoveryProjectBackupApiFp(this.configuration).recoveryProjectBackupServiceList(projectId, locationId, backupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create recovery/backup.tag
     * @summary Create recovery/backup.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} backupId Backup Id
     * @param {Tag} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecoveryProjectBackupApi
     */
    public recoveryProjectBackupTagCreate(projectId: string, locationId: string, backupId: string, tag: Tag, options?: any) {
        return RecoveryProjectBackupApiFp(this.configuration).recoveryProjectBackupTagCreate(projectId, locationId, backupId, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete recovery/backup.tag
     * @summary Delete recovery/backup.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} backupId Backup Id
     * @param {string} tagId tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecoveryProjectBackupApi
     */
    public recoveryProjectBackupTagDelete(projectId: string, locationId: string, backupId: string, tagId: string, options?: any) {
        return RecoveryProjectBackupApiFp(this.configuration).recoveryProjectBackupTagDelete(projectId, locationId, backupId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get recovery/backup.tag
     * @summary Get recovery/backup.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} backupId Backup Id
     * @param {string} tagId tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecoveryProjectBackupApi
     */
    public recoveryProjectBackupTagGet(projectId: string, locationId: string, backupId: string, tagId: string, options?: any) {
        return RecoveryProjectBackupApiFp(this.configuration).recoveryProjectBackupTagGet(projectId, locationId, backupId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List recovery/backup.tag
     * @summary List recovery/backup.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} backupId Backup Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecoveryProjectBackupApi
     */
    public recoveryProjectBackupTagList(projectId: string, locationId: string, backupId: string, options?: any) {
        return RecoveryProjectBackupApiFp(this.configuration).recoveryProjectBackupTagList(projectId, locationId, backupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replace recovery/backup.tag
     * @summary Replace recovery/backup.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} backupId Backup Id
     * @param {Array<Tag>} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecoveryProjectBackupApi
     */
    public recoveryProjectBackupTagPut(projectId: string, locationId: string, backupId: string, tag: Array<Tag>, options?: any) {
        return RecoveryProjectBackupApiFp(this.configuration).recoveryProjectBackupTagPut(projectId, locationId, backupId, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns modified backup
     * @summary Update recovery/backup
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} backupId Backup Id
     * @param {RecoveryProjectBackupUpdate} recoveryProjectBackupUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecoveryProjectBackupApi
     */
    public recoveryProjectBackupUpdate(projectId: string, locationId: string, backupId: string, recoveryProjectBackupUpdate: RecoveryProjectBackupUpdate, options?: any) {
        return RecoveryProjectBackupApiFp(this.configuration).recoveryProjectBackupUpdate(projectId, locationId, backupId, recoveryProjectBackupUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * RecoveryProjectPlanApi - axios parameter creator
 * @export
 */
export const RecoveryProjectPlanApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create plan
         * @summary Create recovery/plan
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {RecoveryProjectPlanCreate} recoveryProjectPlanCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoveryProjectPlanCreate: async (projectId: string, locationId: string, recoveryProjectPlanCreate: RecoveryProjectPlanCreate, xIdempotencyKey?: string, xDryRun?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('recoveryProjectPlanCreate', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('recoveryProjectPlanCreate', 'locationId', locationId)
            // verify required parameter 'recoveryProjectPlanCreate' is not null or undefined
            assertParamExists('recoveryProjectPlanCreate', 'recoveryProjectPlanCreate', recoveryProjectPlanCreate)
            const localVarPath = `/recovery/{locationId}/project/{projectId}/plan`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }

            if (xDryRun !== undefined && xDryRun !== null) {
                localVarHeaderParameter['x-dry-run'] = String(xDryRun);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(recoveryProjectPlanCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete plan
         * @summary Delete recovery/plan
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} planId Plan Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoveryProjectPlanDelete: async (projectId: string, locationId: string, planId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('recoveryProjectPlanDelete', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('recoveryProjectPlanDelete', 'locationId', locationId)
            // verify required parameter 'planId' is not null or undefined
            assertParamExists('recoveryProjectPlanDelete', 'planId', planId)
            const localVarPath = `/recovery/{locationId}/project/{projectId}/plan/{planId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"planId"}}`, encodeURIComponent(String(planId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get recovery/plan.event
         * @summary Get recovery/plan.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} planId Plan Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoveryProjectPlanEventGet: async (projectId: string, locationId: string, planId: string, eventId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('recoveryProjectPlanEventGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('recoveryProjectPlanEventGet', 'locationId', locationId)
            // verify required parameter 'planId' is not null or undefined
            assertParamExists('recoveryProjectPlanEventGet', 'planId', planId)
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('recoveryProjectPlanEventGet', 'eventId', eventId)
            const localVarPath = `/recovery/{locationId}/project/{projectId}/plan/{planId}/event/{eventId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"planId"}}`, encodeURIComponent(String(planId)))
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List recovery/plan.event
         * @summary List recovery/plan.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} planId Plan Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoveryProjectPlanEventList: async (projectId: string, locationId: string, planId: string, $limit?: number, $skip?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('recoveryProjectPlanEventList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('recoveryProjectPlanEventList', 'locationId', locationId)
            // verify required parameter 'planId' is not null or undefined
            assertParamExists('recoveryProjectPlanEventList', 'planId', planId)
            const localVarPath = `/recovery/{locationId}/project/{projectId}/plan/{planId}/event`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"planId"}}`, encodeURIComponent(String(planId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if ($limit !== undefined) {
                localVarQueryParameter['$limit'] = $limit;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single plan
         * @summary Get recovery/plan
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} planId Plan Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoveryProjectPlanGet: async (projectId: string, locationId: string, planId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('recoveryProjectPlanGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('recoveryProjectPlanGet', 'locationId', locationId)
            // verify required parameter 'planId' is not null or undefined
            assertParamExists('recoveryProjectPlanGet', 'planId', planId)
            const localVarPath = `/recovery/{locationId}/project/{projectId}/plan/{planId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"planId"}}`, encodeURIComponent(String(planId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List plan
         * @summary List recovery/plan
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [name] Filter by name
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoveryProjectPlanList: async (projectId: string, locationId: string, name?: string, tagValue?: string, tagKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('recoveryProjectPlanList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('recoveryProjectPlanList', 'locationId', locationId)
            const localVarPath = `/recovery/{locationId}/project/{projectId}/plan`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (tagValue !== undefined) {
                localVarQueryParameter['tag.value'] = tagValue;
            }

            if (tagKey !== undefined) {
                localVarQueryParameter['tag.key'] = tagKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get recovery/plan.service
         * @summary Get recovery/plan.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} planId Plan Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoveryProjectPlanServiceGet: async (projectId: string, locationId: string, planId: string, serviceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('recoveryProjectPlanServiceGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('recoveryProjectPlanServiceGet', 'locationId', locationId)
            // verify required parameter 'planId' is not null or undefined
            assertParamExists('recoveryProjectPlanServiceGet', 'planId', planId)
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('recoveryProjectPlanServiceGet', 'serviceId', serviceId)
            const localVarPath = `/recovery/{locationId}/project/{projectId}/plan/{planId}/service/{serviceId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"planId"}}`, encodeURIComponent(String(planId)))
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List recovery/plan.service
         * @summary List recovery/plan.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} planId Plan Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoveryProjectPlanServiceList: async (projectId: string, locationId: string, planId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('recoveryProjectPlanServiceList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('recoveryProjectPlanServiceList', 'locationId', locationId)
            // verify required parameter 'planId' is not null or undefined
            assertParamExists('recoveryProjectPlanServiceList', 'planId', planId)
            const localVarPath = `/recovery/{locationId}/project/{projectId}/plan/{planId}/service`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"planId"}}`, encodeURIComponent(String(planId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create recovery/plan.tag
         * @summary Create recovery/plan.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} planId Plan Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoveryProjectPlanTagCreate: async (projectId: string, locationId: string, planId: string, tag: Tag, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('recoveryProjectPlanTagCreate', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('recoveryProjectPlanTagCreate', 'locationId', locationId)
            // verify required parameter 'planId' is not null or undefined
            assertParamExists('recoveryProjectPlanTagCreate', 'planId', planId)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('recoveryProjectPlanTagCreate', 'tag', tag)
            const localVarPath = `/recovery/{locationId}/project/{projectId}/plan/{planId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"planId"}}`, encodeURIComponent(String(planId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tag, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete recovery/plan.tag
         * @summary Delete recovery/plan.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} planId Plan Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoveryProjectPlanTagDelete: async (projectId: string, locationId: string, planId: string, tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('recoveryProjectPlanTagDelete', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('recoveryProjectPlanTagDelete', 'locationId', locationId)
            // verify required parameter 'planId' is not null or undefined
            assertParamExists('recoveryProjectPlanTagDelete', 'planId', planId)
            // verify required parameter 'tagId' is not null or undefined
            assertParamExists('recoveryProjectPlanTagDelete', 'tagId', tagId)
            const localVarPath = `/recovery/{locationId}/project/{projectId}/plan/{planId}/tag/{tagId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"planId"}}`, encodeURIComponent(String(planId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get recovery/plan.tag
         * @summary Get recovery/plan.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} planId Plan Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoveryProjectPlanTagGet: async (projectId: string, locationId: string, planId: string, tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('recoveryProjectPlanTagGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('recoveryProjectPlanTagGet', 'locationId', locationId)
            // verify required parameter 'planId' is not null or undefined
            assertParamExists('recoveryProjectPlanTagGet', 'planId', planId)
            // verify required parameter 'tagId' is not null or undefined
            assertParamExists('recoveryProjectPlanTagGet', 'tagId', tagId)
            const localVarPath = `/recovery/{locationId}/project/{projectId}/plan/{planId}/tag/{tagId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"planId"}}`, encodeURIComponent(String(planId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List recovery/plan.tag
         * @summary List recovery/plan.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} planId Plan Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoveryProjectPlanTagList: async (projectId: string, locationId: string, planId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('recoveryProjectPlanTagList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('recoveryProjectPlanTagList', 'locationId', locationId)
            // verify required parameter 'planId' is not null or undefined
            assertParamExists('recoveryProjectPlanTagList', 'planId', planId)
            const localVarPath = `/recovery/{locationId}/project/{projectId}/plan/{planId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"planId"}}`, encodeURIComponent(String(planId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replace recovery/plan.tag
         * @summary Replace recovery/plan.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} planId Plan Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoveryProjectPlanTagPut: async (projectId: string, locationId: string, planId: string, tag: Array<Tag>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('recoveryProjectPlanTagPut', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('recoveryProjectPlanTagPut', 'locationId', locationId)
            // verify required parameter 'planId' is not null or undefined
            assertParamExists('recoveryProjectPlanTagPut', 'planId', planId)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('recoveryProjectPlanTagPut', 'tag', tag)
            const localVarPath = `/recovery/{locationId}/project/{projectId}/plan/{planId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"planId"}}`, encodeURIComponent(String(planId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tag, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns modified plan
         * @summary Update recovery/plan
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} planId Plan Id
         * @param {RecoveryProjectPlanUpdate} recoveryProjectPlanUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoveryProjectPlanUpdate: async (projectId: string, locationId: string, planId: string, recoveryProjectPlanUpdate: RecoveryProjectPlanUpdate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('recoveryProjectPlanUpdate', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('recoveryProjectPlanUpdate', 'locationId', locationId)
            // verify required parameter 'planId' is not null or undefined
            assertParamExists('recoveryProjectPlanUpdate', 'planId', planId)
            // verify required parameter 'recoveryProjectPlanUpdate' is not null or undefined
            assertParamExists('recoveryProjectPlanUpdate', 'recoveryProjectPlanUpdate', recoveryProjectPlanUpdate)
            const localVarPath = `/recovery/{locationId}/project/{projectId}/plan/{planId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"planId"}}`, encodeURIComponent(String(planId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(recoveryProjectPlanUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RecoveryProjectPlanApi - functional programming interface
 * @export
 */
export const RecoveryProjectPlanApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RecoveryProjectPlanApiAxiosParamCreator(configuration)
    return {
        /**
         * Create plan
         * @summary Create recovery/plan
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {RecoveryProjectPlanCreate} recoveryProjectPlanCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recoveryProjectPlanCreate(projectId: string, locationId: string, recoveryProjectPlanCreate: RecoveryProjectPlanCreate, xIdempotencyKey?: string, xDryRun?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Plan>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recoveryProjectPlanCreate(projectId, locationId, recoveryProjectPlanCreate, xIdempotencyKey, xDryRun, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete plan
         * @summary Delete recovery/plan
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} planId Plan Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recoveryProjectPlanDelete(projectId: string, locationId: string, planId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recoveryProjectPlanDelete(projectId, locationId, planId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get recovery/plan.event
         * @summary Get recovery/plan.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} planId Plan Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recoveryProjectPlanEventGet(projectId: string, locationId: string, planId: string, eventId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recoveryProjectPlanEventGet(projectId, locationId, planId, eventId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List recovery/plan.event
         * @summary List recovery/plan.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} planId Plan Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recoveryProjectPlanEventList(projectId: string, locationId: string, planId: string, $limit?: number, $skip?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Event>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recoveryProjectPlanEventList(projectId, locationId, planId, $limit, $skip, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a single plan
         * @summary Get recovery/plan
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} planId Plan Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recoveryProjectPlanGet(projectId: string, locationId: string, planId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Plan>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recoveryProjectPlanGet(projectId, locationId, planId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List plan
         * @summary List recovery/plan
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [name] Filter by name
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recoveryProjectPlanList(projectId: string, locationId: string, name?: string, tagValue?: string, tagKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Plan>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recoveryProjectPlanList(projectId, locationId, name, tagValue, tagKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get recovery/plan.service
         * @summary Get recovery/plan.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} planId Plan Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recoveryProjectPlanServiceGet(projectId: string, locationId: string, planId: string, serviceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceService>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recoveryProjectPlanServiceGet(projectId, locationId, planId, serviceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List recovery/plan.service
         * @summary List recovery/plan.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} planId Plan Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recoveryProjectPlanServiceList(projectId: string, locationId: string, planId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResourceService>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recoveryProjectPlanServiceList(projectId, locationId, planId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create recovery/plan.tag
         * @summary Create recovery/plan.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} planId Plan Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recoveryProjectPlanTagCreate(projectId: string, locationId: string, planId: string, tag: Tag, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recoveryProjectPlanTagCreate(projectId, locationId, planId, tag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete recovery/plan.tag
         * @summary Delete recovery/plan.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} planId Plan Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recoveryProjectPlanTagDelete(projectId: string, locationId: string, planId: string, tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recoveryProjectPlanTagDelete(projectId, locationId, planId, tagId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get recovery/plan.tag
         * @summary Get recovery/plan.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} planId Plan Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recoveryProjectPlanTagGet(projectId: string, locationId: string, planId: string, tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recoveryProjectPlanTagGet(projectId, locationId, planId, tagId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List recovery/plan.tag
         * @summary List recovery/plan.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} planId Plan Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recoveryProjectPlanTagList(projectId: string, locationId: string, planId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recoveryProjectPlanTagList(projectId, locationId, planId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Replace recovery/plan.tag
         * @summary Replace recovery/plan.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} planId Plan Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recoveryProjectPlanTagPut(projectId: string, locationId: string, planId: string, tag: Array<Tag>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recoveryProjectPlanTagPut(projectId, locationId, planId, tag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns modified plan
         * @summary Update recovery/plan
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} planId Plan Id
         * @param {RecoveryProjectPlanUpdate} recoveryProjectPlanUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recoveryProjectPlanUpdate(projectId: string, locationId: string, planId: string, recoveryProjectPlanUpdate: RecoveryProjectPlanUpdate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Plan>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recoveryProjectPlanUpdate(projectId, locationId, planId, recoveryProjectPlanUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * RecoveryProjectPlanApi - factory interface
 * @export
 */
export const RecoveryProjectPlanApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RecoveryProjectPlanApiFp(configuration)
    return {
        /**
         * Create plan
         * @summary Create recovery/plan
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {RecoveryProjectPlanCreate} recoveryProjectPlanCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoveryProjectPlanCreate(projectId: string, locationId: string, recoveryProjectPlanCreate: RecoveryProjectPlanCreate, xIdempotencyKey?: string, xDryRun?: string, options?: any): AxiosPromise<Plan> {
            return localVarFp.recoveryProjectPlanCreate(projectId, locationId, recoveryProjectPlanCreate, xIdempotencyKey, xDryRun, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete plan
         * @summary Delete recovery/plan
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} planId Plan Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoveryProjectPlanDelete(projectId: string, locationId: string, planId: string, options?: any): AxiosPromise<void> {
            return localVarFp.recoveryProjectPlanDelete(projectId, locationId, planId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get recovery/plan.event
         * @summary Get recovery/plan.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} planId Plan Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoveryProjectPlanEventGet(projectId: string, locationId: string, planId: string, eventId: string, options?: any): AxiosPromise<Event> {
            return localVarFp.recoveryProjectPlanEventGet(projectId, locationId, planId, eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * List recovery/plan.event
         * @summary List recovery/plan.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} planId Plan Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoveryProjectPlanEventList(projectId: string, locationId: string, planId: string, $limit?: number, $skip?: number, options?: any): AxiosPromise<Array<Event>> {
            return localVarFp.recoveryProjectPlanEventList(projectId, locationId, planId, $limit, $skip, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single plan
         * @summary Get recovery/plan
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} planId Plan Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoveryProjectPlanGet(projectId: string, locationId: string, planId: string, options?: any): AxiosPromise<Plan> {
            return localVarFp.recoveryProjectPlanGet(projectId, locationId, planId, options).then((request) => request(axios, basePath));
        },
        /**
         * List plan
         * @summary List recovery/plan
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [name] Filter by name
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoveryProjectPlanList(projectId: string, locationId: string, name?: string, tagValue?: string, tagKey?: string, options?: any): AxiosPromise<Array<Plan>> {
            return localVarFp.recoveryProjectPlanList(projectId, locationId, name, tagValue, tagKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get recovery/plan.service
         * @summary Get recovery/plan.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} planId Plan Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoveryProjectPlanServiceGet(projectId: string, locationId: string, planId: string, serviceId: string, options?: any): AxiosPromise<ResourceService> {
            return localVarFp.recoveryProjectPlanServiceGet(projectId, locationId, planId, serviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * List recovery/plan.service
         * @summary List recovery/plan.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} planId Plan Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoveryProjectPlanServiceList(projectId: string, locationId: string, planId: string, options?: any): AxiosPromise<Array<ResourceService>> {
            return localVarFp.recoveryProjectPlanServiceList(projectId, locationId, planId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create recovery/plan.tag
         * @summary Create recovery/plan.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} planId Plan Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoveryProjectPlanTagCreate(projectId: string, locationId: string, planId: string, tag: Tag, options?: any): AxiosPromise<Tag> {
            return localVarFp.recoveryProjectPlanTagCreate(projectId, locationId, planId, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete recovery/plan.tag
         * @summary Delete recovery/plan.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} planId Plan Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoveryProjectPlanTagDelete(projectId: string, locationId: string, planId: string, tagId: string, options?: any): AxiosPromise<void> {
            return localVarFp.recoveryProjectPlanTagDelete(projectId, locationId, planId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get recovery/plan.tag
         * @summary Get recovery/plan.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} planId Plan Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoveryProjectPlanTagGet(projectId: string, locationId: string, planId: string, tagId: string, options?: any): AxiosPromise<Tag> {
            return localVarFp.recoveryProjectPlanTagGet(projectId, locationId, planId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * List recovery/plan.tag
         * @summary List recovery/plan.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} planId Plan Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoveryProjectPlanTagList(projectId: string, locationId: string, planId: string, options?: any): AxiosPromise<Array<Tag>> {
            return localVarFp.recoveryProjectPlanTagList(projectId, locationId, planId, options).then((request) => request(axios, basePath));
        },
        /**
         * Replace recovery/plan.tag
         * @summary Replace recovery/plan.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} planId Plan Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoveryProjectPlanTagPut(projectId: string, locationId: string, planId: string, tag: Array<Tag>, options?: any): AxiosPromise<Array<Tag>> {
            return localVarFp.recoveryProjectPlanTagPut(projectId, locationId, planId, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns modified plan
         * @summary Update recovery/plan
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} planId Plan Id
         * @param {RecoveryProjectPlanUpdate} recoveryProjectPlanUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recoveryProjectPlanUpdate(projectId: string, locationId: string, planId: string, recoveryProjectPlanUpdate: RecoveryProjectPlanUpdate, options?: any): AxiosPromise<Plan> {
            return localVarFp.recoveryProjectPlanUpdate(projectId, locationId, planId, recoveryProjectPlanUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RecoveryProjectPlanApi - object-oriented interface
 * @export
 * @class RecoveryProjectPlanApi
 * @extends {BaseAPI}
 */
export class RecoveryProjectPlanApi extends BaseAPI {
    /**
     * Create plan
     * @summary Create recovery/plan
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {RecoveryProjectPlanCreate} recoveryProjectPlanCreate 
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {string} [xDryRun] Dry run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecoveryProjectPlanApi
     */
    public recoveryProjectPlanCreate(projectId: string, locationId: string, recoveryProjectPlanCreate: RecoveryProjectPlanCreate, xIdempotencyKey?: string, xDryRun?: string, options?: any) {
        return RecoveryProjectPlanApiFp(this.configuration).recoveryProjectPlanCreate(projectId, locationId, recoveryProjectPlanCreate, xIdempotencyKey, xDryRun, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete plan
     * @summary Delete recovery/plan
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} planId Plan Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecoveryProjectPlanApi
     */
    public recoveryProjectPlanDelete(projectId: string, locationId: string, planId: string, options?: any) {
        return RecoveryProjectPlanApiFp(this.configuration).recoveryProjectPlanDelete(projectId, locationId, planId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get recovery/plan.event
     * @summary Get recovery/plan.event
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} planId Plan Id
     * @param {string} eventId eventId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecoveryProjectPlanApi
     */
    public recoveryProjectPlanEventGet(projectId: string, locationId: string, planId: string, eventId: string, options?: any) {
        return RecoveryProjectPlanApiFp(this.configuration).recoveryProjectPlanEventGet(projectId, locationId, planId, eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List recovery/plan.event
     * @summary List recovery/plan.event
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} planId Plan Id
     * @param {number} [$limit] $limit
     * @param {number} [$skip] $skip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecoveryProjectPlanApi
     */
    public recoveryProjectPlanEventList(projectId: string, locationId: string, planId: string, $limit?: number, $skip?: number, options?: any) {
        return RecoveryProjectPlanApiFp(this.configuration).recoveryProjectPlanEventList(projectId, locationId, planId, $limit, $skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single plan
     * @summary Get recovery/plan
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} planId Plan Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecoveryProjectPlanApi
     */
    public recoveryProjectPlanGet(projectId: string, locationId: string, planId: string, options?: any) {
        return RecoveryProjectPlanApiFp(this.configuration).recoveryProjectPlanGet(projectId, locationId, planId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List plan
     * @summary List recovery/plan
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} [name] Filter by name
     * @param {string} [tagValue] Filter by tag.value
     * @param {string} [tagKey] Filter by tag.key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecoveryProjectPlanApi
     */
    public recoveryProjectPlanList(projectId: string, locationId: string, name?: string, tagValue?: string, tagKey?: string, options?: any) {
        return RecoveryProjectPlanApiFp(this.configuration).recoveryProjectPlanList(projectId, locationId, name, tagValue, tagKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get recovery/plan.service
     * @summary Get recovery/plan.service
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} planId Plan Id
     * @param {string} serviceId serviceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecoveryProjectPlanApi
     */
    public recoveryProjectPlanServiceGet(projectId: string, locationId: string, planId: string, serviceId: string, options?: any) {
        return RecoveryProjectPlanApiFp(this.configuration).recoveryProjectPlanServiceGet(projectId, locationId, planId, serviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List recovery/plan.service
     * @summary List recovery/plan.service
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} planId Plan Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecoveryProjectPlanApi
     */
    public recoveryProjectPlanServiceList(projectId: string, locationId: string, planId: string, options?: any) {
        return RecoveryProjectPlanApiFp(this.configuration).recoveryProjectPlanServiceList(projectId, locationId, planId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create recovery/plan.tag
     * @summary Create recovery/plan.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} planId Plan Id
     * @param {Tag} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecoveryProjectPlanApi
     */
    public recoveryProjectPlanTagCreate(projectId: string, locationId: string, planId: string, tag: Tag, options?: any) {
        return RecoveryProjectPlanApiFp(this.configuration).recoveryProjectPlanTagCreate(projectId, locationId, planId, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete recovery/plan.tag
     * @summary Delete recovery/plan.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} planId Plan Id
     * @param {string} tagId tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecoveryProjectPlanApi
     */
    public recoveryProjectPlanTagDelete(projectId: string, locationId: string, planId: string, tagId: string, options?: any) {
        return RecoveryProjectPlanApiFp(this.configuration).recoveryProjectPlanTagDelete(projectId, locationId, planId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get recovery/plan.tag
     * @summary Get recovery/plan.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} planId Plan Id
     * @param {string} tagId tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecoveryProjectPlanApi
     */
    public recoveryProjectPlanTagGet(projectId: string, locationId: string, planId: string, tagId: string, options?: any) {
        return RecoveryProjectPlanApiFp(this.configuration).recoveryProjectPlanTagGet(projectId, locationId, planId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List recovery/plan.tag
     * @summary List recovery/plan.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} planId Plan Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecoveryProjectPlanApi
     */
    public recoveryProjectPlanTagList(projectId: string, locationId: string, planId: string, options?: any) {
        return RecoveryProjectPlanApiFp(this.configuration).recoveryProjectPlanTagList(projectId, locationId, planId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replace recovery/plan.tag
     * @summary Replace recovery/plan.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} planId Plan Id
     * @param {Array<Tag>} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecoveryProjectPlanApi
     */
    public recoveryProjectPlanTagPut(projectId: string, locationId: string, planId: string, tag: Array<Tag>, options?: any) {
        return RecoveryProjectPlanApiFp(this.configuration).recoveryProjectPlanTagPut(projectId, locationId, planId, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns modified plan
     * @summary Update recovery/plan
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} planId Plan Id
     * @param {RecoveryProjectPlanUpdate} recoveryProjectPlanUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RecoveryProjectPlanApi
     */
    public recoveryProjectPlanUpdate(projectId: string, locationId: string, planId: string, recoveryProjectPlanUpdate: RecoveryProjectPlanUpdate, options?: any) {
        return RecoveryProjectPlanApiFp(this.configuration).recoveryProjectPlanUpdate(projectId, locationId, planId, recoveryProjectPlanUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StorageProjectBucketApi - axios parameter creator
 * @export
 */
export const StorageProjectBucketApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns a single bucket
         * @summary Get storage/bucket
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} bucketId Bucket Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectBucketGet: async (projectId: string, locationId: string, bucketId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('storageProjectBucketGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('storageProjectBucketGet', 'locationId', locationId)
            // verify required parameter 'bucketId' is not null or undefined
            assertParamExists('storageProjectBucketGet', 'bucketId', bucketId)
            const localVarPath = `/storage/{locationId}/project/{projectId}/bucket/{bucketId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"bucketId"}}`, encodeURIComponent(String(bucketId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List bucket
         * @summary List storage/bucket
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectBucketList: async (projectId: string, locationId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('storageProjectBucketList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('storageProjectBucketList', 'locationId', locationId)
            const localVarPath = `/storage/{locationId}/project/{projectId}/bucket`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete storage/bucket.object
         * @summary Delete storage/bucket.object
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} bucketId Bucket Id
         * @param {string} objectId objectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectBucketObjectDelete: async (projectId: string, locationId: string, bucketId: string, objectId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('storageProjectBucketObjectDelete', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('storageProjectBucketObjectDelete', 'locationId', locationId)
            // verify required parameter 'bucketId' is not null or undefined
            assertParamExists('storageProjectBucketObjectDelete', 'bucketId', bucketId)
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('storageProjectBucketObjectDelete', 'objectId', objectId)
            const localVarPath = `/storage/{locationId}/project/{projectId}/bucket/{bucketId}/object/{objectId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"bucketId"}}`, encodeURIComponent(String(bucketId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * action download
         * @summary Download storage/bucket.object
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} bucketId Bucket Id
         * @param {string} objectId objectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectBucketObjectDownload: async (projectId: string, locationId: string, bucketId: string, objectId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('storageProjectBucketObjectDownload', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('storageProjectBucketObjectDownload', 'locationId', locationId)
            // verify required parameter 'bucketId' is not null or undefined
            assertParamExists('storageProjectBucketObjectDownload', 'bucketId', bucketId)
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('storageProjectBucketObjectDownload', 'objectId', objectId)
            const localVarPath = `/storage/{locationId}/project/{projectId}/bucket/{bucketId}/object/{objectId}/actions/download`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"bucketId"}}`, encodeURIComponent(String(bucketId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get storage/bucket.object
         * @summary Get storage/bucket.object
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} bucketId Bucket Id
         * @param {string} objectId objectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectBucketObjectGet: async (projectId: string, locationId: string, bucketId: string, objectId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('storageProjectBucketObjectGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('storageProjectBucketObjectGet', 'locationId', locationId)
            // verify required parameter 'bucketId' is not null or undefined
            assertParamExists('storageProjectBucketObjectGet', 'bucketId', bucketId)
            // verify required parameter 'objectId' is not null or undefined
            assertParamExists('storageProjectBucketObjectGet', 'objectId', objectId)
            const localVarPath = `/storage/{locationId}/project/{projectId}/bucket/{bucketId}/object/{objectId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"bucketId"}}`, encodeURIComponent(String(bucketId)))
                .replace(`{${"objectId"}}`, encodeURIComponent(String(objectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List storage/bucket.object
         * @summary List storage/bucket.object
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} bucketId Bucket Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectBucketObjectList: async (projectId: string, locationId: string, bucketId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('storageProjectBucketObjectList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('storageProjectBucketObjectList', 'locationId', locationId)
            // verify required parameter 'bucketId' is not null or undefined
            assertParamExists('storageProjectBucketObjectList', 'bucketId', bucketId)
            const localVarPath = `/storage/{locationId}/project/{projectId}/bucket/{bucketId}/object`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"bucketId"}}`, encodeURIComponent(String(bucketId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * action upload
         * @summary Upload storage/bucket
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} bucketId Bucket Id
         * @param {StorageProjectBucketUpload} storageProjectBucketUpload 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectBucketUpload: async (projectId: string, locationId: string, bucketId: string, storageProjectBucketUpload: StorageProjectBucketUpload, xIdempotencyKey?: string, xDryRun?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('storageProjectBucketUpload', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('storageProjectBucketUpload', 'locationId', locationId)
            // verify required parameter 'bucketId' is not null or undefined
            assertParamExists('storageProjectBucketUpload', 'bucketId', bucketId)
            // verify required parameter 'storageProjectBucketUpload' is not null or undefined
            assertParamExists('storageProjectBucketUpload', 'storageProjectBucketUpload', storageProjectBucketUpload)
            const localVarPath = `/storage/{locationId}/project/{projectId}/bucket/{bucketId}/actions/upload`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"bucketId"}}`, encodeURIComponent(String(bucketId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }

            if (xDryRun !== undefined && xDryRun !== null) {
                localVarHeaderParameter['x-dry-run'] = String(xDryRun);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storageProjectBucketUpload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StorageProjectBucketApi - functional programming interface
 * @export
 */
export const StorageProjectBucketApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StorageProjectBucketApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns a single bucket
         * @summary Get storage/bucket
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} bucketId Bucket Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectBucketGet(projectId: string, locationId: string, bucketId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Bucket>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageProjectBucketGet(projectId, locationId, bucketId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List bucket
         * @summary List storage/bucket
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectBucketList(projectId: string, locationId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Bucket>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageProjectBucketList(projectId, locationId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete storage/bucket.object
         * @summary Delete storage/bucket.object
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} bucketId Bucket Id
         * @param {string} objectId objectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectBucketObjectDelete(projectId: string, locationId: string, bucketId: string, objectId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageProjectBucketObjectDelete(projectId, locationId, bucketId, objectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * action download
         * @summary Download storage/bucket.object
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} bucketId Bucket Id
         * @param {string} objectId objectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectBucketObjectDownload(projectId: string, locationId: string, bucketId: string, objectId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageProjectBucketObjectDownload(projectId, locationId, bucketId, objectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get storage/bucket.object
         * @summary Get storage/bucket.object
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} bucketId Bucket Id
         * @param {string} objectId objectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectBucketObjectGet(projectId: string, locationId: string, bucketId: string, objectId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StorageObject>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageProjectBucketObjectGet(projectId, locationId, bucketId, objectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List storage/bucket.object
         * @summary List storage/bucket.object
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} bucketId Bucket Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectBucketObjectList(projectId: string, locationId: string, bucketId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<StorageObject>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageProjectBucketObjectList(projectId, locationId, bucketId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * action upload
         * @summary Upload storage/bucket
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} bucketId Bucket Id
         * @param {StorageProjectBucketUpload} storageProjectBucketUpload 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectBucketUpload(projectId: string, locationId: string, bucketId: string, storageProjectBucketUpload: StorageProjectBucketUpload, xIdempotencyKey?: string, xDryRun?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Bucket>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageProjectBucketUpload(projectId, locationId, bucketId, storageProjectBucketUpload, xIdempotencyKey, xDryRun, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StorageProjectBucketApi - factory interface
 * @export
 */
export const StorageProjectBucketApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StorageProjectBucketApiFp(configuration)
    return {
        /**
         * Returns a single bucket
         * @summary Get storage/bucket
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} bucketId Bucket Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectBucketGet(projectId: string, locationId: string, bucketId: string, options?: any): AxiosPromise<Bucket> {
            return localVarFp.storageProjectBucketGet(projectId, locationId, bucketId, options).then((request) => request(axios, basePath));
        },
        /**
         * List bucket
         * @summary List storage/bucket
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectBucketList(projectId: string, locationId: string, options?: any): AxiosPromise<Array<Bucket>> {
            return localVarFp.storageProjectBucketList(projectId, locationId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete storage/bucket.object
         * @summary Delete storage/bucket.object
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} bucketId Bucket Id
         * @param {string} objectId objectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectBucketObjectDelete(projectId: string, locationId: string, bucketId: string, objectId: string, options?: any): AxiosPromise<void> {
            return localVarFp.storageProjectBucketObjectDelete(projectId, locationId, bucketId, objectId, options).then((request) => request(axios, basePath));
        },
        /**
         * action download
         * @summary Download storage/bucket.object
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} bucketId Bucket Id
         * @param {string} objectId objectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectBucketObjectDownload(projectId: string, locationId: string, bucketId: string, objectId: string, options?: any): AxiosPromise<void> {
            return localVarFp.storageProjectBucketObjectDownload(projectId, locationId, bucketId, objectId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get storage/bucket.object
         * @summary Get storage/bucket.object
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} bucketId Bucket Id
         * @param {string} objectId objectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectBucketObjectGet(projectId: string, locationId: string, bucketId: string, objectId: string, options?: any): AxiosPromise<StorageObject> {
            return localVarFp.storageProjectBucketObjectGet(projectId, locationId, bucketId, objectId, options).then((request) => request(axios, basePath));
        },
        /**
         * List storage/bucket.object
         * @summary List storage/bucket.object
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} bucketId Bucket Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectBucketObjectList(projectId: string, locationId: string, bucketId: string, options?: any): AxiosPromise<Array<StorageObject>> {
            return localVarFp.storageProjectBucketObjectList(projectId, locationId, bucketId, options).then((request) => request(axios, basePath));
        },
        /**
         * action upload
         * @summary Upload storage/bucket
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} bucketId Bucket Id
         * @param {StorageProjectBucketUpload} storageProjectBucketUpload 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectBucketUpload(projectId: string, locationId: string, bucketId: string, storageProjectBucketUpload: StorageProjectBucketUpload, xIdempotencyKey?: string, xDryRun?: string, options?: any): AxiosPromise<Bucket> {
            return localVarFp.storageProjectBucketUpload(projectId, locationId, bucketId, storageProjectBucketUpload, xIdempotencyKey, xDryRun, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StorageProjectBucketApi - object-oriented interface
 * @export
 * @class StorageProjectBucketApi
 * @extends {BaseAPI}
 */
export class StorageProjectBucketApi extends BaseAPI {
    /**
     * Returns a single bucket
     * @summary Get storage/bucket
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} bucketId Bucket Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectBucketApi
     */
    public storageProjectBucketGet(projectId: string, locationId: string, bucketId: string, options?: any) {
        return StorageProjectBucketApiFp(this.configuration).storageProjectBucketGet(projectId, locationId, bucketId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List bucket
     * @summary List storage/bucket
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectBucketApi
     */
    public storageProjectBucketList(projectId: string, locationId: string, options?: any) {
        return StorageProjectBucketApiFp(this.configuration).storageProjectBucketList(projectId, locationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete storage/bucket.object
     * @summary Delete storage/bucket.object
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} bucketId Bucket Id
     * @param {string} objectId objectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectBucketApi
     */
    public storageProjectBucketObjectDelete(projectId: string, locationId: string, bucketId: string, objectId: string, options?: any) {
        return StorageProjectBucketApiFp(this.configuration).storageProjectBucketObjectDelete(projectId, locationId, bucketId, objectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * action download
     * @summary Download storage/bucket.object
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} bucketId Bucket Id
     * @param {string} objectId objectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectBucketApi
     */
    public storageProjectBucketObjectDownload(projectId: string, locationId: string, bucketId: string, objectId: string, options?: any) {
        return StorageProjectBucketApiFp(this.configuration).storageProjectBucketObjectDownload(projectId, locationId, bucketId, objectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get storage/bucket.object
     * @summary Get storage/bucket.object
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} bucketId Bucket Id
     * @param {string} objectId objectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectBucketApi
     */
    public storageProjectBucketObjectGet(projectId: string, locationId: string, bucketId: string, objectId: string, options?: any) {
        return StorageProjectBucketApiFp(this.configuration).storageProjectBucketObjectGet(projectId, locationId, bucketId, objectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List storage/bucket.object
     * @summary List storage/bucket.object
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} bucketId Bucket Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectBucketApi
     */
    public storageProjectBucketObjectList(projectId: string, locationId: string, bucketId: string, options?: any) {
        return StorageProjectBucketApiFp(this.configuration).storageProjectBucketObjectList(projectId, locationId, bucketId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * action upload
     * @summary Upload storage/bucket
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} bucketId Bucket Id
     * @param {StorageProjectBucketUpload} storageProjectBucketUpload 
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {string} [xDryRun] Dry run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectBucketApi
     */
    public storageProjectBucketUpload(projectId: string, locationId: string, bucketId: string, storageProjectBucketUpload: StorageProjectBucketUpload, xIdempotencyKey?: string, xDryRun?: string, options?: any) {
        return StorageProjectBucketApiFp(this.configuration).storageProjectBucketUpload(projectId, locationId, bucketId, storageProjectBucketUpload, xIdempotencyKey, xDryRun, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StorageProjectDiskApi - axios parameter creator
 * @export
 */
export const StorageProjectDiskApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create disk
         * @summary Create storage/disk
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {StorageProjectDiskCreate} storageProjectDiskCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectDiskCreate: async (projectId: string, locationId: string, storageProjectDiskCreate: StorageProjectDiskCreate, xIdempotencyKey?: string, xDryRun?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('storageProjectDiskCreate', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('storageProjectDiskCreate', 'locationId', locationId)
            // verify required parameter 'storageProjectDiskCreate' is not null or undefined
            assertParamExists('storageProjectDiskCreate', 'storageProjectDiskCreate', storageProjectDiskCreate)
            const localVarPath = `/storage/{locationId}/project/{projectId}/disk`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }

            if (xDryRun !== undefined && xDryRun !== null) {
                localVarHeaderParameter['x-dry-run'] = String(xDryRun);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storageProjectDiskCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete disk
         * @summary Delete storage/disk
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectDiskDelete: async (projectId: string, locationId: string, diskId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('storageProjectDiskDelete', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('storageProjectDiskDelete', 'locationId', locationId)
            // verify required parameter 'diskId' is not null or undefined
            assertParamExists('storageProjectDiskDelete', 'diskId', diskId)
            const localVarPath = `/storage/{locationId}/project/{projectId}/disk/{diskId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"diskId"}}`, encodeURIComponent(String(diskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * action detach
         * @summary Detach storage/disk
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectDiskDetach: async (projectId: string, locationId: string, diskId: string, xIdempotencyKey?: string, xDryRun?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('storageProjectDiskDetach', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('storageProjectDiskDetach', 'locationId', locationId)
            // verify required parameter 'diskId' is not null or undefined
            assertParamExists('storageProjectDiskDetach', 'diskId', diskId)
            const localVarPath = `/storage/{locationId}/project/{projectId}/disk/{diskId}/actions/detach`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"diskId"}}`, encodeURIComponent(String(diskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }

            if (xDryRun !== undefined && xDryRun !== null) {
                localVarHeaderParameter['x-dry-run'] = String(xDryRun);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * action download
         * @summary Download storage/disk
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectDiskDownload: async (projectId: string, locationId: string, diskId: string, xIdempotencyKey?: string, xDryRun?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('storageProjectDiskDownload', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('storageProjectDiskDownload', 'locationId', locationId)
            // verify required parameter 'diskId' is not null or undefined
            assertParamExists('storageProjectDiskDownload', 'diskId', diskId)
            const localVarPath = `/storage/{locationId}/project/{projectId}/disk/{diskId}/actions/download`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"diskId"}}`, encodeURIComponent(String(diskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }

            if (xDryRun !== undefined && xDryRun !== null) {
                localVarHeaderParameter['x-dry-run'] = String(xDryRun);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get storage/disk.event
         * @summary Get storage/disk.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectDiskEventGet: async (projectId: string, locationId: string, diskId: string, eventId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('storageProjectDiskEventGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('storageProjectDiskEventGet', 'locationId', locationId)
            // verify required parameter 'diskId' is not null or undefined
            assertParamExists('storageProjectDiskEventGet', 'diskId', diskId)
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('storageProjectDiskEventGet', 'eventId', eventId)
            const localVarPath = `/storage/{locationId}/project/{projectId}/disk/{diskId}/event/{eventId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"diskId"}}`, encodeURIComponent(String(diskId)))
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List storage/disk.event
         * @summary List storage/disk.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectDiskEventList: async (projectId: string, locationId: string, diskId: string, $limit?: number, $skip?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('storageProjectDiskEventList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('storageProjectDiskEventList', 'locationId', locationId)
            // verify required parameter 'diskId' is not null or undefined
            assertParamExists('storageProjectDiskEventList', 'diskId', diskId)
            const localVarPath = `/storage/{locationId}/project/{projectId}/disk/{diskId}/event`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"diskId"}}`, encodeURIComponent(String(diskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if ($limit !== undefined) {
                localVarQueryParameter['$limit'] = $limit;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single disk
         * @summary Get storage/disk
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectDiskGet: async (projectId: string, locationId: string, diskId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('storageProjectDiskGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('storageProjectDiskGet', 'locationId', locationId)
            // verify required parameter 'diskId' is not null or undefined
            assertParamExists('storageProjectDiskGet', 'diskId', diskId)
            const localVarPath = `/storage/{locationId}/project/{projectId}/disk/{diskId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"diskId"}}`, encodeURIComponent(String(diskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List disk
         * @summary List storage/disk
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [name] Filter by name
         * @param {string} [vm] Filter by vm
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectDiskList: async (projectId: string, locationId: string, name?: string, vm?: string, tagValue?: string, tagKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('storageProjectDiskList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('storageProjectDiskList', 'locationId', locationId)
            const localVarPath = `/storage/{locationId}/project/{projectId}/disk`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (vm !== undefined) {
                localVarQueryParameter['vm'] = vm;
            }

            if (tagValue !== undefined) {
                localVarQueryParameter['tag.value'] = tagValue;
            }

            if (tagKey !== undefined) {
                localVarQueryParameter['tag.key'] = tagKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get storage/disk.metric
         * @summary Get storage/disk.metric
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {string} metricId metricId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectDiskMetricGet: async (projectId: string, locationId: string, diskId: string, metricId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('storageProjectDiskMetricGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('storageProjectDiskMetricGet', 'locationId', locationId)
            // verify required parameter 'diskId' is not null or undefined
            assertParamExists('storageProjectDiskMetricGet', 'diskId', diskId)
            // verify required parameter 'metricId' is not null or undefined
            assertParamExists('storageProjectDiskMetricGet', 'metricId', metricId)
            const localVarPath = `/storage/{locationId}/project/{projectId}/disk/{diskId}/metric/{metricId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"diskId"}}`, encodeURIComponent(String(diskId)))
                .replace(`{${"metricId"}}`, encodeURIComponent(String(metricId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List storage/disk.metric
         * @summary List storage/disk.metric
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectDiskMetricList: async (projectId: string, locationId: string, diskId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('storageProjectDiskMetricList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('storageProjectDiskMetricList', 'locationId', locationId)
            // verify required parameter 'diskId' is not null or undefined
            assertParamExists('storageProjectDiskMetricList', 'diskId', diskId)
            const localVarPath = `/storage/{locationId}/project/{projectId}/disk/{diskId}/metric`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"diskId"}}`, encodeURIComponent(String(diskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List storage/disk.point
         * @summary List storage/disk.point
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {string} metricId metricId
         * @param {string} [interval] interval
         * @param {string} [timespan] timespan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectDiskMetricPointList: async (projectId: string, locationId: string, diskId: string, metricId: string, interval?: string, timespan?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('storageProjectDiskMetricPointList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('storageProjectDiskMetricPointList', 'locationId', locationId)
            // verify required parameter 'diskId' is not null or undefined
            assertParamExists('storageProjectDiskMetricPointList', 'diskId', diskId)
            // verify required parameter 'metricId' is not null or undefined
            assertParamExists('storageProjectDiskMetricPointList', 'metricId', metricId)
            const localVarPath = `/storage/{locationId}/project/{projectId}/disk/{diskId}/metric/{metricId}/point`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"diskId"}}`, encodeURIComponent(String(diskId)))
                .replace(`{${"metricId"}}`, encodeURIComponent(String(metricId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (timespan !== undefined) {
                localVarQueryParameter['timespan'] = timespan;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * action resize
         * @summary Resize storage/disk
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {StorageProjectDiskResize} storageProjectDiskResize 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectDiskResize: async (projectId: string, locationId: string, diskId: string, storageProjectDiskResize: StorageProjectDiskResize, xIdempotencyKey?: string, xDryRun?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('storageProjectDiskResize', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('storageProjectDiskResize', 'locationId', locationId)
            // verify required parameter 'diskId' is not null or undefined
            assertParamExists('storageProjectDiskResize', 'diskId', diskId)
            // verify required parameter 'storageProjectDiskResize' is not null or undefined
            assertParamExists('storageProjectDiskResize', 'storageProjectDiskResize', storageProjectDiskResize)
            const localVarPath = `/storage/{locationId}/project/{projectId}/disk/{diskId}/actions/resize`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"diskId"}}`, encodeURIComponent(String(diskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }

            if (xDryRun !== undefined && xDryRun !== null) {
                localVarHeaderParameter['x-dry-run'] = String(xDryRun);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storageProjectDiskResize, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get storage/disk.service
         * @summary Get storage/disk.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectDiskServiceGet: async (projectId: string, locationId: string, diskId: string, serviceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('storageProjectDiskServiceGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('storageProjectDiskServiceGet', 'locationId', locationId)
            // verify required parameter 'diskId' is not null or undefined
            assertParamExists('storageProjectDiskServiceGet', 'diskId', diskId)
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('storageProjectDiskServiceGet', 'serviceId', serviceId)
            const localVarPath = `/storage/{locationId}/project/{projectId}/disk/{diskId}/service/{serviceId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"diskId"}}`, encodeURIComponent(String(diskId)))
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List storage/disk.service
         * @summary List storage/disk.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectDiskServiceList: async (projectId: string, locationId: string, diskId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('storageProjectDiskServiceList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('storageProjectDiskServiceList', 'locationId', locationId)
            // verify required parameter 'diskId' is not null or undefined
            assertParamExists('storageProjectDiskServiceList', 'diskId', diskId)
            const localVarPath = `/storage/{locationId}/project/{projectId}/disk/{diskId}/service`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"diskId"}}`, encodeURIComponent(String(diskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create storage/disk.tag
         * @summary Create storage/disk.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectDiskTagCreate: async (projectId: string, locationId: string, diskId: string, tag: Tag, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('storageProjectDiskTagCreate', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('storageProjectDiskTagCreate', 'locationId', locationId)
            // verify required parameter 'diskId' is not null or undefined
            assertParamExists('storageProjectDiskTagCreate', 'diskId', diskId)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('storageProjectDiskTagCreate', 'tag', tag)
            const localVarPath = `/storage/{locationId}/project/{projectId}/disk/{diskId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"diskId"}}`, encodeURIComponent(String(diskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tag, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete storage/disk.tag
         * @summary Delete storage/disk.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectDiskTagDelete: async (projectId: string, locationId: string, diskId: string, tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('storageProjectDiskTagDelete', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('storageProjectDiskTagDelete', 'locationId', locationId)
            // verify required parameter 'diskId' is not null or undefined
            assertParamExists('storageProjectDiskTagDelete', 'diskId', diskId)
            // verify required parameter 'tagId' is not null or undefined
            assertParamExists('storageProjectDiskTagDelete', 'tagId', tagId)
            const localVarPath = `/storage/{locationId}/project/{projectId}/disk/{diskId}/tag/{tagId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"diskId"}}`, encodeURIComponent(String(diskId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get storage/disk.tag
         * @summary Get storage/disk.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectDiskTagGet: async (projectId: string, locationId: string, diskId: string, tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('storageProjectDiskTagGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('storageProjectDiskTagGet', 'locationId', locationId)
            // verify required parameter 'diskId' is not null or undefined
            assertParamExists('storageProjectDiskTagGet', 'diskId', diskId)
            // verify required parameter 'tagId' is not null or undefined
            assertParamExists('storageProjectDiskTagGet', 'tagId', tagId)
            const localVarPath = `/storage/{locationId}/project/{projectId}/disk/{diskId}/tag/{tagId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"diskId"}}`, encodeURIComponent(String(diskId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List storage/disk.tag
         * @summary List storage/disk.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectDiskTagList: async (projectId: string, locationId: string, diskId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('storageProjectDiskTagList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('storageProjectDiskTagList', 'locationId', locationId)
            // verify required parameter 'diskId' is not null or undefined
            assertParamExists('storageProjectDiskTagList', 'diskId', diskId)
            const localVarPath = `/storage/{locationId}/project/{projectId}/disk/{diskId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"diskId"}}`, encodeURIComponent(String(diskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replace storage/disk.tag
         * @summary Replace storage/disk.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectDiskTagPut: async (projectId: string, locationId: string, diskId: string, tag: Array<Tag>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('storageProjectDiskTagPut', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('storageProjectDiskTagPut', 'locationId', locationId)
            // verify required parameter 'diskId' is not null or undefined
            assertParamExists('storageProjectDiskTagPut', 'diskId', diskId)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('storageProjectDiskTagPut', 'tag', tag)
            const localVarPath = `/storage/{locationId}/project/{projectId}/disk/{diskId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"diskId"}}`, encodeURIComponent(String(diskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tag, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * action transfer
         * @summary Transfer storage/disk
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {StorageProjectDiskTransfer} storageProjectDiskTransfer 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectDiskTransfer: async (projectId: string, locationId: string, diskId: string, storageProjectDiskTransfer: StorageProjectDiskTransfer, xIdempotencyKey?: string, xDryRun?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('storageProjectDiskTransfer', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('storageProjectDiskTransfer', 'locationId', locationId)
            // verify required parameter 'diskId' is not null or undefined
            assertParamExists('storageProjectDiskTransfer', 'diskId', diskId)
            // verify required parameter 'storageProjectDiskTransfer' is not null or undefined
            assertParamExists('storageProjectDiskTransfer', 'storageProjectDiskTransfer', storageProjectDiskTransfer)
            const localVarPath = `/storage/{locationId}/project/{projectId}/disk/{diskId}/actions/transfer`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"diskId"}}`, encodeURIComponent(String(diskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }

            if (xDryRun !== undefined && xDryRun !== null) {
                localVarHeaderParameter['x-dry-run'] = String(xDryRun);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storageProjectDiskTransfer, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns modified disk
         * @summary Update storage/disk
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {StorageProjectDiskUpdate} storageProjectDiskUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectDiskUpdate: async (projectId: string, locationId: string, diskId: string, storageProjectDiskUpdate: StorageProjectDiskUpdate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('storageProjectDiskUpdate', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('storageProjectDiskUpdate', 'locationId', locationId)
            // verify required parameter 'diskId' is not null or undefined
            assertParamExists('storageProjectDiskUpdate', 'diskId', diskId)
            // verify required parameter 'storageProjectDiskUpdate' is not null or undefined
            assertParamExists('storageProjectDiskUpdate', 'storageProjectDiskUpdate', storageProjectDiskUpdate)
            const localVarPath = `/storage/{locationId}/project/{projectId}/disk/{diskId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"diskId"}}`, encodeURIComponent(String(diskId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storageProjectDiskUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StorageProjectDiskApi - functional programming interface
 * @export
 */
export const StorageProjectDiskApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StorageProjectDiskApiAxiosParamCreator(configuration)
    return {
        /**
         * Create disk
         * @summary Create storage/disk
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {StorageProjectDiskCreate} storageProjectDiskCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectDiskCreate(projectId: string, locationId: string, storageProjectDiskCreate: StorageProjectDiskCreate, xIdempotencyKey?: string, xDryRun?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Disk>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageProjectDiskCreate(projectId, locationId, storageProjectDiskCreate, xIdempotencyKey, xDryRun, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete disk
         * @summary Delete storage/disk
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectDiskDelete(projectId: string, locationId: string, diskId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageProjectDiskDelete(projectId, locationId, diskId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * action detach
         * @summary Detach storage/disk
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectDiskDetach(projectId: string, locationId: string, diskId: string, xIdempotencyKey?: string, xDryRun?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Disk>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageProjectDiskDetach(projectId, locationId, diskId, xIdempotencyKey, xDryRun, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * action download
         * @summary Download storage/disk
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectDiskDownload(projectId: string, locationId: string, diskId: string, xIdempotencyKey?: string, xDryRun?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageProjectDiskDownload(projectId, locationId, diskId, xIdempotencyKey, xDryRun, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get storage/disk.event
         * @summary Get storage/disk.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectDiskEventGet(projectId: string, locationId: string, diskId: string, eventId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageProjectDiskEventGet(projectId, locationId, diskId, eventId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List storage/disk.event
         * @summary List storage/disk.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectDiskEventList(projectId: string, locationId: string, diskId: string, $limit?: number, $skip?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Event>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageProjectDiskEventList(projectId, locationId, diskId, $limit, $skip, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a single disk
         * @summary Get storage/disk
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectDiskGet(projectId: string, locationId: string, diskId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Disk>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageProjectDiskGet(projectId, locationId, diskId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List disk
         * @summary List storage/disk
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [name] Filter by name
         * @param {string} [vm] Filter by vm
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectDiskList(projectId: string, locationId: string, name?: string, vm?: string, tagValue?: string, tagKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Disk>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageProjectDiskList(projectId, locationId, name, vm, tagValue, tagKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get storage/disk.metric
         * @summary Get storage/disk.metric
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {string} metricId metricId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectDiskMetricGet(projectId: string, locationId: string, diskId: string, metricId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Metric>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageProjectDiskMetricGet(projectId, locationId, diskId, metricId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List storage/disk.metric
         * @summary List storage/disk.metric
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectDiskMetricList(projectId: string, locationId: string, diskId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Metric>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageProjectDiskMetricList(projectId, locationId, diskId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List storage/disk.point
         * @summary List storage/disk.point
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {string} metricId metricId
         * @param {string} [interval] interval
         * @param {string} [timespan] timespan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectDiskMetricPointList(projectId: string, locationId: string, diskId: string, metricId: string, interval?: string, timespan?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Point>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageProjectDiskMetricPointList(projectId, locationId, diskId, metricId, interval, timespan, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * action resize
         * @summary Resize storage/disk
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {StorageProjectDiskResize} storageProjectDiskResize 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectDiskResize(projectId: string, locationId: string, diskId: string, storageProjectDiskResize: StorageProjectDiskResize, xIdempotencyKey?: string, xDryRun?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Disk>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageProjectDiskResize(projectId, locationId, diskId, storageProjectDiskResize, xIdempotencyKey, xDryRun, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get storage/disk.service
         * @summary Get storage/disk.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectDiskServiceGet(projectId: string, locationId: string, diskId: string, serviceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceService>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageProjectDiskServiceGet(projectId, locationId, diskId, serviceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List storage/disk.service
         * @summary List storage/disk.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectDiskServiceList(projectId: string, locationId: string, diskId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResourceService>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageProjectDiskServiceList(projectId, locationId, diskId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create storage/disk.tag
         * @summary Create storage/disk.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectDiskTagCreate(projectId: string, locationId: string, diskId: string, tag: Tag, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageProjectDiskTagCreate(projectId, locationId, diskId, tag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete storage/disk.tag
         * @summary Delete storage/disk.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectDiskTagDelete(projectId: string, locationId: string, diskId: string, tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageProjectDiskTagDelete(projectId, locationId, diskId, tagId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get storage/disk.tag
         * @summary Get storage/disk.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectDiskTagGet(projectId: string, locationId: string, diskId: string, tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageProjectDiskTagGet(projectId, locationId, diskId, tagId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List storage/disk.tag
         * @summary List storage/disk.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectDiskTagList(projectId: string, locationId: string, diskId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageProjectDiskTagList(projectId, locationId, diskId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Replace storage/disk.tag
         * @summary Replace storage/disk.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectDiskTagPut(projectId: string, locationId: string, diskId: string, tag: Array<Tag>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageProjectDiskTagPut(projectId, locationId, diskId, tag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * action transfer
         * @summary Transfer storage/disk
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {StorageProjectDiskTransfer} storageProjectDiskTransfer 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectDiskTransfer(projectId: string, locationId: string, diskId: string, storageProjectDiskTransfer: StorageProjectDiskTransfer, xIdempotencyKey?: string, xDryRun?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Disk>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageProjectDiskTransfer(projectId, locationId, diskId, storageProjectDiskTransfer, xIdempotencyKey, xDryRun, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns modified disk
         * @summary Update storage/disk
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {StorageProjectDiskUpdate} storageProjectDiskUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectDiskUpdate(projectId: string, locationId: string, diskId: string, storageProjectDiskUpdate: StorageProjectDiskUpdate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Disk>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageProjectDiskUpdate(projectId, locationId, diskId, storageProjectDiskUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StorageProjectDiskApi - factory interface
 * @export
 */
export const StorageProjectDiskApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StorageProjectDiskApiFp(configuration)
    return {
        /**
         * Create disk
         * @summary Create storage/disk
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {StorageProjectDiskCreate} storageProjectDiskCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectDiskCreate(projectId: string, locationId: string, storageProjectDiskCreate: StorageProjectDiskCreate, xIdempotencyKey?: string, xDryRun?: string, options?: any): AxiosPromise<Disk> {
            return localVarFp.storageProjectDiskCreate(projectId, locationId, storageProjectDiskCreate, xIdempotencyKey, xDryRun, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete disk
         * @summary Delete storage/disk
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectDiskDelete(projectId: string, locationId: string, diskId: string, options?: any): AxiosPromise<void> {
            return localVarFp.storageProjectDiskDelete(projectId, locationId, diskId, options).then((request) => request(axios, basePath));
        },
        /**
         * action detach
         * @summary Detach storage/disk
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectDiskDetach(projectId: string, locationId: string, diskId: string, xIdempotencyKey?: string, xDryRun?: string, options?: any): AxiosPromise<Disk> {
            return localVarFp.storageProjectDiskDetach(projectId, locationId, diskId, xIdempotencyKey, xDryRun, options).then((request) => request(axios, basePath));
        },
        /**
         * action download
         * @summary Download storage/disk
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectDiskDownload(projectId: string, locationId: string, diskId: string, xIdempotencyKey?: string, xDryRun?: string, options?: any): AxiosPromise<void> {
            return localVarFp.storageProjectDiskDownload(projectId, locationId, diskId, xIdempotencyKey, xDryRun, options).then((request) => request(axios, basePath));
        },
        /**
         * Get storage/disk.event
         * @summary Get storage/disk.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectDiskEventGet(projectId: string, locationId: string, diskId: string, eventId: string, options?: any): AxiosPromise<Event> {
            return localVarFp.storageProjectDiskEventGet(projectId, locationId, diskId, eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * List storage/disk.event
         * @summary List storage/disk.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectDiskEventList(projectId: string, locationId: string, diskId: string, $limit?: number, $skip?: number, options?: any): AxiosPromise<Array<Event>> {
            return localVarFp.storageProjectDiskEventList(projectId, locationId, diskId, $limit, $skip, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single disk
         * @summary Get storage/disk
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectDiskGet(projectId: string, locationId: string, diskId: string, options?: any): AxiosPromise<Disk> {
            return localVarFp.storageProjectDiskGet(projectId, locationId, diskId, options).then((request) => request(axios, basePath));
        },
        /**
         * List disk
         * @summary List storage/disk
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [name] Filter by name
         * @param {string} [vm] Filter by vm
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectDiskList(projectId: string, locationId: string, name?: string, vm?: string, tagValue?: string, tagKey?: string, options?: any): AxiosPromise<Array<Disk>> {
            return localVarFp.storageProjectDiskList(projectId, locationId, name, vm, tagValue, tagKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get storage/disk.metric
         * @summary Get storage/disk.metric
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {string} metricId metricId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectDiskMetricGet(projectId: string, locationId: string, diskId: string, metricId: string, options?: any): AxiosPromise<Metric> {
            return localVarFp.storageProjectDiskMetricGet(projectId, locationId, diskId, metricId, options).then((request) => request(axios, basePath));
        },
        /**
         * List storage/disk.metric
         * @summary List storage/disk.metric
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectDiskMetricList(projectId: string, locationId: string, diskId: string, options?: any): AxiosPromise<Array<Metric>> {
            return localVarFp.storageProjectDiskMetricList(projectId, locationId, diskId, options).then((request) => request(axios, basePath));
        },
        /**
         * List storage/disk.point
         * @summary List storage/disk.point
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {string} metricId metricId
         * @param {string} [interval] interval
         * @param {string} [timespan] timespan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectDiskMetricPointList(projectId: string, locationId: string, diskId: string, metricId: string, interval?: string, timespan?: string, options?: any): AxiosPromise<Array<Point>> {
            return localVarFp.storageProjectDiskMetricPointList(projectId, locationId, diskId, metricId, interval, timespan, options).then((request) => request(axios, basePath));
        },
        /**
         * action resize
         * @summary Resize storage/disk
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {StorageProjectDiskResize} storageProjectDiskResize 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectDiskResize(projectId: string, locationId: string, diskId: string, storageProjectDiskResize: StorageProjectDiskResize, xIdempotencyKey?: string, xDryRun?: string, options?: any): AxiosPromise<Disk> {
            return localVarFp.storageProjectDiskResize(projectId, locationId, diskId, storageProjectDiskResize, xIdempotencyKey, xDryRun, options).then((request) => request(axios, basePath));
        },
        /**
         * Get storage/disk.service
         * @summary Get storage/disk.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectDiskServiceGet(projectId: string, locationId: string, diskId: string, serviceId: string, options?: any): AxiosPromise<ResourceService> {
            return localVarFp.storageProjectDiskServiceGet(projectId, locationId, diskId, serviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * List storage/disk.service
         * @summary List storage/disk.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectDiskServiceList(projectId: string, locationId: string, diskId: string, options?: any): AxiosPromise<Array<ResourceService>> {
            return localVarFp.storageProjectDiskServiceList(projectId, locationId, diskId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create storage/disk.tag
         * @summary Create storage/disk.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectDiskTagCreate(projectId: string, locationId: string, diskId: string, tag: Tag, options?: any): AxiosPromise<Tag> {
            return localVarFp.storageProjectDiskTagCreate(projectId, locationId, diskId, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete storage/disk.tag
         * @summary Delete storage/disk.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectDiskTagDelete(projectId: string, locationId: string, diskId: string, tagId: string, options?: any): AxiosPromise<void> {
            return localVarFp.storageProjectDiskTagDelete(projectId, locationId, diskId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get storage/disk.tag
         * @summary Get storage/disk.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectDiskTagGet(projectId: string, locationId: string, diskId: string, tagId: string, options?: any): AxiosPromise<Tag> {
            return localVarFp.storageProjectDiskTagGet(projectId, locationId, diskId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * List storage/disk.tag
         * @summary List storage/disk.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectDiskTagList(projectId: string, locationId: string, diskId: string, options?: any): AxiosPromise<Array<Tag>> {
            return localVarFp.storageProjectDiskTagList(projectId, locationId, diskId, options).then((request) => request(axios, basePath));
        },
        /**
         * Replace storage/disk.tag
         * @summary Replace storage/disk.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectDiskTagPut(projectId: string, locationId: string, diskId: string, tag: Array<Tag>, options?: any): AxiosPromise<Array<Tag>> {
            return localVarFp.storageProjectDiskTagPut(projectId, locationId, diskId, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * action transfer
         * @summary Transfer storage/disk
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {StorageProjectDiskTransfer} storageProjectDiskTransfer 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectDiskTransfer(projectId: string, locationId: string, diskId: string, storageProjectDiskTransfer: StorageProjectDiskTransfer, xIdempotencyKey?: string, xDryRun?: string, options?: any): AxiosPromise<Disk> {
            return localVarFp.storageProjectDiskTransfer(projectId, locationId, diskId, storageProjectDiskTransfer, xIdempotencyKey, xDryRun, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns modified disk
         * @summary Update storage/disk
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} diskId Disk Id
         * @param {StorageProjectDiskUpdate} storageProjectDiskUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectDiskUpdate(projectId: string, locationId: string, diskId: string, storageProjectDiskUpdate: StorageProjectDiskUpdate, options?: any): AxiosPromise<Disk> {
            return localVarFp.storageProjectDiskUpdate(projectId, locationId, diskId, storageProjectDiskUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StorageProjectDiskApi - object-oriented interface
 * @export
 * @class StorageProjectDiskApi
 * @extends {BaseAPI}
 */
export class StorageProjectDiskApi extends BaseAPI {
    /**
     * Create disk
     * @summary Create storage/disk
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {StorageProjectDiskCreate} storageProjectDiskCreate 
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {string} [xDryRun] Dry run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectDiskApi
     */
    public storageProjectDiskCreate(projectId: string, locationId: string, storageProjectDiskCreate: StorageProjectDiskCreate, xIdempotencyKey?: string, xDryRun?: string, options?: any) {
        return StorageProjectDiskApiFp(this.configuration).storageProjectDiskCreate(projectId, locationId, storageProjectDiskCreate, xIdempotencyKey, xDryRun, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete disk
     * @summary Delete storage/disk
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} diskId Disk Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectDiskApi
     */
    public storageProjectDiskDelete(projectId: string, locationId: string, diskId: string, options?: any) {
        return StorageProjectDiskApiFp(this.configuration).storageProjectDiskDelete(projectId, locationId, diskId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * action detach
     * @summary Detach storage/disk
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} diskId Disk Id
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {string} [xDryRun] Dry run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectDiskApi
     */
    public storageProjectDiskDetach(projectId: string, locationId: string, diskId: string, xIdempotencyKey?: string, xDryRun?: string, options?: any) {
        return StorageProjectDiskApiFp(this.configuration).storageProjectDiskDetach(projectId, locationId, diskId, xIdempotencyKey, xDryRun, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * action download
     * @summary Download storage/disk
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} diskId Disk Id
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {string} [xDryRun] Dry run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectDiskApi
     */
    public storageProjectDiskDownload(projectId: string, locationId: string, diskId: string, xIdempotencyKey?: string, xDryRun?: string, options?: any) {
        return StorageProjectDiskApiFp(this.configuration).storageProjectDiskDownload(projectId, locationId, diskId, xIdempotencyKey, xDryRun, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get storage/disk.event
     * @summary Get storage/disk.event
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} diskId Disk Id
     * @param {string} eventId eventId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectDiskApi
     */
    public storageProjectDiskEventGet(projectId: string, locationId: string, diskId: string, eventId: string, options?: any) {
        return StorageProjectDiskApiFp(this.configuration).storageProjectDiskEventGet(projectId, locationId, diskId, eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List storage/disk.event
     * @summary List storage/disk.event
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} diskId Disk Id
     * @param {number} [$limit] $limit
     * @param {number} [$skip] $skip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectDiskApi
     */
    public storageProjectDiskEventList(projectId: string, locationId: string, diskId: string, $limit?: number, $skip?: number, options?: any) {
        return StorageProjectDiskApiFp(this.configuration).storageProjectDiskEventList(projectId, locationId, diskId, $limit, $skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single disk
     * @summary Get storage/disk
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} diskId Disk Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectDiskApi
     */
    public storageProjectDiskGet(projectId: string, locationId: string, diskId: string, options?: any) {
        return StorageProjectDiskApiFp(this.configuration).storageProjectDiskGet(projectId, locationId, diskId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List disk
     * @summary List storage/disk
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} [name] Filter by name
     * @param {string} [vm] Filter by vm
     * @param {string} [tagValue] Filter by tag.value
     * @param {string} [tagKey] Filter by tag.key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectDiskApi
     */
    public storageProjectDiskList(projectId: string, locationId: string, name?: string, vm?: string, tagValue?: string, tagKey?: string, options?: any) {
        return StorageProjectDiskApiFp(this.configuration).storageProjectDiskList(projectId, locationId, name, vm, tagValue, tagKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get storage/disk.metric
     * @summary Get storage/disk.metric
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} diskId Disk Id
     * @param {string} metricId metricId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectDiskApi
     */
    public storageProjectDiskMetricGet(projectId: string, locationId: string, diskId: string, metricId: string, options?: any) {
        return StorageProjectDiskApiFp(this.configuration).storageProjectDiskMetricGet(projectId, locationId, diskId, metricId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List storage/disk.metric
     * @summary List storage/disk.metric
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} diskId Disk Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectDiskApi
     */
    public storageProjectDiskMetricList(projectId: string, locationId: string, diskId: string, options?: any) {
        return StorageProjectDiskApiFp(this.configuration).storageProjectDiskMetricList(projectId, locationId, diskId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List storage/disk.point
     * @summary List storage/disk.point
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} diskId Disk Id
     * @param {string} metricId metricId
     * @param {string} [interval] interval
     * @param {string} [timespan] timespan
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectDiskApi
     */
    public storageProjectDiskMetricPointList(projectId: string, locationId: string, diskId: string, metricId: string, interval?: string, timespan?: string, options?: any) {
        return StorageProjectDiskApiFp(this.configuration).storageProjectDiskMetricPointList(projectId, locationId, diskId, metricId, interval, timespan, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * action resize
     * @summary Resize storage/disk
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} diskId Disk Id
     * @param {StorageProjectDiskResize} storageProjectDiskResize 
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {string} [xDryRun] Dry run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectDiskApi
     */
    public storageProjectDiskResize(projectId: string, locationId: string, diskId: string, storageProjectDiskResize: StorageProjectDiskResize, xIdempotencyKey?: string, xDryRun?: string, options?: any) {
        return StorageProjectDiskApiFp(this.configuration).storageProjectDiskResize(projectId, locationId, diskId, storageProjectDiskResize, xIdempotencyKey, xDryRun, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get storage/disk.service
     * @summary Get storage/disk.service
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} diskId Disk Id
     * @param {string} serviceId serviceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectDiskApi
     */
    public storageProjectDiskServiceGet(projectId: string, locationId: string, diskId: string, serviceId: string, options?: any) {
        return StorageProjectDiskApiFp(this.configuration).storageProjectDiskServiceGet(projectId, locationId, diskId, serviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List storage/disk.service
     * @summary List storage/disk.service
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} diskId Disk Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectDiskApi
     */
    public storageProjectDiskServiceList(projectId: string, locationId: string, diskId: string, options?: any) {
        return StorageProjectDiskApiFp(this.configuration).storageProjectDiskServiceList(projectId, locationId, diskId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create storage/disk.tag
     * @summary Create storage/disk.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} diskId Disk Id
     * @param {Tag} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectDiskApi
     */
    public storageProjectDiskTagCreate(projectId: string, locationId: string, diskId: string, tag: Tag, options?: any) {
        return StorageProjectDiskApiFp(this.configuration).storageProjectDiskTagCreate(projectId, locationId, diskId, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete storage/disk.tag
     * @summary Delete storage/disk.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} diskId Disk Id
     * @param {string} tagId tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectDiskApi
     */
    public storageProjectDiskTagDelete(projectId: string, locationId: string, diskId: string, tagId: string, options?: any) {
        return StorageProjectDiskApiFp(this.configuration).storageProjectDiskTagDelete(projectId, locationId, diskId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get storage/disk.tag
     * @summary Get storage/disk.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} diskId Disk Id
     * @param {string} tagId tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectDiskApi
     */
    public storageProjectDiskTagGet(projectId: string, locationId: string, diskId: string, tagId: string, options?: any) {
        return StorageProjectDiskApiFp(this.configuration).storageProjectDiskTagGet(projectId, locationId, diskId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List storage/disk.tag
     * @summary List storage/disk.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} diskId Disk Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectDiskApi
     */
    public storageProjectDiskTagList(projectId: string, locationId: string, diskId: string, options?: any) {
        return StorageProjectDiskApiFp(this.configuration).storageProjectDiskTagList(projectId, locationId, diskId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replace storage/disk.tag
     * @summary Replace storage/disk.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} diskId Disk Id
     * @param {Array<Tag>} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectDiskApi
     */
    public storageProjectDiskTagPut(projectId: string, locationId: string, diskId: string, tag: Array<Tag>, options?: any) {
        return StorageProjectDiskApiFp(this.configuration).storageProjectDiskTagPut(projectId, locationId, diskId, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * action transfer
     * @summary Transfer storage/disk
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} diskId Disk Id
     * @param {StorageProjectDiskTransfer} storageProjectDiskTransfer 
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {string} [xDryRun] Dry run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectDiskApi
     */
    public storageProjectDiskTransfer(projectId: string, locationId: string, diskId: string, storageProjectDiskTransfer: StorageProjectDiskTransfer, xIdempotencyKey?: string, xDryRun?: string, options?: any) {
        return StorageProjectDiskApiFp(this.configuration).storageProjectDiskTransfer(projectId, locationId, diskId, storageProjectDiskTransfer, xIdempotencyKey, xDryRun, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns modified disk
     * @summary Update storage/disk
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} diskId Disk Id
     * @param {StorageProjectDiskUpdate} storageProjectDiskUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectDiskApi
     */
    public storageProjectDiskUpdate(projectId: string, locationId: string, diskId: string, storageProjectDiskUpdate: StorageProjectDiskUpdate, options?: any) {
        return StorageProjectDiskApiFp(this.configuration).storageProjectDiskUpdate(projectId, locationId, diskId, storageProjectDiskUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StorageProjectImageApi - axios parameter creator
 * @export
 */
export const StorageProjectImageApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create image
         * @summary Create storage/image
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {StorageProjectImageCreate} storageProjectImageCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectImageCreate: async (projectId: string, locationId: string, storageProjectImageCreate: StorageProjectImageCreate, xIdempotencyKey?: string, xDryRun?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('storageProjectImageCreate', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('storageProjectImageCreate', 'locationId', locationId)
            // verify required parameter 'storageProjectImageCreate' is not null or undefined
            assertParamExists('storageProjectImageCreate', 'storageProjectImageCreate', storageProjectImageCreate)
            const localVarPath = `/storage/{locationId}/project/{projectId}/image`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }

            if (xDryRun !== undefined && xDryRun !== null) {
                localVarHeaderParameter['x-dry-run'] = String(xDryRun);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storageProjectImageCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete image
         * @summary Delete storage/image
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} imageId Image Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectImageDelete: async (projectId: string, locationId: string, imageId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('storageProjectImageDelete', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('storageProjectImageDelete', 'locationId', locationId)
            // verify required parameter 'imageId' is not null or undefined
            assertParamExists('storageProjectImageDelete', 'imageId', imageId)
            const localVarPath = `/storage/{locationId}/project/{projectId}/image/{imageId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"imageId"}}`, encodeURIComponent(String(imageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List storage/image.disk
         * @summary List storage/image.disk
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} imageId Image Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectImageDiskList: async (projectId: string, locationId: string, imageId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('storageProjectImageDiskList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('storageProjectImageDiskList', 'locationId', locationId)
            // verify required parameter 'imageId' is not null or undefined
            assertParamExists('storageProjectImageDiskList', 'imageId', imageId)
            const localVarPath = `/storage/{locationId}/project/{projectId}/image/{imageId}/disk`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"imageId"}}`, encodeURIComponent(String(imageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get storage/image.event
         * @summary Get storage/image.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} imageId Image Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectImageEventGet: async (projectId: string, locationId: string, imageId: string, eventId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('storageProjectImageEventGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('storageProjectImageEventGet', 'locationId', locationId)
            // verify required parameter 'imageId' is not null or undefined
            assertParamExists('storageProjectImageEventGet', 'imageId', imageId)
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('storageProjectImageEventGet', 'eventId', eventId)
            const localVarPath = `/storage/{locationId}/project/{projectId}/image/{imageId}/event/{eventId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"imageId"}}`, encodeURIComponent(String(imageId)))
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List storage/image.event
         * @summary List storage/image.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} imageId Image Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectImageEventList: async (projectId: string, locationId: string, imageId: string, $limit?: number, $skip?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('storageProjectImageEventList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('storageProjectImageEventList', 'locationId', locationId)
            // verify required parameter 'imageId' is not null or undefined
            assertParamExists('storageProjectImageEventList', 'imageId', imageId)
            const localVarPath = `/storage/{locationId}/project/{projectId}/image/{imageId}/event`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"imageId"}}`, encodeURIComponent(String(imageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if ($limit !== undefined) {
                localVarQueryParameter['$limit'] = $limit;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single image
         * @summary Get storage/image
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} imageId Image Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectImageGet: async (projectId: string, locationId: string, imageId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('storageProjectImageGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('storageProjectImageGet', 'locationId', locationId)
            // verify required parameter 'imageId' is not null or undefined
            assertParamExists('storageProjectImageGet', 'imageId', imageId)
            const localVarPath = `/storage/{locationId}/project/{projectId}/image/{imageId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"imageId"}}`, encodeURIComponent(String(imageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List image
         * @summary List storage/image
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [name] Filter by name
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectImageList: async (projectId: string, locationId: string, name?: string, tagValue?: string, tagKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('storageProjectImageList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('storageProjectImageList', 'locationId', locationId)
            const localVarPath = `/storage/{locationId}/project/{projectId}/image`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (tagValue !== undefined) {
                localVarQueryParameter['tag.value'] = tagValue;
            }

            if (tagKey !== undefined) {
                localVarQueryParameter['tag.key'] = tagKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get storage/image.service
         * @summary Get storage/image.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} imageId Image Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectImageServiceGet: async (projectId: string, locationId: string, imageId: string, serviceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('storageProjectImageServiceGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('storageProjectImageServiceGet', 'locationId', locationId)
            // verify required parameter 'imageId' is not null or undefined
            assertParamExists('storageProjectImageServiceGet', 'imageId', imageId)
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('storageProjectImageServiceGet', 'serviceId', serviceId)
            const localVarPath = `/storage/{locationId}/project/{projectId}/image/{imageId}/service/{serviceId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"imageId"}}`, encodeURIComponent(String(imageId)))
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List storage/image.service
         * @summary List storage/image.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} imageId Image Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectImageServiceList: async (projectId: string, locationId: string, imageId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('storageProjectImageServiceList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('storageProjectImageServiceList', 'locationId', locationId)
            // verify required parameter 'imageId' is not null or undefined
            assertParamExists('storageProjectImageServiceList', 'imageId', imageId)
            const localVarPath = `/storage/{locationId}/project/{projectId}/image/{imageId}/service`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"imageId"}}`, encodeURIComponent(String(imageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create storage/image.tag
         * @summary Create storage/image.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} imageId Image Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectImageTagCreate: async (projectId: string, locationId: string, imageId: string, tag: Tag, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('storageProjectImageTagCreate', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('storageProjectImageTagCreate', 'locationId', locationId)
            // verify required parameter 'imageId' is not null or undefined
            assertParamExists('storageProjectImageTagCreate', 'imageId', imageId)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('storageProjectImageTagCreate', 'tag', tag)
            const localVarPath = `/storage/{locationId}/project/{projectId}/image/{imageId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"imageId"}}`, encodeURIComponent(String(imageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tag, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete storage/image.tag
         * @summary Delete storage/image.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} imageId Image Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectImageTagDelete: async (projectId: string, locationId: string, imageId: string, tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('storageProjectImageTagDelete', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('storageProjectImageTagDelete', 'locationId', locationId)
            // verify required parameter 'imageId' is not null or undefined
            assertParamExists('storageProjectImageTagDelete', 'imageId', imageId)
            // verify required parameter 'tagId' is not null or undefined
            assertParamExists('storageProjectImageTagDelete', 'tagId', tagId)
            const localVarPath = `/storage/{locationId}/project/{projectId}/image/{imageId}/tag/{tagId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"imageId"}}`, encodeURIComponent(String(imageId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get storage/image.tag
         * @summary Get storage/image.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} imageId Image Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectImageTagGet: async (projectId: string, locationId: string, imageId: string, tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('storageProjectImageTagGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('storageProjectImageTagGet', 'locationId', locationId)
            // verify required parameter 'imageId' is not null or undefined
            assertParamExists('storageProjectImageTagGet', 'imageId', imageId)
            // verify required parameter 'tagId' is not null or undefined
            assertParamExists('storageProjectImageTagGet', 'tagId', tagId)
            const localVarPath = `/storage/{locationId}/project/{projectId}/image/{imageId}/tag/{tagId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"imageId"}}`, encodeURIComponent(String(imageId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List storage/image.tag
         * @summary List storage/image.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} imageId Image Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectImageTagList: async (projectId: string, locationId: string, imageId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('storageProjectImageTagList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('storageProjectImageTagList', 'locationId', locationId)
            // verify required parameter 'imageId' is not null or undefined
            assertParamExists('storageProjectImageTagList', 'imageId', imageId)
            const localVarPath = `/storage/{locationId}/project/{projectId}/image/{imageId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"imageId"}}`, encodeURIComponent(String(imageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replace storage/image.tag
         * @summary Replace storage/image.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} imageId Image Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectImageTagPut: async (projectId: string, locationId: string, imageId: string, tag: Array<Tag>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('storageProjectImageTagPut', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('storageProjectImageTagPut', 'locationId', locationId)
            // verify required parameter 'imageId' is not null or undefined
            assertParamExists('storageProjectImageTagPut', 'imageId', imageId)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('storageProjectImageTagPut', 'tag', tag)
            const localVarPath = `/storage/{locationId}/project/{projectId}/image/{imageId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"imageId"}}`, encodeURIComponent(String(imageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tag, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * action transfer
         * @summary Transfer storage/image
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} imageId Image Id
         * @param {StorageProjectImageTransfer} storageProjectImageTransfer 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectImageTransfer: async (projectId: string, locationId: string, imageId: string, storageProjectImageTransfer: StorageProjectImageTransfer, xIdempotencyKey?: string, xDryRun?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('storageProjectImageTransfer', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('storageProjectImageTransfer', 'locationId', locationId)
            // verify required parameter 'imageId' is not null or undefined
            assertParamExists('storageProjectImageTransfer', 'imageId', imageId)
            // verify required parameter 'storageProjectImageTransfer' is not null or undefined
            assertParamExists('storageProjectImageTransfer', 'storageProjectImageTransfer', storageProjectImageTransfer)
            const localVarPath = `/storage/{locationId}/project/{projectId}/image/{imageId}/actions/transfer`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"imageId"}}`, encodeURIComponent(String(imageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }

            if (xDryRun !== undefined && xDryRun !== null) {
                localVarHeaderParameter['x-dry-run'] = String(xDryRun);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storageProjectImageTransfer, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns modified image
         * @summary Update storage/image
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} imageId Image Id
         * @param {StorageProjectImageUpdate} storageProjectImageUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectImageUpdate: async (projectId: string, locationId: string, imageId: string, storageProjectImageUpdate: StorageProjectImageUpdate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('storageProjectImageUpdate', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('storageProjectImageUpdate', 'locationId', locationId)
            // verify required parameter 'imageId' is not null or undefined
            assertParamExists('storageProjectImageUpdate', 'imageId', imageId)
            // verify required parameter 'storageProjectImageUpdate' is not null or undefined
            assertParamExists('storageProjectImageUpdate', 'storageProjectImageUpdate', storageProjectImageUpdate)
            const localVarPath = `/storage/{locationId}/project/{projectId}/image/{imageId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"imageId"}}`, encodeURIComponent(String(imageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storageProjectImageUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StorageProjectImageApi - functional programming interface
 * @export
 */
export const StorageProjectImageApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StorageProjectImageApiAxiosParamCreator(configuration)
    return {
        /**
         * Create image
         * @summary Create storage/image
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {StorageProjectImageCreate} storageProjectImageCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectImageCreate(projectId: string, locationId: string, storageProjectImageCreate: StorageProjectImageCreate, xIdempotencyKey?: string, xDryRun?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Image>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageProjectImageCreate(projectId, locationId, storageProjectImageCreate, xIdempotencyKey, xDryRun, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete image
         * @summary Delete storage/image
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} imageId Image Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectImageDelete(projectId: string, locationId: string, imageId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageProjectImageDelete(projectId, locationId, imageId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List storage/image.disk
         * @summary List storage/image.disk
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} imageId Image Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectImageDiskList(projectId: string, locationId: string, imageId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Disk>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageProjectImageDiskList(projectId, locationId, imageId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get storage/image.event
         * @summary Get storage/image.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} imageId Image Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectImageEventGet(projectId: string, locationId: string, imageId: string, eventId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageProjectImageEventGet(projectId, locationId, imageId, eventId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List storage/image.event
         * @summary List storage/image.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} imageId Image Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectImageEventList(projectId: string, locationId: string, imageId: string, $limit?: number, $skip?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Event>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageProjectImageEventList(projectId, locationId, imageId, $limit, $skip, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a single image
         * @summary Get storage/image
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} imageId Image Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectImageGet(projectId: string, locationId: string, imageId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Image>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageProjectImageGet(projectId, locationId, imageId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List image
         * @summary List storage/image
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [name] Filter by name
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectImageList(projectId: string, locationId: string, name?: string, tagValue?: string, tagKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Image>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageProjectImageList(projectId, locationId, name, tagValue, tagKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get storage/image.service
         * @summary Get storage/image.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} imageId Image Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectImageServiceGet(projectId: string, locationId: string, imageId: string, serviceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceService>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageProjectImageServiceGet(projectId, locationId, imageId, serviceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List storage/image.service
         * @summary List storage/image.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} imageId Image Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectImageServiceList(projectId: string, locationId: string, imageId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResourceService>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageProjectImageServiceList(projectId, locationId, imageId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create storage/image.tag
         * @summary Create storage/image.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} imageId Image Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectImageTagCreate(projectId: string, locationId: string, imageId: string, tag: Tag, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageProjectImageTagCreate(projectId, locationId, imageId, tag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete storage/image.tag
         * @summary Delete storage/image.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} imageId Image Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectImageTagDelete(projectId: string, locationId: string, imageId: string, tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageProjectImageTagDelete(projectId, locationId, imageId, tagId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get storage/image.tag
         * @summary Get storage/image.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} imageId Image Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectImageTagGet(projectId: string, locationId: string, imageId: string, tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageProjectImageTagGet(projectId, locationId, imageId, tagId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List storage/image.tag
         * @summary List storage/image.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} imageId Image Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectImageTagList(projectId: string, locationId: string, imageId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageProjectImageTagList(projectId, locationId, imageId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Replace storage/image.tag
         * @summary Replace storage/image.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} imageId Image Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectImageTagPut(projectId: string, locationId: string, imageId: string, tag: Array<Tag>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageProjectImageTagPut(projectId, locationId, imageId, tag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * action transfer
         * @summary Transfer storage/image
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} imageId Image Id
         * @param {StorageProjectImageTransfer} storageProjectImageTransfer 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectImageTransfer(projectId: string, locationId: string, imageId: string, storageProjectImageTransfer: StorageProjectImageTransfer, xIdempotencyKey?: string, xDryRun?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Image>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageProjectImageTransfer(projectId, locationId, imageId, storageProjectImageTransfer, xIdempotencyKey, xDryRun, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns modified image
         * @summary Update storage/image
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} imageId Image Id
         * @param {StorageProjectImageUpdate} storageProjectImageUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectImageUpdate(projectId: string, locationId: string, imageId: string, storageProjectImageUpdate: StorageProjectImageUpdate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Image>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageProjectImageUpdate(projectId, locationId, imageId, storageProjectImageUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StorageProjectImageApi - factory interface
 * @export
 */
export const StorageProjectImageApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StorageProjectImageApiFp(configuration)
    return {
        /**
         * Create image
         * @summary Create storage/image
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {StorageProjectImageCreate} storageProjectImageCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectImageCreate(projectId: string, locationId: string, storageProjectImageCreate: StorageProjectImageCreate, xIdempotencyKey?: string, xDryRun?: string, options?: any): AxiosPromise<Image> {
            return localVarFp.storageProjectImageCreate(projectId, locationId, storageProjectImageCreate, xIdempotencyKey, xDryRun, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete image
         * @summary Delete storage/image
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} imageId Image Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectImageDelete(projectId: string, locationId: string, imageId: string, options?: any): AxiosPromise<void> {
            return localVarFp.storageProjectImageDelete(projectId, locationId, imageId, options).then((request) => request(axios, basePath));
        },
        /**
         * List storage/image.disk
         * @summary List storage/image.disk
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} imageId Image Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectImageDiskList(projectId: string, locationId: string, imageId: string, options?: any): AxiosPromise<Array<Disk>> {
            return localVarFp.storageProjectImageDiskList(projectId, locationId, imageId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get storage/image.event
         * @summary Get storage/image.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} imageId Image Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectImageEventGet(projectId: string, locationId: string, imageId: string, eventId: string, options?: any): AxiosPromise<Event> {
            return localVarFp.storageProjectImageEventGet(projectId, locationId, imageId, eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * List storage/image.event
         * @summary List storage/image.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} imageId Image Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectImageEventList(projectId: string, locationId: string, imageId: string, $limit?: number, $skip?: number, options?: any): AxiosPromise<Array<Event>> {
            return localVarFp.storageProjectImageEventList(projectId, locationId, imageId, $limit, $skip, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single image
         * @summary Get storage/image
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} imageId Image Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectImageGet(projectId: string, locationId: string, imageId: string, options?: any): AxiosPromise<Image> {
            return localVarFp.storageProjectImageGet(projectId, locationId, imageId, options).then((request) => request(axios, basePath));
        },
        /**
         * List image
         * @summary List storage/image
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [name] Filter by name
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectImageList(projectId: string, locationId: string, name?: string, tagValue?: string, tagKey?: string, options?: any): AxiosPromise<Array<Image>> {
            return localVarFp.storageProjectImageList(projectId, locationId, name, tagValue, tagKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get storage/image.service
         * @summary Get storage/image.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} imageId Image Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectImageServiceGet(projectId: string, locationId: string, imageId: string, serviceId: string, options?: any): AxiosPromise<ResourceService> {
            return localVarFp.storageProjectImageServiceGet(projectId, locationId, imageId, serviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * List storage/image.service
         * @summary List storage/image.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} imageId Image Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectImageServiceList(projectId: string, locationId: string, imageId: string, options?: any): AxiosPromise<Array<ResourceService>> {
            return localVarFp.storageProjectImageServiceList(projectId, locationId, imageId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create storage/image.tag
         * @summary Create storage/image.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} imageId Image Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectImageTagCreate(projectId: string, locationId: string, imageId: string, tag: Tag, options?: any): AxiosPromise<Tag> {
            return localVarFp.storageProjectImageTagCreate(projectId, locationId, imageId, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete storage/image.tag
         * @summary Delete storage/image.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} imageId Image Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectImageTagDelete(projectId: string, locationId: string, imageId: string, tagId: string, options?: any): AxiosPromise<void> {
            return localVarFp.storageProjectImageTagDelete(projectId, locationId, imageId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get storage/image.tag
         * @summary Get storage/image.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} imageId Image Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectImageTagGet(projectId: string, locationId: string, imageId: string, tagId: string, options?: any): AxiosPromise<Tag> {
            return localVarFp.storageProjectImageTagGet(projectId, locationId, imageId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * List storage/image.tag
         * @summary List storage/image.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} imageId Image Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectImageTagList(projectId: string, locationId: string, imageId: string, options?: any): AxiosPromise<Array<Tag>> {
            return localVarFp.storageProjectImageTagList(projectId, locationId, imageId, options).then((request) => request(axios, basePath));
        },
        /**
         * Replace storage/image.tag
         * @summary Replace storage/image.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} imageId Image Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectImageTagPut(projectId: string, locationId: string, imageId: string, tag: Array<Tag>, options?: any): AxiosPromise<Array<Tag>> {
            return localVarFp.storageProjectImageTagPut(projectId, locationId, imageId, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * action transfer
         * @summary Transfer storage/image
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} imageId Image Id
         * @param {StorageProjectImageTransfer} storageProjectImageTransfer 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectImageTransfer(projectId: string, locationId: string, imageId: string, storageProjectImageTransfer: StorageProjectImageTransfer, xIdempotencyKey?: string, xDryRun?: string, options?: any): AxiosPromise<Image> {
            return localVarFp.storageProjectImageTransfer(projectId, locationId, imageId, storageProjectImageTransfer, xIdempotencyKey, xDryRun, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns modified image
         * @summary Update storage/image
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} imageId Image Id
         * @param {StorageProjectImageUpdate} storageProjectImageUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectImageUpdate(projectId: string, locationId: string, imageId: string, storageProjectImageUpdate: StorageProjectImageUpdate, options?: any): AxiosPromise<Image> {
            return localVarFp.storageProjectImageUpdate(projectId, locationId, imageId, storageProjectImageUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StorageProjectImageApi - object-oriented interface
 * @export
 * @class StorageProjectImageApi
 * @extends {BaseAPI}
 */
export class StorageProjectImageApi extends BaseAPI {
    /**
     * Create image
     * @summary Create storage/image
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {StorageProjectImageCreate} storageProjectImageCreate 
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {string} [xDryRun] Dry run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectImageApi
     */
    public storageProjectImageCreate(projectId: string, locationId: string, storageProjectImageCreate: StorageProjectImageCreate, xIdempotencyKey?: string, xDryRun?: string, options?: any) {
        return StorageProjectImageApiFp(this.configuration).storageProjectImageCreate(projectId, locationId, storageProjectImageCreate, xIdempotencyKey, xDryRun, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete image
     * @summary Delete storage/image
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} imageId Image Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectImageApi
     */
    public storageProjectImageDelete(projectId: string, locationId: string, imageId: string, options?: any) {
        return StorageProjectImageApiFp(this.configuration).storageProjectImageDelete(projectId, locationId, imageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List storage/image.disk
     * @summary List storage/image.disk
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} imageId Image Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectImageApi
     */
    public storageProjectImageDiskList(projectId: string, locationId: string, imageId: string, options?: any) {
        return StorageProjectImageApiFp(this.configuration).storageProjectImageDiskList(projectId, locationId, imageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get storage/image.event
     * @summary Get storage/image.event
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} imageId Image Id
     * @param {string} eventId eventId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectImageApi
     */
    public storageProjectImageEventGet(projectId: string, locationId: string, imageId: string, eventId: string, options?: any) {
        return StorageProjectImageApiFp(this.configuration).storageProjectImageEventGet(projectId, locationId, imageId, eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List storage/image.event
     * @summary List storage/image.event
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} imageId Image Id
     * @param {number} [$limit] $limit
     * @param {number} [$skip] $skip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectImageApi
     */
    public storageProjectImageEventList(projectId: string, locationId: string, imageId: string, $limit?: number, $skip?: number, options?: any) {
        return StorageProjectImageApiFp(this.configuration).storageProjectImageEventList(projectId, locationId, imageId, $limit, $skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single image
     * @summary Get storage/image
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} imageId Image Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectImageApi
     */
    public storageProjectImageGet(projectId: string, locationId: string, imageId: string, options?: any) {
        return StorageProjectImageApiFp(this.configuration).storageProjectImageGet(projectId, locationId, imageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List image
     * @summary List storage/image
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} [name] Filter by name
     * @param {string} [tagValue] Filter by tag.value
     * @param {string} [tagKey] Filter by tag.key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectImageApi
     */
    public storageProjectImageList(projectId: string, locationId: string, name?: string, tagValue?: string, tagKey?: string, options?: any) {
        return StorageProjectImageApiFp(this.configuration).storageProjectImageList(projectId, locationId, name, tagValue, tagKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get storage/image.service
     * @summary Get storage/image.service
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} imageId Image Id
     * @param {string} serviceId serviceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectImageApi
     */
    public storageProjectImageServiceGet(projectId: string, locationId: string, imageId: string, serviceId: string, options?: any) {
        return StorageProjectImageApiFp(this.configuration).storageProjectImageServiceGet(projectId, locationId, imageId, serviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List storage/image.service
     * @summary List storage/image.service
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} imageId Image Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectImageApi
     */
    public storageProjectImageServiceList(projectId: string, locationId: string, imageId: string, options?: any) {
        return StorageProjectImageApiFp(this.configuration).storageProjectImageServiceList(projectId, locationId, imageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create storage/image.tag
     * @summary Create storage/image.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} imageId Image Id
     * @param {Tag} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectImageApi
     */
    public storageProjectImageTagCreate(projectId: string, locationId: string, imageId: string, tag: Tag, options?: any) {
        return StorageProjectImageApiFp(this.configuration).storageProjectImageTagCreate(projectId, locationId, imageId, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete storage/image.tag
     * @summary Delete storage/image.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} imageId Image Id
     * @param {string} tagId tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectImageApi
     */
    public storageProjectImageTagDelete(projectId: string, locationId: string, imageId: string, tagId: string, options?: any) {
        return StorageProjectImageApiFp(this.configuration).storageProjectImageTagDelete(projectId, locationId, imageId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get storage/image.tag
     * @summary Get storage/image.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} imageId Image Id
     * @param {string} tagId tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectImageApi
     */
    public storageProjectImageTagGet(projectId: string, locationId: string, imageId: string, tagId: string, options?: any) {
        return StorageProjectImageApiFp(this.configuration).storageProjectImageTagGet(projectId, locationId, imageId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List storage/image.tag
     * @summary List storage/image.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} imageId Image Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectImageApi
     */
    public storageProjectImageTagList(projectId: string, locationId: string, imageId: string, options?: any) {
        return StorageProjectImageApiFp(this.configuration).storageProjectImageTagList(projectId, locationId, imageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replace storage/image.tag
     * @summary Replace storage/image.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} imageId Image Id
     * @param {Array<Tag>} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectImageApi
     */
    public storageProjectImageTagPut(projectId: string, locationId: string, imageId: string, tag: Array<Tag>, options?: any) {
        return StorageProjectImageApiFp(this.configuration).storageProjectImageTagPut(projectId, locationId, imageId, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * action transfer
     * @summary Transfer storage/image
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} imageId Image Id
     * @param {StorageProjectImageTransfer} storageProjectImageTransfer 
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {string} [xDryRun] Dry run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectImageApi
     */
    public storageProjectImageTransfer(projectId: string, locationId: string, imageId: string, storageProjectImageTransfer: StorageProjectImageTransfer, xIdempotencyKey?: string, xDryRun?: string, options?: any) {
        return StorageProjectImageApiFp(this.configuration).storageProjectImageTransfer(projectId, locationId, imageId, storageProjectImageTransfer, xIdempotencyKey, xDryRun, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns modified image
     * @summary Update storage/image
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} imageId Image Id
     * @param {StorageProjectImageUpdate} storageProjectImageUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectImageApi
     */
    public storageProjectImageUpdate(projectId: string, locationId: string, imageId: string, storageProjectImageUpdate: StorageProjectImageUpdate, options?: any) {
        return StorageProjectImageApiFp(this.configuration).storageProjectImageUpdate(projectId, locationId, imageId, storageProjectImageUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StorageProjectIsoApi - axios parameter creator
 * @export
 */
export const StorageProjectIsoApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Create iso
         * @summary Create storage/iso
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {StorageProjectIsoCreate} storageProjectIsoCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectIsoCreate: async (projectId: string, locationId: string, storageProjectIsoCreate: StorageProjectIsoCreate, xIdempotencyKey?: string, xDryRun?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('storageProjectIsoCreate', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('storageProjectIsoCreate', 'locationId', locationId)
            // verify required parameter 'storageProjectIsoCreate' is not null or undefined
            assertParamExists('storageProjectIsoCreate', 'storageProjectIsoCreate', storageProjectIsoCreate)
            const localVarPath = `/storage/{locationId}/project/{projectId}/iso`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }

            if (xDryRun !== undefined && xDryRun !== null) {
                localVarHeaderParameter['x-dry-run'] = String(xDryRun);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storageProjectIsoCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete iso
         * @summary Delete storage/iso
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} isoId Iso Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectIsoDelete: async (projectId: string, locationId: string, isoId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('storageProjectIsoDelete', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('storageProjectIsoDelete', 'locationId', locationId)
            // verify required parameter 'isoId' is not null or undefined
            assertParamExists('storageProjectIsoDelete', 'isoId', isoId)
            const localVarPath = `/storage/{locationId}/project/{projectId}/iso/{isoId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"isoId"}}`, encodeURIComponent(String(isoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * action detach
         * @summary Detach storage/iso
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} isoId Iso Id
         * @param {StorageProjectIsoDetach} storageProjectIsoDetach 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectIsoDetach: async (projectId: string, locationId: string, isoId: string, storageProjectIsoDetach: StorageProjectIsoDetach, xIdempotencyKey?: string, xDryRun?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('storageProjectIsoDetach', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('storageProjectIsoDetach', 'locationId', locationId)
            // verify required parameter 'isoId' is not null or undefined
            assertParamExists('storageProjectIsoDetach', 'isoId', isoId)
            // verify required parameter 'storageProjectIsoDetach' is not null or undefined
            assertParamExists('storageProjectIsoDetach', 'storageProjectIsoDetach', storageProjectIsoDetach)
            const localVarPath = `/storage/{locationId}/project/{projectId}/iso/{isoId}/actions/detach`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"isoId"}}`, encodeURIComponent(String(isoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }

            if (xDryRun !== undefined && xDryRun !== null) {
                localVarHeaderParameter['x-dry-run'] = String(xDryRun);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storageProjectIsoDetach, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get storage/iso.event
         * @summary Get storage/iso.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} isoId Iso Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectIsoEventGet: async (projectId: string, locationId: string, isoId: string, eventId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('storageProjectIsoEventGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('storageProjectIsoEventGet', 'locationId', locationId)
            // verify required parameter 'isoId' is not null or undefined
            assertParamExists('storageProjectIsoEventGet', 'isoId', isoId)
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('storageProjectIsoEventGet', 'eventId', eventId)
            const localVarPath = `/storage/{locationId}/project/{projectId}/iso/{isoId}/event/{eventId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"isoId"}}`, encodeURIComponent(String(isoId)))
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List storage/iso.event
         * @summary List storage/iso.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} isoId Iso Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectIsoEventList: async (projectId: string, locationId: string, isoId: string, $limit?: number, $skip?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('storageProjectIsoEventList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('storageProjectIsoEventList', 'locationId', locationId)
            // verify required parameter 'isoId' is not null or undefined
            assertParamExists('storageProjectIsoEventList', 'isoId', isoId)
            const localVarPath = `/storage/{locationId}/project/{projectId}/iso/{isoId}/event`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"isoId"}}`, encodeURIComponent(String(isoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if ($limit !== undefined) {
                localVarQueryParameter['$limit'] = $limit;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single iso
         * @summary Get storage/iso
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} isoId Iso Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectIsoGet: async (projectId: string, locationId: string, isoId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('storageProjectIsoGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('storageProjectIsoGet', 'locationId', locationId)
            // verify required parameter 'isoId' is not null or undefined
            assertParamExists('storageProjectIsoGet', 'isoId', isoId)
            const localVarPath = `/storage/{locationId}/project/{projectId}/iso/{isoId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"isoId"}}`, encodeURIComponent(String(isoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List iso
         * @summary List storage/iso
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [name] Filter by name
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectIsoList: async (projectId: string, locationId: string, name?: string, tagValue?: string, tagKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('storageProjectIsoList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('storageProjectIsoList', 'locationId', locationId)
            const localVarPath = `/storage/{locationId}/project/{projectId}/iso`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (tagValue !== undefined) {
                localVarQueryParameter['tag.value'] = tagValue;
            }

            if (tagKey !== undefined) {
                localVarQueryParameter['tag.key'] = tagKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get storage/iso.service
         * @summary Get storage/iso.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} isoId Iso Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectIsoServiceGet: async (projectId: string, locationId: string, isoId: string, serviceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('storageProjectIsoServiceGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('storageProjectIsoServiceGet', 'locationId', locationId)
            // verify required parameter 'isoId' is not null or undefined
            assertParamExists('storageProjectIsoServiceGet', 'isoId', isoId)
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('storageProjectIsoServiceGet', 'serviceId', serviceId)
            const localVarPath = `/storage/{locationId}/project/{projectId}/iso/{isoId}/service/{serviceId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"isoId"}}`, encodeURIComponent(String(isoId)))
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List storage/iso.service
         * @summary List storage/iso.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} isoId Iso Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectIsoServiceList: async (projectId: string, locationId: string, isoId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('storageProjectIsoServiceList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('storageProjectIsoServiceList', 'locationId', locationId)
            // verify required parameter 'isoId' is not null or undefined
            assertParamExists('storageProjectIsoServiceList', 'isoId', isoId)
            const localVarPath = `/storage/{locationId}/project/{projectId}/iso/{isoId}/service`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"isoId"}}`, encodeURIComponent(String(isoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create storage/iso.tag
         * @summary Create storage/iso.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} isoId Iso Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectIsoTagCreate: async (projectId: string, locationId: string, isoId: string, tag: Tag, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('storageProjectIsoTagCreate', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('storageProjectIsoTagCreate', 'locationId', locationId)
            // verify required parameter 'isoId' is not null or undefined
            assertParamExists('storageProjectIsoTagCreate', 'isoId', isoId)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('storageProjectIsoTagCreate', 'tag', tag)
            const localVarPath = `/storage/{locationId}/project/{projectId}/iso/{isoId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"isoId"}}`, encodeURIComponent(String(isoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tag, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete storage/iso.tag
         * @summary Delete storage/iso.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} isoId Iso Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectIsoTagDelete: async (projectId: string, locationId: string, isoId: string, tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('storageProjectIsoTagDelete', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('storageProjectIsoTagDelete', 'locationId', locationId)
            // verify required parameter 'isoId' is not null or undefined
            assertParamExists('storageProjectIsoTagDelete', 'isoId', isoId)
            // verify required parameter 'tagId' is not null or undefined
            assertParamExists('storageProjectIsoTagDelete', 'tagId', tagId)
            const localVarPath = `/storage/{locationId}/project/{projectId}/iso/{isoId}/tag/{tagId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"isoId"}}`, encodeURIComponent(String(isoId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get storage/iso.tag
         * @summary Get storage/iso.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} isoId Iso Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectIsoTagGet: async (projectId: string, locationId: string, isoId: string, tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('storageProjectIsoTagGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('storageProjectIsoTagGet', 'locationId', locationId)
            // verify required parameter 'isoId' is not null or undefined
            assertParamExists('storageProjectIsoTagGet', 'isoId', isoId)
            // verify required parameter 'tagId' is not null or undefined
            assertParamExists('storageProjectIsoTagGet', 'tagId', tagId)
            const localVarPath = `/storage/{locationId}/project/{projectId}/iso/{isoId}/tag/{tagId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"isoId"}}`, encodeURIComponent(String(isoId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List storage/iso.tag
         * @summary List storage/iso.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} isoId Iso Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectIsoTagList: async (projectId: string, locationId: string, isoId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('storageProjectIsoTagList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('storageProjectIsoTagList', 'locationId', locationId)
            // verify required parameter 'isoId' is not null or undefined
            assertParamExists('storageProjectIsoTagList', 'isoId', isoId)
            const localVarPath = `/storage/{locationId}/project/{projectId}/iso/{isoId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"isoId"}}`, encodeURIComponent(String(isoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replace storage/iso.tag
         * @summary Replace storage/iso.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} isoId Iso Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectIsoTagPut: async (projectId: string, locationId: string, isoId: string, tag: Array<Tag>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('storageProjectIsoTagPut', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('storageProjectIsoTagPut', 'locationId', locationId)
            // verify required parameter 'isoId' is not null or undefined
            assertParamExists('storageProjectIsoTagPut', 'isoId', isoId)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('storageProjectIsoTagPut', 'tag', tag)
            const localVarPath = `/storage/{locationId}/project/{projectId}/iso/{isoId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"isoId"}}`, encodeURIComponent(String(isoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tag, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * action transfer
         * @summary Transfer storage/iso
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} isoId Iso Id
         * @param {StorageProjectIsoTransfer} storageProjectIsoTransfer 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectIsoTransfer: async (projectId: string, locationId: string, isoId: string, storageProjectIsoTransfer: StorageProjectIsoTransfer, xIdempotencyKey?: string, xDryRun?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('storageProjectIsoTransfer', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('storageProjectIsoTransfer', 'locationId', locationId)
            // verify required parameter 'isoId' is not null or undefined
            assertParamExists('storageProjectIsoTransfer', 'isoId', isoId)
            // verify required parameter 'storageProjectIsoTransfer' is not null or undefined
            assertParamExists('storageProjectIsoTransfer', 'storageProjectIsoTransfer', storageProjectIsoTransfer)
            const localVarPath = `/storage/{locationId}/project/{projectId}/iso/{isoId}/actions/transfer`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"isoId"}}`, encodeURIComponent(String(isoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }

            if (xDryRun !== undefined && xDryRun !== null) {
                localVarHeaderParameter['x-dry-run'] = String(xDryRun);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storageProjectIsoTransfer, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns modified iso
         * @summary Update storage/iso
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} isoId Iso Id
         * @param {StorageProjectIsoUpdate} storageProjectIsoUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectIsoUpdate: async (projectId: string, locationId: string, isoId: string, storageProjectIsoUpdate: StorageProjectIsoUpdate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('storageProjectIsoUpdate', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('storageProjectIsoUpdate', 'locationId', locationId)
            // verify required parameter 'isoId' is not null or undefined
            assertParamExists('storageProjectIsoUpdate', 'isoId', isoId)
            // verify required parameter 'storageProjectIsoUpdate' is not null or undefined
            assertParamExists('storageProjectIsoUpdate', 'storageProjectIsoUpdate', storageProjectIsoUpdate)
            const localVarPath = `/storage/{locationId}/project/{projectId}/iso/{isoId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"isoId"}}`, encodeURIComponent(String(isoId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storageProjectIsoUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StorageProjectIsoApi - functional programming interface
 * @export
 */
export const StorageProjectIsoApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StorageProjectIsoApiAxiosParamCreator(configuration)
    return {
        /**
         * Create iso
         * @summary Create storage/iso
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {StorageProjectIsoCreate} storageProjectIsoCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectIsoCreate(projectId: string, locationId: string, storageProjectIsoCreate: StorageProjectIsoCreate, xIdempotencyKey?: string, xDryRun?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Iso>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageProjectIsoCreate(projectId, locationId, storageProjectIsoCreate, xIdempotencyKey, xDryRun, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete iso
         * @summary Delete storage/iso
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} isoId Iso Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectIsoDelete(projectId: string, locationId: string, isoId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageProjectIsoDelete(projectId, locationId, isoId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * action detach
         * @summary Detach storage/iso
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} isoId Iso Id
         * @param {StorageProjectIsoDetach} storageProjectIsoDetach 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectIsoDetach(projectId: string, locationId: string, isoId: string, storageProjectIsoDetach: StorageProjectIsoDetach, xIdempotencyKey?: string, xDryRun?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Iso>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageProjectIsoDetach(projectId, locationId, isoId, storageProjectIsoDetach, xIdempotencyKey, xDryRun, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get storage/iso.event
         * @summary Get storage/iso.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} isoId Iso Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectIsoEventGet(projectId: string, locationId: string, isoId: string, eventId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageProjectIsoEventGet(projectId, locationId, isoId, eventId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List storage/iso.event
         * @summary List storage/iso.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} isoId Iso Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectIsoEventList(projectId: string, locationId: string, isoId: string, $limit?: number, $skip?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Event>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageProjectIsoEventList(projectId, locationId, isoId, $limit, $skip, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a single iso
         * @summary Get storage/iso
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} isoId Iso Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectIsoGet(projectId: string, locationId: string, isoId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Iso>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageProjectIsoGet(projectId, locationId, isoId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List iso
         * @summary List storage/iso
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [name] Filter by name
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectIsoList(projectId: string, locationId: string, name?: string, tagValue?: string, tagKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Iso>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageProjectIsoList(projectId, locationId, name, tagValue, tagKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get storage/iso.service
         * @summary Get storage/iso.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} isoId Iso Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectIsoServiceGet(projectId: string, locationId: string, isoId: string, serviceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceService>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageProjectIsoServiceGet(projectId, locationId, isoId, serviceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List storage/iso.service
         * @summary List storage/iso.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} isoId Iso Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectIsoServiceList(projectId: string, locationId: string, isoId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResourceService>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageProjectIsoServiceList(projectId, locationId, isoId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create storage/iso.tag
         * @summary Create storage/iso.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} isoId Iso Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectIsoTagCreate(projectId: string, locationId: string, isoId: string, tag: Tag, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageProjectIsoTagCreate(projectId, locationId, isoId, tag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete storage/iso.tag
         * @summary Delete storage/iso.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} isoId Iso Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectIsoTagDelete(projectId: string, locationId: string, isoId: string, tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageProjectIsoTagDelete(projectId, locationId, isoId, tagId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get storage/iso.tag
         * @summary Get storage/iso.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} isoId Iso Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectIsoTagGet(projectId: string, locationId: string, isoId: string, tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageProjectIsoTagGet(projectId, locationId, isoId, tagId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List storage/iso.tag
         * @summary List storage/iso.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} isoId Iso Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectIsoTagList(projectId: string, locationId: string, isoId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageProjectIsoTagList(projectId, locationId, isoId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Replace storage/iso.tag
         * @summary Replace storage/iso.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} isoId Iso Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectIsoTagPut(projectId: string, locationId: string, isoId: string, tag: Array<Tag>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageProjectIsoTagPut(projectId, locationId, isoId, tag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * action transfer
         * @summary Transfer storage/iso
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} isoId Iso Id
         * @param {StorageProjectIsoTransfer} storageProjectIsoTransfer 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectIsoTransfer(projectId: string, locationId: string, isoId: string, storageProjectIsoTransfer: StorageProjectIsoTransfer, xIdempotencyKey?: string, xDryRun?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Iso>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageProjectIsoTransfer(projectId, locationId, isoId, storageProjectIsoTransfer, xIdempotencyKey, xDryRun, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns modified iso
         * @summary Update storage/iso
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} isoId Iso Id
         * @param {StorageProjectIsoUpdate} storageProjectIsoUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectIsoUpdate(projectId: string, locationId: string, isoId: string, storageProjectIsoUpdate: StorageProjectIsoUpdate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Iso>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageProjectIsoUpdate(projectId, locationId, isoId, storageProjectIsoUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StorageProjectIsoApi - factory interface
 * @export
 */
export const StorageProjectIsoApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StorageProjectIsoApiFp(configuration)
    return {
        /**
         * Create iso
         * @summary Create storage/iso
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {StorageProjectIsoCreate} storageProjectIsoCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectIsoCreate(projectId: string, locationId: string, storageProjectIsoCreate: StorageProjectIsoCreate, xIdempotencyKey?: string, xDryRun?: string, options?: any): AxiosPromise<Iso> {
            return localVarFp.storageProjectIsoCreate(projectId, locationId, storageProjectIsoCreate, xIdempotencyKey, xDryRun, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete iso
         * @summary Delete storage/iso
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} isoId Iso Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectIsoDelete(projectId: string, locationId: string, isoId: string, options?: any): AxiosPromise<void> {
            return localVarFp.storageProjectIsoDelete(projectId, locationId, isoId, options).then((request) => request(axios, basePath));
        },
        /**
         * action detach
         * @summary Detach storage/iso
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} isoId Iso Id
         * @param {StorageProjectIsoDetach} storageProjectIsoDetach 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectIsoDetach(projectId: string, locationId: string, isoId: string, storageProjectIsoDetach: StorageProjectIsoDetach, xIdempotencyKey?: string, xDryRun?: string, options?: any): AxiosPromise<Iso> {
            return localVarFp.storageProjectIsoDetach(projectId, locationId, isoId, storageProjectIsoDetach, xIdempotencyKey, xDryRun, options).then((request) => request(axios, basePath));
        },
        /**
         * Get storage/iso.event
         * @summary Get storage/iso.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} isoId Iso Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectIsoEventGet(projectId: string, locationId: string, isoId: string, eventId: string, options?: any): AxiosPromise<Event> {
            return localVarFp.storageProjectIsoEventGet(projectId, locationId, isoId, eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * List storage/iso.event
         * @summary List storage/iso.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} isoId Iso Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectIsoEventList(projectId: string, locationId: string, isoId: string, $limit?: number, $skip?: number, options?: any): AxiosPromise<Array<Event>> {
            return localVarFp.storageProjectIsoEventList(projectId, locationId, isoId, $limit, $skip, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single iso
         * @summary Get storage/iso
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} isoId Iso Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectIsoGet(projectId: string, locationId: string, isoId: string, options?: any): AxiosPromise<Iso> {
            return localVarFp.storageProjectIsoGet(projectId, locationId, isoId, options).then((request) => request(axios, basePath));
        },
        /**
         * List iso
         * @summary List storage/iso
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [name] Filter by name
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectIsoList(projectId: string, locationId: string, name?: string, tagValue?: string, tagKey?: string, options?: any): AxiosPromise<Array<Iso>> {
            return localVarFp.storageProjectIsoList(projectId, locationId, name, tagValue, tagKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get storage/iso.service
         * @summary Get storage/iso.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} isoId Iso Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectIsoServiceGet(projectId: string, locationId: string, isoId: string, serviceId: string, options?: any): AxiosPromise<ResourceService> {
            return localVarFp.storageProjectIsoServiceGet(projectId, locationId, isoId, serviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * List storage/iso.service
         * @summary List storage/iso.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} isoId Iso Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectIsoServiceList(projectId: string, locationId: string, isoId: string, options?: any): AxiosPromise<Array<ResourceService>> {
            return localVarFp.storageProjectIsoServiceList(projectId, locationId, isoId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create storage/iso.tag
         * @summary Create storage/iso.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} isoId Iso Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectIsoTagCreate(projectId: string, locationId: string, isoId: string, tag: Tag, options?: any): AxiosPromise<Tag> {
            return localVarFp.storageProjectIsoTagCreate(projectId, locationId, isoId, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete storage/iso.tag
         * @summary Delete storage/iso.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} isoId Iso Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectIsoTagDelete(projectId: string, locationId: string, isoId: string, tagId: string, options?: any): AxiosPromise<void> {
            return localVarFp.storageProjectIsoTagDelete(projectId, locationId, isoId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get storage/iso.tag
         * @summary Get storage/iso.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} isoId Iso Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectIsoTagGet(projectId: string, locationId: string, isoId: string, tagId: string, options?: any): AxiosPromise<Tag> {
            return localVarFp.storageProjectIsoTagGet(projectId, locationId, isoId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * List storage/iso.tag
         * @summary List storage/iso.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} isoId Iso Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectIsoTagList(projectId: string, locationId: string, isoId: string, options?: any): AxiosPromise<Array<Tag>> {
            return localVarFp.storageProjectIsoTagList(projectId, locationId, isoId, options).then((request) => request(axios, basePath));
        },
        /**
         * Replace storage/iso.tag
         * @summary Replace storage/iso.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} isoId Iso Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectIsoTagPut(projectId: string, locationId: string, isoId: string, tag: Array<Tag>, options?: any): AxiosPromise<Array<Tag>> {
            return localVarFp.storageProjectIsoTagPut(projectId, locationId, isoId, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * action transfer
         * @summary Transfer storage/iso
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} isoId Iso Id
         * @param {StorageProjectIsoTransfer} storageProjectIsoTransfer 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectIsoTransfer(projectId: string, locationId: string, isoId: string, storageProjectIsoTransfer: StorageProjectIsoTransfer, xIdempotencyKey?: string, xDryRun?: string, options?: any): AxiosPromise<Iso> {
            return localVarFp.storageProjectIsoTransfer(projectId, locationId, isoId, storageProjectIsoTransfer, xIdempotencyKey, xDryRun, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns modified iso
         * @summary Update storage/iso
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} isoId Iso Id
         * @param {StorageProjectIsoUpdate} storageProjectIsoUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectIsoUpdate(projectId: string, locationId: string, isoId: string, storageProjectIsoUpdate: StorageProjectIsoUpdate, options?: any): AxiosPromise<Iso> {
            return localVarFp.storageProjectIsoUpdate(projectId, locationId, isoId, storageProjectIsoUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StorageProjectIsoApi - object-oriented interface
 * @export
 * @class StorageProjectIsoApi
 * @extends {BaseAPI}
 */
export class StorageProjectIsoApi extends BaseAPI {
    /**
     * Create iso
     * @summary Create storage/iso
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {StorageProjectIsoCreate} storageProjectIsoCreate 
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {string} [xDryRun] Dry run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectIsoApi
     */
    public storageProjectIsoCreate(projectId: string, locationId: string, storageProjectIsoCreate: StorageProjectIsoCreate, xIdempotencyKey?: string, xDryRun?: string, options?: any) {
        return StorageProjectIsoApiFp(this.configuration).storageProjectIsoCreate(projectId, locationId, storageProjectIsoCreate, xIdempotencyKey, xDryRun, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete iso
     * @summary Delete storage/iso
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} isoId Iso Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectIsoApi
     */
    public storageProjectIsoDelete(projectId: string, locationId: string, isoId: string, options?: any) {
        return StorageProjectIsoApiFp(this.configuration).storageProjectIsoDelete(projectId, locationId, isoId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * action detach
     * @summary Detach storage/iso
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} isoId Iso Id
     * @param {StorageProjectIsoDetach} storageProjectIsoDetach 
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {string} [xDryRun] Dry run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectIsoApi
     */
    public storageProjectIsoDetach(projectId: string, locationId: string, isoId: string, storageProjectIsoDetach: StorageProjectIsoDetach, xIdempotencyKey?: string, xDryRun?: string, options?: any) {
        return StorageProjectIsoApiFp(this.configuration).storageProjectIsoDetach(projectId, locationId, isoId, storageProjectIsoDetach, xIdempotencyKey, xDryRun, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get storage/iso.event
     * @summary Get storage/iso.event
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} isoId Iso Id
     * @param {string} eventId eventId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectIsoApi
     */
    public storageProjectIsoEventGet(projectId: string, locationId: string, isoId: string, eventId: string, options?: any) {
        return StorageProjectIsoApiFp(this.configuration).storageProjectIsoEventGet(projectId, locationId, isoId, eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List storage/iso.event
     * @summary List storage/iso.event
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} isoId Iso Id
     * @param {number} [$limit] $limit
     * @param {number} [$skip] $skip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectIsoApi
     */
    public storageProjectIsoEventList(projectId: string, locationId: string, isoId: string, $limit?: number, $skip?: number, options?: any) {
        return StorageProjectIsoApiFp(this.configuration).storageProjectIsoEventList(projectId, locationId, isoId, $limit, $skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single iso
     * @summary Get storage/iso
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} isoId Iso Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectIsoApi
     */
    public storageProjectIsoGet(projectId: string, locationId: string, isoId: string, options?: any) {
        return StorageProjectIsoApiFp(this.configuration).storageProjectIsoGet(projectId, locationId, isoId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List iso
     * @summary List storage/iso
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} [name] Filter by name
     * @param {string} [tagValue] Filter by tag.value
     * @param {string} [tagKey] Filter by tag.key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectIsoApi
     */
    public storageProjectIsoList(projectId: string, locationId: string, name?: string, tagValue?: string, tagKey?: string, options?: any) {
        return StorageProjectIsoApiFp(this.configuration).storageProjectIsoList(projectId, locationId, name, tagValue, tagKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get storage/iso.service
     * @summary Get storage/iso.service
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} isoId Iso Id
     * @param {string} serviceId serviceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectIsoApi
     */
    public storageProjectIsoServiceGet(projectId: string, locationId: string, isoId: string, serviceId: string, options?: any) {
        return StorageProjectIsoApiFp(this.configuration).storageProjectIsoServiceGet(projectId, locationId, isoId, serviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List storage/iso.service
     * @summary List storage/iso.service
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} isoId Iso Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectIsoApi
     */
    public storageProjectIsoServiceList(projectId: string, locationId: string, isoId: string, options?: any) {
        return StorageProjectIsoApiFp(this.configuration).storageProjectIsoServiceList(projectId, locationId, isoId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create storage/iso.tag
     * @summary Create storage/iso.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} isoId Iso Id
     * @param {Tag} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectIsoApi
     */
    public storageProjectIsoTagCreate(projectId: string, locationId: string, isoId: string, tag: Tag, options?: any) {
        return StorageProjectIsoApiFp(this.configuration).storageProjectIsoTagCreate(projectId, locationId, isoId, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete storage/iso.tag
     * @summary Delete storage/iso.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} isoId Iso Id
     * @param {string} tagId tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectIsoApi
     */
    public storageProjectIsoTagDelete(projectId: string, locationId: string, isoId: string, tagId: string, options?: any) {
        return StorageProjectIsoApiFp(this.configuration).storageProjectIsoTagDelete(projectId, locationId, isoId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get storage/iso.tag
     * @summary Get storage/iso.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} isoId Iso Id
     * @param {string} tagId tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectIsoApi
     */
    public storageProjectIsoTagGet(projectId: string, locationId: string, isoId: string, tagId: string, options?: any) {
        return StorageProjectIsoApiFp(this.configuration).storageProjectIsoTagGet(projectId, locationId, isoId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List storage/iso.tag
     * @summary List storage/iso.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} isoId Iso Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectIsoApi
     */
    public storageProjectIsoTagList(projectId: string, locationId: string, isoId: string, options?: any) {
        return StorageProjectIsoApiFp(this.configuration).storageProjectIsoTagList(projectId, locationId, isoId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replace storage/iso.tag
     * @summary Replace storage/iso.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} isoId Iso Id
     * @param {Array<Tag>} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectIsoApi
     */
    public storageProjectIsoTagPut(projectId: string, locationId: string, isoId: string, tag: Array<Tag>, options?: any) {
        return StorageProjectIsoApiFp(this.configuration).storageProjectIsoTagPut(projectId, locationId, isoId, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * action transfer
     * @summary Transfer storage/iso
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} isoId Iso Id
     * @param {StorageProjectIsoTransfer} storageProjectIsoTransfer 
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {string} [xDryRun] Dry run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectIsoApi
     */
    public storageProjectIsoTransfer(projectId: string, locationId: string, isoId: string, storageProjectIsoTransfer: StorageProjectIsoTransfer, xIdempotencyKey?: string, xDryRun?: string, options?: any) {
        return StorageProjectIsoApiFp(this.configuration).storageProjectIsoTransfer(projectId, locationId, isoId, storageProjectIsoTransfer, xIdempotencyKey, xDryRun, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns modified iso
     * @summary Update storage/iso
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} isoId Iso Id
     * @param {StorageProjectIsoUpdate} storageProjectIsoUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectIsoApi
     */
    public storageProjectIsoUpdate(projectId: string, locationId: string, isoId: string, storageProjectIsoUpdate: StorageProjectIsoUpdate, options?: any) {
        return StorageProjectIsoApiFp(this.configuration).storageProjectIsoUpdate(projectId, locationId, isoId, storageProjectIsoUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StorageProjectVaultApi - axios parameter creator
 * @export
 */
export const StorageProjectVaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get storage/vault.connect
         * @summary Get storage/vault.connect
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {string} connectId connectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultConnectGet: async (projectId: string, locationId: string, vaultId: string, connectId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('storageProjectVaultConnectGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('storageProjectVaultConnectGet', 'locationId', locationId)
            // verify required parameter 'vaultId' is not null or undefined
            assertParamExists('storageProjectVaultConnectGet', 'vaultId', vaultId)
            // verify required parameter 'connectId' is not null or undefined
            assertParamExists('storageProjectVaultConnectGet', 'connectId', connectId)
            const localVarPath = `/storage/{locationId}/project/{projectId}/vault/{vaultId}/connect/{connectId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"vaultId"}}`, encodeURIComponent(String(vaultId)))
                .replace(`{${"connectId"}}`, encodeURIComponent(String(connectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List storage/vault.connect
         * @summary List storage/vault.connect
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultConnectList: async (projectId: string, locationId: string, vaultId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('storageProjectVaultConnectList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('storageProjectVaultConnectList', 'locationId', locationId)
            // verify required parameter 'vaultId' is not null or undefined
            assertParamExists('storageProjectVaultConnectList', 'vaultId', vaultId)
            const localVarPath = `/storage/{locationId}/project/{projectId}/vault/{vaultId}/connect`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"vaultId"}}`, encodeURIComponent(String(vaultId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create vault
         * @summary Create storage/vault
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {StorageProjectVaultCreate} storageProjectVaultCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultCreate: async (projectId: string, locationId: string, storageProjectVaultCreate: StorageProjectVaultCreate, xIdempotencyKey?: string, xDryRun?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('storageProjectVaultCreate', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('storageProjectVaultCreate', 'locationId', locationId)
            // verify required parameter 'storageProjectVaultCreate' is not null or undefined
            assertParamExists('storageProjectVaultCreate', 'storageProjectVaultCreate', storageProjectVaultCreate)
            const localVarPath = `/storage/{locationId}/project/{projectId}/vault`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }

            if (xDryRun !== undefined && xDryRun !== null) {
                localVarHeaderParameter['x-dry-run'] = String(xDryRun);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storageProjectVaultCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create storage/vault.credential
         * @summary Create storage/vault.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {VaultCredential} vaultCredential 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultCredentialCreate: async (projectId: string, locationId: string, vaultId: string, vaultCredential: VaultCredential, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('storageProjectVaultCredentialCreate', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('storageProjectVaultCredentialCreate', 'locationId', locationId)
            // verify required parameter 'vaultId' is not null or undefined
            assertParamExists('storageProjectVaultCredentialCreate', 'vaultId', vaultId)
            // verify required parameter 'vaultCredential' is not null or undefined
            assertParamExists('storageProjectVaultCredentialCreate', 'vaultCredential', vaultCredential)
            const localVarPath = `/storage/{locationId}/project/{projectId}/vault/{vaultId}/credential`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"vaultId"}}`, encodeURIComponent(String(vaultId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(vaultCredential, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete storage/vault.credential
         * @summary Delete storage/vault.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {string} credentialId credentialId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultCredentialDelete: async (projectId: string, locationId: string, vaultId: string, credentialId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('storageProjectVaultCredentialDelete', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('storageProjectVaultCredentialDelete', 'locationId', locationId)
            // verify required parameter 'vaultId' is not null or undefined
            assertParamExists('storageProjectVaultCredentialDelete', 'vaultId', vaultId)
            // verify required parameter 'credentialId' is not null or undefined
            assertParamExists('storageProjectVaultCredentialDelete', 'credentialId', credentialId)
            const localVarPath = `/storage/{locationId}/project/{projectId}/vault/{vaultId}/credential/{credentialId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"vaultId"}}`, encodeURIComponent(String(vaultId)))
                .replace(`{${"credentialId"}}`, encodeURIComponent(String(credentialId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get storage/vault.credential
         * @summary Get storage/vault.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {string} credentialId credentialId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultCredentialGet: async (projectId: string, locationId: string, vaultId: string, credentialId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('storageProjectVaultCredentialGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('storageProjectVaultCredentialGet', 'locationId', locationId)
            // verify required parameter 'vaultId' is not null or undefined
            assertParamExists('storageProjectVaultCredentialGet', 'vaultId', vaultId)
            // verify required parameter 'credentialId' is not null or undefined
            assertParamExists('storageProjectVaultCredentialGet', 'credentialId', credentialId)
            const localVarPath = `/storage/{locationId}/project/{projectId}/vault/{vaultId}/credential/{credentialId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"vaultId"}}`, encodeURIComponent(String(vaultId)))
                .replace(`{${"credentialId"}}`, encodeURIComponent(String(credentialId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List storage/vault.credential
         * @summary List storage/vault.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultCredentialList: async (projectId: string, locationId: string, vaultId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('storageProjectVaultCredentialList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('storageProjectVaultCredentialList', 'locationId', locationId)
            // verify required parameter 'vaultId' is not null or undefined
            assertParamExists('storageProjectVaultCredentialList', 'vaultId', vaultId)
            const localVarPath = `/storage/{locationId}/project/{projectId}/vault/{vaultId}/credential`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"vaultId"}}`, encodeURIComponent(String(vaultId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update storage/vault.credential
         * @summary Update storage/vault.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {string} credentialId credentialId
         * @param {StorageProjectVaultCredentialPatch} storageProjectVaultCredentialPatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultCredentialPatch: async (projectId: string, locationId: string, vaultId: string, credentialId: string, storageProjectVaultCredentialPatch: StorageProjectVaultCredentialPatch, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('storageProjectVaultCredentialPatch', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('storageProjectVaultCredentialPatch', 'locationId', locationId)
            // verify required parameter 'vaultId' is not null or undefined
            assertParamExists('storageProjectVaultCredentialPatch', 'vaultId', vaultId)
            // verify required parameter 'credentialId' is not null or undefined
            assertParamExists('storageProjectVaultCredentialPatch', 'credentialId', credentialId)
            // verify required parameter 'storageProjectVaultCredentialPatch' is not null or undefined
            assertParamExists('storageProjectVaultCredentialPatch', 'storageProjectVaultCredentialPatch', storageProjectVaultCredentialPatch)
            const localVarPath = `/storage/{locationId}/project/{projectId}/vault/{vaultId}/credential/{credentialId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"vaultId"}}`, encodeURIComponent(String(vaultId)))
                .replace(`{${"credentialId"}}`, encodeURIComponent(String(credentialId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storageProjectVaultCredentialPatch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete vault
         * @summary Delete storage/vault
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {StorageProjectVaultDelete} storageProjectVaultDelete 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultDelete: async (projectId: string, locationId: string, vaultId: string, storageProjectVaultDelete: StorageProjectVaultDelete, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('storageProjectVaultDelete', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('storageProjectVaultDelete', 'locationId', locationId)
            // verify required parameter 'vaultId' is not null or undefined
            assertParamExists('storageProjectVaultDelete', 'vaultId', vaultId)
            // verify required parameter 'storageProjectVaultDelete' is not null or undefined
            assertParamExists('storageProjectVaultDelete', 'storageProjectVaultDelete', storageProjectVaultDelete)
            const localVarPath = `/storage/{locationId}/project/{projectId}/vault/{vaultId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"vaultId"}}`, encodeURIComponent(String(vaultId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storageProjectVaultDelete, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get storage/vault.event
         * @summary Get storage/vault.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultEventGet: async (projectId: string, locationId: string, vaultId: string, eventId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('storageProjectVaultEventGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('storageProjectVaultEventGet', 'locationId', locationId)
            // verify required parameter 'vaultId' is not null or undefined
            assertParamExists('storageProjectVaultEventGet', 'vaultId', vaultId)
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('storageProjectVaultEventGet', 'eventId', eventId)
            const localVarPath = `/storage/{locationId}/project/{projectId}/vault/{vaultId}/event/{eventId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"vaultId"}}`, encodeURIComponent(String(vaultId)))
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List storage/vault.event
         * @summary List storage/vault.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultEventList: async (projectId: string, locationId: string, vaultId: string, $limit?: number, $skip?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('storageProjectVaultEventList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('storageProjectVaultEventList', 'locationId', locationId)
            // verify required parameter 'vaultId' is not null or undefined
            assertParamExists('storageProjectVaultEventList', 'vaultId', vaultId)
            const localVarPath = `/storage/{locationId}/project/{projectId}/vault/{vaultId}/event`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"vaultId"}}`, encodeURIComponent(String(vaultId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if ($limit !== undefined) {
                localVarQueryParameter['$limit'] = $limit;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single vault
         * @summary Get storage/vault
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultGet: async (projectId: string, locationId: string, vaultId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('storageProjectVaultGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('storageProjectVaultGet', 'locationId', locationId)
            // verify required parameter 'vaultId' is not null or undefined
            assertParamExists('storageProjectVaultGet', 'vaultId', vaultId)
            const localVarPath = `/storage/{locationId}/project/{projectId}/vault/{vaultId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"vaultId"}}`, encodeURIComponent(String(vaultId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List vault
         * @summary List storage/vault
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [name] Filter by name
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultList: async (projectId: string, locationId: string, name?: string, tagValue?: string, tagKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('storageProjectVaultList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('storageProjectVaultList', 'locationId', locationId)
            const localVarPath = `/storage/{locationId}/project/{projectId}/vault`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (tagValue !== undefined) {
                localVarQueryParameter['tag.value'] = tagValue;
            }

            if (tagKey !== undefined) {
                localVarQueryParameter['tag.key'] = tagKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * action resize
         * @summary Resize storage/vault
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {StorageProjectVaultResize} storageProjectVaultResize 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultResize: async (projectId: string, locationId: string, vaultId: string, storageProjectVaultResize: StorageProjectVaultResize, xIdempotencyKey?: string, xDryRun?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('storageProjectVaultResize', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('storageProjectVaultResize', 'locationId', locationId)
            // verify required parameter 'vaultId' is not null or undefined
            assertParamExists('storageProjectVaultResize', 'vaultId', vaultId)
            // verify required parameter 'storageProjectVaultResize' is not null or undefined
            assertParamExists('storageProjectVaultResize', 'storageProjectVaultResize', storageProjectVaultResize)
            const localVarPath = `/storage/{locationId}/project/{projectId}/vault/{vaultId}/actions/resize`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"vaultId"}}`, encodeURIComponent(String(vaultId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }

            if (xDryRun !== undefined && xDryRun !== null) {
                localVarHeaderParameter['x-dry-run'] = String(xDryRun);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storageProjectVaultResize, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get storage/vault.service
         * @summary Get storage/vault.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultServiceGet: async (projectId: string, locationId: string, vaultId: string, serviceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('storageProjectVaultServiceGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('storageProjectVaultServiceGet', 'locationId', locationId)
            // verify required parameter 'vaultId' is not null or undefined
            assertParamExists('storageProjectVaultServiceGet', 'vaultId', vaultId)
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('storageProjectVaultServiceGet', 'serviceId', serviceId)
            const localVarPath = `/storage/{locationId}/project/{projectId}/vault/{vaultId}/service/{serviceId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"vaultId"}}`, encodeURIComponent(String(vaultId)))
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List storage/vault.service
         * @summary List storage/vault.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultServiceList: async (projectId: string, locationId: string, vaultId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('storageProjectVaultServiceList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('storageProjectVaultServiceList', 'locationId', locationId)
            // verify required parameter 'vaultId' is not null or undefined
            assertParamExists('storageProjectVaultServiceList', 'vaultId', vaultId)
            const localVarPath = `/storage/{locationId}/project/{projectId}/vault/{vaultId}/service`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"vaultId"}}`, encodeURIComponent(String(vaultId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create storage/vault.snapshot
         * @summary Create storage/vault.snapshot
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {StorageProjectVaultSnapshotCreate} storageProjectVaultSnapshotCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultSnapshotCreate: async (projectId: string, locationId: string, vaultId: string, storageProjectVaultSnapshotCreate: StorageProjectVaultSnapshotCreate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('storageProjectVaultSnapshotCreate', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('storageProjectVaultSnapshotCreate', 'locationId', locationId)
            // verify required parameter 'vaultId' is not null or undefined
            assertParamExists('storageProjectVaultSnapshotCreate', 'vaultId', vaultId)
            // verify required parameter 'storageProjectVaultSnapshotCreate' is not null or undefined
            assertParamExists('storageProjectVaultSnapshotCreate', 'storageProjectVaultSnapshotCreate', storageProjectVaultSnapshotCreate)
            const localVarPath = `/storage/{locationId}/project/{projectId}/vault/{vaultId}/snapshot`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"vaultId"}}`, encodeURIComponent(String(vaultId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storageProjectVaultSnapshotCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete storage/vault.snapshot
         * @summary Delete storage/vault.snapshot
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {string} snapshotId snapshotId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultSnapshotDelete: async (projectId: string, locationId: string, vaultId: string, snapshotId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('storageProjectVaultSnapshotDelete', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('storageProjectVaultSnapshotDelete', 'locationId', locationId)
            // verify required parameter 'vaultId' is not null or undefined
            assertParamExists('storageProjectVaultSnapshotDelete', 'vaultId', vaultId)
            // verify required parameter 'snapshotId' is not null or undefined
            assertParamExists('storageProjectVaultSnapshotDelete', 'snapshotId', snapshotId)
            const localVarPath = `/storage/{locationId}/project/{projectId}/vault/{vaultId}/snapshot/{snapshotId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"vaultId"}}`, encodeURIComponent(String(vaultId)))
                .replace(`{${"snapshotId"}}`, encodeURIComponent(String(snapshotId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get storage/vault.snapshot
         * @summary Get storage/vault.snapshot
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {string} snapshotId snapshotId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultSnapshotGet: async (projectId: string, locationId: string, vaultId: string, snapshotId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('storageProjectVaultSnapshotGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('storageProjectVaultSnapshotGet', 'locationId', locationId)
            // verify required parameter 'vaultId' is not null or undefined
            assertParamExists('storageProjectVaultSnapshotGet', 'vaultId', vaultId)
            // verify required parameter 'snapshotId' is not null or undefined
            assertParamExists('storageProjectVaultSnapshotGet', 'snapshotId', snapshotId)
            const localVarPath = `/storage/{locationId}/project/{projectId}/vault/{vaultId}/snapshot/{snapshotId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"vaultId"}}`, encodeURIComponent(String(vaultId)))
                .replace(`{${"snapshotId"}}`, encodeURIComponent(String(snapshotId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List storage/vault.snapshot
         * @summary List storage/vault.snapshot
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultSnapshotList: async (projectId: string, locationId: string, vaultId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('storageProjectVaultSnapshotList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('storageProjectVaultSnapshotList', 'locationId', locationId)
            // verify required parameter 'vaultId' is not null or undefined
            assertParamExists('storageProjectVaultSnapshotList', 'vaultId', vaultId)
            const localVarPath = `/storage/{locationId}/project/{projectId}/vault/{vaultId}/snapshot`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"vaultId"}}`, encodeURIComponent(String(vaultId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * action start
         * @summary Start storage/vault
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultStart: async (projectId: string, locationId: string, vaultId: string, xIdempotencyKey?: string, xDryRun?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('storageProjectVaultStart', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('storageProjectVaultStart', 'locationId', locationId)
            // verify required parameter 'vaultId' is not null or undefined
            assertParamExists('storageProjectVaultStart', 'vaultId', vaultId)
            const localVarPath = `/storage/{locationId}/project/{projectId}/vault/{vaultId}/actions/start`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"vaultId"}}`, encodeURIComponent(String(vaultId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }

            if (xDryRun !== undefined && xDryRun !== null) {
                localVarHeaderParameter['x-dry-run'] = String(xDryRun);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * action stop
         * @summary Stop storage/vault
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultStop: async (projectId: string, locationId: string, vaultId: string, xIdempotencyKey?: string, xDryRun?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('storageProjectVaultStop', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('storageProjectVaultStop', 'locationId', locationId)
            // verify required parameter 'vaultId' is not null or undefined
            assertParamExists('storageProjectVaultStop', 'vaultId', vaultId)
            const localVarPath = `/storage/{locationId}/project/{projectId}/vault/{vaultId}/actions/stop`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"vaultId"}}`, encodeURIComponent(String(vaultId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }

            if (xDryRun !== undefined && xDryRun !== null) {
                localVarHeaderParameter['x-dry-run'] = String(xDryRun);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create storage/vault.tag
         * @summary Create storage/vault.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultTagCreate: async (projectId: string, locationId: string, vaultId: string, tag: Tag, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('storageProjectVaultTagCreate', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('storageProjectVaultTagCreate', 'locationId', locationId)
            // verify required parameter 'vaultId' is not null or undefined
            assertParamExists('storageProjectVaultTagCreate', 'vaultId', vaultId)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('storageProjectVaultTagCreate', 'tag', tag)
            const localVarPath = `/storage/{locationId}/project/{projectId}/vault/{vaultId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"vaultId"}}`, encodeURIComponent(String(vaultId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tag, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete storage/vault.tag
         * @summary Delete storage/vault.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultTagDelete: async (projectId: string, locationId: string, vaultId: string, tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('storageProjectVaultTagDelete', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('storageProjectVaultTagDelete', 'locationId', locationId)
            // verify required parameter 'vaultId' is not null or undefined
            assertParamExists('storageProjectVaultTagDelete', 'vaultId', vaultId)
            // verify required parameter 'tagId' is not null or undefined
            assertParamExists('storageProjectVaultTagDelete', 'tagId', tagId)
            const localVarPath = `/storage/{locationId}/project/{projectId}/vault/{vaultId}/tag/{tagId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"vaultId"}}`, encodeURIComponent(String(vaultId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get storage/vault.tag
         * @summary Get storage/vault.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultTagGet: async (projectId: string, locationId: string, vaultId: string, tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('storageProjectVaultTagGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('storageProjectVaultTagGet', 'locationId', locationId)
            // verify required parameter 'vaultId' is not null or undefined
            assertParamExists('storageProjectVaultTagGet', 'vaultId', vaultId)
            // verify required parameter 'tagId' is not null or undefined
            assertParamExists('storageProjectVaultTagGet', 'tagId', tagId)
            const localVarPath = `/storage/{locationId}/project/{projectId}/vault/{vaultId}/tag/{tagId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"vaultId"}}`, encodeURIComponent(String(vaultId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List storage/vault.tag
         * @summary List storage/vault.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultTagList: async (projectId: string, locationId: string, vaultId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('storageProjectVaultTagList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('storageProjectVaultTagList', 'locationId', locationId)
            // verify required parameter 'vaultId' is not null or undefined
            assertParamExists('storageProjectVaultTagList', 'vaultId', vaultId)
            const localVarPath = `/storage/{locationId}/project/{projectId}/vault/{vaultId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"vaultId"}}`, encodeURIComponent(String(vaultId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replace storage/vault.tag
         * @summary Replace storage/vault.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultTagPut: async (projectId: string, locationId: string, vaultId: string, tag: Array<Tag>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('storageProjectVaultTagPut', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('storageProjectVaultTagPut', 'locationId', locationId)
            // verify required parameter 'vaultId' is not null or undefined
            assertParamExists('storageProjectVaultTagPut', 'vaultId', vaultId)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('storageProjectVaultTagPut', 'tag', tag)
            const localVarPath = `/storage/{locationId}/project/{projectId}/vault/{vaultId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"vaultId"}}`, encodeURIComponent(String(vaultId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tag, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns modified vault
         * @summary Update storage/vault
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {StorageProjectVaultUpdate} storageProjectVaultUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultUpdate: async (projectId: string, locationId: string, vaultId: string, storageProjectVaultUpdate: StorageProjectVaultUpdate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('storageProjectVaultUpdate', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('storageProjectVaultUpdate', 'locationId', locationId)
            // verify required parameter 'vaultId' is not null or undefined
            assertParamExists('storageProjectVaultUpdate', 'vaultId', vaultId)
            // verify required parameter 'storageProjectVaultUpdate' is not null or undefined
            assertParamExists('storageProjectVaultUpdate', 'storageProjectVaultUpdate', storageProjectVaultUpdate)
            const localVarPath = `/storage/{locationId}/project/{projectId}/vault/{vaultId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"vaultId"}}`, encodeURIComponent(String(vaultId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storageProjectVaultUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StorageProjectVaultApi - functional programming interface
 * @export
 */
export const StorageProjectVaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StorageProjectVaultApiAxiosParamCreator(configuration)
    return {
        /**
         * Get storage/vault.connect
         * @summary Get storage/vault.connect
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {string} connectId connectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectVaultConnectGet(projectId: string, locationId: string, vaultId: string, connectId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceConnect>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageProjectVaultConnectGet(projectId, locationId, vaultId, connectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List storage/vault.connect
         * @summary List storage/vault.connect
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectVaultConnectList(projectId: string, locationId: string, vaultId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResourceConnect>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageProjectVaultConnectList(projectId, locationId, vaultId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create vault
         * @summary Create storage/vault
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {StorageProjectVaultCreate} storageProjectVaultCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectVaultCreate(projectId: string, locationId: string, storageProjectVaultCreate: StorageProjectVaultCreate, xIdempotencyKey?: string, xDryRun?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Vault>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageProjectVaultCreate(projectId, locationId, storageProjectVaultCreate, xIdempotencyKey, xDryRun, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create storage/vault.credential
         * @summary Create storage/vault.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {VaultCredential} vaultCredential 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectVaultCredentialCreate(projectId: string, locationId: string, vaultId: string, vaultCredential: VaultCredential, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VaultCredential>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageProjectVaultCredentialCreate(projectId, locationId, vaultId, vaultCredential, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete storage/vault.credential
         * @summary Delete storage/vault.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {string} credentialId credentialId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectVaultCredentialDelete(projectId: string, locationId: string, vaultId: string, credentialId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Vault>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageProjectVaultCredentialDelete(projectId, locationId, vaultId, credentialId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get storage/vault.credential
         * @summary Get storage/vault.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {string} credentialId credentialId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectVaultCredentialGet(projectId: string, locationId: string, vaultId: string, credentialId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VaultCredential>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageProjectVaultCredentialGet(projectId, locationId, vaultId, credentialId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List storage/vault.credential
         * @summary List storage/vault.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectVaultCredentialList(projectId: string, locationId: string, vaultId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<VaultCredential>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageProjectVaultCredentialList(projectId, locationId, vaultId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update storage/vault.credential
         * @summary Update storage/vault.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {string} credentialId credentialId
         * @param {StorageProjectVaultCredentialPatch} storageProjectVaultCredentialPatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectVaultCredentialPatch(projectId: string, locationId: string, vaultId: string, credentialId: string, storageProjectVaultCredentialPatch: StorageProjectVaultCredentialPatch, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<VaultCredential>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageProjectVaultCredentialPatch(projectId, locationId, vaultId, credentialId, storageProjectVaultCredentialPatch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete vault
         * @summary Delete storage/vault
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {StorageProjectVaultDelete} storageProjectVaultDelete 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectVaultDelete(projectId: string, locationId: string, vaultId: string, storageProjectVaultDelete: StorageProjectVaultDelete, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageProjectVaultDelete(projectId, locationId, vaultId, storageProjectVaultDelete, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get storage/vault.event
         * @summary Get storage/vault.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectVaultEventGet(projectId: string, locationId: string, vaultId: string, eventId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageProjectVaultEventGet(projectId, locationId, vaultId, eventId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List storage/vault.event
         * @summary List storage/vault.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectVaultEventList(projectId: string, locationId: string, vaultId: string, $limit?: number, $skip?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Event>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageProjectVaultEventList(projectId, locationId, vaultId, $limit, $skip, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a single vault
         * @summary Get storage/vault
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectVaultGet(projectId: string, locationId: string, vaultId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Vault>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageProjectVaultGet(projectId, locationId, vaultId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List vault
         * @summary List storage/vault
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [name] Filter by name
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectVaultList(projectId: string, locationId: string, name?: string, tagValue?: string, tagKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Vault>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageProjectVaultList(projectId, locationId, name, tagValue, tagKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * action resize
         * @summary Resize storage/vault
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {StorageProjectVaultResize} storageProjectVaultResize 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectVaultResize(projectId: string, locationId: string, vaultId: string, storageProjectVaultResize: StorageProjectVaultResize, xIdempotencyKey?: string, xDryRun?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Vault>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageProjectVaultResize(projectId, locationId, vaultId, storageProjectVaultResize, xIdempotencyKey, xDryRun, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get storage/vault.service
         * @summary Get storage/vault.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectVaultServiceGet(projectId: string, locationId: string, vaultId: string, serviceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceService>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageProjectVaultServiceGet(projectId, locationId, vaultId, serviceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List storage/vault.service
         * @summary List storage/vault.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectVaultServiceList(projectId: string, locationId: string, vaultId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResourceService>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageProjectVaultServiceList(projectId, locationId, vaultId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create storage/vault.snapshot
         * @summary Create storage/vault.snapshot
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {StorageProjectVaultSnapshotCreate} storageProjectVaultSnapshotCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectVaultSnapshotCreate(projectId: string, locationId: string, vaultId: string, storageProjectVaultSnapshotCreate: StorageProjectVaultSnapshotCreate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StorageSnapshot>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageProjectVaultSnapshotCreate(projectId, locationId, vaultId, storageProjectVaultSnapshotCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete storage/vault.snapshot
         * @summary Delete storage/vault.snapshot
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {string} snapshotId snapshotId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectVaultSnapshotDelete(projectId: string, locationId: string, vaultId: string, snapshotId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StorageSnapshot>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageProjectVaultSnapshotDelete(projectId, locationId, vaultId, snapshotId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get storage/vault.snapshot
         * @summary Get storage/vault.snapshot
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {string} snapshotId snapshotId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectVaultSnapshotGet(projectId: string, locationId: string, vaultId: string, snapshotId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StorageSnapshot>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageProjectVaultSnapshotGet(projectId, locationId, vaultId, snapshotId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List storage/vault.snapshot
         * @summary List storage/vault.snapshot
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectVaultSnapshotList(projectId: string, locationId: string, vaultId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<StorageSnapshot>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageProjectVaultSnapshotList(projectId, locationId, vaultId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * action start
         * @summary Start storage/vault
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectVaultStart(projectId: string, locationId: string, vaultId: string, xIdempotencyKey?: string, xDryRun?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Vault>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageProjectVaultStart(projectId, locationId, vaultId, xIdempotencyKey, xDryRun, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * action stop
         * @summary Stop storage/vault
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectVaultStop(projectId: string, locationId: string, vaultId: string, xIdempotencyKey?: string, xDryRun?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Vault>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageProjectVaultStop(projectId, locationId, vaultId, xIdempotencyKey, xDryRun, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create storage/vault.tag
         * @summary Create storage/vault.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectVaultTagCreate(projectId: string, locationId: string, vaultId: string, tag: Tag, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageProjectVaultTagCreate(projectId, locationId, vaultId, tag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete storage/vault.tag
         * @summary Delete storage/vault.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectVaultTagDelete(projectId: string, locationId: string, vaultId: string, tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageProjectVaultTagDelete(projectId, locationId, vaultId, tagId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get storage/vault.tag
         * @summary Get storage/vault.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectVaultTagGet(projectId: string, locationId: string, vaultId: string, tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageProjectVaultTagGet(projectId, locationId, vaultId, tagId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List storage/vault.tag
         * @summary List storage/vault.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectVaultTagList(projectId: string, locationId: string, vaultId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageProjectVaultTagList(projectId, locationId, vaultId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Replace storage/vault.tag
         * @summary Replace storage/vault.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectVaultTagPut(projectId: string, locationId: string, vaultId: string, tag: Array<Tag>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageProjectVaultTagPut(projectId, locationId, vaultId, tag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns modified vault
         * @summary Update storage/vault
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {StorageProjectVaultUpdate} storageProjectVaultUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storageProjectVaultUpdate(projectId: string, locationId: string, vaultId: string, storageProjectVaultUpdate: StorageProjectVaultUpdate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Vault>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storageProjectVaultUpdate(projectId, locationId, vaultId, storageProjectVaultUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StorageProjectVaultApi - factory interface
 * @export
 */
export const StorageProjectVaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StorageProjectVaultApiFp(configuration)
    return {
        /**
         * Get storage/vault.connect
         * @summary Get storage/vault.connect
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {string} connectId connectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultConnectGet(projectId: string, locationId: string, vaultId: string, connectId: string, options?: any): AxiosPromise<ResourceConnect> {
            return localVarFp.storageProjectVaultConnectGet(projectId, locationId, vaultId, connectId, options).then((request) => request(axios, basePath));
        },
        /**
         * List storage/vault.connect
         * @summary List storage/vault.connect
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultConnectList(projectId: string, locationId: string, vaultId: string, options?: any): AxiosPromise<Array<ResourceConnect>> {
            return localVarFp.storageProjectVaultConnectList(projectId, locationId, vaultId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create vault
         * @summary Create storage/vault
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {StorageProjectVaultCreate} storageProjectVaultCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultCreate(projectId: string, locationId: string, storageProjectVaultCreate: StorageProjectVaultCreate, xIdempotencyKey?: string, xDryRun?: string, options?: any): AxiosPromise<Vault> {
            return localVarFp.storageProjectVaultCreate(projectId, locationId, storageProjectVaultCreate, xIdempotencyKey, xDryRun, options).then((request) => request(axios, basePath));
        },
        /**
         * Create storage/vault.credential
         * @summary Create storage/vault.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {VaultCredential} vaultCredential 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultCredentialCreate(projectId: string, locationId: string, vaultId: string, vaultCredential: VaultCredential, options?: any): AxiosPromise<VaultCredential> {
            return localVarFp.storageProjectVaultCredentialCreate(projectId, locationId, vaultId, vaultCredential, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete storage/vault.credential
         * @summary Delete storage/vault.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {string} credentialId credentialId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultCredentialDelete(projectId: string, locationId: string, vaultId: string, credentialId: string, options?: any): AxiosPromise<Vault> {
            return localVarFp.storageProjectVaultCredentialDelete(projectId, locationId, vaultId, credentialId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get storage/vault.credential
         * @summary Get storage/vault.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {string} credentialId credentialId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultCredentialGet(projectId: string, locationId: string, vaultId: string, credentialId: string, options?: any): AxiosPromise<VaultCredential> {
            return localVarFp.storageProjectVaultCredentialGet(projectId, locationId, vaultId, credentialId, options).then((request) => request(axios, basePath));
        },
        /**
         * List storage/vault.credential
         * @summary List storage/vault.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultCredentialList(projectId: string, locationId: string, vaultId: string, options?: any): AxiosPromise<Array<VaultCredential>> {
            return localVarFp.storageProjectVaultCredentialList(projectId, locationId, vaultId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update storage/vault.credential
         * @summary Update storage/vault.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {string} credentialId credentialId
         * @param {StorageProjectVaultCredentialPatch} storageProjectVaultCredentialPatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultCredentialPatch(projectId: string, locationId: string, vaultId: string, credentialId: string, storageProjectVaultCredentialPatch: StorageProjectVaultCredentialPatch, options?: any): AxiosPromise<VaultCredential> {
            return localVarFp.storageProjectVaultCredentialPatch(projectId, locationId, vaultId, credentialId, storageProjectVaultCredentialPatch, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete vault
         * @summary Delete storage/vault
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {StorageProjectVaultDelete} storageProjectVaultDelete 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultDelete(projectId: string, locationId: string, vaultId: string, storageProjectVaultDelete: StorageProjectVaultDelete, options?: any): AxiosPromise<void> {
            return localVarFp.storageProjectVaultDelete(projectId, locationId, vaultId, storageProjectVaultDelete, options).then((request) => request(axios, basePath));
        },
        /**
         * Get storage/vault.event
         * @summary Get storage/vault.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultEventGet(projectId: string, locationId: string, vaultId: string, eventId: string, options?: any): AxiosPromise<Event> {
            return localVarFp.storageProjectVaultEventGet(projectId, locationId, vaultId, eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * List storage/vault.event
         * @summary List storage/vault.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultEventList(projectId: string, locationId: string, vaultId: string, $limit?: number, $skip?: number, options?: any): AxiosPromise<Array<Event>> {
            return localVarFp.storageProjectVaultEventList(projectId, locationId, vaultId, $limit, $skip, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single vault
         * @summary Get storage/vault
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultGet(projectId: string, locationId: string, vaultId: string, options?: any): AxiosPromise<Vault> {
            return localVarFp.storageProjectVaultGet(projectId, locationId, vaultId, options).then((request) => request(axios, basePath));
        },
        /**
         * List vault
         * @summary List storage/vault
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [name] Filter by name
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultList(projectId: string, locationId: string, name?: string, tagValue?: string, tagKey?: string, options?: any): AxiosPromise<Array<Vault>> {
            return localVarFp.storageProjectVaultList(projectId, locationId, name, tagValue, tagKey, options).then((request) => request(axios, basePath));
        },
        /**
         * action resize
         * @summary Resize storage/vault
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {StorageProjectVaultResize} storageProjectVaultResize 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultResize(projectId: string, locationId: string, vaultId: string, storageProjectVaultResize: StorageProjectVaultResize, xIdempotencyKey?: string, xDryRun?: string, options?: any): AxiosPromise<Vault> {
            return localVarFp.storageProjectVaultResize(projectId, locationId, vaultId, storageProjectVaultResize, xIdempotencyKey, xDryRun, options).then((request) => request(axios, basePath));
        },
        /**
         * Get storage/vault.service
         * @summary Get storage/vault.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultServiceGet(projectId: string, locationId: string, vaultId: string, serviceId: string, options?: any): AxiosPromise<ResourceService> {
            return localVarFp.storageProjectVaultServiceGet(projectId, locationId, vaultId, serviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * List storage/vault.service
         * @summary List storage/vault.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultServiceList(projectId: string, locationId: string, vaultId: string, options?: any): AxiosPromise<Array<ResourceService>> {
            return localVarFp.storageProjectVaultServiceList(projectId, locationId, vaultId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create storage/vault.snapshot
         * @summary Create storage/vault.snapshot
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {StorageProjectVaultSnapshotCreate} storageProjectVaultSnapshotCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultSnapshotCreate(projectId: string, locationId: string, vaultId: string, storageProjectVaultSnapshotCreate: StorageProjectVaultSnapshotCreate, options?: any): AxiosPromise<StorageSnapshot> {
            return localVarFp.storageProjectVaultSnapshotCreate(projectId, locationId, vaultId, storageProjectVaultSnapshotCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete storage/vault.snapshot
         * @summary Delete storage/vault.snapshot
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {string} snapshotId snapshotId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultSnapshotDelete(projectId: string, locationId: string, vaultId: string, snapshotId: string, options?: any): AxiosPromise<StorageSnapshot> {
            return localVarFp.storageProjectVaultSnapshotDelete(projectId, locationId, vaultId, snapshotId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get storage/vault.snapshot
         * @summary Get storage/vault.snapshot
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {string} snapshotId snapshotId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultSnapshotGet(projectId: string, locationId: string, vaultId: string, snapshotId: string, options?: any): AxiosPromise<StorageSnapshot> {
            return localVarFp.storageProjectVaultSnapshotGet(projectId, locationId, vaultId, snapshotId, options).then((request) => request(axios, basePath));
        },
        /**
         * List storage/vault.snapshot
         * @summary List storage/vault.snapshot
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultSnapshotList(projectId: string, locationId: string, vaultId: string, options?: any): AxiosPromise<Array<StorageSnapshot>> {
            return localVarFp.storageProjectVaultSnapshotList(projectId, locationId, vaultId, options).then((request) => request(axios, basePath));
        },
        /**
         * action start
         * @summary Start storage/vault
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultStart(projectId: string, locationId: string, vaultId: string, xIdempotencyKey?: string, xDryRun?: string, options?: any): AxiosPromise<Vault> {
            return localVarFp.storageProjectVaultStart(projectId, locationId, vaultId, xIdempotencyKey, xDryRun, options).then((request) => request(axios, basePath));
        },
        /**
         * action stop
         * @summary Stop storage/vault
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultStop(projectId: string, locationId: string, vaultId: string, xIdempotencyKey?: string, xDryRun?: string, options?: any): AxiosPromise<Vault> {
            return localVarFp.storageProjectVaultStop(projectId, locationId, vaultId, xIdempotencyKey, xDryRun, options).then((request) => request(axios, basePath));
        },
        /**
         * Create storage/vault.tag
         * @summary Create storage/vault.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultTagCreate(projectId: string, locationId: string, vaultId: string, tag: Tag, options?: any): AxiosPromise<Tag> {
            return localVarFp.storageProjectVaultTagCreate(projectId, locationId, vaultId, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete storage/vault.tag
         * @summary Delete storage/vault.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultTagDelete(projectId: string, locationId: string, vaultId: string, tagId: string, options?: any): AxiosPromise<void> {
            return localVarFp.storageProjectVaultTagDelete(projectId, locationId, vaultId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get storage/vault.tag
         * @summary Get storage/vault.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultTagGet(projectId: string, locationId: string, vaultId: string, tagId: string, options?: any): AxiosPromise<Tag> {
            return localVarFp.storageProjectVaultTagGet(projectId, locationId, vaultId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * List storage/vault.tag
         * @summary List storage/vault.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultTagList(projectId: string, locationId: string, vaultId: string, options?: any): AxiosPromise<Array<Tag>> {
            return localVarFp.storageProjectVaultTagList(projectId, locationId, vaultId, options).then((request) => request(axios, basePath));
        },
        /**
         * Replace storage/vault.tag
         * @summary Replace storage/vault.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultTagPut(projectId: string, locationId: string, vaultId: string, tag: Array<Tag>, options?: any): AxiosPromise<Array<Tag>> {
            return localVarFp.storageProjectVaultTagPut(projectId, locationId, vaultId, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns modified vault
         * @summary Update storage/vault
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} vaultId Vault Id
         * @param {StorageProjectVaultUpdate} storageProjectVaultUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storageProjectVaultUpdate(projectId: string, locationId: string, vaultId: string, storageProjectVaultUpdate: StorageProjectVaultUpdate, options?: any): AxiosPromise<Vault> {
            return localVarFp.storageProjectVaultUpdate(projectId, locationId, vaultId, storageProjectVaultUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StorageProjectVaultApi - object-oriented interface
 * @export
 * @class StorageProjectVaultApi
 * @extends {BaseAPI}
 */
export class StorageProjectVaultApi extends BaseAPI {
    /**
     * Get storage/vault.connect
     * @summary Get storage/vault.connect
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} vaultId Vault Id
     * @param {string} connectId connectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectVaultApi
     */
    public storageProjectVaultConnectGet(projectId: string, locationId: string, vaultId: string, connectId: string, options?: any) {
        return StorageProjectVaultApiFp(this.configuration).storageProjectVaultConnectGet(projectId, locationId, vaultId, connectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List storage/vault.connect
     * @summary List storage/vault.connect
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} vaultId Vault Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectVaultApi
     */
    public storageProjectVaultConnectList(projectId: string, locationId: string, vaultId: string, options?: any) {
        return StorageProjectVaultApiFp(this.configuration).storageProjectVaultConnectList(projectId, locationId, vaultId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create vault
     * @summary Create storage/vault
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {StorageProjectVaultCreate} storageProjectVaultCreate 
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {string} [xDryRun] Dry run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectVaultApi
     */
    public storageProjectVaultCreate(projectId: string, locationId: string, storageProjectVaultCreate: StorageProjectVaultCreate, xIdempotencyKey?: string, xDryRun?: string, options?: any) {
        return StorageProjectVaultApiFp(this.configuration).storageProjectVaultCreate(projectId, locationId, storageProjectVaultCreate, xIdempotencyKey, xDryRun, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create storage/vault.credential
     * @summary Create storage/vault.credential
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} vaultId Vault Id
     * @param {VaultCredential} vaultCredential 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectVaultApi
     */
    public storageProjectVaultCredentialCreate(projectId: string, locationId: string, vaultId: string, vaultCredential: VaultCredential, options?: any) {
        return StorageProjectVaultApiFp(this.configuration).storageProjectVaultCredentialCreate(projectId, locationId, vaultId, vaultCredential, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete storage/vault.credential
     * @summary Delete storage/vault.credential
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} vaultId Vault Id
     * @param {string} credentialId credentialId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectVaultApi
     */
    public storageProjectVaultCredentialDelete(projectId: string, locationId: string, vaultId: string, credentialId: string, options?: any) {
        return StorageProjectVaultApiFp(this.configuration).storageProjectVaultCredentialDelete(projectId, locationId, vaultId, credentialId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get storage/vault.credential
     * @summary Get storage/vault.credential
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} vaultId Vault Id
     * @param {string} credentialId credentialId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectVaultApi
     */
    public storageProjectVaultCredentialGet(projectId: string, locationId: string, vaultId: string, credentialId: string, options?: any) {
        return StorageProjectVaultApiFp(this.configuration).storageProjectVaultCredentialGet(projectId, locationId, vaultId, credentialId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List storage/vault.credential
     * @summary List storage/vault.credential
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} vaultId Vault Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectVaultApi
     */
    public storageProjectVaultCredentialList(projectId: string, locationId: string, vaultId: string, options?: any) {
        return StorageProjectVaultApiFp(this.configuration).storageProjectVaultCredentialList(projectId, locationId, vaultId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update storage/vault.credential
     * @summary Update storage/vault.credential
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} vaultId Vault Id
     * @param {string} credentialId credentialId
     * @param {StorageProjectVaultCredentialPatch} storageProjectVaultCredentialPatch 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectVaultApi
     */
    public storageProjectVaultCredentialPatch(projectId: string, locationId: string, vaultId: string, credentialId: string, storageProjectVaultCredentialPatch: StorageProjectVaultCredentialPatch, options?: any) {
        return StorageProjectVaultApiFp(this.configuration).storageProjectVaultCredentialPatch(projectId, locationId, vaultId, credentialId, storageProjectVaultCredentialPatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete vault
     * @summary Delete storage/vault
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} vaultId Vault Id
     * @param {StorageProjectVaultDelete} storageProjectVaultDelete 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectVaultApi
     */
    public storageProjectVaultDelete(projectId: string, locationId: string, vaultId: string, storageProjectVaultDelete: StorageProjectVaultDelete, options?: any) {
        return StorageProjectVaultApiFp(this.configuration).storageProjectVaultDelete(projectId, locationId, vaultId, storageProjectVaultDelete, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get storage/vault.event
     * @summary Get storage/vault.event
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} vaultId Vault Id
     * @param {string} eventId eventId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectVaultApi
     */
    public storageProjectVaultEventGet(projectId: string, locationId: string, vaultId: string, eventId: string, options?: any) {
        return StorageProjectVaultApiFp(this.configuration).storageProjectVaultEventGet(projectId, locationId, vaultId, eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List storage/vault.event
     * @summary List storage/vault.event
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} vaultId Vault Id
     * @param {number} [$limit] $limit
     * @param {number} [$skip] $skip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectVaultApi
     */
    public storageProjectVaultEventList(projectId: string, locationId: string, vaultId: string, $limit?: number, $skip?: number, options?: any) {
        return StorageProjectVaultApiFp(this.configuration).storageProjectVaultEventList(projectId, locationId, vaultId, $limit, $skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single vault
     * @summary Get storage/vault
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} vaultId Vault Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectVaultApi
     */
    public storageProjectVaultGet(projectId: string, locationId: string, vaultId: string, options?: any) {
        return StorageProjectVaultApiFp(this.configuration).storageProjectVaultGet(projectId, locationId, vaultId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List vault
     * @summary List storage/vault
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} [name] Filter by name
     * @param {string} [tagValue] Filter by tag.value
     * @param {string} [tagKey] Filter by tag.key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectVaultApi
     */
    public storageProjectVaultList(projectId: string, locationId: string, name?: string, tagValue?: string, tagKey?: string, options?: any) {
        return StorageProjectVaultApiFp(this.configuration).storageProjectVaultList(projectId, locationId, name, tagValue, tagKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * action resize
     * @summary Resize storage/vault
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} vaultId Vault Id
     * @param {StorageProjectVaultResize} storageProjectVaultResize 
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {string} [xDryRun] Dry run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectVaultApi
     */
    public storageProjectVaultResize(projectId: string, locationId: string, vaultId: string, storageProjectVaultResize: StorageProjectVaultResize, xIdempotencyKey?: string, xDryRun?: string, options?: any) {
        return StorageProjectVaultApiFp(this.configuration).storageProjectVaultResize(projectId, locationId, vaultId, storageProjectVaultResize, xIdempotencyKey, xDryRun, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get storage/vault.service
     * @summary Get storage/vault.service
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} vaultId Vault Id
     * @param {string} serviceId serviceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectVaultApi
     */
    public storageProjectVaultServiceGet(projectId: string, locationId: string, vaultId: string, serviceId: string, options?: any) {
        return StorageProjectVaultApiFp(this.configuration).storageProjectVaultServiceGet(projectId, locationId, vaultId, serviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List storage/vault.service
     * @summary List storage/vault.service
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} vaultId Vault Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectVaultApi
     */
    public storageProjectVaultServiceList(projectId: string, locationId: string, vaultId: string, options?: any) {
        return StorageProjectVaultApiFp(this.configuration).storageProjectVaultServiceList(projectId, locationId, vaultId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create storage/vault.snapshot
     * @summary Create storage/vault.snapshot
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} vaultId Vault Id
     * @param {StorageProjectVaultSnapshotCreate} storageProjectVaultSnapshotCreate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectVaultApi
     */
    public storageProjectVaultSnapshotCreate(projectId: string, locationId: string, vaultId: string, storageProjectVaultSnapshotCreate: StorageProjectVaultSnapshotCreate, options?: any) {
        return StorageProjectVaultApiFp(this.configuration).storageProjectVaultSnapshotCreate(projectId, locationId, vaultId, storageProjectVaultSnapshotCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete storage/vault.snapshot
     * @summary Delete storage/vault.snapshot
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} vaultId Vault Id
     * @param {string} snapshotId snapshotId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectVaultApi
     */
    public storageProjectVaultSnapshotDelete(projectId: string, locationId: string, vaultId: string, snapshotId: string, options?: any) {
        return StorageProjectVaultApiFp(this.configuration).storageProjectVaultSnapshotDelete(projectId, locationId, vaultId, snapshotId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get storage/vault.snapshot
     * @summary Get storage/vault.snapshot
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} vaultId Vault Id
     * @param {string} snapshotId snapshotId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectVaultApi
     */
    public storageProjectVaultSnapshotGet(projectId: string, locationId: string, vaultId: string, snapshotId: string, options?: any) {
        return StorageProjectVaultApiFp(this.configuration).storageProjectVaultSnapshotGet(projectId, locationId, vaultId, snapshotId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List storage/vault.snapshot
     * @summary List storage/vault.snapshot
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} vaultId Vault Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectVaultApi
     */
    public storageProjectVaultSnapshotList(projectId: string, locationId: string, vaultId: string, options?: any) {
        return StorageProjectVaultApiFp(this.configuration).storageProjectVaultSnapshotList(projectId, locationId, vaultId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * action start
     * @summary Start storage/vault
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} vaultId Vault Id
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {string} [xDryRun] Dry run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectVaultApi
     */
    public storageProjectVaultStart(projectId: string, locationId: string, vaultId: string, xIdempotencyKey?: string, xDryRun?: string, options?: any) {
        return StorageProjectVaultApiFp(this.configuration).storageProjectVaultStart(projectId, locationId, vaultId, xIdempotencyKey, xDryRun, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * action stop
     * @summary Stop storage/vault
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} vaultId Vault Id
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {string} [xDryRun] Dry run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectVaultApi
     */
    public storageProjectVaultStop(projectId: string, locationId: string, vaultId: string, xIdempotencyKey?: string, xDryRun?: string, options?: any) {
        return StorageProjectVaultApiFp(this.configuration).storageProjectVaultStop(projectId, locationId, vaultId, xIdempotencyKey, xDryRun, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create storage/vault.tag
     * @summary Create storage/vault.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} vaultId Vault Id
     * @param {Tag} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectVaultApi
     */
    public storageProjectVaultTagCreate(projectId: string, locationId: string, vaultId: string, tag: Tag, options?: any) {
        return StorageProjectVaultApiFp(this.configuration).storageProjectVaultTagCreate(projectId, locationId, vaultId, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete storage/vault.tag
     * @summary Delete storage/vault.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} vaultId Vault Id
     * @param {string} tagId tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectVaultApi
     */
    public storageProjectVaultTagDelete(projectId: string, locationId: string, vaultId: string, tagId: string, options?: any) {
        return StorageProjectVaultApiFp(this.configuration).storageProjectVaultTagDelete(projectId, locationId, vaultId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get storage/vault.tag
     * @summary Get storage/vault.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} vaultId Vault Id
     * @param {string} tagId tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectVaultApi
     */
    public storageProjectVaultTagGet(projectId: string, locationId: string, vaultId: string, tagId: string, options?: any) {
        return StorageProjectVaultApiFp(this.configuration).storageProjectVaultTagGet(projectId, locationId, vaultId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List storage/vault.tag
     * @summary List storage/vault.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} vaultId Vault Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectVaultApi
     */
    public storageProjectVaultTagList(projectId: string, locationId: string, vaultId: string, options?: any) {
        return StorageProjectVaultApiFp(this.configuration).storageProjectVaultTagList(projectId, locationId, vaultId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replace storage/vault.tag
     * @summary Replace storage/vault.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} vaultId Vault Id
     * @param {Array<Tag>} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectVaultApi
     */
    public storageProjectVaultTagPut(projectId: string, locationId: string, vaultId: string, tag: Array<Tag>, options?: any) {
        return StorageProjectVaultApiFp(this.configuration).storageProjectVaultTagPut(projectId, locationId, vaultId, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns modified vault
     * @summary Update storage/vault
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} vaultId Vault Id
     * @param {StorageProjectVaultUpdate} storageProjectVaultUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StorageProjectVaultApi
     */
    public storageProjectVaultUpdate(projectId: string, locationId: string, vaultId: string, storageProjectVaultUpdate: StorageProjectVaultUpdate, options?: any) {
        return StorageProjectVaultApiFp(this.configuration).storageProjectVaultUpdate(projectId, locationId, vaultId, storageProjectVaultUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SupportProjectTicketApi - axios parameter creator
 * @export
 */
export const SupportProjectTicketApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * action close
         * @summary Close support/ticket
         * @param {string} projectId Project Id
         * @param {string} ticketId Ticket Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supportProjectTicketClose: async (projectId: string, ticketId: string, xIdempotencyKey?: string, xDryRun?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('supportProjectTicketClose', 'projectId', projectId)
            // verify required parameter 'ticketId' is not null or undefined
            assertParamExists('supportProjectTicketClose', 'ticketId', ticketId)
            const localVarPath = `/support/project/{projectId}/ticket/{ticketId}/actions/close`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"ticketId"}}`, encodeURIComponent(String(ticketId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }

            if (xDryRun !== undefined && xDryRun !== null) {
                localVarHeaderParameter['x-dry-run'] = String(xDryRun);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create ticket
         * @summary Create support/ticket
         * @param {string} projectId Project Id
         * @param {SupportProjectTicketCreate} supportProjectTicketCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supportProjectTicketCreate: async (projectId: string, supportProjectTicketCreate: SupportProjectTicketCreate, xIdempotencyKey?: string, xDryRun?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('supportProjectTicketCreate', 'projectId', projectId)
            // verify required parameter 'supportProjectTicketCreate' is not null or undefined
            assertParamExists('supportProjectTicketCreate', 'supportProjectTicketCreate', supportProjectTicketCreate)
            const localVarPath = `/support/project/{projectId}/ticket`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }

            if (xDryRun !== undefined && xDryRun !== null) {
                localVarHeaderParameter['x-dry-run'] = String(xDryRun);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(supportProjectTicketCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single ticket
         * @summary Get support/ticket
         * @param {string} projectId Project Id
         * @param {string} ticketId Ticket Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supportProjectTicketGet: async (projectId: string, ticketId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('supportProjectTicketGet', 'projectId', projectId)
            // verify required parameter 'ticketId' is not null or undefined
            assertParamExists('supportProjectTicketGet', 'ticketId', ticketId)
            const localVarPath = `/support/project/{projectId}/ticket/{ticketId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"ticketId"}}`, encodeURIComponent(String(ticketId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List ticket
         * @summary List support/ticket
         * @param {string} projectId Project Id
         * @param {string} [state] Filter by state
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supportProjectTicketList: async (projectId: string, state?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('supportProjectTicketList', 'projectId', projectId)
            const localVarPath = `/support/project/{projectId}/ticket`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create support/ticket.message
         * @summary Create support/ticket.message
         * @param {string} projectId Project Id
         * @param {string} ticketId Ticket Id
         * @param {SupportMessage} supportMessage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supportProjectTicketMessageCreate: async (projectId: string, ticketId: string, supportMessage: SupportMessage, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('supportProjectTicketMessageCreate', 'projectId', projectId)
            // verify required parameter 'ticketId' is not null or undefined
            assertParamExists('supportProjectTicketMessageCreate', 'ticketId', ticketId)
            // verify required parameter 'supportMessage' is not null or undefined
            assertParamExists('supportProjectTicketMessageCreate', 'supportMessage', supportMessage)
            const localVarPath = `/support/project/{projectId}/ticket/{ticketId}/message`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"ticketId"}}`, encodeURIComponent(String(ticketId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(supportMessage, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get support/ticket.message
         * @summary Get support/ticket.message
         * @param {string} projectId Project Id
         * @param {string} ticketId Ticket Id
         * @param {string} messageId messageId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supportProjectTicketMessageGet: async (projectId: string, ticketId: string, messageId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('supportProjectTicketMessageGet', 'projectId', projectId)
            // verify required parameter 'ticketId' is not null or undefined
            assertParamExists('supportProjectTicketMessageGet', 'ticketId', ticketId)
            // verify required parameter 'messageId' is not null or undefined
            assertParamExists('supportProjectTicketMessageGet', 'messageId', messageId)
            const localVarPath = `/support/project/{projectId}/ticket/{ticketId}/message/{messageId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"ticketId"}}`, encodeURIComponent(String(ticketId)))
                .replace(`{${"messageId"}}`, encodeURIComponent(String(messageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List support/ticket.message
         * @summary List support/ticket.message
         * @param {string} projectId Project Id
         * @param {string} ticketId Ticket Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supportProjectTicketMessageList: async (projectId: string, ticketId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('supportProjectTicketMessageList', 'projectId', projectId)
            // verify required parameter 'ticketId' is not null or undefined
            assertParamExists('supportProjectTicketMessageList', 'ticketId', ticketId)
            const localVarPath = `/support/project/{projectId}/ticket/{ticketId}/message`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"ticketId"}}`, encodeURIComponent(String(ticketId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SupportProjectTicketApi - functional programming interface
 * @export
 */
export const SupportProjectTicketApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SupportProjectTicketApiAxiosParamCreator(configuration)
    return {
        /**
         * action close
         * @summary Close support/ticket
         * @param {string} projectId Project Id
         * @param {string} ticketId Ticket Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async supportProjectTicketClose(projectId: string, ticketId: string, xIdempotencyKey?: string, xDryRun?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Ticket>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.supportProjectTicketClose(projectId, ticketId, xIdempotencyKey, xDryRun, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create ticket
         * @summary Create support/ticket
         * @param {string} projectId Project Id
         * @param {SupportProjectTicketCreate} supportProjectTicketCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async supportProjectTicketCreate(projectId: string, supportProjectTicketCreate: SupportProjectTicketCreate, xIdempotencyKey?: string, xDryRun?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Ticket>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.supportProjectTicketCreate(projectId, supportProjectTicketCreate, xIdempotencyKey, xDryRun, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a single ticket
         * @summary Get support/ticket
         * @param {string} projectId Project Id
         * @param {string} ticketId Ticket Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async supportProjectTicketGet(projectId: string, ticketId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Ticket>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.supportProjectTicketGet(projectId, ticketId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List ticket
         * @summary List support/ticket
         * @param {string} projectId Project Id
         * @param {string} [state] Filter by state
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async supportProjectTicketList(projectId: string, state?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Ticket>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.supportProjectTicketList(projectId, state, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create support/ticket.message
         * @summary Create support/ticket.message
         * @param {string} projectId Project Id
         * @param {string} ticketId Ticket Id
         * @param {SupportMessage} supportMessage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async supportProjectTicketMessageCreate(projectId: string, ticketId: string, supportMessage: SupportMessage, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupportMessage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.supportProjectTicketMessageCreate(projectId, ticketId, supportMessage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get support/ticket.message
         * @summary Get support/ticket.message
         * @param {string} projectId Project Id
         * @param {string} ticketId Ticket Id
         * @param {string} messageId messageId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async supportProjectTicketMessageGet(projectId: string, ticketId: string, messageId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SupportMessage>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.supportProjectTicketMessageGet(projectId, ticketId, messageId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List support/ticket.message
         * @summary List support/ticket.message
         * @param {string} projectId Project Id
         * @param {string} ticketId Ticket Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async supportProjectTicketMessageList(projectId: string, ticketId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SupportMessage>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.supportProjectTicketMessageList(projectId, ticketId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SupportProjectTicketApi - factory interface
 * @export
 */
export const SupportProjectTicketApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SupportProjectTicketApiFp(configuration)
    return {
        /**
         * action close
         * @summary Close support/ticket
         * @param {string} projectId Project Id
         * @param {string} ticketId Ticket Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supportProjectTicketClose(projectId: string, ticketId: string, xIdempotencyKey?: string, xDryRun?: string, options?: any): AxiosPromise<Ticket> {
            return localVarFp.supportProjectTicketClose(projectId, ticketId, xIdempotencyKey, xDryRun, options).then((request) => request(axios, basePath));
        },
        /**
         * Create ticket
         * @summary Create support/ticket
         * @param {string} projectId Project Id
         * @param {SupportProjectTicketCreate} supportProjectTicketCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supportProjectTicketCreate(projectId: string, supportProjectTicketCreate: SupportProjectTicketCreate, xIdempotencyKey?: string, xDryRun?: string, options?: any): AxiosPromise<Ticket> {
            return localVarFp.supportProjectTicketCreate(projectId, supportProjectTicketCreate, xIdempotencyKey, xDryRun, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single ticket
         * @summary Get support/ticket
         * @param {string} projectId Project Id
         * @param {string} ticketId Ticket Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supportProjectTicketGet(projectId: string, ticketId: string, options?: any): AxiosPromise<Ticket> {
            return localVarFp.supportProjectTicketGet(projectId, ticketId, options).then((request) => request(axios, basePath));
        },
        /**
         * List ticket
         * @summary List support/ticket
         * @param {string} projectId Project Id
         * @param {string} [state] Filter by state
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supportProjectTicketList(projectId: string, state?: string, options?: any): AxiosPromise<Array<Ticket>> {
            return localVarFp.supportProjectTicketList(projectId, state, options).then((request) => request(axios, basePath));
        },
        /**
         * Create support/ticket.message
         * @summary Create support/ticket.message
         * @param {string} projectId Project Id
         * @param {string} ticketId Ticket Id
         * @param {SupportMessage} supportMessage 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supportProjectTicketMessageCreate(projectId: string, ticketId: string, supportMessage: SupportMessage, options?: any): AxiosPromise<SupportMessage> {
            return localVarFp.supportProjectTicketMessageCreate(projectId, ticketId, supportMessage, options).then((request) => request(axios, basePath));
        },
        /**
         * Get support/ticket.message
         * @summary Get support/ticket.message
         * @param {string} projectId Project Id
         * @param {string} ticketId Ticket Id
         * @param {string} messageId messageId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supportProjectTicketMessageGet(projectId: string, ticketId: string, messageId: string, options?: any): AxiosPromise<SupportMessage> {
            return localVarFp.supportProjectTicketMessageGet(projectId, ticketId, messageId, options).then((request) => request(axios, basePath));
        },
        /**
         * List support/ticket.message
         * @summary List support/ticket.message
         * @param {string} projectId Project Id
         * @param {string} ticketId Ticket Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        supportProjectTicketMessageList(projectId: string, ticketId: string, options?: any): AxiosPromise<Array<SupportMessage>> {
            return localVarFp.supportProjectTicketMessageList(projectId, ticketId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SupportProjectTicketApi - object-oriented interface
 * @export
 * @class SupportProjectTicketApi
 * @extends {BaseAPI}
 */
export class SupportProjectTicketApi extends BaseAPI {
    /**
     * action close
     * @summary Close support/ticket
     * @param {string} projectId Project Id
     * @param {string} ticketId Ticket Id
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {string} [xDryRun] Dry run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SupportProjectTicketApi
     */
    public supportProjectTicketClose(projectId: string, ticketId: string, xIdempotencyKey?: string, xDryRun?: string, options?: any) {
        return SupportProjectTicketApiFp(this.configuration).supportProjectTicketClose(projectId, ticketId, xIdempotencyKey, xDryRun, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create ticket
     * @summary Create support/ticket
     * @param {string} projectId Project Id
     * @param {SupportProjectTicketCreate} supportProjectTicketCreate 
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {string} [xDryRun] Dry run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SupportProjectTicketApi
     */
    public supportProjectTicketCreate(projectId: string, supportProjectTicketCreate: SupportProjectTicketCreate, xIdempotencyKey?: string, xDryRun?: string, options?: any) {
        return SupportProjectTicketApiFp(this.configuration).supportProjectTicketCreate(projectId, supportProjectTicketCreate, xIdempotencyKey, xDryRun, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single ticket
     * @summary Get support/ticket
     * @param {string} projectId Project Id
     * @param {string} ticketId Ticket Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SupportProjectTicketApi
     */
    public supportProjectTicketGet(projectId: string, ticketId: string, options?: any) {
        return SupportProjectTicketApiFp(this.configuration).supportProjectTicketGet(projectId, ticketId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List ticket
     * @summary List support/ticket
     * @param {string} projectId Project Id
     * @param {string} [state] Filter by state
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SupportProjectTicketApi
     */
    public supportProjectTicketList(projectId: string, state?: string, options?: any) {
        return SupportProjectTicketApiFp(this.configuration).supportProjectTicketList(projectId, state, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create support/ticket.message
     * @summary Create support/ticket.message
     * @param {string} projectId Project Id
     * @param {string} ticketId Ticket Id
     * @param {SupportMessage} supportMessage 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SupportProjectTicketApi
     */
    public supportProjectTicketMessageCreate(projectId: string, ticketId: string, supportMessage: SupportMessage, options?: any) {
        return SupportProjectTicketApiFp(this.configuration).supportProjectTicketMessageCreate(projectId, ticketId, supportMessage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get support/ticket.message
     * @summary Get support/ticket.message
     * @param {string} projectId Project Id
     * @param {string} ticketId Ticket Id
     * @param {string} messageId messageId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SupportProjectTicketApi
     */
    public supportProjectTicketMessageGet(projectId: string, ticketId: string, messageId: string, options?: any) {
        return SupportProjectTicketApiFp(this.configuration).supportProjectTicketMessageGet(projectId, ticketId, messageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List support/ticket.message
     * @summary List support/ticket.message
     * @param {string} projectId Project Id
     * @param {string} ticketId Ticket Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SupportProjectTicketApi
     */
    public supportProjectTicketMessageList(projectId: string, ticketId: string, options?: any) {
        return SupportProjectTicketApiFp(this.configuration).supportProjectTicketMessageList(projectId, ticketId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * VmhostProjectInstanceApi - axios parameter creator
 * @export
 */
export const VmhostProjectInstanceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get vmhost/instance.event
         * @summary Get vmhost/instance.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vmhostProjectInstanceEventGet: async (projectId: string, locationId: string, instanceId: string, eventId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('vmhostProjectInstanceEventGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('vmhostProjectInstanceEventGet', 'locationId', locationId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('vmhostProjectInstanceEventGet', 'instanceId', instanceId)
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('vmhostProjectInstanceEventGet', 'eventId', eventId)
            const localVarPath = `/vmhost/{locationId}/project/{projectId}/instance/{instanceId}/event/{eventId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List vmhost/instance.event
         * @summary List vmhost/instance.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vmhostProjectInstanceEventList: async (projectId: string, locationId: string, instanceId: string, $limit?: number, $skip?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('vmhostProjectInstanceEventList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('vmhostProjectInstanceEventList', 'locationId', locationId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('vmhostProjectInstanceEventList', 'instanceId', instanceId)
            const localVarPath = `/vmhost/{locationId}/project/{projectId}/instance/{instanceId}/event`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if ($limit !== undefined) {
                localVarQueryParameter['$limit'] = $limit;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single instance
         * @summary Get vmhost/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vmhostProjectInstanceGet: async (projectId: string, locationId: string, instanceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('vmhostProjectInstanceGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('vmhostProjectInstanceGet', 'locationId', locationId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('vmhostProjectInstanceGet', 'instanceId', instanceId)
            const localVarPath = `/vmhost/{locationId}/project/{projectId}/instance/{instanceId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List instance
         * @summary List vmhost/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [enabledServices] Filter by enabledServices
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vmhostProjectInstanceList: async (projectId: string, locationId: string, enabledServices?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('vmhostProjectInstanceList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('vmhostProjectInstanceList', 'locationId', locationId)
            const localVarPath = `/vmhost/{locationId}/project/{projectId}/instance`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (enabledServices !== undefined) {
                localVarQueryParameter['enabledServices'] = enabledServices;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get vmhost/instance.service
         * @summary Get vmhost/instance.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vmhostProjectInstanceServiceGet: async (projectId: string, locationId: string, instanceId: string, serviceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('vmhostProjectInstanceServiceGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('vmhostProjectInstanceServiceGet', 'locationId', locationId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('vmhostProjectInstanceServiceGet', 'instanceId', instanceId)
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('vmhostProjectInstanceServiceGet', 'serviceId', serviceId)
            const localVarPath = `/vmhost/{locationId}/project/{projectId}/instance/{instanceId}/service/{serviceId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List vmhost/instance.service
         * @summary List vmhost/instance.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vmhostProjectInstanceServiceList: async (projectId: string, locationId: string, instanceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('vmhostProjectInstanceServiceList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('vmhostProjectInstanceServiceList', 'locationId', locationId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('vmhostProjectInstanceServiceList', 'instanceId', instanceId)
            const localVarPath = `/vmhost/{locationId}/project/{projectId}/instance/{instanceId}/service`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create vmhost/instance.tag
         * @summary Create vmhost/instance.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vmhostProjectInstanceTagCreate: async (projectId: string, locationId: string, instanceId: string, tag: Tag, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('vmhostProjectInstanceTagCreate', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('vmhostProjectInstanceTagCreate', 'locationId', locationId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('vmhostProjectInstanceTagCreate', 'instanceId', instanceId)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('vmhostProjectInstanceTagCreate', 'tag', tag)
            const localVarPath = `/vmhost/{locationId}/project/{projectId}/instance/{instanceId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tag, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete vmhost/instance.tag
         * @summary Delete vmhost/instance.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vmhostProjectInstanceTagDelete: async (projectId: string, locationId: string, instanceId: string, tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('vmhostProjectInstanceTagDelete', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('vmhostProjectInstanceTagDelete', 'locationId', locationId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('vmhostProjectInstanceTagDelete', 'instanceId', instanceId)
            // verify required parameter 'tagId' is not null or undefined
            assertParamExists('vmhostProjectInstanceTagDelete', 'tagId', tagId)
            const localVarPath = `/vmhost/{locationId}/project/{projectId}/instance/{instanceId}/tag/{tagId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get vmhost/instance.tag
         * @summary Get vmhost/instance.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vmhostProjectInstanceTagGet: async (projectId: string, locationId: string, instanceId: string, tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('vmhostProjectInstanceTagGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('vmhostProjectInstanceTagGet', 'locationId', locationId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('vmhostProjectInstanceTagGet', 'instanceId', instanceId)
            // verify required parameter 'tagId' is not null or undefined
            assertParamExists('vmhostProjectInstanceTagGet', 'tagId', tagId)
            const localVarPath = `/vmhost/{locationId}/project/{projectId}/instance/{instanceId}/tag/{tagId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List vmhost/instance.tag
         * @summary List vmhost/instance.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vmhostProjectInstanceTagList: async (projectId: string, locationId: string, instanceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('vmhostProjectInstanceTagList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('vmhostProjectInstanceTagList', 'locationId', locationId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('vmhostProjectInstanceTagList', 'instanceId', instanceId)
            const localVarPath = `/vmhost/{locationId}/project/{projectId}/instance/{instanceId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replace vmhost/instance.tag
         * @summary Replace vmhost/instance.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vmhostProjectInstanceTagPut: async (projectId: string, locationId: string, instanceId: string, tag: Array<Tag>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('vmhostProjectInstanceTagPut', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('vmhostProjectInstanceTagPut', 'locationId', locationId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('vmhostProjectInstanceTagPut', 'instanceId', instanceId)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('vmhostProjectInstanceTagPut', 'tag', tag)
            const localVarPath = `/vmhost/{locationId}/project/{projectId}/instance/{instanceId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tag, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VmhostProjectInstanceApi - functional programming interface
 * @export
 */
export const VmhostProjectInstanceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VmhostProjectInstanceApiAxiosParamCreator(configuration)
    return {
        /**
         * Get vmhost/instance.event
         * @summary Get vmhost/instance.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vmhostProjectInstanceEventGet(projectId: string, locationId: string, instanceId: string, eventId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.vmhostProjectInstanceEventGet(projectId, locationId, instanceId, eventId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List vmhost/instance.event
         * @summary List vmhost/instance.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vmhostProjectInstanceEventList(projectId: string, locationId: string, instanceId: string, $limit?: number, $skip?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Event>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.vmhostProjectInstanceEventList(projectId, locationId, instanceId, $limit, $skip, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a single instance
         * @summary Get vmhost/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vmhostProjectInstanceGet(projectId: string, locationId: string, instanceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Vmhost>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.vmhostProjectInstanceGet(projectId, locationId, instanceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List instance
         * @summary List vmhost/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [enabledServices] Filter by enabledServices
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vmhostProjectInstanceList(projectId: string, locationId: string, enabledServices?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Vmhost>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.vmhostProjectInstanceList(projectId, locationId, enabledServices, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get vmhost/instance.service
         * @summary Get vmhost/instance.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vmhostProjectInstanceServiceGet(projectId: string, locationId: string, instanceId: string, serviceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceService>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.vmhostProjectInstanceServiceGet(projectId, locationId, instanceId, serviceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List vmhost/instance.service
         * @summary List vmhost/instance.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vmhostProjectInstanceServiceList(projectId: string, locationId: string, instanceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResourceService>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.vmhostProjectInstanceServiceList(projectId, locationId, instanceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create vmhost/instance.tag
         * @summary Create vmhost/instance.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vmhostProjectInstanceTagCreate(projectId: string, locationId: string, instanceId: string, tag: Tag, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.vmhostProjectInstanceTagCreate(projectId, locationId, instanceId, tag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete vmhost/instance.tag
         * @summary Delete vmhost/instance.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vmhostProjectInstanceTagDelete(projectId: string, locationId: string, instanceId: string, tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.vmhostProjectInstanceTagDelete(projectId, locationId, instanceId, tagId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get vmhost/instance.tag
         * @summary Get vmhost/instance.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vmhostProjectInstanceTagGet(projectId: string, locationId: string, instanceId: string, tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.vmhostProjectInstanceTagGet(projectId, locationId, instanceId, tagId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List vmhost/instance.tag
         * @summary List vmhost/instance.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vmhostProjectInstanceTagList(projectId: string, locationId: string, instanceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.vmhostProjectInstanceTagList(projectId, locationId, instanceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Replace vmhost/instance.tag
         * @summary Replace vmhost/instance.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async vmhostProjectInstanceTagPut(projectId: string, locationId: string, instanceId: string, tag: Array<Tag>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.vmhostProjectInstanceTagPut(projectId, locationId, instanceId, tag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * VmhostProjectInstanceApi - factory interface
 * @export
 */
export const VmhostProjectInstanceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VmhostProjectInstanceApiFp(configuration)
    return {
        /**
         * Get vmhost/instance.event
         * @summary Get vmhost/instance.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vmhostProjectInstanceEventGet(projectId: string, locationId: string, instanceId: string, eventId: string, options?: any): AxiosPromise<Event> {
            return localVarFp.vmhostProjectInstanceEventGet(projectId, locationId, instanceId, eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * List vmhost/instance.event
         * @summary List vmhost/instance.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vmhostProjectInstanceEventList(projectId: string, locationId: string, instanceId: string, $limit?: number, $skip?: number, options?: any): AxiosPromise<Array<Event>> {
            return localVarFp.vmhostProjectInstanceEventList(projectId, locationId, instanceId, $limit, $skip, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single instance
         * @summary Get vmhost/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vmhostProjectInstanceGet(projectId: string, locationId: string, instanceId: string, options?: any): AxiosPromise<Vmhost> {
            return localVarFp.vmhostProjectInstanceGet(projectId, locationId, instanceId, options).then((request) => request(axios, basePath));
        },
        /**
         * List instance
         * @summary List vmhost/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [enabledServices] Filter by enabledServices
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vmhostProjectInstanceList(projectId: string, locationId: string, enabledServices?: string, options?: any): AxiosPromise<Array<Vmhost>> {
            return localVarFp.vmhostProjectInstanceList(projectId, locationId, enabledServices, options).then((request) => request(axios, basePath));
        },
        /**
         * Get vmhost/instance.service
         * @summary Get vmhost/instance.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vmhostProjectInstanceServiceGet(projectId: string, locationId: string, instanceId: string, serviceId: string, options?: any): AxiosPromise<ResourceService> {
            return localVarFp.vmhostProjectInstanceServiceGet(projectId, locationId, instanceId, serviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * List vmhost/instance.service
         * @summary List vmhost/instance.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vmhostProjectInstanceServiceList(projectId: string, locationId: string, instanceId: string, options?: any): AxiosPromise<Array<ResourceService>> {
            return localVarFp.vmhostProjectInstanceServiceList(projectId, locationId, instanceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create vmhost/instance.tag
         * @summary Create vmhost/instance.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vmhostProjectInstanceTagCreate(projectId: string, locationId: string, instanceId: string, tag: Tag, options?: any): AxiosPromise<Tag> {
            return localVarFp.vmhostProjectInstanceTagCreate(projectId, locationId, instanceId, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete vmhost/instance.tag
         * @summary Delete vmhost/instance.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vmhostProjectInstanceTagDelete(projectId: string, locationId: string, instanceId: string, tagId: string, options?: any): AxiosPromise<void> {
            return localVarFp.vmhostProjectInstanceTagDelete(projectId, locationId, instanceId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get vmhost/instance.tag
         * @summary Get vmhost/instance.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vmhostProjectInstanceTagGet(projectId: string, locationId: string, instanceId: string, tagId: string, options?: any): AxiosPromise<Tag> {
            return localVarFp.vmhostProjectInstanceTagGet(projectId, locationId, instanceId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * List vmhost/instance.tag
         * @summary List vmhost/instance.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vmhostProjectInstanceTagList(projectId: string, locationId: string, instanceId: string, options?: any): AxiosPromise<Array<Tag>> {
            return localVarFp.vmhostProjectInstanceTagList(projectId, locationId, instanceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Replace vmhost/instance.tag
         * @summary Replace vmhost/instance.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        vmhostProjectInstanceTagPut(projectId: string, locationId: string, instanceId: string, tag: Array<Tag>, options?: any): AxiosPromise<Array<Tag>> {
            return localVarFp.vmhostProjectInstanceTagPut(projectId, locationId, instanceId, tag, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VmhostProjectInstanceApi - object-oriented interface
 * @export
 * @class VmhostProjectInstanceApi
 * @extends {BaseAPI}
 */
export class VmhostProjectInstanceApi extends BaseAPI {
    /**
     * Get vmhost/instance.event
     * @summary Get vmhost/instance.event
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {string} eventId eventId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VmhostProjectInstanceApi
     */
    public vmhostProjectInstanceEventGet(projectId: string, locationId: string, instanceId: string, eventId: string, options?: any) {
        return VmhostProjectInstanceApiFp(this.configuration).vmhostProjectInstanceEventGet(projectId, locationId, instanceId, eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List vmhost/instance.event
     * @summary List vmhost/instance.event
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {number} [$limit] $limit
     * @param {number} [$skip] $skip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VmhostProjectInstanceApi
     */
    public vmhostProjectInstanceEventList(projectId: string, locationId: string, instanceId: string, $limit?: number, $skip?: number, options?: any) {
        return VmhostProjectInstanceApiFp(this.configuration).vmhostProjectInstanceEventList(projectId, locationId, instanceId, $limit, $skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single instance
     * @summary Get vmhost/instance
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VmhostProjectInstanceApi
     */
    public vmhostProjectInstanceGet(projectId: string, locationId: string, instanceId: string, options?: any) {
        return VmhostProjectInstanceApiFp(this.configuration).vmhostProjectInstanceGet(projectId, locationId, instanceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List instance
     * @summary List vmhost/instance
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} [enabledServices] Filter by enabledServices
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VmhostProjectInstanceApi
     */
    public vmhostProjectInstanceList(projectId: string, locationId: string, enabledServices?: string, options?: any) {
        return VmhostProjectInstanceApiFp(this.configuration).vmhostProjectInstanceList(projectId, locationId, enabledServices, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get vmhost/instance.service
     * @summary Get vmhost/instance.service
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {string} serviceId serviceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VmhostProjectInstanceApi
     */
    public vmhostProjectInstanceServiceGet(projectId: string, locationId: string, instanceId: string, serviceId: string, options?: any) {
        return VmhostProjectInstanceApiFp(this.configuration).vmhostProjectInstanceServiceGet(projectId, locationId, instanceId, serviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List vmhost/instance.service
     * @summary List vmhost/instance.service
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VmhostProjectInstanceApi
     */
    public vmhostProjectInstanceServiceList(projectId: string, locationId: string, instanceId: string, options?: any) {
        return VmhostProjectInstanceApiFp(this.configuration).vmhostProjectInstanceServiceList(projectId, locationId, instanceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create vmhost/instance.tag
     * @summary Create vmhost/instance.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {Tag} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VmhostProjectInstanceApi
     */
    public vmhostProjectInstanceTagCreate(projectId: string, locationId: string, instanceId: string, tag: Tag, options?: any) {
        return VmhostProjectInstanceApiFp(this.configuration).vmhostProjectInstanceTagCreate(projectId, locationId, instanceId, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete vmhost/instance.tag
     * @summary Delete vmhost/instance.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {string} tagId tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VmhostProjectInstanceApi
     */
    public vmhostProjectInstanceTagDelete(projectId: string, locationId: string, instanceId: string, tagId: string, options?: any) {
        return VmhostProjectInstanceApiFp(this.configuration).vmhostProjectInstanceTagDelete(projectId, locationId, instanceId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get vmhost/instance.tag
     * @summary Get vmhost/instance.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {string} tagId tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VmhostProjectInstanceApi
     */
    public vmhostProjectInstanceTagGet(projectId: string, locationId: string, instanceId: string, tagId: string, options?: any) {
        return VmhostProjectInstanceApiFp(this.configuration).vmhostProjectInstanceTagGet(projectId, locationId, instanceId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List vmhost/instance.tag
     * @summary List vmhost/instance.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VmhostProjectInstanceApi
     */
    public vmhostProjectInstanceTagList(projectId: string, locationId: string, instanceId: string, options?: any) {
        return VmhostProjectInstanceApiFp(this.configuration).vmhostProjectInstanceTagList(projectId, locationId, instanceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replace vmhost/instance.tag
     * @summary Replace vmhost/instance.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {Array<Tag>} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VmhostProjectInstanceApi
     */
    public vmhostProjectInstanceTagPut(projectId: string, locationId: string, instanceId: string, tag: Array<Tag>, options?: any) {
        return VmhostProjectInstanceApiFp(this.configuration).vmhostProjectInstanceTagPut(projectId, locationId, instanceId, tag, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * WebsiteProjectInstanceApi - axios parameter creator
 * @export
 */
export const WebsiteProjectInstanceApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get website/instance.connect
         * @summary Get website/instance.connect
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} connectId connectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceConnectGet: async (projectId: string, locationId: string, instanceId: string, connectId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('websiteProjectInstanceConnectGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('websiteProjectInstanceConnectGet', 'locationId', locationId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('websiteProjectInstanceConnectGet', 'instanceId', instanceId)
            // verify required parameter 'connectId' is not null or undefined
            assertParamExists('websiteProjectInstanceConnectGet', 'connectId', connectId)
            const localVarPath = `/website/{locationId}/project/{projectId}/instance/{instanceId}/connect/{connectId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"connectId"}}`, encodeURIComponent(String(connectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List website/instance.connect
         * @summary List website/instance.connect
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceConnectList: async (projectId: string, locationId: string, instanceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('websiteProjectInstanceConnectList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('websiteProjectInstanceConnectList', 'locationId', locationId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('websiteProjectInstanceConnectList', 'instanceId', instanceId)
            const localVarPath = `/website/{locationId}/project/{projectId}/instance/{instanceId}/connect`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create instance
         * @summary Create website/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {WebsiteProjectInstanceCreate} websiteProjectInstanceCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceCreate: async (projectId: string, locationId: string, websiteProjectInstanceCreate: WebsiteProjectInstanceCreate, xIdempotencyKey?: string, xDryRun?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('websiteProjectInstanceCreate', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('websiteProjectInstanceCreate', 'locationId', locationId)
            // verify required parameter 'websiteProjectInstanceCreate' is not null or undefined
            assertParamExists('websiteProjectInstanceCreate', 'websiteProjectInstanceCreate', websiteProjectInstanceCreate)
            const localVarPath = `/website/{locationId}/project/{projectId}/instance`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }

            if (xDryRun !== undefined && xDryRun !== null) {
                localVarHeaderParameter['x-dry-run'] = String(xDryRun);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(websiteProjectInstanceCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create website/instance.credential
         * @summary Create website/instance.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {WebsiteCredential} websiteCredential 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceCredentialCreate: async (projectId: string, locationId: string, instanceId: string, websiteCredential: WebsiteCredential, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('websiteProjectInstanceCredentialCreate', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('websiteProjectInstanceCredentialCreate', 'locationId', locationId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('websiteProjectInstanceCredentialCreate', 'instanceId', instanceId)
            // verify required parameter 'websiteCredential' is not null or undefined
            assertParamExists('websiteProjectInstanceCredentialCreate', 'websiteCredential', websiteCredential)
            const localVarPath = `/website/{locationId}/project/{projectId}/instance/{instanceId}/credential`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(websiteCredential, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete website/instance.credential
         * @summary Delete website/instance.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} credentialId credentialId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceCredentialDelete: async (projectId: string, locationId: string, instanceId: string, credentialId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('websiteProjectInstanceCredentialDelete', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('websiteProjectInstanceCredentialDelete', 'locationId', locationId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('websiteProjectInstanceCredentialDelete', 'instanceId', instanceId)
            // verify required parameter 'credentialId' is not null or undefined
            assertParamExists('websiteProjectInstanceCredentialDelete', 'credentialId', credentialId)
            const localVarPath = `/website/{locationId}/project/{projectId}/instance/{instanceId}/credential/{credentialId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"credentialId"}}`, encodeURIComponent(String(credentialId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get website/instance.credential
         * @summary Get website/instance.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} credentialId credentialId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceCredentialGet: async (projectId: string, locationId: string, instanceId: string, credentialId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('websiteProjectInstanceCredentialGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('websiteProjectInstanceCredentialGet', 'locationId', locationId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('websiteProjectInstanceCredentialGet', 'instanceId', instanceId)
            // verify required parameter 'credentialId' is not null or undefined
            assertParamExists('websiteProjectInstanceCredentialGet', 'credentialId', credentialId)
            const localVarPath = `/website/{locationId}/project/{projectId}/instance/{instanceId}/credential/{credentialId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"credentialId"}}`, encodeURIComponent(String(credentialId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List website/instance.credential
         * @summary List website/instance.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceCredentialList: async (projectId: string, locationId: string, instanceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('websiteProjectInstanceCredentialList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('websiteProjectInstanceCredentialList', 'locationId', locationId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('websiteProjectInstanceCredentialList', 'instanceId', instanceId)
            const localVarPath = `/website/{locationId}/project/{projectId}/instance/{instanceId}/credential`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update website/instance.credential
         * @summary Update website/instance.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} credentialId credentialId
         * @param {WebsiteProjectInstanceCredentialPatch} websiteProjectInstanceCredentialPatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceCredentialPatch: async (projectId: string, locationId: string, instanceId: string, credentialId: string, websiteProjectInstanceCredentialPatch: WebsiteProjectInstanceCredentialPatch, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('websiteProjectInstanceCredentialPatch', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('websiteProjectInstanceCredentialPatch', 'locationId', locationId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('websiteProjectInstanceCredentialPatch', 'instanceId', instanceId)
            // verify required parameter 'credentialId' is not null or undefined
            assertParamExists('websiteProjectInstanceCredentialPatch', 'credentialId', credentialId)
            // verify required parameter 'websiteProjectInstanceCredentialPatch' is not null or undefined
            assertParamExists('websiteProjectInstanceCredentialPatch', 'websiteProjectInstanceCredentialPatch', websiteProjectInstanceCredentialPatch)
            const localVarPath = `/website/{locationId}/project/{projectId}/instance/{instanceId}/credential/{credentialId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"credentialId"}}`, encodeURIComponent(String(credentialId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(websiteProjectInstanceCredentialPatch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete instance
         * @summary Delete website/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceDelete: async (projectId: string, locationId: string, instanceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('websiteProjectInstanceDelete', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('websiteProjectInstanceDelete', 'locationId', locationId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('websiteProjectInstanceDelete', 'instanceId', instanceId)
            const localVarPath = `/website/{locationId}/project/{projectId}/instance/{instanceId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create website/instance.domain
         * @summary Create website/instance.domain
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {Domain} domain 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceDomainCreate: async (projectId: string, locationId: string, instanceId: string, domain: Domain, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('websiteProjectInstanceDomainCreate', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('websiteProjectInstanceDomainCreate', 'locationId', locationId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('websiteProjectInstanceDomainCreate', 'instanceId', instanceId)
            // verify required parameter 'domain' is not null or undefined
            assertParamExists('websiteProjectInstanceDomainCreate', 'domain', domain)
            const localVarPath = `/website/{locationId}/project/{projectId}/instance/{instanceId}/domain`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(domain, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete website/instance.domain
         * @summary Delete website/instance.domain
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} domainId domainId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceDomainDelete: async (projectId: string, locationId: string, instanceId: string, domainId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('websiteProjectInstanceDomainDelete', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('websiteProjectInstanceDomainDelete', 'locationId', locationId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('websiteProjectInstanceDomainDelete', 'instanceId', instanceId)
            // verify required parameter 'domainId' is not null or undefined
            assertParamExists('websiteProjectInstanceDomainDelete', 'domainId', domainId)
            const localVarPath = `/website/{locationId}/project/{projectId}/instance/{instanceId}/domain/{domainId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"domainId"}}`, encodeURIComponent(String(domainId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get website/instance.domain
         * @summary Get website/instance.domain
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} domainId domainId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceDomainGet: async (projectId: string, locationId: string, instanceId: string, domainId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('websiteProjectInstanceDomainGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('websiteProjectInstanceDomainGet', 'locationId', locationId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('websiteProjectInstanceDomainGet', 'instanceId', instanceId)
            // verify required parameter 'domainId' is not null or undefined
            assertParamExists('websiteProjectInstanceDomainGet', 'domainId', domainId)
            const localVarPath = `/website/{locationId}/project/{projectId}/instance/{instanceId}/domain/{domainId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"domainId"}}`, encodeURIComponent(String(domainId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List website/instance.domain
         * @summary List website/instance.domain
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceDomainList: async (projectId: string, locationId: string, instanceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('websiteProjectInstanceDomainList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('websiteProjectInstanceDomainList', 'locationId', locationId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('websiteProjectInstanceDomainList', 'instanceId', instanceId)
            const localVarPath = `/website/{locationId}/project/{projectId}/instance/{instanceId}/domain`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create website/instance.env
         * @summary Create website/instance.env
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {WebsiteEnv} websiteEnv 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceEnvCreate: async (projectId: string, locationId: string, instanceId: string, websiteEnv: WebsiteEnv, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('websiteProjectInstanceEnvCreate', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('websiteProjectInstanceEnvCreate', 'locationId', locationId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('websiteProjectInstanceEnvCreate', 'instanceId', instanceId)
            // verify required parameter 'websiteEnv' is not null or undefined
            assertParamExists('websiteProjectInstanceEnvCreate', 'websiteEnv', websiteEnv)
            const localVarPath = `/website/{locationId}/project/{projectId}/instance/{instanceId}/env`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(websiteEnv, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete website/instance.env
         * @summary Delete website/instance.env
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} envId envId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceEnvDelete: async (projectId: string, locationId: string, instanceId: string, envId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('websiteProjectInstanceEnvDelete', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('websiteProjectInstanceEnvDelete', 'locationId', locationId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('websiteProjectInstanceEnvDelete', 'instanceId', instanceId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('websiteProjectInstanceEnvDelete', 'envId', envId)
            const localVarPath = `/website/{locationId}/project/{projectId}/instance/{instanceId}/env/{envId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get website/instance.env
         * @summary Get website/instance.env
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} envId envId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceEnvGet: async (projectId: string, locationId: string, instanceId: string, envId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('websiteProjectInstanceEnvGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('websiteProjectInstanceEnvGet', 'locationId', locationId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('websiteProjectInstanceEnvGet', 'instanceId', instanceId)
            // verify required parameter 'envId' is not null or undefined
            assertParamExists('websiteProjectInstanceEnvGet', 'envId', envId)
            const localVarPath = `/website/{locationId}/project/{projectId}/instance/{instanceId}/env/{envId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"envId"}}`, encodeURIComponent(String(envId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List website/instance.env
         * @summary List website/instance.env
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceEnvList: async (projectId: string, locationId: string, instanceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('websiteProjectInstanceEnvList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('websiteProjectInstanceEnvList', 'locationId', locationId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('websiteProjectInstanceEnvList', 'instanceId', instanceId)
            const localVarPath = `/website/{locationId}/project/{projectId}/instance/{instanceId}/env`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get website/instance.event
         * @summary Get website/instance.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceEventGet: async (projectId: string, locationId: string, instanceId: string, eventId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('websiteProjectInstanceEventGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('websiteProjectInstanceEventGet', 'locationId', locationId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('websiteProjectInstanceEventGet', 'instanceId', instanceId)
            // verify required parameter 'eventId' is not null or undefined
            assertParamExists('websiteProjectInstanceEventGet', 'eventId', eventId)
            const localVarPath = `/website/{locationId}/project/{projectId}/instance/{instanceId}/event/{eventId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"eventId"}}`, encodeURIComponent(String(eventId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List website/instance.event
         * @summary List website/instance.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceEventList: async (projectId: string, locationId: string, instanceId: string, $limit?: number, $skip?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('websiteProjectInstanceEventList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('websiteProjectInstanceEventList', 'locationId', locationId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('websiteProjectInstanceEventList', 'instanceId', instanceId)
            const localVarPath = `/website/{locationId}/project/{projectId}/instance/{instanceId}/event`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if ($limit !== undefined) {
                localVarQueryParameter['$limit'] = $limit;
            }

            if ($skip !== undefined) {
                localVarQueryParameter['$skip'] = $skip;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single instance
         * @summary Get website/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceGet: async (projectId: string, locationId: string, instanceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('websiteProjectInstanceGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('websiteProjectInstanceGet', 'locationId', locationId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('websiteProjectInstanceGet', 'instanceId', instanceId)
            const localVarPath = `/website/{locationId}/project/{projectId}/instance/{instanceId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create website/instance.link
         * @summary Create website/instance.link
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {WebsiteLink} websiteLink 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceLinkCreate: async (projectId: string, locationId: string, instanceId: string, websiteLink: WebsiteLink, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('websiteProjectInstanceLinkCreate', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('websiteProjectInstanceLinkCreate', 'locationId', locationId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('websiteProjectInstanceLinkCreate', 'instanceId', instanceId)
            // verify required parameter 'websiteLink' is not null or undefined
            assertParamExists('websiteProjectInstanceLinkCreate', 'websiteLink', websiteLink)
            const localVarPath = `/website/{locationId}/project/{projectId}/instance/{instanceId}/link`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(websiteLink, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete website/instance.link
         * @summary Delete website/instance.link
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} linkId linkId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceLinkDelete: async (projectId: string, locationId: string, instanceId: string, linkId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('websiteProjectInstanceLinkDelete', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('websiteProjectInstanceLinkDelete', 'locationId', locationId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('websiteProjectInstanceLinkDelete', 'instanceId', instanceId)
            // verify required parameter 'linkId' is not null or undefined
            assertParamExists('websiteProjectInstanceLinkDelete', 'linkId', linkId)
            const localVarPath = `/website/{locationId}/project/{projectId}/instance/{instanceId}/link/{linkId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"linkId"}}`, encodeURIComponent(String(linkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get website/instance.link
         * @summary Get website/instance.link
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} linkId linkId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceLinkGet: async (projectId: string, locationId: string, instanceId: string, linkId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('websiteProjectInstanceLinkGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('websiteProjectInstanceLinkGet', 'locationId', locationId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('websiteProjectInstanceLinkGet', 'instanceId', instanceId)
            // verify required parameter 'linkId' is not null or undefined
            assertParamExists('websiteProjectInstanceLinkGet', 'linkId', linkId)
            const localVarPath = `/website/{locationId}/project/{projectId}/instance/{instanceId}/link/{linkId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"linkId"}}`, encodeURIComponent(String(linkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List website/instance.link
         * @summary List website/instance.link
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceLinkList: async (projectId: string, locationId: string, instanceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('websiteProjectInstanceLinkList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('websiteProjectInstanceLinkList', 'locationId', locationId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('websiteProjectInstanceLinkList', 'instanceId', instanceId)
            const localVarPath = `/website/{locationId}/project/{projectId}/instance/{instanceId}/link`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List instance
         * @summary List website/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [name] Filter by name
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceList: async (projectId: string, locationId: string, name?: string, tagValue?: string, tagKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('websiteProjectInstanceList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('websiteProjectInstanceList', 'locationId', locationId)
            const localVarPath = `/website/{locationId}/project/{projectId}/instance`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (tagValue !== undefined) {
                localVarQueryParameter['tag.value'] = tagValue;
            }

            if (tagKey !== undefined) {
                localVarQueryParameter['tag.key'] = tagKey;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get website/instance.log
         * @summary Get website/instance.log
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} logId logId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceLogGet: async (projectId: string, locationId: string, instanceId: string, logId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('websiteProjectInstanceLogGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('websiteProjectInstanceLogGet', 'locationId', locationId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('websiteProjectInstanceLogGet', 'instanceId', instanceId)
            // verify required parameter 'logId' is not null or undefined
            assertParamExists('websiteProjectInstanceLogGet', 'logId', logId)
            const localVarPath = `/website/{locationId}/project/{projectId}/instance/{instanceId}/log/{logId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"logId"}}`, encodeURIComponent(String(logId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List website/instance.log
         * @summary List website/instance.log
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceLogList: async (projectId: string, locationId: string, instanceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('websiteProjectInstanceLogList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('websiteProjectInstanceLogList', 'locationId', locationId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('websiteProjectInstanceLogList', 'instanceId', instanceId)
            const localVarPath = `/website/{locationId}/project/{projectId}/instance/{instanceId}/log`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * action read
         * @summary Read website/instance.log
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} logId logId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceLogRead: async (projectId: string, locationId: string, instanceId: string, logId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('websiteProjectInstanceLogRead', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('websiteProjectInstanceLogRead', 'locationId', locationId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('websiteProjectInstanceLogRead', 'instanceId', instanceId)
            // verify required parameter 'logId' is not null or undefined
            assertParamExists('websiteProjectInstanceLogRead', 'logId', logId)
            const localVarPath = `/website/{locationId}/project/{projectId}/instance/{instanceId}/log/{logId}/actions/read`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"logId"}}`, encodeURIComponent(String(logId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get website/instance.metric
         * @summary Get website/instance.metric
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} metricId metricId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceMetricGet: async (projectId: string, locationId: string, instanceId: string, metricId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('websiteProjectInstanceMetricGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('websiteProjectInstanceMetricGet', 'locationId', locationId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('websiteProjectInstanceMetricGet', 'instanceId', instanceId)
            // verify required parameter 'metricId' is not null or undefined
            assertParamExists('websiteProjectInstanceMetricGet', 'metricId', metricId)
            const localVarPath = `/website/{locationId}/project/{projectId}/instance/{instanceId}/metric/{metricId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"metricId"}}`, encodeURIComponent(String(metricId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List website/instance.metric
         * @summary List website/instance.metric
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceMetricList: async (projectId: string, locationId: string, instanceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('websiteProjectInstanceMetricList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('websiteProjectInstanceMetricList', 'locationId', locationId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('websiteProjectInstanceMetricList', 'instanceId', instanceId)
            const localVarPath = `/website/{locationId}/project/{projectId}/instance/{instanceId}/metric`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List website/instance.point
         * @summary List website/instance.point
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} metricId metricId
         * @param {string} [interval] interval
         * @param {string} [timespan] timespan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceMetricPointList: async (projectId: string, locationId: string, instanceId: string, metricId: string, interval?: string, timespan?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('websiteProjectInstanceMetricPointList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('websiteProjectInstanceMetricPointList', 'locationId', locationId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('websiteProjectInstanceMetricPointList', 'instanceId', instanceId)
            // verify required parameter 'metricId' is not null or undefined
            assertParamExists('websiteProjectInstanceMetricPointList', 'metricId', metricId)
            const localVarPath = `/website/{locationId}/project/{projectId}/instance/{instanceId}/metric/{metricId}/point`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"metricId"}}`, encodeURIComponent(String(metricId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (timespan !== undefined) {
                localVarQueryParameter['timespan'] = timespan;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * action restart
         * @summary Restart website/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceRestart: async (projectId: string, locationId: string, instanceId: string, xIdempotencyKey?: string, xDryRun?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('websiteProjectInstanceRestart', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('websiteProjectInstanceRestart', 'locationId', locationId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('websiteProjectInstanceRestart', 'instanceId', instanceId)
            const localVarPath = `/website/{locationId}/project/{projectId}/instance/{instanceId}/actions/restart`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }

            if (xDryRun !== undefined && xDryRun !== null) {
                localVarHeaderParameter['x-dry-run'] = String(xDryRun);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get website/instance.service
         * @summary Get website/instance.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceServiceGet: async (projectId: string, locationId: string, instanceId: string, serviceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('websiteProjectInstanceServiceGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('websiteProjectInstanceServiceGet', 'locationId', locationId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('websiteProjectInstanceServiceGet', 'instanceId', instanceId)
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('websiteProjectInstanceServiceGet', 'serviceId', serviceId)
            const localVarPath = `/website/{locationId}/project/{projectId}/instance/{instanceId}/service/{serviceId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"serviceId"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List website/instance.service
         * @summary List website/instance.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceServiceList: async (projectId: string, locationId: string, instanceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('websiteProjectInstanceServiceList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('websiteProjectInstanceServiceList', 'locationId', locationId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('websiteProjectInstanceServiceList', 'instanceId', instanceId)
            const localVarPath = `/website/{locationId}/project/{projectId}/instance/{instanceId}/service`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get website/instance.sideapp
         * @summary Get website/instance.sideapp
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} sideappId sideappId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceSideappGet: async (projectId: string, locationId: string, instanceId: string, sideappId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('websiteProjectInstanceSideappGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('websiteProjectInstanceSideappGet', 'locationId', locationId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('websiteProjectInstanceSideappGet', 'instanceId', instanceId)
            // verify required parameter 'sideappId' is not null or undefined
            assertParamExists('websiteProjectInstanceSideappGet', 'sideappId', sideappId)
            const localVarPath = `/website/{locationId}/project/{projectId}/instance/{instanceId}/sideapp/{sideappId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"sideappId"}}`, encodeURIComponent(String(sideappId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List website/instance.sideapp
         * @summary List website/instance.sideapp
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceSideappList: async (projectId: string, locationId: string, instanceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('websiteProjectInstanceSideappList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('websiteProjectInstanceSideappList', 'locationId', locationId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('websiteProjectInstanceSideappList', 'instanceId', instanceId)
            const localVarPath = `/website/{locationId}/project/{projectId}/instance/{instanceId}/sideapp`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * action open
         * @summary Open website/instance.sideapp
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} sideappId sideappId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceSideappOpen: async (projectId: string, locationId: string, instanceId: string, sideappId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('websiteProjectInstanceSideappOpen', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('websiteProjectInstanceSideappOpen', 'locationId', locationId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('websiteProjectInstanceSideappOpen', 'instanceId', instanceId)
            // verify required parameter 'sideappId' is not null or undefined
            assertParamExists('websiteProjectInstanceSideappOpen', 'sideappId', sideappId)
            const localVarPath = `/website/{locationId}/project/{projectId}/instance/{instanceId}/sideapp/{sideappId}/actions/open`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"sideappId"}}`, encodeURIComponent(String(sideappId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create website/instance.snapshot
         * @summary Create website/instance.snapshot
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {WebsiteSnapshot} websiteSnapshot 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceSnapshotCreate: async (projectId: string, locationId: string, instanceId: string, websiteSnapshot: WebsiteSnapshot, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('websiteProjectInstanceSnapshotCreate', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('websiteProjectInstanceSnapshotCreate', 'locationId', locationId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('websiteProjectInstanceSnapshotCreate', 'instanceId', instanceId)
            // verify required parameter 'websiteSnapshot' is not null or undefined
            assertParamExists('websiteProjectInstanceSnapshotCreate', 'websiteSnapshot', websiteSnapshot)
            const localVarPath = `/website/{locationId}/project/{projectId}/instance/{instanceId}/snapshot`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(websiteSnapshot, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete website/instance.snapshot
         * @summary Delete website/instance.snapshot
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} snapshotId snapshotId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceSnapshotDelete: async (projectId: string, locationId: string, instanceId: string, snapshotId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('websiteProjectInstanceSnapshotDelete', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('websiteProjectInstanceSnapshotDelete', 'locationId', locationId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('websiteProjectInstanceSnapshotDelete', 'instanceId', instanceId)
            // verify required parameter 'snapshotId' is not null or undefined
            assertParamExists('websiteProjectInstanceSnapshotDelete', 'snapshotId', snapshotId)
            const localVarPath = `/website/{locationId}/project/{projectId}/instance/{instanceId}/snapshot/{snapshotId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"snapshotId"}}`, encodeURIComponent(String(snapshotId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * action download
         * @summary Download website/instance.snapshot
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} snapshotId snapshotId
         * @param {WebsiteProjectInstanceSnapshotDownload} websiteProjectInstanceSnapshotDownload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceSnapshotDownload: async (projectId: string, locationId: string, instanceId: string, snapshotId: string, websiteProjectInstanceSnapshotDownload: WebsiteProjectInstanceSnapshotDownload, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('websiteProjectInstanceSnapshotDownload', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('websiteProjectInstanceSnapshotDownload', 'locationId', locationId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('websiteProjectInstanceSnapshotDownload', 'instanceId', instanceId)
            // verify required parameter 'snapshotId' is not null or undefined
            assertParamExists('websiteProjectInstanceSnapshotDownload', 'snapshotId', snapshotId)
            // verify required parameter 'websiteProjectInstanceSnapshotDownload' is not null or undefined
            assertParamExists('websiteProjectInstanceSnapshotDownload', 'websiteProjectInstanceSnapshotDownload', websiteProjectInstanceSnapshotDownload)
            const localVarPath = `/website/{locationId}/project/{projectId}/instance/{instanceId}/snapshot/{snapshotId}/actions/download`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"snapshotId"}}`, encodeURIComponent(String(snapshotId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(websiteProjectInstanceSnapshotDownload, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get website/instance.snapshot
         * @summary Get website/instance.snapshot
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} snapshotId snapshotId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceSnapshotGet: async (projectId: string, locationId: string, instanceId: string, snapshotId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('websiteProjectInstanceSnapshotGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('websiteProjectInstanceSnapshotGet', 'locationId', locationId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('websiteProjectInstanceSnapshotGet', 'instanceId', instanceId)
            // verify required parameter 'snapshotId' is not null or undefined
            assertParamExists('websiteProjectInstanceSnapshotGet', 'snapshotId', snapshotId)
            const localVarPath = `/website/{locationId}/project/{projectId}/instance/{instanceId}/snapshot/{snapshotId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"snapshotId"}}`, encodeURIComponent(String(snapshotId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List website/instance.snapshot
         * @summary List website/instance.snapshot
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceSnapshotList: async (projectId: string, locationId: string, instanceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('websiteProjectInstanceSnapshotList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('websiteProjectInstanceSnapshotList', 'locationId', locationId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('websiteProjectInstanceSnapshotList', 'instanceId', instanceId)
            const localVarPath = `/website/{locationId}/project/{projectId}/instance/{instanceId}/snapshot`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * action start
         * @summary Start website/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceStart: async (projectId: string, locationId: string, instanceId: string, xIdempotencyKey?: string, xDryRun?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('websiteProjectInstanceStart', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('websiteProjectInstanceStart', 'locationId', locationId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('websiteProjectInstanceStart', 'instanceId', instanceId)
            const localVarPath = `/website/{locationId}/project/{projectId}/instance/{instanceId}/actions/start`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }

            if (xDryRun !== undefined && xDryRun !== null) {
                localVarHeaderParameter['x-dry-run'] = String(xDryRun);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * action stop
         * @summary Stop website/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceStop: async (projectId: string, locationId: string, instanceId: string, xIdempotencyKey?: string, xDryRun?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('websiteProjectInstanceStop', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('websiteProjectInstanceStop', 'locationId', locationId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('websiteProjectInstanceStop', 'instanceId', instanceId)
            const localVarPath = `/website/{locationId}/project/{projectId}/instance/{instanceId}/actions/stop`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }

            if (xDryRun !== undefined && xDryRun !== null) {
                localVarHeaderParameter['x-dry-run'] = String(xDryRun);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create website/instance.tag
         * @summary Create website/instance.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceTagCreate: async (projectId: string, locationId: string, instanceId: string, tag: Tag, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('websiteProjectInstanceTagCreate', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('websiteProjectInstanceTagCreate', 'locationId', locationId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('websiteProjectInstanceTagCreate', 'instanceId', instanceId)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('websiteProjectInstanceTagCreate', 'tag', tag)
            const localVarPath = `/website/{locationId}/project/{projectId}/instance/{instanceId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tag, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete website/instance.tag
         * @summary Delete website/instance.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceTagDelete: async (projectId: string, locationId: string, instanceId: string, tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('websiteProjectInstanceTagDelete', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('websiteProjectInstanceTagDelete', 'locationId', locationId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('websiteProjectInstanceTagDelete', 'instanceId', instanceId)
            // verify required parameter 'tagId' is not null or undefined
            assertParamExists('websiteProjectInstanceTagDelete', 'tagId', tagId)
            const localVarPath = `/website/{locationId}/project/{projectId}/instance/{instanceId}/tag/{tagId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get website/instance.tag
         * @summary Get website/instance.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceTagGet: async (projectId: string, locationId: string, instanceId: string, tagId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('websiteProjectInstanceTagGet', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('websiteProjectInstanceTagGet', 'locationId', locationId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('websiteProjectInstanceTagGet', 'instanceId', instanceId)
            // verify required parameter 'tagId' is not null or undefined
            assertParamExists('websiteProjectInstanceTagGet', 'tagId', tagId)
            const localVarPath = `/website/{locationId}/project/{projectId}/instance/{instanceId}/tag/{tagId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)))
                .replace(`{${"tagId"}}`, encodeURIComponent(String(tagId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List website/instance.tag
         * @summary List website/instance.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceTagList: async (projectId: string, locationId: string, instanceId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('websiteProjectInstanceTagList', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('websiteProjectInstanceTagList', 'locationId', locationId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('websiteProjectInstanceTagList', 'instanceId', instanceId)
            const localVarPath = `/website/{locationId}/project/{projectId}/instance/{instanceId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replace website/instance.tag
         * @summary Replace website/instance.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceTagPut: async (projectId: string, locationId: string, instanceId: string, tag: Array<Tag>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('websiteProjectInstanceTagPut', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('websiteProjectInstanceTagPut', 'locationId', locationId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('websiteProjectInstanceTagPut', 'instanceId', instanceId)
            // verify required parameter 'tag' is not null or undefined
            assertParamExists('websiteProjectInstanceTagPut', 'tag', tag)
            const localVarPath = `/website/{locationId}/project/{projectId}/instance/{instanceId}/tag`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(tag, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * action transfer
         * @summary Transfer website/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {WebsiteProjectInstanceTransfer} websiteProjectInstanceTransfer 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceTransfer: async (projectId: string, locationId: string, instanceId: string, websiteProjectInstanceTransfer: WebsiteProjectInstanceTransfer, xIdempotencyKey?: string, xDryRun?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('websiteProjectInstanceTransfer', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('websiteProjectInstanceTransfer', 'locationId', locationId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('websiteProjectInstanceTransfer', 'instanceId', instanceId)
            // verify required parameter 'websiteProjectInstanceTransfer' is not null or undefined
            assertParamExists('websiteProjectInstanceTransfer', 'websiteProjectInstanceTransfer', websiteProjectInstanceTransfer)
            const localVarPath = `/website/{locationId}/project/{projectId}/instance/{instanceId}/actions/transfer`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (xIdempotencyKey !== undefined && xIdempotencyKey !== null) {
                localVarHeaderParameter['x-idempotency-key'] = String(xIdempotencyKey);
            }

            if (xDryRun !== undefined && xDryRun !== null) {
                localVarHeaderParameter['x-dry-run'] = String(xDryRun);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(websiteProjectInstanceTransfer, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns modified instance
         * @summary Update website/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {WebsiteProjectInstanceUpdate} websiteProjectInstanceUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceUpdate: async (projectId: string, locationId: string, instanceId: string, websiteProjectInstanceUpdate: WebsiteProjectInstanceUpdate, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('websiteProjectInstanceUpdate', 'projectId', projectId)
            // verify required parameter 'locationId' is not null or undefined
            assertParamExists('websiteProjectInstanceUpdate', 'locationId', locationId)
            // verify required parameter 'instanceId' is not null or undefined
            assertParamExists('websiteProjectInstanceUpdate', 'instanceId', instanceId)
            // verify required parameter 'websiteProjectInstanceUpdate' is not null or undefined
            assertParamExists('websiteProjectInstanceUpdate', 'websiteProjectInstanceUpdate', websiteProjectInstanceUpdate)
            const localVarPath = `/website/{locationId}/project/{projectId}/instance/{instanceId}`
                .replace(`{${"projectId"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"locationId"}}`, encodeURIComponent(String(locationId)))
                .replace(`{${"instanceId"}}`, encodeURIComponent(String(instanceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(websiteProjectInstanceUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * WebsiteProjectInstanceApi - functional programming interface
 * @export
 */
export const WebsiteProjectInstanceApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = WebsiteProjectInstanceApiAxiosParamCreator(configuration)
    return {
        /**
         * Get website/instance.connect
         * @summary Get website/instance.connect
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} connectId connectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websiteProjectInstanceConnectGet(projectId: string, locationId: string, instanceId: string, connectId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceConnect>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.websiteProjectInstanceConnectGet(projectId, locationId, instanceId, connectId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List website/instance.connect
         * @summary List website/instance.connect
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websiteProjectInstanceConnectList(projectId: string, locationId: string, instanceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResourceConnect>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.websiteProjectInstanceConnectList(projectId, locationId, instanceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create instance
         * @summary Create website/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {WebsiteProjectInstanceCreate} websiteProjectInstanceCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websiteProjectInstanceCreate(projectId: string, locationId: string, websiteProjectInstanceCreate: WebsiteProjectInstanceCreate, xIdempotencyKey?: string, xDryRun?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Website>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.websiteProjectInstanceCreate(projectId, locationId, websiteProjectInstanceCreate, xIdempotencyKey, xDryRun, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create website/instance.credential
         * @summary Create website/instance.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {WebsiteCredential} websiteCredential 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websiteProjectInstanceCredentialCreate(projectId: string, locationId: string, instanceId: string, websiteCredential: WebsiteCredential, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebsiteCredential>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.websiteProjectInstanceCredentialCreate(projectId, locationId, instanceId, websiteCredential, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete website/instance.credential
         * @summary Delete website/instance.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} credentialId credentialId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websiteProjectInstanceCredentialDelete(projectId: string, locationId: string, instanceId: string, credentialId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Website>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.websiteProjectInstanceCredentialDelete(projectId, locationId, instanceId, credentialId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get website/instance.credential
         * @summary Get website/instance.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} credentialId credentialId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websiteProjectInstanceCredentialGet(projectId: string, locationId: string, instanceId: string, credentialId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebsiteCredential>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.websiteProjectInstanceCredentialGet(projectId, locationId, instanceId, credentialId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List website/instance.credential
         * @summary List website/instance.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websiteProjectInstanceCredentialList(projectId: string, locationId: string, instanceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WebsiteCredential>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.websiteProjectInstanceCredentialList(projectId, locationId, instanceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Update website/instance.credential
         * @summary Update website/instance.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} credentialId credentialId
         * @param {WebsiteProjectInstanceCredentialPatch} websiteProjectInstanceCredentialPatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websiteProjectInstanceCredentialPatch(projectId: string, locationId: string, instanceId: string, credentialId: string, websiteProjectInstanceCredentialPatch: WebsiteProjectInstanceCredentialPatch, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebsiteCredential>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.websiteProjectInstanceCredentialPatch(projectId, locationId, instanceId, credentialId, websiteProjectInstanceCredentialPatch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete instance
         * @summary Delete website/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websiteProjectInstanceDelete(projectId: string, locationId: string, instanceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.websiteProjectInstanceDelete(projectId, locationId, instanceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create website/instance.domain
         * @summary Create website/instance.domain
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {Domain} domain 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websiteProjectInstanceDomainCreate(projectId: string, locationId: string, instanceId: string, domain: Domain, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Domain>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.websiteProjectInstanceDomainCreate(projectId, locationId, instanceId, domain, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete website/instance.domain
         * @summary Delete website/instance.domain
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} domainId domainId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websiteProjectInstanceDomainDelete(projectId: string, locationId: string, instanceId: string, domainId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.websiteProjectInstanceDomainDelete(projectId, locationId, instanceId, domainId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get website/instance.domain
         * @summary Get website/instance.domain
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} domainId domainId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websiteProjectInstanceDomainGet(projectId: string, locationId: string, instanceId: string, domainId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Domain>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.websiteProjectInstanceDomainGet(projectId, locationId, instanceId, domainId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List website/instance.domain
         * @summary List website/instance.domain
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websiteProjectInstanceDomainList(projectId: string, locationId: string, instanceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Domain>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.websiteProjectInstanceDomainList(projectId, locationId, instanceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create website/instance.env
         * @summary Create website/instance.env
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {WebsiteEnv} websiteEnv 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websiteProjectInstanceEnvCreate(projectId: string, locationId: string, instanceId: string, websiteEnv: WebsiteEnv, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebsiteEnv>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.websiteProjectInstanceEnvCreate(projectId, locationId, instanceId, websiteEnv, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete website/instance.env
         * @summary Delete website/instance.env
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} envId envId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websiteProjectInstanceEnvDelete(projectId: string, locationId: string, instanceId: string, envId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.websiteProjectInstanceEnvDelete(projectId, locationId, instanceId, envId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get website/instance.env
         * @summary Get website/instance.env
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} envId envId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websiteProjectInstanceEnvGet(projectId: string, locationId: string, instanceId: string, envId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebsiteEnv>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.websiteProjectInstanceEnvGet(projectId, locationId, instanceId, envId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List website/instance.env
         * @summary List website/instance.env
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websiteProjectInstanceEnvList(projectId: string, locationId: string, instanceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WebsiteEnv>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.websiteProjectInstanceEnvList(projectId, locationId, instanceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get website/instance.event
         * @summary Get website/instance.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websiteProjectInstanceEventGet(projectId: string, locationId: string, instanceId: string, eventId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Event>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.websiteProjectInstanceEventGet(projectId, locationId, instanceId, eventId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List website/instance.event
         * @summary List website/instance.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websiteProjectInstanceEventList(projectId: string, locationId: string, instanceId: string, $limit?: number, $skip?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Event>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.websiteProjectInstanceEventList(projectId, locationId, instanceId, $limit, $skip, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a single instance
         * @summary Get website/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websiteProjectInstanceGet(projectId: string, locationId: string, instanceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Website>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.websiteProjectInstanceGet(projectId, locationId, instanceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create website/instance.link
         * @summary Create website/instance.link
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {WebsiteLink} websiteLink 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websiteProjectInstanceLinkCreate(projectId: string, locationId: string, instanceId: string, websiteLink: WebsiteLink, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebsiteLink>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.websiteProjectInstanceLinkCreate(projectId, locationId, instanceId, websiteLink, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete website/instance.link
         * @summary Delete website/instance.link
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} linkId linkId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websiteProjectInstanceLinkDelete(projectId: string, locationId: string, instanceId: string, linkId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.websiteProjectInstanceLinkDelete(projectId, locationId, instanceId, linkId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get website/instance.link
         * @summary Get website/instance.link
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} linkId linkId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websiteProjectInstanceLinkGet(projectId: string, locationId: string, instanceId: string, linkId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebsiteLink>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.websiteProjectInstanceLinkGet(projectId, locationId, instanceId, linkId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List website/instance.link
         * @summary List website/instance.link
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websiteProjectInstanceLinkList(projectId: string, locationId: string, instanceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WebsiteLink>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.websiteProjectInstanceLinkList(projectId, locationId, instanceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List instance
         * @summary List website/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [name] Filter by name
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websiteProjectInstanceList(projectId: string, locationId: string, name?: string, tagValue?: string, tagKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Website>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.websiteProjectInstanceList(projectId, locationId, name, tagValue, tagKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get website/instance.log
         * @summary Get website/instance.log
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} logId logId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websiteProjectInstanceLogGet(projectId: string, locationId: string, instanceId: string, logId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Log>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.websiteProjectInstanceLogGet(projectId, locationId, instanceId, logId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List website/instance.log
         * @summary List website/instance.log
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websiteProjectInstanceLogList(projectId: string, locationId: string, instanceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Log>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.websiteProjectInstanceLogList(projectId, locationId, instanceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * action read
         * @summary Read website/instance.log
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} logId logId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websiteProjectInstanceLogRead(projectId: string, locationId: string, instanceId: string, logId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.websiteProjectInstanceLogRead(projectId, locationId, instanceId, logId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get website/instance.metric
         * @summary Get website/instance.metric
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} metricId metricId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websiteProjectInstanceMetricGet(projectId: string, locationId: string, instanceId: string, metricId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Metric>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.websiteProjectInstanceMetricGet(projectId, locationId, instanceId, metricId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List website/instance.metric
         * @summary List website/instance.metric
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websiteProjectInstanceMetricList(projectId: string, locationId: string, instanceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Metric>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.websiteProjectInstanceMetricList(projectId, locationId, instanceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List website/instance.point
         * @summary List website/instance.point
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} metricId metricId
         * @param {string} [interval] interval
         * @param {string} [timespan] timespan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websiteProjectInstanceMetricPointList(projectId: string, locationId: string, instanceId: string, metricId: string, interval?: string, timespan?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Point>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.websiteProjectInstanceMetricPointList(projectId, locationId, instanceId, metricId, interval, timespan, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * action restart
         * @summary Restart website/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websiteProjectInstanceRestart(projectId: string, locationId: string, instanceId: string, xIdempotencyKey?: string, xDryRun?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Website>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.websiteProjectInstanceRestart(projectId, locationId, instanceId, xIdempotencyKey, xDryRun, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get website/instance.service
         * @summary Get website/instance.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websiteProjectInstanceServiceGet(projectId: string, locationId: string, instanceId: string, serviceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResourceService>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.websiteProjectInstanceServiceGet(projectId, locationId, instanceId, serviceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List website/instance.service
         * @summary List website/instance.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websiteProjectInstanceServiceList(projectId: string, locationId: string, instanceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ResourceService>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.websiteProjectInstanceServiceList(projectId, locationId, instanceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get website/instance.sideapp
         * @summary Get website/instance.sideapp
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} sideappId sideappId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websiteProjectInstanceSideappGet(projectId: string, locationId: string, instanceId: string, sideappId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebsiteSideapp>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.websiteProjectInstanceSideappGet(projectId, locationId, instanceId, sideappId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List website/instance.sideapp
         * @summary List website/instance.sideapp
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websiteProjectInstanceSideappList(projectId: string, locationId: string, instanceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WebsiteSideapp>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.websiteProjectInstanceSideappList(projectId, locationId, instanceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * action open
         * @summary Open website/instance.sideapp
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} sideappId sideappId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websiteProjectInstanceSideappOpen(projectId: string, locationId: string, instanceId: string, sideappId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.websiteProjectInstanceSideappOpen(projectId, locationId, instanceId, sideappId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create website/instance.snapshot
         * @summary Create website/instance.snapshot
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {WebsiteSnapshot} websiteSnapshot 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websiteProjectInstanceSnapshotCreate(projectId: string, locationId: string, instanceId: string, websiteSnapshot: WebsiteSnapshot, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebsiteSnapshot>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.websiteProjectInstanceSnapshotCreate(projectId, locationId, instanceId, websiteSnapshot, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete website/instance.snapshot
         * @summary Delete website/instance.snapshot
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} snapshotId snapshotId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websiteProjectInstanceSnapshotDelete(projectId: string, locationId: string, instanceId: string, snapshotId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Website>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.websiteProjectInstanceSnapshotDelete(projectId, locationId, instanceId, snapshotId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * action download
         * @summary Download website/instance.snapshot
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} snapshotId snapshotId
         * @param {WebsiteProjectInstanceSnapshotDownload} websiteProjectInstanceSnapshotDownload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websiteProjectInstanceSnapshotDownload(projectId: string, locationId: string, instanceId: string, snapshotId: string, websiteProjectInstanceSnapshotDownload: WebsiteProjectInstanceSnapshotDownload, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.websiteProjectInstanceSnapshotDownload(projectId, locationId, instanceId, snapshotId, websiteProjectInstanceSnapshotDownload, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get website/instance.snapshot
         * @summary Get website/instance.snapshot
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} snapshotId snapshotId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websiteProjectInstanceSnapshotGet(projectId: string, locationId: string, instanceId: string, snapshotId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WebsiteSnapshot>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.websiteProjectInstanceSnapshotGet(projectId, locationId, instanceId, snapshotId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List website/instance.snapshot
         * @summary List website/instance.snapshot
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websiteProjectInstanceSnapshotList(projectId: string, locationId: string, instanceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<WebsiteSnapshot>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.websiteProjectInstanceSnapshotList(projectId, locationId, instanceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * action start
         * @summary Start website/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websiteProjectInstanceStart(projectId: string, locationId: string, instanceId: string, xIdempotencyKey?: string, xDryRun?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Website>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.websiteProjectInstanceStart(projectId, locationId, instanceId, xIdempotencyKey, xDryRun, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * action stop
         * @summary Stop website/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websiteProjectInstanceStop(projectId: string, locationId: string, instanceId: string, xIdempotencyKey?: string, xDryRun?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Website>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.websiteProjectInstanceStop(projectId, locationId, instanceId, xIdempotencyKey, xDryRun, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Create website/instance.tag
         * @summary Create website/instance.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websiteProjectInstanceTagCreate(projectId: string, locationId: string, instanceId: string, tag: Tag, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.websiteProjectInstanceTagCreate(projectId, locationId, instanceId, tag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Delete website/instance.tag
         * @summary Delete website/instance.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websiteProjectInstanceTagDelete(projectId: string, locationId: string, instanceId: string, tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.websiteProjectInstanceTagDelete(projectId, locationId, instanceId, tagId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Get website/instance.tag
         * @summary Get website/instance.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websiteProjectInstanceTagGet(projectId: string, locationId: string, instanceId: string, tagId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Tag>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.websiteProjectInstanceTagGet(projectId, locationId, instanceId, tagId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * List website/instance.tag
         * @summary List website/instance.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websiteProjectInstanceTagList(projectId: string, locationId: string, instanceId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.websiteProjectInstanceTagList(projectId, locationId, instanceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Replace website/instance.tag
         * @summary Replace website/instance.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websiteProjectInstanceTagPut(projectId: string, locationId: string, instanceId: string, tag: Array<Tag>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.websiteProjectInstanceTagPut(projectId, locationId, instanceId, tag, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * action transfer
         * @summary Transfer website/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {WebsiteProjectInstanceTransfer} websiteProjectInstanceTransfer 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websiteProjectInstanceTransfer(projectId: string, locationId: string, instanceId: string, websiteProjectInstanceTransfer: WebsiteProjectInstanceTransfer, xIdempotencyKey?: string, xDryRun?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Website>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.websiteProjectInstanceTransfer(projectId, locationId, instanceId, websiteProjectInstanceTransfer, xIdempotencyKey, xDryRun, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns modified instance
         * @summary Update website/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {WebsiteProjectInstanceUpdate} websiteProjectInstanceUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async websiteProjectInstanceUpdate(projectId: string, locationId: string, instanceId: string, websiteProjectInstanceUpdate: WebsiteProjectInstanceUpdate, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Website>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.websiteProjectInstanceUpdate(projectId, locationId, instanceId, websiteProjectInstanceUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * WebsiteProjectInstanceApi - factory interface
 * @export
 */
export const WebsiteProjectInstanceApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = WebsiteProjectInstanceApiFp(configuration)
    return {
        /**
         * Get website/instance.connect
         * @summary Get website/instance.connect
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} connectId connectId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceConnectGet(projectId: string, locationId: string, instanceId: string, connectId: string, options?: any): AxiosPromise<ResourceConnect> {
            return localVarFp.websiteProjectInstanceConnectGet(projectId, locationId, instanceId, connectId, options).then((request) => request(axios, basePath));
        },
        /**
         * List website/instance.connect
         * @summary List website/instance.connect
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceConnectList(projectId: string, locationId: string, instanceId: string, options?: any): AxiosPromise<Array<ResourceConnect>> {
            return localVarFp.websiteProjectInstanceConnectList(projectId, locationId, instanceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create instance
         * @summary Create website/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {WebsiteProjectInstanceCreate} websiteProjectInstanceCreate 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceCreate(projectId: string, locationId: string, websiteProjectInstanceCreate: WebsiteProjectInstanceCreate, xIdempotencyKey?: string, xDryRun?: string, options?: any): AxiosPromise<Website> {
            return localVarFp.websiteProjectInstanceCreate(projectId, locationId, websiteProjectInstanceCreate, xIdempotencyKey, xDryRun, options).then((request) => request(axios, basePath));
        },
        /**
         * Create website/instance.credential
         * @summary Create website/instance.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {WebsiteCredential} websiteCredential 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceCredentialCreate(projectId: string, locationId: string, instanceId: string, websiteCredential: WebsiteCredential, options?: any): AxiosPromise<WebsiteCredential> {
            return localVarFp.websiteProjectInstanceCredentialCreate(projectId, locationId, instanceId, websiteCredential, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete website/instance.credential
         * @summary Delete website/instance.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} credentialId credentialId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceCredentialDelete(projectId: string, locationId: string, instanceId: string, credentialId: string, options?: any): AxiosPromise<Website> {
            return localVarFp.websiteProjectInstanceCredentialDelete(projectId, locationId, instanceId, credentialId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get website/instance.credential
         * @summary Get website/instance.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} credentialId credentialId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceCredentialGet(projectId: string, locationId: string, instanceId: string, credentialId: string, options?: any): AxiosPromise<WebsiteCredential> {
            return localVarFp.websiteProjectInstanceCredentialGet(projectId, locationId, instanceId, credentialId, options).then((request) => request(axios, basePath));
        },
        /**
         * List website/instance.credential
         * @summary List website/instance.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceCredentialList(projectId: string, locationId: string, instanceId: string, options?: any): AxiosPromise<Array<WebsiteCredential>> {
            return localVarFp.websiteProjectInstanceCredentialList(projectId, locationId, instanceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update website/instance.credential
         * @summary Update website/instance.credential
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} credentialId credentialId
         * @param {WebsiteProjectInstanceCredentialPatch} websiteProjectInstanceCredentialPatch 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceCredentialPatch(projectId: string, locationId: string, instanceId: string, credentialId: string, websiteProjectInstanceCredentialPatch: WebsiteProjectInstanceCredentialPatch, options?: any): AxiosPromise<WebsiteCredential> {
            return localVarFp.websiteProjectInstanceCredentialPatch(projectId, locationId, instanceId, credentialId, websiteProjectInstanceCredentialPatch, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete instance
         * @summary Delete website/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceDelete(projectId: string, locationId: string, instanceId: string, options?: any): AxiosPromise<void> {
            return localVarFp.websiteProjectInstanceDelete(projectId, locationId, instanceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create website/instance.domain
         * @summary Create website/instance.domain
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {Domain} domain 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceDomainCreate(projectId: string, locationId: string, instanceId: string, domain: Domain, options?: any): AxiosPromise<Domain> {
            return localVarFp.websiteProjectInstanceDomainCreate(projectId, locationId, instanceId, domain, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete website/instance.domain
         * @summary Delete website/instance.domain
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} domainId domainId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceDomainDelete(projectId: string, locationId: string, instanceId: string, domainId: string, options?: any): AxiosPromise<void> {
            return localVarFp.websiteProjectInstanceDomainDelete(projectId, locationId, instanceId, domainId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get website/instance.domain
         * @summary Get website/instance.domain
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} domainId domainId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceDomainGet(projectId: string, locationId: string, instanceId: string, domainId: string, options?: any): AxiosPromise<Domain> {
            return localVarFp.websiteProjectInstanceDomainGet(projectId, locationId, instanceId, domainId, options).then((request) => request(axios, basePath));
        },
        /**
         * List website/instance.domain
         * @summary List website/instance.domain
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceDomainList(projectId: string, locationId: string, instanceId: string, options?: any): AxiosPromise<Array<Domain>> {
            return localVarFp.websiteProjectInstanceDomainList(projectId, locationId, instanceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create website/instance.env
         * @summary Create website/instance.env
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {WebsiteEnv} websiteEnv 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceEnvCreate(projectId: string, locationId: string, instanceId: string, websiteEnv: WebsiteEnv, options?: any): AxiosPromise<WebsiteEnv> {
            return localVarFp.websiteProjectInstanceEnvCreate(projectId, locationId, instanceId, websiteEnv, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete website/instance.env
         * @summary Delete website/instance.env
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} envId envId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceEnvDelete(projectId: string, locationId: string, instanceId: string, envId: string, options?: any): AxiosPromise<void> {
            return localVarFp.websiteProjectInstanceEnvDelete(projectId, locationId, instanceId, envId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get website/instance.env
         * @summary Get website/instance.env
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} envId envId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceEnvGet(projectId: string, locationId: string, instanceId: string, envId: string, options?: any): AxiosPromise<WebsiteEnv> {
            return localVarFp.websiteProjectInstanceEnvGet(projectId, locationId, instanceId, envId, options).then((request) => request(axios, basePath));
        },
        /**
         * List website/instance.env
         * @summary List website/instance.env
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceEnvList(projectId: string, locationId: string, instanceId: string, options?: any): AxiosPromise<Array<WebsiteEnv>> {
            return localVarFp.websiteProjectInstanceEnvList(projectId, locationId, instanceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get website/instance.event
         * @summary Get website/instance.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} eventId eventId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceEventGet(projectId: string, locationId: string, instanceId: string, eventId: string, options?: any): AxiosPromise<Event> {
            return localVarFp.websiteProjectInstanceEventGet(projectId, locationId, instanceId, eventId, options).then((request) => request(axios, basePath));
        },
        /**
         * List website/instance.event
         * @summary List website/instance.event
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {number} [$limit] $limit
         * @param {number} [$skip] $skip
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceEventList(projectId: string, locationId: string, instanceId: string, $limit?: number, $skip?: number, options?: any): AxiosPromise<Array<Event>> {
            return localVarFp.websiteProjectInstanceEventList(projectId, locationId, instanceId, $limit, $skip, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single instance
         * @summary Get website/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceGet(projectId: string, locationId: string, instanceId: string, options?: any): AxiosPromise<Website> {
            return localVarFp.websiteProjectInstanceGet(projectId, locationId, instanceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create website/instance.link
         * @summary Create website/instance.link
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {WebsiteLink} websiteLink 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceLinkCreate(projectId: string, locationId: string, instanceId: string, websiteLink: WebsiteLink, options?: any): AxiosPromise<WebsiteLink> {
            return localVarFp.websiteProjectInstanceLinkCreate(projectId, locationId, instanceId, websiteLink, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete website/instance.link
         * @summary Delete website/instance.link
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} linkId linkId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceLinkDelete(projectId: string, locationId: string, instanceId: string, linkId: string, options?: any): AxiosPromise<void> {
            return localVarFp.websiteProjectInstanceLinkDelete(projectId, locationId, instanceId, linkId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get website/instance.link
         * @summary Get website/instance.link
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} linkId linkId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceLinkGet(projectId: string, locationId: string, instanceId: string, linkId: string, options?: any): AxiosPromise<WebsiteLink> {
            return localVarFp.websiteProjectInstanceLinkGet(projectId, locationId, instanceId, linkId, options).then((request) => request(axios, basePath));
        },
        /**
         * List website/instance.link
         * @summary List website/instance.link
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceLinkList(projectId: string, locationId: string, instanceId: string, options?: any): AxiosPromise<Array<WebsiteLink>> {
            return localVarFp.websiteProjectInstanceLinkList(projectId, locationId, instanceId, options).then((request) => request(axios, basePath));
        },
        /**
         * List instance
         * @summary List website/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} [name] Filter by name
         * @param {string} [tagValue] Filter by tag.value
         * @param {string} [tagKey] Filter by tag.key
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceList(projectId: string, locationId: string, name?: string, tagValue?: string, tagKey?: string, options?: any): AxiosPromise<Array<Website>> {
            return localVarFp.websiteProjectInstanceList(projectId, locationId, name, tagValue, tagKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Get website/instance.log
         * @summary Get website/instance.log
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} logId logId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceLogGet(projectId: string, locationId: string, instanceId: string, logId: string, options?: any): AxiosPromise<Log> {
            return localVarFp.websiteProjectInstanceLogGet(projectId, locationId, instanceId, logId, options).then((request) => request(axios, basePath));
        },
        /**
         * List website/instance.log
         * @summary List website/instance.log
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceLogList(projectId: string, locationId: string, instanceId: string, options?: any): AxiosPromise<Array<Log>> {
            return localVarFp.websiteProjectInstanceLogList(projectId, locationId, instanceId, options).then((request) => request(axios, basePath));
        },
        /**
         * action read
         * @summary Read website/instance.log
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} logId logId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceLogRead(projectId: string, locationId: string, instanceId: string, logId: string, options?: any): AxiosPromise<void> {
            return localVarFp.websiteProjectInstanceLogRead(projectId, locationId, instanceId, logId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get website/instance.metric
         * @summary Get website/instance.metric
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} metricId metricId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceMetricGet(projectId: string, locationId: string, instanceId: string, metricId: string, options?: any): AxiosPromise<Metric> {
            return localVarFp.websiteProjectInstanceMetricGet(projectId, locationId, instanceId, metricId, options).then((request) => request(axios, basePath));
        },
        /**
         * List website/instance.metric
         * @summary List website/instance.metric
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceMetricList(projectId: string, locationId: string, instanceId: string, options?: any): AxiosPromise<Array<Metric>> {
            return localVarFp.websiteProjectInstanceMetricList(projectId, locationId, instanceId, options).then((request) => request(axios, basePath));
        },
        /**
         * List website/instance.point
         * @summary List website/instance.point
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} metricId metricId
         * @param {string} [interval] interval
         * @param {string} [timespan] timespan
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceMetricPointList(projectId: string, locationId: string, instanceId: string, metricId: string, interval?: string, timespan?: string, options?: any): AxiosPromise<Array<Point>> {
            return localVarFp.websiteProjectInstanceMetricPointList(projectId, locationId, instanceId, metricId, interval, timespan, options).then((request) => request(axios, basePath));
        },
        /**
         * action restart
         * @summary Restart website/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceRestart(projectId: string, locationId: string, instanceId: string, xIdempotencyKey?: string, xDryRun?: string, options?: any): AxiosPromise<Website> {
            return localVarFp.websiteProjectInstanceRestart(projectId, locationId, instanceId, xIdempotencyKey, xDryRun, options).then((request) => request(axios, basePath));
        },
        /**
         * Get website/instance.service
         * @summary Get website/instance.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} serviceId serviceId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceServiceGet(projectId: string, locationId: string, instanceId: string, serviceId: string, options?: any): AxiosPromise<ResourceService> {
            return localVarFp.websiteProjectInstanceServiceGet(projectId, locationId, instanceId, serviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * List website/instance.service
         * @summary List website/instance.service
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceServiceList(projectId: string, locationId: string, instanceId: string, options?: any): AxiosPromise<Array<ResourceService>> {
            return localVarFp.websiteProjectInstanceServiceList(projectId, locationId, instanceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get website/instance.sideapp
         * @summary Get website/instance.sideapp
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} sideappId sideappId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceSideappGet(projectId: string, locationId: string, instanceId: string, sideappId: string, options?: any): AxiosPromise<WebsiteSideapp> {
            return localVarFp.websiteProjectInstanceSideappGet(projectId, locationId, instanceId, sideappId, options).then((request) => request(axios, basePath));
        },
        /**
         * List website/instance.sideapp
         * @summary List website/instance.sideapp
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceSideappList(projectId: string, locationId: string, instanceId: string, options?: any): AxiosPromise<Array<WebsiteSideapp>> {
            return localVarFp.websiteProjectInstanceSideappList(projectId, locationId, instanceId, options).then((request) => request(axios, basePath));
        },
        /**
         * action open
         * @summary Open website/instance.sideapp
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} sideappId sideappId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceSideappOpen(projectId: string, locationId: string, instanceId: string, sideappId: string, options?: any): AxiosPromise<void> {
            return localVarFp.websiteProjectInstanceSideappOpen(projectId, locationId, instanceId, sideappId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create website/instance.snapshot
         * @summary Create website/instance.snapshot
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {WebsiteSnapshot} websiteSnapshot 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceSnapshotCreate(projectId: string, locationId: string, instanceId: string, websiteSnapshot: WebsiteSnapshot, options?: any): AxiosPromise<WebsiteSnapshot> {
            return localVarFp.websiteProjectInstanceSnapshotCreate(projectId, locationId, instanceId, websiteSnapshot, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete website/instance.snapshot
         * @summary Delete website/instance.snapshot
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} snapshotId snapshotId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceSnapshotDelete(projectId: string, locationId: string, instanceId: string, snapshotId: string, options?: any): AxiosPromise<Website> {
            return localVarFp.websiteProjectInstanceSnapshotDelete(projectId, locationId, instanceId, snapshotId, options).then((request) => request(axios, basePath));
        },
        /**
         * action download
         * @summary Download website/instance.snapshot
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} snapshotId snapshotId
         * @param {WebsiteProjectInstanceSnapshotDownload} websiteProjectInstanceSnapshotDownload 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceSnapshotDownload(projectId: string, locationId: string, instanceId: string, snapshotId: string, websiteProjectInstanceSnapshotDownload: WebsiteProjectInstanceSnapshotDownload, options?: any): AxiosPromise<void> {
            return localVarFp.websiteProjectInstanceSnapshotDownload(projectId, locationId, instanceId, snapshotId, websiteProjectInstanceSnapshotDownload, options).then((request) => request(axios, basePath));
        },
        /**
         * Get website/instance.snapshot
         * @summary Get website/instance.snapshot
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} snapshotId snapshotId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceSnapshotGet(projectId: string, locationId: string, instanceId: string, snapshotId: string, options?: any): AxiosPromise<WebsiteSnapshot> {
            return localVarFp.websiteProjectInstanceSnapshotGet(projectId, locationId, instanceId, snapshotId, options).then((request) => request(axios, basePath));
        },
        /**
         * List website/instance.snapshot
         * @summary List website/instance.snapshot
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceSnapshotList(projectId: string, locationId: string, instanceId: string, options?: any): AxiosPromise<Array<WebsiteSnapshot>> {
            return localVarFp.websiteProjectInstanceSnapshotList(projectId, locationId, instanceId, options).then((request) => request(axios, basePath));
        },
        /**
         * action start
         * @summary Start website/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceStart(projectId: string, locationId: string, instanceId: string, xIdempotencyKey?: string, xDryRun?: string, options?: any): AxiosPromise<Website> {
            return localVarFp.websiteProjectInstanceStart(projectId, locationId, instanceId, xIdempotencyKey, xDryRun, options).then((request) => request(axios, basePath));
        },
        /**
         * action stop
         * @summary Stop website/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceStop(projectId: string, locationId: string, instanceId: string, xIdempotencyKey?: string, xDryRun?: string, options?: any): AxiosPromise<Website> {
            return localVarFp.websiteProjectInstanceStop(projectId, locationId, instanceId, xIdempotencyKey, xDryRun, options).then((request) => request(axios, basePath));
        },
        /**
         * Create website/instance.tag
         * @summary Create website/instance.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {Tag} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceTagCreate(projectId: string, locationId: string, instanceId: string, tag: Tag, options?: any): AxiosPromise<Tag> {
            return localVarFp.websiteProjectInstanceTagCreate(projectId, locationId, instanceId, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete website/instance.tag
         * @summary Delete website/instance.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceTagDelete(projectId: string, locationId: string, instanceId: string, tagId: string, options?: any): AxiosPromise<void> {
            return localVarFp.websiteProjectInstanceTagDelete(projectId, locationId, instanceId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get website/instance.tag
         * @summary Get website/instance.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {string} tagId tagId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceTagGet(projectId: string, locationId: string, instanceId: string, tagId: string, options?: any): AxiosPromise<Tag> {
            return localVarFp.websiteProjectInstanceTagGet(projectId, locationId, instanceId, tagId, options).then((request) => request(axios, basePath));
        },
        /**
         * List website/instance.tag
         * @summary List website/instance.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceTagList(projectId: string, locationId: string, instanceId: string, options?: any): AxiosPromise<Array<Tag>> {
            return localVarFp.websiteProjectInstanceTagList(projectId, locationId, instanceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Replace website/instance.tag
         * @summary Replace website/instance.tag
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {Array<Tag>} tag 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceTagPut(projectId: string, locationId: string, instanceId: string, tag: Array<Tag>, options?: any): AxiosPromise<Array<Tag>> {
            return localVarFp.websiteProjectInstanceTagPut(projectId, locationId, instanceId, tag, options).then((request) => request(axios, basePath));
        },
        /**
         * action transfer
         * @summary Transfer website/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {WebsiteProjectInstanceTransfer} websiteProjectInstanceTransfer 
         * @param {string} [xIdempotencyKey] Idempotency key
         * @param {string} [xDryRun] Dry run
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceTransfer(projectId: string, locationId: string, instanceId: string, websiteProjectInstanceTransfer: WebsiteProjectInstanceTransfer, xIdempotencyKey?: string, xDryRun?: string, options?: any): AxiosPromise<Website> {
            return localVarFp.websiteProjectInstanceTransfer(projectId, locationId, instanceId, websiteProjectInstanceTransfer, xIdempotencyKey, xDryRun, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns modified instance
         * @summary Update website/instance
         * @param {string} projectId Project Id
         * @param {string} locationId Location Id
         * @param {string} instanceId Instance Id
         * @param {WebsiteProjectInstanceUpdate} websiteProjectInstanceUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        websiteProjectInstanceUpdate(projectId: string, locationId: string, instanceId: string, websiteProjectInstanceUpdate: WebsiteProjectInstanceUpdate, options?: any): AxiosPromise<Website> {
            return localVarFp.websiteProjectInstanceUpdate(projectId, locationId, instanceId, websiteProjectInstanceUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * WebsiteProjectInstanceApi - object-oriented interface
 * @export
 * @class WebsiteProjectInstanceApi
 * @extends {BaseAPI}
 */
export class WebsiteProjectInstanceApi extends BaseAPI {
    /**
     * Get website/instance.connect
     * @summary Get website/instance.connect
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {string} connectId connectId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsiteProjectInstanceApi
     */
    public websiteProjectInstanceConnectGet(projectId: string, locationId: string, instanceId: string, connectId: string, options?: any) {
        return WebsiteProjectInstanceApiFp(this.configuration).websiteProjectInstanceConnectGet(projectId, locationId, instanceId, connectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List website/instance.connect
     * @summary List website/instance.connect
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsiteProjectInstanceApi
     */
    public websiteProjectInstanceConnectList(projectId: string, locationId: string, instanceId: string, options?: any) {
        return WebsiteProjectInstanceApiFp(this.configuration).websiteProjectInstanceConnectList(projectId, locationId, instanceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create instance
     * @summary Create website/instance
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {WebsiteProjectInstanceCreate} websiteProjectInstanceCreate 
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {string} [xDryRun] Dry run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsiteProjectInstanceApi
     */
    public websiteProjectInstanceCreate(projectId: string, locationId: string, websiteProjectInstanceCreate: WebsiteProjectInstanceCreate, xIdempotencyKey?: string, xDryRun?: string, options?: any) {
        return WebsiteProjectInstanceApiFp(this.configuration).websiteProjectInstanceCreate(projectId, locationId, websiteProjectInstanceCreate, xIdempotencyKey, xDryRun, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create website/instance.credential
     * @summary Create website/instance.credential
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {WebsiteCredential} websiteCredential 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsiteProjectInstanceApi
     */
    public websiteProjectInstanceCredentialCreate(projectId: string, locationId: string, instanceId: string, websiteCredential: WebsiteCredential, options?: any) {
        return WebsiteProjectInstanceApiFp(this.configuration).websiteProjectInstanceCredentialCreate(projectId, locationId, instanceId, websiteCredential, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete website/instance.credential
     * @summary Delete website/instance.credential
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {string} credentialId credentialId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsiteProjectInstanceApi
     */
    public websiteProjectInstanceCredentialDelete(projectId: string, locationId: string, instanceId: string, credentialId: string, options?: any) {
        return WebsiteProjectInstanceApiFp(this.configuration).websiteProjectInstanceCredentialDelete(projectId, locationId, instanceId, credentialId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get website/instance.credential
     * @summary Get website/instance.credential
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {string} credentialId credentialId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsiteProjectInstanceApi
     */
    public websiteProjectInstanceCredentialGet(projectId: string, locationId: string, instanceId: string, credentialId: string, options?: any) {
        return WebsiteProjectInstanceApiFp(this.configuration).websiteProjectInstanceCredentialGet(projectId, locationId, instanceId, credentialId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List website/instance.credential
     * @summary List website/instance.credential
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsiteProjectInstanceApi
     */
    public websiteProjectInstanceCredentialList(projectId: string, locationId: string, instanceId: string, options?: any) {
        return WebsiteProjectInstanceApiFp(this.configuration).websiteProjectInstanceCredentialList(projectId, locationId, instanceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update website/instance.credential
     * @summary Update website/instance.credential
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {string} credentialId credentialId
     * @param {WebsiteProjectInstanceCredentialPatch} websiteProjectInstanceCredentialPatch 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsiteProjectInstanceApi
     */
    public websiteProjectInstanceCredentialPatch(projectId: string, locationId: string, instanceId: string, credentialId: string, websiteProjectInstanceCredentialPatch: WebsiteProjectInstanceCredentialPatch, options?: any) {
        return WebsiteProjectInstanceApiFp(this.configuration).websiteProjectInstanceCredentialPatch(projectId, locationId, instanceId, credentialId, websiteProjectInstanceCredentialPatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete instance
     * @summary Delete website/instance
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsiteProjectInstanceApi
     */
    public websiteProjectInstanceDelete(projectId: string, locationId: string, instanceId: string, options?: any) {
        return WebsiteProjectInstanceApiFp(this.configuration).websiteProjectInstanceDelete(projectId, locationId, instanceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create website/instance.domain
     * @summary Create website/instance.domain
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {Domain} domain 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsiteProjectInstanceApi
     */
    public websiteProjectInstanceDomainCreate(projectId: string, locationId: string, instanceId: string, domain: Domain, options?: any) {
        return WebsiteProjectInstanceApiFp(this.configuration).websiteProjectInstanceDomainCreate(projectId, locationId, instanceId, domain, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete website/instance.domain
     * @summary Delete website/instance.domain
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {string} domainId domainId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsiteProjectInstanceApi
     */
    public websiteProjectInstanceDomainDelete(projectId: string, locationId: string, instanceId: string, domainId: string, options?: any) {
        return WebsiteProjectInstanceApiFp(this.configuration).websiteProjectInstanceDomainDelete(projectId, locationId, instanceId, domainId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get website/instance.domain
     * @summary Get website/instance.domain
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {string} domainId domainId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsiteProjectInstanceApi
     */
    public websiteProjectInstanceDomainGet(projectId: string, locationId: string, instanceId: string, domainId: string, options?: any) {
        return WebsiteProjectInstanceApiFp(this.configuration).websiteProjectInstanceDomainGet(projectId, locationId, instanceId, domainId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List website/instance.domain
     * @summary List website/instance.domain
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsiteProjectInstanceApi
     */
    public websiteProjectInstanceDomainList(projectId: string, locationId: string, instanceId: string, options?: any) {
        return WebsiteProjectInstanceApiFp(this.configuration).websiteProjectInstanceDomainList(projectId, locationId, instanceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create website/instance.env
     * @summary Create website/instance.env
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {WebsiteEnv} websiteEnv 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsiteProjectInstanceApi
     */
    public websiteProjectInstanceEnvCreate(projectId: string, locationId: string, instanceId: string, websiteEnv: WebsiteEnv, options?: any) {
        return WebsiteProjectInstanceApiFp(this.configuration).websiteProjectInstanceEnvCreate(projectId, locationId, instanceId, websiteEnv, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete website/instance.env
     * @summary Delete website/instance.env
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {string} envId envId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsiteProjectInstanceApi
     */
    public websiteProjectInstanceEnvDelete(projectId: string, locationId: string, instanceId: string, envId: string, options?: any) {
        return WebsiteProjectInstanceApiFp(this.configuration).websiteProjectInstanceEnvDelete(projectId, locationId, instanceId, envId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get website/instance.env
     * @summary Get website/instance.env
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {string} envId envId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsiteProjectInstanceApi
     */
    public websiteProjectInstanceEnvGet(projectId: string, locationId: string, instanceId: string, envId: string, options?: any) {
        return WebsiteProjectInstanceApiFp(this.configuration).websiteProjectInstanceEnvGet(projectId, locationId, instanceId, envId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List website/instance.env
     * @summary List website/instance.env
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsiteProjectInstanceApi
     */
    public websiteProjectInstanceEnvList(projectId: string, locationId: string, instanceId: string, options?: any) {
        return WebsiteProjectInstanceApiFp(this.configuration).websiteProjectInstanceEnvList(projectId, locationId, instanceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get website/instance.event
     * @summary Get website/instance.event
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {string} eventId eventId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsiteProjectInstanceApi
     */
    public websiteProjectInstanceEventGet(projectId: string, locationId: string, instanceId: string, eventId: string, options?: any) {
        return WebsiteProjectInstanceApiFp(this.configuration).websiteProjectInstanceEventGet(projectId, locationId, instanceId, eventId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List website/instance.event
     * @summary List website/instance.event
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {number} [$limit] $limit
     * @param {number} [$skip] $skip
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsiteProjectInstanceApi
     */
    public websiteProjectInstanceEventList(projectId: string, locationId: string, instanceId: string, $limit?: number, $skip?: number, options?: any) {
        return WebsiteProjectInstanceApiFp(this.configuration).websiteProjectInstanceEventList(projectId, locationId, instanceId, $limit, $skip, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single instance
     * @summary Get website/instance
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsiteProjectInstanceApi
     */
    public websiteProjectInstanceGet(projectId: string, locationId: string, instanceId: string, options?: any) {
        return WebsiteProjectInstanceApiFp(this.configuration).websiteProjectInstanceGet(projectId, locationId, instanceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create website/instance.link
     * @summary Create website/instance.link
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {WebsiteLink} websiteLink 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsiteProjectInstanceApi
     */
    public websiteProjectInstanceLinkCreate(projectId: string, locationId: string, instanceId: string, websiteLink: WebsiteLink, options?: any) {
        return WebsiteProjectInstanceApiFp(this.configuration).websiteProjectInstanceLinkCreate(projectId, locationId, instanceId, websiteLink, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete website/instance.link
     * @summary Delete website/instance.link
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {string} linkId linkId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsiteProjectInstanceApi
     */
    public websiteProjectInstanceLinkDelete(projectId: string, locationId: string, instanceId: string, linkId: string, options?: any) {
        return WebsiteProjectInstanceApiFp(this.configuration).websiteProjectInstanceLinkDelete(projectId, locationId, instanceId, linkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get website/instance.link
     * @summary Get website/instance.link
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {string} linkId linkId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsiteProjectInstanceApi
     */
    public websiteProjectInstanceLinkGet(projectId: string, locationId: string, instanceId: string, linkId: string, options?: any) {
        return WebsiteProjectInstanceApiFp(this.configuration).websiteProjectInstanceLinkGet(projectId, locationId, instanceId, linkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List website/instance.link
     * @summary List website/instance.link
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsiteProjectInstanceApi
     */
    public websiteProjectInstanceLinkList(projectId: string, locationId: string, instanceId: string, options?: any) {
        return WebsiteProjectInstanceApiFp(this.configuration).websiteProjectInstanceLinkList(projectId, locationId, instanceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List instance
     * @summary List website/instance
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} [name] Filter by name
     * @param {string} [tagValue] Filter by tag.value
     * @param {string} [tagKey] Filter by tag.key
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsiteProjectInstanceApi
     */
    public websiteProjectInstanceList(projectId: string, locationId: string, name?: string, tagValue?: string, tagKey?: string, options?: any) {
        return WebsiteProjectInstanceApiFp(this.configuration).websiteProjectInstanceList(projectId, locationId, name, tagValue, tagKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get website/instance.log
     * @summary Get website/instance.log
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {string} logId logId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsiteProjectInstanceApi
     */
    public websiteProjectInstanceLogGet(projectId: string, locationId: string, instanceId: string, logId: string, options?: any) {
        return WebsiteProjectInstanceApiFp(this.configuration).websiteProjectInstanceLogGet(projectId, locationId, instanceId, logId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List website/instance.log
     * @summary List website/instance.log
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsiteProjectInstanceApi
     */
    public websiteProjectInstanceLogList(projectId: string, locationId: string, instanceId: string, options?: any) {
        return WebsiteProjectInstanceApiFp(this.configuration).websiteProjectInstanceLogList(projectId, locationId, instanceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * action read
     * @summary Read website/instance.log
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {string} logId logId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsiteProjectInstanceApi
     */
    public websiteProjectInstanceLogRead(projectId: string, locationId: string, instanceId: string, logId: string, options?: any) {
        return WebsiteProjectInstanceApiFp(this.configuration).websiteProjectInstanceLogRead(projectId, locationId, instanceId, logId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get website/instance.metric
     * @summary Get website/instance.metric
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {string} metricId metricId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsiteProjectInstanceApi
     */
    public websiteProjectInstanceMetricGet(projectId: string, locationId: string, instanceId: string, metricId: string, options?: any) {
        return WebsiteProjectInstanceApiFp(this.configuration).websiteProjectInstanceMetricGet(projectId, locationId, instanceId, metricId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List website/instance.metric
     * @summary List website/instance.metric
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsiteProjectInstanceApi
     */
    public websiteProjectInstanceMetricList(projectId: string, locationId: string, instanceId: string, options?: any) {
        return WebsiteProjectInstanceApiFp(this.configuration).websiteProjectInstanceMetricList(projectId, locationId, instanceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List website/instance.point
     * @summary List website/instance.point
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {string} metricId metricId
     * @param {string} [interval] interval
     * @param {string} [timespan] timespan
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsiteProjectInstanceApi
     */
    public websiteProjectInstanceMetricPointList(projectId: string, locationId: string, instanceId: string, metricId: string, interval?: string, timespan?: string, options?: any) {
        return WebsiteProjectInstanceApiFp(this.configuration).websiteProjectInstanceMetricPointList(projectId, locationId, instanceId, metricId, interval, timespan, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * action restart
     * @summary Restart website/instance
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {string} [xDryRun] Dry run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsiteProjectInstanceApi
     */
    public websiteProjectInstanceRestart(projectId: string, locationId: string, instanceId: string, xIdempotencyKey?: string, xDryRun?: string, options?: any) {
        return WebsiteProjectInstanceApiFp(this.configuration).websiteProjectInstanceRestart(projectId, locationId, instanceId, xIdempotencyKey, xDryRun, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get website/instance.service
     * @summary Get website/instance.service
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {string} serviceId serviceId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsiteProjectInstanceApi
     */
    public websiteProjectInstanceServiceGet(projectId: string, locationId: string, instanceId: string, serviceId: string, options?: any) {
        return WebsiteProjectInstanceApiFp(this.configuration).websiteProjectInstanceServiceGet(projectId, locationId, instanceId, serviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List website/instance.service
     * @summary List website/instance.service
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsiteProjectInstanceApi
     */
    public websiteProjectInstanceServiceList(projectId: string, locationId: string, instanceId: string, options?: any) {
        return WebsiteProjectInstanceApiFp(this.configuration).websiteProjectInstanceServiceList(projectId, locationId, instanceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get website/instance.sideapp
     * @summary Get website/instance.sideapp
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {string} sideappId sideappId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsiteProjectInstanceApi
     */
    public websiteProjectInstanceSideappGet(projectId: string, locationId: string, instanceId: string, sideappId: string, options?: any) {
        return WebsiteProjectInstanceApiFp(this.configuration).websiteProjectInstanceSideappGet(projectId, locationId, instanceId, sideappId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List website/instance.sideapp
     * @summary List website/instance.sideapp
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsiteProjectInstanceApi
     */
    public websiteProjectInstanceSideappList(projectId: string, locationId: string, instanceId: string, options?: any) {
        return WebsiteProjectInstanceApiFp(this.configuration).websiteProjectInstanceSideappList(projectId, locationId, instanceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * action open
     * @summary Open website/instance.sideapp
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {string} sideappId sideappId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsiteProjectInstanceApi
     */
    public websiteProjectInstanceSideappOpen(projectId: string, locationId: string, instanceId: string, sideappId: string, options?: any) {
        return WebsiteProjectInstanceApiFp(this.configuration).websiteProjectInstanceSideappOpen(projectId, locationId, instanceId, sideappId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create website/instance.snapshot
     * @summary Create website/instance.snapshot
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {WebsiteSnapshot} websiteSnapshot 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsiteProjectInstanceApi
     */
    public websiteProjectInstanceSnapshotCreate(projectId: string, locationId: string, instanceId: string, websiteSnapshot: WebsiteSnapshot, options?: any) {
        return WebsiteProjectInstanceApiFp(this.configuration).websiteProjectInstanceSnapshotCreate(projectId, locationId, instanceId, websiteSnapshot, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete website/instance.snapshot
     * @summary Delete website/instance.snapshot
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {string} snapshotId snapshotId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsiteProjectInstanceApi
     */
    public websiteProjectInstanceSnapshotDelete(projectId: string, locationId: string, instanceId: string, snapshotId: string, options?: any) {
        return WebsiteProjectInstanceApiFp(this.configuration).websiteProjectInstanceSnapshotDelete(projectId, locationId, instanceId, snapshotId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * action download
     * @summary Download website/instance.snapshot
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {string} snapshotId snapshotId
     * @param {WebsiteProjectInstanceSnapshotDownload} websiteProjectInstanceSnapshotDownload 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsiteProjectInstanceApi
     */
    public websiteProjectInstanceSnapshotDownload(projectId: string, locationId: string, instanceId: string, snapshotId: string, websiteProjectInstanceSnapshotDownload: WebsiteProjectInstanceSnapshotDownload, options?: any) {
        return WebsiteProjectInstanceApiFp(this.configuration).websiteProjectInstanceSnapshotDownload(projectId, locationId, instanceId, snapshotId, websiteProjectInstanceSnapshotDownload, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get website/instance.snapshot
     * @summary Get website/instance.snapshot
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {string} snapshotId snapshotId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsiteProjectInstanceApi
     */
    public websiteProjectInstanceSnapshotGet(projectId: string, locationId: string, instanceId: string, snapshotId: string, options?: any) {
        return WebsiteProjectInstanceApiFp(this.configuration).websiteProjectInstanceSnapshotGet(projectId, locationId, instanceId, snapshotId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List website/instance.snapshot
     * @summary List website/instance.snapshot
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsiteProjectInstanceApi
     */
    public websiteProjectInstanceSnapshotList(projectId: string, locationId: string, instanceId: string, options?: any) {
        return WebsiteProjectInstanceApiFp(this.configuration).websiteProjectInstanceSnapshotList(projectId, locationId, instanceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * action start
     * @summary Start website/instance
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {string} [xDryRun] Dry run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsiteProjectInstanceApi
     */
    public websiteProjectInstanceStart(projectId: string, locationId: string, instanceId: string, xIdempotencyKey?: string, xDryRun?: string, options?: any) {
        return WebsiteProjectInstanceApiFp(this.configuration).websiteProjectInstanceStart(projectId, locationId, instanceId, xIdempotencyKey, xDryRun, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * action stop
     * @summary Stop website/instance
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {string} [xDryRun] Dry run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsiteProjectInstanceApi
     */
    public websiteProjectInstanceStop(projectId: string, locationId: string, instanceId: string, xIdempotencyKey?: string, xDryRun?: string, options?: any) {
        return WebsiteProjectInstanceApiFp(this.configuration).websiteProjectInstanceStop(projectId, locationId, instanceId, xIdempotencyKey, xDryRun, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create website/instance.tag
     * @summary Create website/instance.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {Tag} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsiteProjectInstanceApi
     */
    public websiteProjectInstanceTagCreate(projectId: string, locationId: string, instanceId: string, tag: Tag, options?: any) {
        return WebsiteProjectInstanceApiFp(this.configuration).websiteProjectInstanceTagCreate(projectId, locationId, instanceId, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete website/instance.tag
     * @summary Delete website/instance.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {string} tagId tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsiteProjectInstanceApi
     */
    public websiteProjectInstanceTagDelete(projectId: string, locationId: string, instanceId: string, tagId: string, options?: any) {
        return WebsiteProjectInstanceApiFp(this.configuration).websiteProjectInstanceTagDelete(projectId, locationId, instanceId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get website/instance.tag
     * @summary Get website/instance.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {string} tagId tagId
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsiteProjectInstanceApi
     */
    public websiteProjectInstanceTagGet(projectId: string, locationId: string, instanceId: string, tagId: string, options?: any) {
        return WebsiteProjectInstanceApiFp(this.configuration).websiteProjectInstanceTagGet(projectId, locationId, instanceId, tagId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List website/instance.tag
     * @summary List website/instance.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsiteProjectInstanceApi
     */
    public websiteProjectInstanceTagList(projectId: string, locationId: string, instanceId: string, options?: any) {
        return WebsiteProjectInstanceApiFp(this.configuration).websiteProjectInstanceTagList(projectId, locationId, instanceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Replace website/instance.tag
     * @summary Replace website/instance.tag
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {Array<Tag>} tag 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsiteProjectInstanceApi
     */
    public websiteProjectInstanceTagPut(projectId: string, locationId: string, instanceId: string, tag: Array<Tag>, options?: any) {
        return WebsiteProjectInstanceApiFp(this.configuration).websiteProjectInstanceTagPut(projectId, locationId, instanceId, tag, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * action transfer
     * @summary Transfer website/instance
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {WebsiteProjectInstanceTransfer} websiteProjectInstanceTransfer 
     * @param {string} [xIdempotencyKey] Idempotency key
     * @param {string} [xDryRun] Dry run
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsiteProjectInstanceApi
     */
    public websiteProjectInstanceTransfer(projectId: string, locationId: string, instanceId: string, websiteProjectInstanceTransfer: WebsiteProjectInstanceTransfer, xIdempotencyKey?: string, xDryRun?: string, options?: any) {
        return WebsiteProjectInstanceApiFp(this.configuration).websiteProjectInstanceTransfer(projectId, locationId, instanceId, websiteProjectInstanceTransfer, xIdempotencyKey, xDryRun, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns modified instance
     * @summary Update website/instance
     * @param {string} projectId Project Id
     * @param {string} locationId Location Id
     * @param {string} instanceId Instance Id
     * @param {WebsiteProjectInstanceUpdate} websiteProjectInstanceUpdate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof WebsiteProjectInstanceApi
     */
    public websiteProjectInstanceUpdate(projectId: string, locationId: string, instanceId: string, websiteProjectInstanceUpdate: WebsiteProjectInstanceUpdate, options?: any) {
        return WebsiteProjectInstanceApiFp(this.configuration).websiteProjectInstanceUpdate(projectId, locationId, instanceId, websiteProjectInstanceUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}


